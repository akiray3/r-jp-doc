x
単項演算子および二項演算子はジェネリック関数です。メソッドは個別に、またはOpsグループジェネリック関数を介して記述することができます（ディスパッチの計算方法についてはOpsを参照してください）。  (ディスパッチがどのように計算されるかについてはOpsを参照してください)。
数値ベクトルとして指定される場合、xは整数である必要はありませんが、Datesのヘルプの小数日に関するコメントを参照してください。
日付/時刻には2つの基本的なクラスがあります。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
二項演算子: には2つの意味があります: 因子a:bはinteraction(a, b)と等価です（ただし、レベルの順序とラベルは異なります）。
パッケージpkgの場合、pkg::nameは名前空間pkgでエクスポートされた変数名の値を返し、aspkg:::nameは内部の変数名の値を返します。  パッケージの名前空間は、呼び出す前にロードされていなければロードされますが、パッケージはこれらのarchパスにはアタッチされません。
パッケージ pkg の場合、pkg::name は名前空間 pkg 内の export された変数名の値を返し、aspkg::name は内部の変数名の値を返します。  パッケージ名前空間は、呼び出す前にロードされていなければロードされますが、パッケージはこれらのarchパスにはアタッチされません。
!"は論理否定(NOT)を示します。
クラス "hexmode "は、単に16進数で表示されることを保証するためだけに使用される、このクラス属性を持つ整数ベクトルで構成されます。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルで構成され、 単に8進数で表示されるようにするために使用される。  サブセット([)も機能する。
バイナリ比較演算子はジェネリック関数です。メソッドは個別に記述することもできますし、Opsグループのジェネリック関数を使用することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください)。
NA
これらの演算子はジェネリックです。  特定のクラスのオブジェクトのインデックスを処理するメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、既定のメソッドにのみ適用されます。  置換関数[<-、[[<-、$<-は、式の代入側でインデックス付けを行う場合に使用するため、別々のメソッドが必要であることに注意してください。
関数Iには主に2つの使い方があります。
データ・フレームはいくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトル添字（x[i]またはx[[i]]）と一緒に使われると、あたかもそれがリストであるかのようにデータフレームに添字を付けます。  この使用法では、警告とともにドロップ引数は無視される。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔ではありません（イギリスとその植民地では1752年に採用されました）。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のメソッドがあります。
これらの演算子は汎用です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックスが作成される場合に使用する置換関数[<-、[[<-、$<-には、別々のメソッドが必要であることに注意してください。
これは、DLL を管理する内部テーブルに問い合わせます。
未使用のレベルが削除されても、残りのレベルの順序は保持されます。
hexmode "クラスは、そのクラス属性を持つ整数ベクトルで構成され、単に16進数で表示されることを保証するために使用されます。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックスが作成される場合に使用する置換関数[<-、[[<-、$<-には、別々のメソッドが必要であることに注意してください。
noquote は、引数を "noquote" クラスのオブジェクトとして返します。  c()メソッドと添え字メソッド("[.noquote")があり、サブセットによってクラスが失われないようにします。  printメソッド(print.noquote)は、文字列を引用符なしで表示します("...." は .... と表示されます)。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常（パッケージの'DESCRIPTION'ファイルなどでは）、シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  サブセット([)も機能する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付/時刻を表すベクトルの名前付きリストです。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。内部メソッド、[.data.frame]、[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックス付けを行う場合は、置換関数[<-, [[<-, $<-に別々のメソッドが必要であることに注意してください。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname名'が計算されます。  ...の引数に名前が付けられていれば、その名前が使用される。  残りの引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は、与えられた引数がシンボルであればそれを使用し、deparse.level = 2は、引数をdeparseします。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  要するに、options(warn = 0)でwarningが少なくとも1回呼び出された場合である。
これらの演算子は汎用的です。  InternalMethods、[.data.frame]、[.factor.Methods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックス付けを行う場合は、置換関数[<-, [[<-, $<-に別々のメソッドが必要であることに注意してください。
データ・フレームは、いくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトルインデックス（x[i]またはx[[i]]）と共に使用される場合、データフレームをリストのようにインデックス付けします。  この使用法では、警告とともにドロップ引数は無視される。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されるが、グレゴリオ暦が使われていたのはそれほど昔ではない（イギリスとその植民地では1752年に採用された）。
未使用のレベルが削除されても、残りのレベルの順序は維持される。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなど)は、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現される。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付/時刻を表すベクトルの名前付きリストです。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。内部メソッド、[.data.frame]、[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックス付けを行う場合は、置換関数[<-, [[<-, $<-に別々のメソッドが必要であることに注意してください。
データ・フレームは、いくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトルインデックス（x[i]またはx[[i]]）と共に使用される場合、データフレームをリストのようにインデックス付けします。  この使用法では、drop 引数は警告とともに無視される。
未使用のレベルが削除されても、残りのレベルの順序は保持されます。
数値バージョンは、1つ以上の非負整数からなるシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなどでは)、シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現される。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。内部メソッド、[.data.frame]、[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックス付けを行う場合は、置換関数[<-, [[<-, $<-に別々のメソッドが必要であることに注意してください。
データ・フレームは、いくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトルインデックス（x[i]またはx[[i]]）と共に使用される場合、データフレームをリストのようにインデックス付けします。  この使用法では、警告とともにドロップ引数は無視される。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔ではありません（イギリスとその植民地では1752年に採用されました）。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもある。
未使用のレベルが削除されても、残りのレベルの順序は保持されます。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常は(パッケージの'DESCRIPTION'ファイルなどでは)シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現される。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、以下を表す名前付きベクトルのリストである。
NA
これらの演算子は、パッケージ・メソッドの正式なクラスをサポートしており、パッケージ・メソッドがロードされたときにのみ有効になります（デフォルト）。  詳細、特にslot()と@演算子の違いについては、slotを参照してください。
これらの演算子はパッケージメソッドの正式なクラスをサポートしており、パッケージメソッドがロードされたときにのみ有効になります（デフォルト）。  詳細、特にslot()と@演算子の違いについては、slotを参照してください。
単項演算子および二項演算子はジェネリック関数です: メソッドは個別に、またはOpsグループジェネリック関数を使用して記述できます。  (ディスパッチの計算方法についてはOpsを参照してください)。
関数 difftime は、2 つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime" クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。
単項演算子と二項演算子はジェネリック関数です。これらのメソッドは個別に記述することも、Opsグループ・ジェネリック関数を介して記述することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください)。
関数 difftime は、2 つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime" クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック(Ops参照)の論理演算と算術演算のためのメソッドがあります。
は論理否定(NOT)を表す。
クラス "hexmode "は、単に16進数で表示されることを保証するためだけに使用される、このクラス属性を持つ整数ベクトルで構成されます。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルで構成され、 単に8進数で表示されるようにするために使用されます。  サブセット([)も動作します。
は論理否定（NOT）を表します。
ベクトルが行列に昇格した場合、as.matrixとは異なり、その名前は行名や列名に昇格しません。
単項演算子および二項演算子はジェネリック関数です。メソッドは個別に記述することも、Opsグループジェネリック関数を使用して記述することもできます。  (ディスパッチの計算方法についてはOpsを参照してください）。
単項演算子および二項演算子はジェネリック関数です:メソッドはそれらに対して個別に記述することも、Opsグループジェネリック関数を介して記述することもできます。  (ディスパッチの計算方法についてはOpsを参照してください)。
in%は現在"%in%" <- function(x, table) match(x, table, nomatch = 0) > 0として定義されています。
XとYはFUNに適した引数でなければならない。  FUNが呼び出される前に、XとYの長さの積がrepによって拡張される。
XとYの次元数が同じでない場合、小さい方の配列にサイズ1の次元がパディングされる。  返される配列は、Xを1項ずつ取り出し、その項をFUN(x, Y, ...)として展開することで構成される部分行列で構成される。
単項演算子と二項演算子はジェネリック関数であり、メソッドは個別に、またはOpsグループジェネリック関数を使用して記述することができます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください)。
単項演算子および二項演算子はジェネリック関数です:メソッドはそれらに対して個別に記述することも、Opsグループジェネリック関数を介して記述することもできます。  (ディスパッチの計算方法についてはOpsを参照してください)。
数値ベクトルとして指定される場合、xは整数である必要はありませんが、Datesのヘルプの小数日に関するコメントを参照してください。
日付/時刻には2つの基本的なクラスがあります。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
バイナリ比較演算子はジェネリック関数です。メソッドは個別に、またはOpsグループのジェネリック関数を使用して記述することができます。  (ディスパッチの計算方法についてはOpsを参照してください）。
3つの異なる代入演算子があり、そのうちの2つは左向きと右向きの形式を持ちます。
3つの異なる代入演算子があり、そのうちの2つは左向きと右向きの形式を持っています。
二項比較演算子はジェネリック関数です。メソッドは個別に、またはOpsグループジェネリック関数を介して、それらのために書くことができます。  (ディスパッチがどのように計算されるかはOpsを参照してください）。
3つの異なる代入演算子があり、そのうちの2つは左向きと右向きの形式を持ちます。
二項比較演算子はジェネリック関数です。メソッドは個別に、またはOpsグループジェネリック関数を介して記述することができます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください）。
二項比較演算子はジェネリック関数です。メソッドは個別に、またはOpsグループジェネリック関数を介して記述することができます。  (ディスパッチの計算方法についてはOpsを参照してください)。
バイナリ比較演算子はジェネリック関数です。これらのメソッドは個別に、またはOpsグループジェネリック関数を介して記述することができます。  (ディスパッチの計算方法についてはOpsを参照してください)。
は論理否定(NOT)を表します。
クラス "hexmode "はこのクラス属性を持つ整数ベクトルで構成され、単に16進数で表示されることを保証するために使用されます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、 単に8進数で表示されるようにするために使用されます。  サブセット([)も動作します。
は論理否定（NOT）を表します。
左辺は省略可能で、文脈によっては片辺の式が使われることもある。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frameと[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックスが作成される場合に使用する置換関数[<-、[[<-、$<-には、別々のメソッドが必要であることに注意してください。
これは、DLL を管理する内部テーブルに問い合わせます。
数値バージョンは1つ以上の非負整数からなるシーケンスで、通常は(パッケージの'DESCRIPTION'ファイルなどでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは3つ（メジャー、マイナー、パッチレベル）で構成されます。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックス付けを行う場合は、置換関数[<-, [[<-, $<-に別々のメソッドが必要であることに注意してください。
データ・フレームは、いくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトルインデックス（x[i]またはx[[i]]）と共に使用される場合、データフレームをリストのようにインデックス付けします。  この使用法では、警告とともにドロップ引数は無視される。
使用されるデフォルトのアルゴリズム（method = "left.keep"）は、Sと同様である。単一の文字列に対して、以下のように動作する。まず、文字列の両端の空白が取り除かれ、次に（必要であれば）その他の空白が取り除かれる。次に、小文字の母音が取り除かれ、次に小文字の子音が取り除かれる。最後に、省略形がminlengthよりまだ長い場合は、大文字と記号が取り除かれる。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループジェネリックで定義することもできます。  複素引数(およびデフォルトのメソッド)、z、abs(z) == Mod(z)、sqrt(z) == z^0.5。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します、すなわち、正の引数の場合、atan2(y, x) == atan(y/x)です。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Math グループ・ジェネリックを介して定義することもできます。
環境をロックすることで、環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。
トップレベル・タスクは、入力行全体ではなく個々の式である。  従って、expression1 ; expression2という形の入力行は2つのトップレベルタスクを生成する。
ある文字列を別の文字列に変換するのに必要な挿入、削除、置換の総数である。
これは、ある文字列を別の文字列に変換するのに必要な挿入、削除、置換の総数です。
LISPのような）伝統的な点線ペアリストは依然として利用可能ですが、ユーザが目にすることはほとんどありません（関数の形式を除いて）。
これはジェネリック関数です: メソッドは直接定義することもできますし、Summaryグループのgenericを介して定義することもできます。これが正しく動作するためには、引数...には名前を付ける必要があり、ディスパッチは第1引数に行われます。
all.equalはジェネリック関数で、ターゲット引数にメソッドをディスパッチします。  使用可能なメソッドを見るにはemethods("all.equal")を使用しますが、デフォルトのメソッドもいくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  利用可能なメソッドを見るには、emethods("all.equal")を使用しますが、デフォルトのメソッドも、論理ターゲット用のrawメソッドなどを使用して、いくつかのディスパッチを行うことに注意してください。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  使用可能なメソッドを見るにはemethods("all.equal")を使用しますが、デフォルトのメソッドも、例えばlogicaltargetsのrawメソッドを使用するなど、いくつかのディスパッチを行うことに注意してください。
これらの関数は、引数のデフォルト値が異なるだけです。
これらの関数は、引数のデフォルト値が異なるだけである。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
これはジェネリック関数です。メソッドは直接定義することも、Summaryグループのgenericを通して定義することもできます。これが正しく動作するためには、引数...には名前を付け、ディスパッチは最初の引数に行います。
これらはベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つジェネリック関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
文字型のNAは、文字列 "NA "とは異なります。  明示的に欠損文字列を指定する必要があるプログラマーは、（"NA "ではなく）NA_character_を使用するか、is.na<-を使用して要素をNAに設定してください。
文字型のNAは文字列 "NA "とは異なる。  明示的に欠損文字列を指定する必要があるプログラマーは、（"NA "ではなく）NA_character_を使うか、is.na<-を使って要素をNAに設定すべきである。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなど)は、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、次のようなベクターの名前付きリストである。
NA
NA
NA
NA
Xが配列ではなく、nulldimでない値を持つクラスのオブジェクト（データフレームなど）である場合、2次元（データフレームなど）であればas.matrixで、as.arrayであればas.arrayで配列への強制を試みます。
複素数ベクトルはcomplexで作成できます。  ベクトルは、その長さ、実部と虚部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数ゼロのベクトルが生成されます)。
この関数は主に関数の引数リストを表示するために対話的に使用されます。  プログラミングでは、代わりに公式を使うことを考えよう。
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができます。  これは単に、次元(属性 "dim")とオプションでその次元の名前(属性 "dimnames")を与える追加属性とともに格納されるベクトルです。
NA
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができます。  これは単に、次元（属性 "dim"）と、オプションでそれらの次元の名前（属性 "dimnames"）を指定する追加属性と共に格納されるベクトルです。
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができます。  それは単に、次元（属性 "dim"）とオプションでそれらの次元の名前（属性 "dimnames"）を与える追加属性と一緒に格納されるベクトルです。
は、評価されない関数呼び出し、つまり、与えられた引数（nameは呼び出される関数名を示す文字列でなければなりません）に名前付き関数を適用した評価されない式を返します。  呼び出しは評価されませんが、引数...は評価されることに注意してください。
as.characterとis.characterは汎用です。特定のクラスのオブジェクトを処理するメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すため、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表されます。  現在のところ、コンディションはS3スタイルのオブジェクトであるが、これはいずれ変更される可能性がある。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになる。
as.characterとis.characterは汎用的です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。
as.characterとis.characterは汎用的です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。
クラス "hexmode "は、単に16進数で表示されることを保証するために使用される、そのクラス属性を持つ整数ベクトルで構成されています。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つ(メジャー、マイナー、パッチレベル)で構成されます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  サブセット([)も機能する。
formatメソッドとas.characterメソッド、およびstrftimecは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換します。
これらの関数とクラスは、ソース・コード参照を扱います。
複素数ベクトルは、complex.  ベクトルは、その長さ、実部と虚部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数ゼロのベクトルが生成されます)。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、この暦はそれほど古くはありません（イギリスとその植民地では1752年に採用されました）。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常（例えばパッケージの'DESCRIPTION'ファイルでは）シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付/時刻を表すベクトルの名前付きリストです。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname name'が計算されます。  ...の引数に名前が付けられていれば、その名前が使用されます。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2はその引数を使用します。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。
通常のベクトル再利用ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。
xとformatには通常のベクトルの再循環ルールが適用されるので、答えはベクトルの長い方の長さになる。
xとformatには通常のベクトルの再循環ルールが適用されるので、答えはベクトルの長い方の長さになる。
xとformatには通常のベクトルの再循環ルールが適用されるので、答えはベクトルの長い方の長さになる。
xとformatには通常のベクトルの再循環ルールが適用されるので、答えはベクトルの長い方の長さになる。
通常のベクトル再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになる。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示すattributeを持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算および算術演算用のメソッドも用意されています。
double は指定された長さの倍精度ベクトルを作成します。  これはnumericと同じです。
関数 difftime は、2 つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime" クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のうちの1つに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTCの真夜中として扱われます。
これはプリミティブな汎用関数です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。
ここでの'Expression'は口語的な意味、つまり数学的な式の意味で使われているのではありません。  Rの式ベクトルは、例えばparseが返すような呼び出しやシンボルなどのリストです。
ここでの「式」は、口語的な意味、つまり数学的な式の意味では使われていません。  それらはRにおける呼び出し（seecall）であり、R式ベクトルとは、例えばparseによって返されるような、呼び出しやシンボルなどのリストである。
ベクトルxの型に制限はなく、as.characterメソッドを持ち、ソート可能（byorder）であればよい。
NA
NA
クラス "hexmode "は、単に16進数で表示されることを保証するために使用される、そのクラス属性を持つ整数ベクトルで構成されます。
整数ベクトルが存在するのは、それを期待するCやFortranコードにデータを渡せるようにするためであり、（小さな）整数データを正確かつコンパクトに表現できるようにするためである。
Rの内部ではほとんどすべてのリストがジェネリック・ベクトルであり、（LISPのような）伝統的なドット・ペア・リストは依然として使用可能ですが、（関数の形式として使用される以外は）ユーザが目にすることはほとんどありません。
Rの内部ではほとんどすべてのリストがGeneric Vectorsであるのに対し、（LISPのような）伝統的なドットペアリストは、（関数のformalsとして以外は）利用可能だが、ユーザーが目にすることはほとんどない。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使用されていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。
Rでは、内部的にはほとんどすべてのリストがGeneric Vectorsであり、（LISPのような）伝統的な点線のペアリストは依然として使用可能ですが、（関数の形式として使用される以外は）ユーザーが目にすることはほとんどありません。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。
Rの内部ではほとんどすべてのリストがGeneric Vectorsであり、伝統的な点線ペアリスト（LISPのもの）は依然として使用可能ですが、（関数の形式として使用される以外は）ユーザが目にすることはほとんどありません。
Rの内部ではほとんどすべてのリストがGeneric Vectorsであるのに対して、（LISPのような）伝統的なドット付きペアリストは利用可能なままであるが、（関数のformalsを除いて）ユーザーが目にすることはほとんどない。
Rの内部ではほとんどすべてのリストがGeneric Vectorsであるのに対して、（LISPのような）伝統的なドット付きペアリストは依然として利用可能ですが、ユーザが目にすることはほとんどありません（関数のformalsを除いて）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  4つともlogical(1)ベクトルである。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  4つともlogical(1)ベクトルである。
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとする。  どちらも与えられない場合、1列の行列が返される。
nrow または ncol のいずれかが与えられない場合、データの長さともう一方のパラメータからそれを推測しようとします。  どちらも与えられない場合、1列の行列が返される。
nrow または ncol のいずれかが与えられない場合、データの長さともう一方のパラメータからそれを推測しようとします。  どちらも与えられない場合、1列の行列が返される。
noquote は、引数を "noquote" クラスのオブジェクトとして返します。  c() メソッドと subscriptmethod ("[.noquote") があり、サブセットによってクラスが失われないようになっています。  printメソッド(print.noquote)は、文字列を引用符なしで表示します("...... "は......と表示されます)。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
名前は10,000バイトに制限されています（Rの2.13.0より前のバージョンでは256バイトでした）。
NULLは、構文的に適法な方法であればどのような方法でもインデックスを付けることができます(Extractを参照)。  NULLを持つオブジェクトは置換演算子で変更することができ、右辺の型に強制されます。
NULLは、構文上適法な方法であればどのような方法でもインデックスを付けることができます(Extract参照)。  NULLを持つオブジェクトは置換演算子で変更でき、右辺の型に強制されます。
numericはdouble（およびreal）と同じです。指定された長さの倍精度ベクトルを作成し、各要素は0に等しくなります。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなどでは)、シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  サブセット([)も機能する。
as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
Rの内部では、ほとんどすべてのリストがGeneric Vectorsであり、伝統的なドット付きペアリスト（LISPのもの）は利用可能ですが、（関数の形式として利用される以外は）ユーザが目にすることはほとんどありません。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のうちの1つに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTC午前0時のものとして扱われます。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  時刻を伴わない日付は、UTCの真夜中として扱われます。
QR分解は、多くの統計手法で重要な役割を果たす。  QR分解は、多くの統計技法において重要な役割を果たします。特に、行列 ∕ボールド{A}とベクトル∕ボールド{b}が与えられたとき、その方程式 ∕ボールド{Ax}=∕ボールド{b}を解くのに使われます。  回帰係数の計算やニュートン・ラプソンアルゴリズムの適用に便利です。
raw 型は生のバイトを保持するためのものです。  バイトのシーケンスを抽出したり、要素を置き換えたりすることができます(ただし、 raw ベクトルの要素によってのみ)。  関係演算子（バイト表現の数値順序を使用した比較を参照）は、ビット単位の解釈を持つ論理演算子（論理を参照）と同様に動作します。
doubleは、指定された長さの倍精度ベクトルを作成します。  これはnumericと同じです。
doubleは、指定された長さの倍精度ベクトルを作成します。  これはnumericと同じです。
名前は10,000バイトに制限されます（Rの2.13.0より前のバージョンでは256バイトでした）。
引数dnnが与えられない場合、内部関数list.namesが呼び出されて'dimname名'が計算される。  もし...の引数に名前が付けられていれば、その名前が使用されます。  残りの引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数をdeparseします。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、「dimname名」が計算される。  ...の引数に名前が付けられていれば、その名前が使用される。  deparse.level=0は空の名前を与え、deparse.level=1は与えられた引数がシンボルであればそれを使用し、deparse.level=2は引数をdeparseする。
アトミック・モードには、"logical"、"integer"、"numeric"（同義語の "double"）、"complex"、"character"、"raw "がある。
アトミックモードは "logical"、"integer"、"numeric"（同義語 "double"）、"complex"、"character"、"raw"。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返す。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません（現在ではすべて持っています）。  しかし、それを使うことを意図しているわけではありません。
分割の値は、split(x, slice.index(x, MARGIN))によっても（あまり効率的ではないが）得ることができる。
isS4はmethodspackageに依存しないので、特にmethodspackageをrequireする必要性を検出するのに使える。
isS4はmethodspackageに依存しないので、特にそのパッケージをrequireする必要性を検出するのに使えることに注意。
xとして与えられる名前に制限はない：構文以外の名前でもよい（make.namesを参照）。
2つの引数atan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します。
2つの引数のatan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します、すなわち、正の引数の場合、atan2(y, x) == atan(y/x)です。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループジェネリックを介して定義することもできます。
変数名や関数名を評価するとき、Rはsearchでリストされたデータベースからその名前を検索します。  適切な型の最初の名前が使用されます。
関数loadNamespaceとattachNamespaceは通常、libraryが名前空間と必要なインポートをロードするために使用されるときに暗黙的に呼び出されます。  しかし、これらの関数を直接呼び出すと便利な場合もあります。
これらの関数は、オブジェクトの単一の属性へのアクセスを提供します。置換形は、指定された属性に指定された値を取らせます（または、指定された値を持つ新しい属性を作成します）。
all.equalは汎用関数で、引数targetにメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行うことに注意してください。
これらの関数は、オブジェクトの単一の属性へのアクセスを提供します。replacement形式は、指定された属性に指定された値を取らせます（または、指定された値で新しい属性を作成します）。
attrとは異なり、NULLオブジェクトに属性を設定してもエラーにはなりません。
attr とは異なり、NULL オブジェクトに属性を設定することはエラーではありません。
NA
NA
係数行列が上三角形（または '右', 'R'）または下三角形（'左', 'L'）である連立一次方程式を解きます。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境との関連で「parent」を使用しないのが最善である。
Windows以外では、パスのチルダ展開が行われる。
expon.scaled = TRUEの場合、exp(-x) I(x;nu)またはexp(x) K(x;nu)が返される。
expon.scaled = TRUE の場合、exp(-x) I(x;nu) または exp(x) K(x;nu) が返される。
expon.scaled = TRUE の場合、exp(-x) I(x;nu) または exp(x) K(x;nu) が返される。
expon.scaled = TRUE ならば、exp(-x) I(x;nu) または exp(x) K(x;nu) が返される。
関数 beta と lbeta は、ベータ関数とベータ関数の自然対数を返す、
環境をロックすることで、環境からの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
環境をロックすると、環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
domain が NULL または "" で、gettext または ngettext がパッケージ pkg の名前空間の関数から呼び出された場合、domain は "R-pkg" に設定されます。  それ以外の場合、デフォルトのドメインはありません。
整数ベクトルの各要素は 32 ビットです。
整数ベクトルの各要素は 32 ビットです。
整数ベクトルの各要素は32ビットである。
整数ベクトルの各要素は 32 ビットである。
整数ベクトルの各要素は32ビットである。
整数ベクトルの各要素は32ビットである。
最初の形式では、fun には操作する関数を示す文字列を指定することができ、親フレームから検索される。  指定されない場合は、関数呼び出し本体が使用される。
最初の形式の場合、funには、親フレームから検索される操作対象の関数を表す文字列を指定することができます。  指定されない場合は、関数呼び出し本体が使用されます。
NA
breakは、forループ、whileループ、またはrepeatループから抜け出す。  breakもnextも、入れ子になったループの一番内側だけに適用される。
browserの呼び出しは関数本体に含めることができる。この呼び出しに達すると、現在の式の実行が一時停止され、Rインタプリタにアクセスできるようになる。
browserText関数とbrowserCondition関数は、これらの値を取得する方法を提供します。  常に複数のブラウザ・コンテキストがアクティブである可能性があるため、異なるコンテキストからの値の取得もサポートしています。  最も内側にある（最近開始された）ブラウザ・コンテキストには1番が振られ、その他のコンテキストには連番が振られる。
browserText関数とbrowserCondition関数は、これらの値を取得する方法を提供します。  常に複数のブラウザ・コンテキストがアクティブである可能性があるため、異なるコンテキストからの値の取得もサポートしています。  最も内側にある（最近開始された）ブラウザ・コンテキストには1番が振られ、その他のコンテキストには連番が振られる。
browserText関数とbrowserCondition関数は、これらの値を取得する方法を提供します。  常に複数のブラウザ・コンテキストがアクティブである可能性があるため、異なるコンテキストからの値の取得もサポートしています。  最も内側の（最近開始された）ブラウザ・コンテキストには1番が振られ、その他のコンテキストには連番が振られます。
builtins()は、シンボル・テーブルのオブジェクトのソートされていないリスト、つまりベース環境のすべてのオブジェクトを返します。  ls(baseenv(),all.names=TRUE)を使用した方が混乱が少ない。
データフレームは行ごとに、1つ以上の因子の値でサブセットされたデータフレームに分割され、関数FUNはそれぞれのサブセットに順番に適用されます。
データ・フレームは行ごとに、1 つ以上の因子の値でサブセットされたデータ・フレームに分割され、functionFUN が各サブセットに順番に適用されます。
データフレームは行ごとに、1 つ以上の因子の値でサブセットされたデータフレームに分割され、functionFUN が順番に各サブセットに適用される。
最初の 11 個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる可能性があります。
出力型は、NULL < raw < logical < integer < double < complex < character < list < expression の階層にあるコンポーネントのうち、最も高い型から決定される。  ペアリストはリストとして扱われ、ベクトル以外の構成要素（名前/シンボルやコールなど）は1要素リストとして扱われる。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のためのメソッドもあります。
ベクトルxの型は制限されません。as.characterメソッドを持ち、(byorderで)ソート可能でなければなりません。
noquoteは引数を "noquote "クラスのオブジェクトとして返します。  c()メソッドとsubscriptメソッド("[.noquote")があり、サブセットによってクラスが失われないようになっています。  printメソッド(print.noquote)は、文字列を引用符なしで表示します("...." は .... と表示されます)。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常（パッケージの'DESCRIPTION'ファイルなどでは）、シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年からの(UTC時間帯における)秒数を表す ベクトルの名前付きリストである。
last.warningオブジェクトが存在し、warnings()が使われる状況については、 options("warn")の説明を参照のこと。  要するに、これはoptions(warn = 0)でwarningが少なくとも1回呼び出された場合である。
は、評価されない関数呼び出し、つまり、与えられた引数（nameは、呼び出される関数の名前を与える文字列でなければなりません）に適用された名前付き関数からなる評価されない式を返します。  呼び出しは評価されないが、引数...は評価されることに注意。
callCCは、計算の早期終了に便利な非ローカル終了メカニズムを提供する。  exit関数は1つの引数、つまり意図された戻り値を取ります。  funのボディがexit関数を呼び出すと、callCCの呼び出しは直ちに戻り、exit関数に供給された値がcallCCによって返された値となる。
NA
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換する。範囲指定はサポートされているが、文字クラスと繰り返し文字はサポートされていない。  oldに含まれる文字数がnewより多い場合はエラーが通知され、少ない場合はnewの末尾の余分な文字は無視される。
catは、引数を文字ベクトルに変換し、それらを1つの文字ベクトルに連結し、各要素に与えられたsep = string(s)を付加して出力する。
関数cbindとrbindはS3汎用関数であり、データフレーム用のメソッドを持つ。  データフレームメソッドは、少なくとも1つの引数がデータフレームで、残りがベクトルまたは行列である場合に使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスの場合、つまりisS4(.)がtrueの場合、S4メソッドが求められ、パッケージ・メソッドから隠されたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、deparse.levelはデフォルトのメソッドと同様に従われる。
関数cbindとrbindは、データフレーム用のメソッドを持つS3汎用関数です。  データ・フレーム・メソッドは、少なくとも1つの引数がデータ・フレームで、残りがベクトルまたは行列の場合に使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスの場合、つまりisS4(.)がtrueの場合、S4メソッドが求められ、パッケージ・メソッドから隠されたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、deparse.levelはデフォルトのメソッドと同様に従われる。
これらはジェネリック関数であり、メソッドは個別に定義することも、Math groupgenericを介して定義することもできる。
この関数は、関数の引数に省略形が許され、可能な値のターゲットテーブルに対して一意に展開される必要がある場合に特に便利です。
as.characterとis.characterは汎用です。特定のクラスのオブジェクトを処理するメソッドを書くことができます。  さらに、as.characterの場合、デフォルトのメソッドはas.vectorを呼び出すため、ディスパッチはまずas.characterのメソッドに対して行われ、次にas.vectorのメソッドに対して行われます。
部分一致よりも完全一致の方が優先されます（マッチする値がターゲットの最初の部分と完全一致するが、ターゲットの方が長い場合）。
packBitsは生入力、整数入力、論理入力を受け付けます。
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換します。範囲指定はサポートされていますが、文字クラスと繰り返し文字はサポートされていません。  oldがnewより多くの文字を含む場合はエラーが通知され、newの方が少ない場合は、newの末尾の余分な文字は無視される。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、次のようなベクターの名前付きリストである。
NA
cholは一般的：ここでの説明はdefaultmethodに適用されます。
chol は一般的なもので、ここでの説明はデフォルトメソッドに適用される。
NA
関数 beta と lbeta は、ベータ関数とベータ関数の自然対数を返します、
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明します。S4 "クラス（およびメソッド）については、後述の "形式クラス "を参照してください。
ここでは、いわゆる「S3」クラス（およびメソッド）について説明します。S4 "クラス(およびメソッド)については、以下の'正式なクラス'を参照。
複数の文字列を1回または複数回プッシュバックすることができる。プッシュバックされた文字列はスタックを形成するので、最初に取り出される行は、最後にプッシュバックを呼び出したときの最初の文字列になる。  プッシュバックされた行は、readLinesやscanといった通常のテキスト読み取り関数によって、コネクションからの通常の入力に先立って読み取られる。
最初の11の関数は接続を作成します。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる可能性があります。
最初の11個の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnection または socketAccept によって作成されたソケットコネクション、および serverSocket によって作成されたサーバーソケットコネクションを除く）、引数 open に空でない値を設定することでオープンされる可能性がある。
これらの関数とクラスは、ソースコード参照を扱います。
これらの関数とクラスはソースコード参照を扱います。
stdin()、stdout()、stderr() は、それぞれコンソールの入力、出力、エラーに対応する標準接続で す (ファイル・ストリームとは限りません)。  stdout()およびstderr()接続は、シンクによって再指示することができる(状況によっては、 stdout()からの出力を分割することもできる: ヘルプ・ページを参照)。
NA
これらの関数は、applyにFUN = meanまたはFUN = sumを適切なマージン付きで使用するのと同等であるが、より高速である。  これらの関数は高速化のために書かれているため、NaNとNAの微妙な点がぼやけてしまっている。  もしna.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、これはプラットフォームに依存するかもしれない。
オブジェクトがdimnamestを持つ場合、第1成分が行名として使用され、第2成分（もしあれば）が列名として使用されます。  データフレームの場合、wnamesとcolnamesは最終的にそれぞれrow.namesとnamesを呼び出しますが、後者の方が好ましいです。
オブジェクトがdimnamestを持つ場合、第1成分が行名として使用され、第2成分（もしあれば）が列名として使用されます。  データフレームの場合、wnamesとcolnamesは最終的にそれぞれrow.namesとnamesを呼び出しますが、後者の方が好ましいです。
これらの関数は、applyにFUN = meanまたはFUN = sumを適切なマージン付きで使用するのと同じですが、より高速です。  これらの関数はスピード重視で書かれているため、NaNとNAの微妙な違いがぼやけてしまっている。  na.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、プラットフォーム依存かもしれない。
これらの引数は、標準のRコマンドライン処理が行われる前に取り込まれる。  つまり、これらは変更されていない値である。  これは特にRの--argscommand-lineフラグで有用である。
NA
NA
複素数ベクトルはcomplexで作成できる。  ベクトルは、その長さ、実部と虚部、またはモジュラスと引数を与えて指定することができる。  (長さだけを指定すると、複素数ゼロのベクトルが生成される)。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
library(package)とrequire(package)はどちらもpackageという名前のパッケージの名前空間をロードし、これらのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
NA
複素数ベクトルはcomplexで作成できます。  ベクトルは、長さ、実部と虚部、またはモジュラスと引数を与えて指定できます。  (長さだけを指定すると、複素数ゼロのベクトルが生成される)。
NA
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループジェネリックを介して定義することもできます。
2つの引数のatan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します。
NA
ほとんどのプラットフォームでは、Rの初期化時にCのスタック情報が記録され、スタックチェックに使用される。  この情報が利用できない場合、サイズはNAとして返され、スタックチェックは行われない。
これらはジェネリック関数であり、メソッドは個別に定義することも、Mathグループのジェネリックを介して定義することもできます。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これは、curl -I -Lまたはcurl -Iが報告する内容を報告します。  ftp:// URLの場合、「ヘッダー」はデータ転送前のクライアントとサーバー間の会話の記録である。
breaksが1つの数値として指定された場合、データの範囲は同じ長さのbreakに分割され、極端な値がbreakの区間内に収まるように、外側の限界は範囲の0.1%だけ移動される。  (xが定数ベクトルの場合、等しい長さの区間が作成され、そのうちの1つは単一の値を含みます)。
rightのデフォルトは、デフォルトの方法とは異なることに注意してください。  include.lowest = TRUEを使用すると、日付範囲の両端が含まれます。
breaksが1つの数値として指定された場合、データの範囲は同じ長さのbreakに分割され、極端な値が両方ともbreak区間内に収まるように、外側の限界は範囲の0.1%だけ遠ざけられます。  (xが定数ベクトルの場合、等しい長さの区間が作成され、そのうちの1つは単一の値を含みます)。
rightのデフォルトは、デフォルトの方法とは異なることに注意してください。  include.lowest = TRUEを使用すると、日付範囲の両端が含まれます。
NA
データ・フレームは、"data.frame "クラスで指定された、行名が一意である同じ行数の変数のリストです。  変数を含まない場合は、行名が行数を決定する。
論理列と因子列は整数に変換される。  文字列はまず因数に変換され、次に整数に変換される。is.numericに従って）数値でないその他の列は、as.numericまたはS4オブジェクトの場合はas(, "numeric")によって変換される。  変換後）すべての列が整数の場合、結果は整数行列となり、そうでない場合は数値（double）行列となります。
NA
デバッグ用のフラグが付けられた関数に入ると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  各ステップごとに新しいブラウザコンテキストが開始されます（前のコンテキストは破棄されます）。
デバッグ用のフラグが付けられた関数が入力されると、通常の実行は中断され、関数本体が一度に1ステートメントずつ実行されます。  各ステップごとに新しいブラウザコンテキストが開始されます（前のコンテキストは破棄されます）。
デバッグ用のフラグが付けられた関数が入力されると、通常の実行は中断され、関数本体が一度に1ステートメントずつ実行されます。  各ステップごとに新しいブラウザ・コンテキストが開始されます（前のコンテキストは破棄されます）。
データ・フレームは、"data.frame "というクラス名を持つ、同じ行数の変数のリストです。  変数が含まれていない場合は、行名が行数を決定します。
eval.envとassign.envのデフォルトは、現在アクティブな環境です。
これらの関数は、未評価の式（ここで'expression'は、expressionで使用されるmodeと型(typeof)の "expression "のベクトルという厳密な概念よりも広い意味でとらえられる）を文字列（parseの逆の一種）に変換します。
これらの関数は、評価されない式（ここで、'expression'は、expressionで使用されるmodeと型(typeof) "expression "のベクトルの厳密な概念よりも広い意味でとらえられる）を文字列（parseの逆の一種）に変換します。
determinant関数はLU分解を使用し、det関数は単にdeterminant呼び出しのラッパーです。
これは、検索リスト上の位置を参照する単一の数値引数で最も一般的に使用され、package:toolsのような検索リスト上の項目の引用符なしまたは引用符付きの名前でも使用できます。
determinant関数はLU分解を使用し、det関数は単にdeterminant呼び出しのラッパーです。
行列式関数はLU分解を使用し、det関数は単にdeterminantへの呼び出しのラッパーです。
dputはファイルを開き、オブジェクトxをそのファイルに格納する。  xが関数の場合、関連する環境は取り除かれるため、スコープ情報が失われる可能性がある。
diagには4つの異なる使い方がある：
diagには4つの異なる使い方がある：
diffは、デフォルトのメソッドとクラス "ts"、"POSIXt"、"Date "用のメソッドを持つ汎用関数です。
diffは、デフォルトのメソッドと、クラス "ts"、"POSIXt"、"Date "に対するものを持つ汎用関数である。
diffは、デフォルトのメソッドとクラス "ts"、"POSIXt"、"Date "に対するものを持つ汎用関数である。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。
diffは、デフォルトのメソッドとクラス "ts"、"POSIXt"、"Date "用のメソッドを持つ汎用関数です。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。
関数betaとlbetaはベータ関数とベータ関数の自然対数を返します、
関数dimとdim<-は内部ジェネリックプリミティブ関数です。
関数dimおよびdim<-は、内部ジェネリックプリミティブ関数である。
関数dimおよびdim<-は内部ジェネリックプリミティブ関数である。
関数dimnamesとdimnames<-はジェネリックである。
関数dmnamesとdmnames<-はジェネリックである。
関数dmnamesおよびdmnames<-はジェネリックである。
関数dmnamesおよびdmnames<-はジェネリックである。
NA
dir.existsは、（file.existsと同じ意味で）パスが存在し、ディレクトリであることをチェックします。
dir.existsは、パスが（file.existsと同じ意味で）存在し、ディレクトリであるかどうかをチェックします。
Windows以外では、パスのチルダ展開が行われます。
quoteがFALSE（デフォルト）の場合、引数は（envirではなく呼び出し側の環境で）評価される。  quoteがTRUEの場合、各引数は引用符で囲まれ（quoteを参照）、引数評価の結果、引用符が削除される。
NA
doubleは、指定された長さの倍精度ベクトルを作成します。  これはnumericと同じである。
dputはファイルを開き、オブジェクトxをそのファイルに格納する。  オブジェクト名は書き込まれません（dumpとは異なります）。xが関数の場合、関連する環境は取り除かれます。
この関数の目的は、Rの出力、例えば警告やエラーメッセージで使用するテキストを引用するための簡単なマークアップ手段を提供することです。
NA
factor "クラスのメソッドは、現在のところfactor(x, exclude=exclude)と同じです。  データ・フレーム・メソッドでは、すべての因子列に対して exclude を "グローバルに "指定することはほとんどありません。
factor "クラスのメソッドは、現在のところfactor(x, exclude=exclude)と同じです。  データ・フレーム・メソッドでは、すべての factor 列に対して exclude を "グローバルに" 指定する必要はほとんどありません。
factor "クラスのメソッドは、現在のところfactor(x, exclude=exclude)と同じです。  データ・フレーム・メソッドでは、すべての factor 列に対して exclude を "グローバルに" 指定する必要はほとんどありません。
指定されたオブジェクトの一部が（スコープ内に）存在しない場合は、警告とともに除外されます。  fileがファイルでオブジェクトが存在しない場合、ファイルは作成されません。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなどでは)、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年からの(UTC時間帯における)秒数を表す ベクトルの名前付きリストである。
last.warningオブジェクトが存在し、warnings()が使われる状況については、 options("warn")の説明を参照のこと。  要するに、options(warn = 0)でwarningが少なくとも1回呼び出された場合である。
dyn.loadがロードするオブジェクトは、macOSを除くすべてのプラットフォームで「dynamicallyloadable libraries」（「DLL」と略される）と呼ばれる。  Unix系では「dynamicallyhared objects」（略称「DSO」）、または「shared objects」とも呼ばれる。  (POSIX標準では「実行可能オブジェクトファイル」を使っているが、他の誰も使っていない)。
dyn.loadがロードするオブジェクトは、macOSを除くすべてのプラットフォームで「dynamicallyloadable libraries」（「DLL」と略される）と呼ばれる。  Unix系では「dynamicallyhared objects」（略称「DSO」）、または「shared objects」とも呼ばれる。  (POSIX標準では'実行可能オブジェクトファイル'を使っているが、他の誰も使っていない)。
pos 引数は、オブジェクトを検索する環境を、正の整数（検索リスト内の位置）、 検索リスト内の要素の文字列名、環境（現在アクティブな関数呼び出しにアクセスするために sys.framet を使用することを含む）のいずれかの方法で指定することができます。  デフォルトの-1は、toget呼び出しの現在の環境を示す。envir引数は、環境を指定する別の方法である。
NA
対称行列が指定されていない場合、isSymmetric(x)はその行列が対称であるかどうかを、もっともらしい数値誤差の範囲内で判定します。  この値を自分で設定する方が確実であり、一般的にはるかに高速である。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成される。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境との関連で「parent」を使用しないことが最善です。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言することができる。  これらの宣言はエンコーディングによって読み取ることができ、エンコーディングは "latin1"、"UTF-8"、"bytes"、または "unknown "の値の文字ベクトルを返します。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言できる。  これらの宣言はエンコーディングによって読み込むことができ、エンコーディングは "latin1"、"UTF-8"、"bytes"、または "unknown "の値の文字ベクトルを返します。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。
これは、バックスラッシュと、制御文字である˶a(ベル)、˶b(バックスペース)、 ˶f(フォームフィード)、˶n(ラインフィード)、˶r(キャリッジリ ターン)、˶t(タブ)、˶v(垂直タブ)をエスケープします。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言できます。  これらの宣言はエンコードによって読み取ることができ、エンコードは "latin1"、"UTF-8"、"bytes"、"unknown "のいずれかの値の文字ベクトルを返す。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言できる。  これらの宣言はEncodingで読み込むことができ、Encodingは "latin1"、"UTF-8"、"bytes"、"unknown "の値の文字ベクトルを返す。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。
startsWith()と同等ですが、それよりはるかに高速です。
以下のmyplotの例では、この機能の簡単な使い方を示している。deparse関数とsubstitute関数を使用して、myplot関数の実際の引数の文字列バージョンであるプロットのラベルを作成している。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境と関連して「parent」を使用しないのが最善です。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境と関連して「parent」を使用しないのが最善です。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境との関連で'parent'を使用しないことが最善です。
環境をロックすることで、環境からの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
環境はフレーム、つまり名前付きオブジェクトの集合と、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境との関連で「parent」を使用しないのが最善です。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、条件はS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
envirが指定されていない場合、デフォルトはparent.frame()(evalがコールされた環境)です。
envirが指定されない場合、デフォルトはparent.frame()(evalが呼び出された環境)です。
envirが指定されない場合、デフォルトはparent.frame()(evalが呼び出された環境)です。
where引数は、オブジェクトを検索する環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frameを使用することを含む）として指定することができます。  envir引数は環境を指定する別の方法ですが、主にバックコンパチビリティのためにあります。
logb以外は全てジェネリック関数であり、メソッドは個別に定義することも、Mathgroupジェネリックを介して定義することもできる。
NA
logb 以外はジェネリック関数です。メソッドは個別に定義することも、Mathgroup ジェネリックを介して定義することもできます。
ここでの「式」は口語的な意味、つまり数学的な式の意味で使われているのではない。  Rの式ベクトルは、例えばparseによって返されるような、呼び出しやシンボルなどのリストです。
これらは外部ライブラリであることが多いが、インストール時にRにコンパイルされていることもある。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  4つとも論理(1)ベクトルである。
ベクトルxの型に制限はなく、as.characterメソッドを持ち、ソート可能（byorder）であればよい。
関数betaとlbetaは、ベータ関数とベータ関数の自然対数を返します、
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptによって作成されたソケット接続とserverSocketによって作成されたサーバソケットコネクションを除く）。
最初の11個の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnection または socketAccept によって生成されたソケットコネクション、および serverSocket によって生成されたサーバーソケットコネクションを除く）、引数 open に空でない値を設定することでオープンされる。
モード値には、排他的または以下の値を指定できる。
これらの関数はすべてパス名を展開します: path.expandを参照してください。
NA
これらの関数はすべてパス名を展開します: path.expandを参照してください。
これらの関数はすべてパス名を展開します: path.expandを参照してください。
これらの関数はすべてパス名を展開します： path.expandを参照してください。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  大文字と小文字を区別しないファイルシステムについては、file.existsのヘルプのセクションも参照のこと。
これらの関数はすべて、パス名を展開する: path.expandを参照のこと。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  大文字小文字を区別しないファイルシステムについては、file.existsのヘルプのセクションも参照のこと。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsではディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  大文字小文字を区別しないファイルシステムについては、file.existsのヘルプのセクションも参照のこと。
この関数はRで多用されているため、実装は高速（pasteより高速）に設計されている。
これらの関数はすべてパス名を展開します: path.expandを参照してください。
...引数は連結されて1つの文字列となります。ファイルを個別に指定することも、1つのベクトルとして指定することもできます。これらの関数はすべて、パス名を展開します: path.expandを参照してください。
この関数はRのヘルプ・システムの中核をなすものだが、ページなど他の目的にも使うことができる。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  大文字小文字を区別しないファイル・システムについては、file.existsのヘルプのセクションも参照のこと。
これらの関数はすべて、パス名を展開します： path.expandを参照してください。
initが与えられた場合、Reduceは論理的にそれぞれxの開始点（左から右へ進む場合）または終了点に追加します。この拡張される可能性のあるベクトルvがn > 1個の要素を持つ場合、Reduceはそれぞれvの要素に左から右へ、または右から左へfを連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  したがって、fは常に2つの引数で呼び出されることが保証される。
もしinitが与えられれば、Reduceは論理的にそれをxの開始点（左から右へ進む場合）または終了点にそれぞれ追加する。この拡張される可能性のあるベクトルvがn > 1個の要素を持つ場合、Reduceはvの要素に左から右へ、または右から左へ、それぞれfを連続して適用する。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  したがって、fは常に2つの引数で呼び出される。
find.packageは、指定されたパッケージが見つかる場所へのパスを返します。  lib.locがNULLの場合、ライブラリの前にロードされた名前空間が検索されます。  パッケージが複数回見つかった場合は、最初にマッチしたものが使用されます。  quiet = TRUEでない限り、名前付きパッケージが見つからなかった場合は警告が、見つからなかった場合はエラーが表示されます。  verbose = TRUE の場合、複数回見つかったパッケージについての警告が表示されます。  返されるパッケージには、'Meta' サブディレクトリか、有効なバージョンフィールドを含む 'DESCRIPTION' ファイルが含まれていなければなりません。
関数 findInterval は，あるベクトル x の別のベクトル vec におけるインデックスを求めます．  これは些細なことであり、apply( outer(x, vec, ">="), 1, sum)と等価であるが、実のところ、内部アルゴリズムでは、ren <- length(x) (and N <- length(vec))の場合に、O(n * log(N))の複雑さを保証する区間探索を使用する。  (ほぼ)ソートされたxの場合は、さらに速く、基本的にO(n)である。
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、実質的に[[演算子と同等である。  これは、オブジェクトにデフォルト・メソッドを適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  オペレータとは異なり、これらはビルトインであり、特別なものではない（すべての引数が評価される）ので、引数の欠落を許さないことに注意してください。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
これらはジェネリック関数であり、メソッドは個別に定義することも、Math groupgenericを介して定義することもできる。
最初の11の関数はコネクションを作成します。  デフォルトではコネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる可能性があります。
最初の11個の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnection または socketAccept によって作成されたソケットコネクション、および serverSocket によって作成されたサーバーソケットコネクションを除く）、引数 open に空でない値を設定することによってオープンされる可能性がある。
breakは、forループ、whileループ、またはrepeatループから抜け出し、制御は最内周のループの外側にある最初のステートメントに移されます。  breakもnextも、入れ子になったループの一番内側だけに適用される。
force は、形式引数の評価を強制する。  これは、レキシカル・スコープ・ルールによって引数がクロージャに取り込まれ、後で明示的な代入やループ内の暗黙的な代入、あるいはapply関数によって変更される場合に便利です。
forceAndCallは、...で指定された引数で関数FUNを呼び出します。  FUNの値がクロージャの場合、関数本体を実行する前に、関数の最初のn個の引数が評価されます（つまり、遅延評価の約束が強制されます）。  FUNの値がプリミティブの場合、FUN(...)の呼び出しは通常の方法で評価される。
最初の形式では、funには操作する関数を指定する文字列を指定することもでき、デフォルトでは親フレームからenvirで検索されます。  指定されない場合は、formalsを呼び出す関数が使用されます。
最初の形式の場合、funには、操作する関数を指定する文字列を指定することもでき、デフォルトでは親フレームからenvirで検索されます。  指定されない場合は、formalsを呼び出す関数が使用されます。
formalsは汎用関数です。  ここで説明するメソッド以外に、日付（format.Dateを参照）、日付-時刻（format.POSIXctを参照）、その他のクラス（format.octmodeやformat.distなど）用のメソッドがあります。
formatは汎用関数です。  ここで説明したメソッド以外にも、日付（format.Dateを参照）、日付時刻（format.POSIXctを参照）、そしてformat.octmodeやformat.distといった他のクラス用のメソッドがあります。
formatは汎用関数です。  ここで説明するメソッド以外に、日付（format.Dateを参照）、日付時刻（format.POSIXctを参照）、およびformat.octmodeやformat.distなどの他のクラス用のメソッドがあります。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。
formatは汎用関数です。  ここで説明するメソッド以外に、日付（format.Dateを参照）、日付-時刻（format.POSIXctを参照）、その他のクラス（format.octmodeやformat.distなど）用のメソッドがあります。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。
formatはジェネリック関数です。  ここで説明するメソッド以外に、日付（format.Dateを参照）、日付-時刻（format.POSIXctを参照）、その他のクラス（format.octmodeやformat.distなど）用のメソッドがあります。
hexmode "クラスは、単に16進数で表示されることを保証するために使用される、このクラス属性を持つ整数ベクトルで構成されています。
NA
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、これらのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
数値バージョンは1つ以上の非負整数のシーケンスで、通常は(パッケージの'DESCRIPTION'ファイルなどでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  サブセット([)も動作する。
library(package)とrequire(package)は、どちらもpackageという名前のパッケージの名前空間をロードし、それをarchリストにアタッチします。requireは、他の関数の内部で使用するように設計されており、パッケージが存在しない場合、FALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
format および as.character メソッドと strftimec は、"POSIXlt" および "POSIXct" クラスのオブジェクトを文字ベクトルに変換します。
formatメソッドとas.characterメソッドとstrftimeconvertオブジェクトは、クラス "POSIXlt "と "POSIXct "から文字ベクトルに変換されます。
format.pvalは主にprint.summary.lmなどの補助関数であり、固定値、浮動小数点数、非常に小さな値に対して別々の書式を行う。eps未満の値は"< [eps]"（ここで'[eps]'はformat(eps, digits)を表す）として書式設定される。
因子の場合、最初の maxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは "(その他)" で要約されます (最大で maxsum の頻度になります)。
数値の場合、formatC() は必要に応じて prettyNum() を呼び出し、それ自体が .format.zeros(*, replace=replace.zero) を呼び出します("必要な場合": zero.print が NULL でない場合、 drop0trailing が true の場合、または big.mark、small.mark、decimal.mark のいずれかがデフォルトでない場合)。
引数から項目のベクトルと対応する説明を抽出した後、両者を文字ベクトルに強制する。
係数行列が上三角形(または'右', 'R')または下三角形('左', 'L')の連立一次方程式を解きます。
引数リストの名前は、バッククォートされた非標準名（'backquote'を参照）であってもよい。
関数 beta と lbeta は、ベータ関数とベータ関数の自然対数を返す、
gcを呼び出すと、ガベージ・コレクションが行われる。これは、ユーザーの介入なしに自動的に行われ、gcを呼び出す主な目的は、メモリ使用量のレポートである。  正確なレポートを得るためには、full = TRUEを使用すべきである。
タイマーの分解能のため、これは過小評価となる可能性がある。
gcを呼び出すと、ガベージ・コレクションが行われる。これは、ユーザーの介入なしに自動的に行われ、gcを呼び出す主な目的は、メモリ使用量のレポートのためである。  正確なレポートを得るためには、full = TRUEを使用すべきである。
gctorture(TRUE)を呼び出すと、メモリ・マネージャはすべての割り当てに対して強制的にフルGCを実行します。gctorture2はより洗練されたインタフェースを提供し、GC拷問の開始を延期することができ、また、ステップ割り当てごとにのみGCを実行するオプションを提供します。
gctorture(TRUE)を呼び出すと、メモリ・マネージャーはすべての割り当てに対して強制的にGCを実行します。gctorture2は、GCの拷問の開始を延期することができ、また、ステップ割り当てごとにGCのみを実行するオプションを与える、より洗練されたインタフェースを提供します。
pos引数は、オブジェクトを検索する環境を、正の整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frametを使用することを含む）として、いくつかの方法のいずれかで指定することができます。  デフォルトの-1は、toget呼び出しの現在の環境を示す。envir引数は、環境を指定する別の方法である。
where引数は、オブジェクトを探す環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frameを使用することを含む）として指定することができます。  envir引数は、環境を指定する別の方法であるが、主にバックコンパチビリティのために存在する。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる(状況によっては、 stdout()からの出力を分割することもできる: ヘルプページを参照)。
NA
NA
stdin()、stdout()、stderr() は、それぞれコンソールの入力、出力、エラーに対応する標準接続です (ファイルストリームとは限りません)。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、 stdout()からの出力を分割することもできる：ヘルプページを参照）。
これは、R内部で登録および処理された後の登録情報を受け取ります。  つまり、拡張情報を使用します。
これは、登録され、R内部によって処理された後の登録情報を取ります。  つまり、extendedinformationを使用する。
これは、登録され、R内部で処理された後の登録情報を取る。  つまり、拡張情報を使用する。
これらの演算子は汎用的です。  InternalMethods、[.data.frame]、[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  式の代入側でインデックスが作成される場合は、置換関数[<-, [[<-, $<-に別々のメソッドが必要です。
エラーの動作は、実行中のコード内で確立されたエラー・ハンドラと、options(error=) で設定された現在のデフォルトのエラー・ハンドラによって制御されます。  エラーはまず、ingsignalCondition() を使用するかのようにシグナルされます。  ハンドラがない場合、またはすべてのハンドラが返された場合、エラー・メッセージが出力され（options("show.error.messages")がtrueの場合）、デフォルトのエラー・ハンドラが使用されます。  対話的な使用におけるデフォルトの動作(NULLerrorハンドラ)は、トップ・レベルのプロンプトまたはトップ・レベルのブラウザに戻ることであり、非対話的な使用では、(効果的に)q("no", status = 1, runLast = FALSE)を呼び出すことである。デフォルト・ハンドラは、エラー・メッセージをバッファに格納する。  また、traceback() で取得できるコール・スタックのトレースも格納されます。
getExportedValue は、名前空間 ns でエクスポートされた変数名の値を返します。
setHookは、ユーザーがシステム（またはユーザー）関数から呼び出される関数のリストであるフックを登録するための一般的なメカニズムを提供します。  フックの初期セットは、パッケージ/名前空間上のイベントに関連しています。これらのフックは、topackageEventの呼び出しによって命名されます。
これはDLLを管理する内部テーブルに問い合わせる。
getExportedValue は、名前空間 ns でエクスポートされた変数名の値を返します。
getExportedValue は、名前空間 ns でエクスポートされた変数名の値を返します。
getExportedValue は、名前空間 ns 内のエクスポートされた変数名の値を返します。
packageHasNamespaceはパッケージが名前空間を持っているかどうかを示すものではありません(現在はすべて持っています)。  しかし、それを使うことを意図しているわけではありません。
getExportedValueは、名前空間nsにエクスポートされた変数名の値を返します。
getExportedValueは、名前空間nsでエクスポートされた変数名の値を返します。
getExportedValue は、名前空間 ns でエクスポートされた変数名の値を返します。
シンボルが含まれている DLL によって明示的に登録されている場合は、引数の数と呼び出されるイン ターフェースに関する情報が返されます。そうでない場合は、汎用ネイティブ・シンボル・オブジェクトが返されま す。
引数なしで options() を呼び出すと、オプションの現在の値を含むリストが返されます。  以下のすべてのオプションが初期設定されているわけではないことに注意してください。  単一のオプションの値にアクセスするには、長さ1のリストであるoptions("width")ではなく、例えばgetOption("width")を使うべきである。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
これらの関数とクラスはソースコードの参照を扱う。
NA
domain が NULL または "" で、gettext または ngettext がパッケージ pkg の名前空間の関数から呼び出された場合、 domain は "R-pkg" に設定されます。  それ以外の場合、デフォルトのドメインはありません。
sprintfは、システムのsprintf C-library関数のラッパーです。  渡される値のモードが与えられた書式と一致することをチェックし、Rの特殊な値（NA、Inf、-Inf、NaN）が正しく処理されるように試みられている。
マークされたエンコーディングのファイルパスがどのように解釈されるかについては、 filesを参照のこと。
NA
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成される。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境と関連して「parent」を使用しないのが最善です。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。
文字列または文字ベクトルであるべき引数は、可能であればcharacterに強制される。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制される。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制される。
grep とは異なり、生のベクトル x 内でマッチするパターンを探します。例えば、空の文字列にマッチするパターンは本質的に無限であるため、予期せぬ結果を招く可能性があります。
この関数は，同じ値が隣接するように要素を部分的にソートします．NAの値は最後に来る。  これは、ベストであることが保証されているので、同値は保持され、データがすでにグループ化/ソートされている場合、グループ化は変更されません。  これは集計に有用であり、特に文字ベクトルに対して高速である。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制される。
conがオープンされている場合、変更された接続がオープンされます。  ラッパーの接続を閉じると、基礎となる接続も閉じられます。
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することでオープンすることができます。
関数Iには主に2つの用途がある。
エンコーディング名と利用可能なエンコーディングはプラットフォームに依存する。  すべてのRプラットフォームは、""（現在のロケールのエンコード）、"latin1"、"UTF-8 "をサポートしている。
エンコーディングの名前と使用可能なエンコーディングは、プラットフォームに依存します。  すべてのRプラットフォームは、""（現在のロケールのエンコーディング）、"latin1"、"UTF-8 "をサポートしています。
オプションとして、RはICU(http://site.icu-project.org)によって文字列を照合するように構築することができる。  そのようなシステムでは、icuSetCollateを使用して照合方法を調整することができる。他のビルドでは、この関数を呼び出しても何もせず、警告が表示される。
オプションとして、RはICU(http://site.icu-project.org)によって文字列を照合するようにビルドできる。  このようなシステムでは、icuSetCollateを使用して照合順序を調整することができます。他のビルドでは、この関数を呼び出しても何もせず、警告が表示されます。
if文やwhile文、また&&や||を使用する論理式において、完全に等しいかどうかをテストする方法は、identicalを呼び出すことである。  これらのアプリケーションでは、単一の論理値を確実に取得する必要があります。
NA
breakは、for、while、またはrepeatループから抜け出し、制御は最内周のループの外側にある最初の文に移されます。  breakもnextも、入れ子になったループの一番内側だけに適用される。
yesまたはnoが短すぎる場合、それらの要素は再利用される。yesはtestのいずれかの要素がtrueの場合にのみ評価され、noも同様に評価される。
複素数ベクトルはcomplexで作成できる。  ベクトルは長さ、実数部、虚数部、またはモジュラスと引数で指定できます。  (長さだけを指定すると、複素数ゼロのベクトルが生成されます)。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在はすべて持っています)。  しかし、そのような使い方は想定されていません。
saveRDSとreadRDSは、1つのRobjectを接続先（通常はファイル）に保存し、そのオブジェクトをリストアする手段を提供します。  これは、1つまたは複数の名前付きオブジェクトを環境に保存したりリストアしたりするsaveやloadとは異なります。  例えば、パッケージのメタデータを保存したり、help.searchdatabasesを保存したりするために、".rds "という拡張子が最もよく使われている。
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明します。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。
整数ベクトルは、それを期待するCやFortranコードにデータを渡せるように、また、（小さな）整数データを正確かつコンパクトに表現できるように存在します。
NA
対話型Rセッションとは、対話する人間のオペレータがいることを前提としたセッションのことで、例えば、Rは間違った入力の訂正を促したり、次に何をすべきか、次のプロットに移ってもよいかどうかを尋ねたりすることができます。
union、intersect、setdiff、setequalのそれぞれは、引数の重複する値を破棄し、引数に対してas.vectorを適用します（特に文字ベクトルに対して係数を強制します）。
packBitsは生入力、整数入力、論理入力を受け付けます。
これらはどのロケールでも動作し、マルチバイト文字セットをサポートしていないプラットフォームでも動作する。
vector'はis.vectorの意味で使われる。
この関数は、代入可能な値を返すが、代入されないと表示されない関数を使用したい場合に便利です。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができる。  これは単に、次元（属性 "dim"）とオプションでその次元の名前（属性 "dimnames"）を与える追加属性とともに格納されるベクトルです。
is.atomicは、atomic型（"logical"、"integer"、"numeric"、"complex"、"character"、"raw"）とNULLに対して真となります。
は、評価されない関数呼び出し、つまり、与えられた引数（nameは、呼び出される関数名を示す文字列でなければならない）に名前付き関数を適用した評価されない式を返します。  呼び出しは評価されませんが、引数...は評価されることに注意してください。
as.characterとis.characterは汎用です。特定のクラスのオブジェクトを処理するメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すため、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。
複素数ベクトルはcomplexで作成できます。  ベクトルは長さ、実数部と虚数部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます)。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  ベクトルとして動作するクラスでは、多くの場合、as.data.frame.vectorのコピーがメソッドとして動作します。
doubleは指定された長さの倍精度ベクトルを作成します。  これは numeric と同じです。
union、intersect、setdiff、setequalのそれぞれは、引数の重複する値を破棄し、引数にas.vectorを適用します（特に文字ベクトルにはcoerce係数を適用します）。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境との関連で'parent'を使用しないことが最善です。
ここでの「式」は口語的な意味、つまり数学的な式の意味で使われているのではない。  Rの式ベクトルは、例えばparseが返すような、呼び出しやシンボルなどのリストです。
ベクトルxの型に制限はなく、as.characterメソッドを持ち、ソート可能（byorder）であればよい。
is.finiteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が有限であれば（すなわち、NA、NaN、Inf、Infのいずれでもなければ）TRUEとなり、そうでなければFALSEとなります。  複素数は、実部と虚部の両方が有限であれば有限である。
is.primitive(x)は、xがプリミティブ関数であるかどうか、すなわちtypeof(x)が "builtin "または "special "であるかどうかを判定する。
is.finiteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が有限であれば（すなわち、NA、NaN、Inf、またはInfの値のいずれかでなければ）TRUEであり、そうでなければFALSEである。  複素数は実部と虚部の両方が有限であれば有限である。
整数ベクトルが存在するのは、それを期待するCやFortranコードにデータを渡せるようにするためであり、（小さな）整数データを正確かつコンパクトに表現できるようにするためである。
NA
Rの内部ではほとんどすべてのリストがジェネリックベクトルであり、（LISPのような）伝統的なドットペアリストは依然として使用可能ですが、（関数の形式として使用される以外は）ユーザが目にすることはほとんどありません。
dyn.loadがロードするオブジェクトは、macOSを除くすべてのプラットフォームで「dynamicallyloadable libraries」（「DLL」と略される）と呼ばれる。  Unix系では「dynamicallyhared objects」（略称「DSO」）、または「shared objects」とも呼ばれる。  (POSIX標準では'実行可能オブジェクトファイル'を使用していますが、他の誰も使用していません)。
TRUEとFALSEはR言語の論理定数を示す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  4つともlogical(1)ベクトルである。
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとする。  どちらも与えられない場合、1列の行列が返される。
文字型の NA は、文字列 "NA" とは異なる。  明示的に欠損文字列を指定する必要があるプログラマは、（"NA "ではなく）NA_character_を使用するか、is.na<-を使用して要素をNAに設定すべきである。
文字型のNAは文字列 "NA "とは異なる。  明示的に欠落文字列を指定する必要があるプログラマーは、（"NA "ではなく）NA_character_を使うか、is.na<-を使って要素をNAに設定してください。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなど)は、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
文字型のNAは、文字列 "NA "とは異なる。  明示的に欠損文字列を指定する必要があるプログラマーは、"NA "ではなく "NA_character_"を使用するか、is.na<-を使用して要素をNAに設定してください。
文字型のNAは文字列 "NA "とは異なる。  明示的に欠損文字列を指定する必要があるプログラマーは、（"NA "ではなく）NA_character_を使うか、is.na<-を使って要素をNAに設定すべきである。
as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは3つ（メジャー、マイナー、パッチレベル）で構成されます。
名前は10,000バイトに制限される（Rの2.13.0より前のバージョンでは256バイトだった）。
is.finiteはxと同じ長さのベクトルを返し、そのj番目の要素はx[j]が有限であれば(すなわち、NA, NaN, Inf,-Inf のいずれでもなければ)TRUEとなり、そうでなければFALSEとなる。  複素数は、実部と虚部の両方が有限であれば有限である。
NULLは、構文上適法な方法であればどのような方法でもインデックスを付けることができます（Extract参照）。  値がNULLのオブジェクトは置換演算子で変更でき、右辺の型に強制されます。
numericはdouble（およびreal）と同じです。指定された長さの倍精度ベクトルを作成し、各要素は0に等しくなります。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなどでは)、シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは3つ(メジャー、マイナー、パッチレベル)で構成されます。
numericはdouble（およびreal）と同じです。指定された長さの倍精度ベクトルを作成し、各要素は0に等しくなります。
difftime関数は、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime "クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。
numericはdouble（およびreal）と同じです。指定された長さの倍精度ベクトルが作成され、各要素は0に等しくなります。
NA
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現される。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
Rの内部では、ほとんどすべてのリストがジェネリックベクタであり、伝統的な（LISPのような）点線のペアリストは利用可能ですが、ユーザが目にすることはほとんどありません（関数のフォーマルとして利用する場合を除く）。
is.primitive(x)は、xがプリミティブ関数であるかどうか、つまりtypeof(x)が "builtin "または "special "であるかどうかをテストします。
QR分解は多くの統計的手法で重要な役割を果たしている。  QR分解は多くの統計的手法で重要な役割を果たします。特に、与えられた行列 ㊟とベクトル㊟に対して方程式㊟=㊟を解くのに使われます。  これは回帰係数の計算やニュートン・ラプソンアルゴリズムの適用に役立ちます。
この関数は、R、S、S-PLUSのすべてのバージョンで正しく実行できるように書かれています。S-PLUS 8.0より前のRとSの両方の方言でコードを実行できるようにするには、コードでis.Rを定義するか、is.Rを次のように使用する必要があります。
raw型は生のバイトを保持するためのものです。  バイトのシーケンスを抽出したり、要素を置き換えたりすることができる（ただし、rawベクトルの要素に限る）。  関係演算子（バイト表現の数値順序を使用した比較を参照）は、ビット単位の解釈を持つ論理演算子（論理を参照）と同様に機能する。
is.atomicは、atomic型（"logical"、"integer"、"numeric"、"complex"、"character"、"raw"）とNULLに対して真となる。
NA
名前は10,000バイトに制限される（Rの2.13.0より前のバージョンでは256バイト）。
引数dnnが与えられない場合、内部関数list.namesが呼び出されて'dimname名'が計算される。  もし...の引数に名前が付けられていれば、その名前が使用されます。  残りの引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2はその引数を使用します。
is.unsortedは汎用的で、特定のクラスのオブジェクトを扱うメソッドを書くことができる。
アトミック・モードには、"logical"、"integer"、"numeric"（同義語の "double"）、"complex"、"character"、"raw "がある。
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明する。S4 "クラス（およびメソッド）については、後述の "形式クラス "を参照のこと。
stdin()、stdout()、stderr() は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができます（状況によっては、stdout()からの出力を分割することもできます：ヘルプページを参照）。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在はすべてそうなっています)。むしろ'NAMESPACE'ファイルを持っているかどうかを示します。  しかし、そのような使い方は想定されていません。
デバッグ用のフラグが付けられた関数に入ると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  各ステップごとに新しいブラウザ・コンテキストが開始されます（前のコンテキストは破棄されます）。
は論理否定（NOT）を示す。
最初の11の関数はコネクションを作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することでオープンされる可能性があります。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在はすべて持っています)。  しかし、そのような使い方は想定されていません。
loadNamespace関数とattachNamespace関数は通常、libraryを使用してネームスペースと必要なインポートをロードするときに暗黙的に呼び出されます。  しかし、これらの関数を直接呼び出すと便利な場合もあります。
ISOdatetimeとISOdateはstrptimeの便利なラッパーで、デフォルトとISOdateがタイムゾーンとしてUTCを設定する点だけが異なります。  時刻を伴わない日付については、通常は "Date "クラスを使う方がよいでしょう。
ISOdatetimeとISOdateはstrptimeの便利なラッパーで、デフォルトが異なり、ISOdateはタイムゾーンとしてUTCを設定します。  時刻を伴わない日付については、通常は "Date "クラスを使用する方がよいでしょう。
最初の11の関数は接続を作成します。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされます。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトであるが、これはいずれ変更されるかもしれない。
isS4はmethodsパッケージには依存しないので、特にそのパッケージを要求する必要性を検出するために使用できることに注意してください。
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します: 現時点では、(おそらくgz圧縮された)ファイル接続のみがサポートしています。
行列メソッドは、デフォルトではeigenの内部で使用され、all.equalを使用して丸め誤差までの行列の対称性をテストします。  すべての状況において適切であるとは限りません。
行列の対称性を四捨五入誤差まで検定するために、デフォルトではeigenの内部でall.equal.Matrixメソッドが使用されます。  すべての状況で適切であるとは限りません。
は論理否定(NOT)を表す。
ここで n <- length(x), a は量引数 (指定された場合) である。
NA
NA
NA
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition数は 安い近似によって推定される。  しかし、(svdによる)正確な計算も十分に速い。
kappa()では、exact = FALSE (デフォルト)の場合、2-ノルム条件数は、 安価な近似によって推定される。  しかし、(svdによる)正確な計算も十分に速い。
kappa()では、exact = FALSE (デフォルト)の場合、2-ノルム条件数は、 安価な近似によって推定される。  しかし、(svdによる)正確な計算も十分に速い。
kappa()では、exact = FALSE (デフォルト)の場合、2-ノルム条件数は、 安価な近似によって推定される。  しかし、(svdによる)正確な計算も十分に速い。
X と Y が同じ次元数でない場合，小さい方の配列にサイズ 1 の次元が詰められます．  返される配列は、Xを1項ずつ受け取り、その項をFUN(x, Y, ...)として展開することで構成される部分行列である。
Latin-1 ロケール」には、Windows コードページ 1252 のような (印字可能な文字の) スーパーセットは含まれるが、 Latin-9 (ISO 8859-15) は含まれない。
NA
NA
特異値分解は、多くの統計手法で重要な役割を果たす。svdとLa.svdは、戻り値が異なる2つのインタフェースを提供する。
NA
NA
FUNは、match.funの呼び出しによって見つけられ、通常、関数、シンボル（バッククオート名など）、またはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定されます。
これらは、R自身によってのみ使用される内部関数である。
これらは R 自身のみが使用する内部関数です。
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、基本的に[[ 演算子と同等です。  これは、オブジェクトにデフォルト・メソッドを適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  オペレータとは異なり、これらはビルトインであり、特別なものではない（すべての引数が評価される）ので、引数の欠落を許さないことに注意してください。
関数betaとlbetaはベータ関数とベータ関数の自然対数を返します、
関数betaとlbetaは、ベータ関数とベータ関数の自然対数を返します、
length<-は "factor "メソッドを持っています。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表します。
どちらの関数も汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。length<-には "factor "メソッドがあります。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。
length<-には "factor "メソッドがあります。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表します。
事実上、length(x[[i]])はすべてのiに対して呼び出されるので、lengthに関するメソッドはすべて考慮されます。
Rには少数の組み込み定数があります。
Rには少数の組み込み定数がある。
抽出形式も置換形式も汎用的で、新しいメソッドを書くことができます。  置換関数の最も重要なメソッドは因子のメソッドである。
抽出形式も置換形式も汎用的であり、新しいメソッドを書くことができる。  置換機能で最も重要なメソッドは因子に対するものである。
抽出形式も置換形式も汎用的であり、新しいメソッドを書くことができる。  置換機能で最も重要なメソッドは因子に対するものである。
抽出形式も置換形式も汎用的であり、新しいメソッドを書くことができる。  replacement関数の最も重要なメソッドは因子に対するメソッドです。
関数 beta と lbeta はベータ関数とベータ関数の自然対数を返します、
関数 beta と lbeta は、ベータ関数とベータ関数の自然対数を返します、
NA
library(package)とrequire(package)は、どちらもpackageという名前のパッケージの名前空間をロードし、これらのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
これらの関数が扱うオブジェクトの種類については、dyn.loadを参照のこと。
これらの関数が扱うオブジェクトの種類については、dyn.loadを参照のこと。
RはGNU GENERAL PUBLIC LICENSE（バージョン2、1991年6月またはバージョン3、2007年6月）に従って配布されています。  バージョン2のライセンスのコピーはファイル'R_HOME/doc/COPYING'にあり、RShowDoc("COPYING")で見ることができます。  バージョン3のライセンスは、RShowDoc("GPL-3")で表示できます。
RはGNU GENERAL PUBLIC LICENSE（バージョン2、1991年6月またはバージョン3、2007年6月）の条件の下で配布されています。  バージョン2のライセンスのコピーは 'R_HOME/doc/COPYING' ファイルにあり、RShowDoc("COPYING") で見ることができます。  バージョン3のライセンスはRShowDoc("GPL-3")で表示できます。
Rの内部ではほとんどすべてのリストがGeneric Vectorsであり、LISPのような伝統的なドットペア・リストは利用可能であるが、ユーザが見ることはほとんどない（関数のフォーマルとして利用する場合を除く）。
NA
NA
全てのリスト要素は "そのまま "扱われることに注意してください（同じ長さに複製される可能性は別として）。
これは、環境上でハッシュが使用されていない限り、大きな入力に対して非常に遅くなります。
loadは、現在または以前のフォーマットで保存されたRオブジェクトをロードすることができます。  圧縮ファイル(saveを参照)をファイルから直接読み込むことも、適切な接続(urlへの呼び出しを含む)から読み込むこともできます。
関数loadNamespaceとattachNamespaceは通常、libraryが名前空間と必要なインポートをロードするために使用されるときに暗黙的に呼び出されます。  しかし、これらの関数を直接呼び出すと便利な場合もあります。
packageHasNamespaceは、パッケージが名前空間を持っているかどうかを示すものではありません（現在ではすべてそうなっています）。  しかし、そのような使い方は想定されていません。
loadNamespace関数とattachNamespace関数は通常、libraryを使用してネームスペースと必要なインポートをロードするときに暗黙的に呼び出されます。  しかし、これらの関数を直接呼び出すと便利な場合もあります。
envirが指定されていない場合、デフォルトはparent.frame()(evalが呼び出された環境)です。
environmentをロックすることで、environmentからの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
環境をロックすると、環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
logb 以外はジェネリック関数です。メソッドは個別に定義することも、Mathgroup ジェネリックを介して定義することもできます。
logb 以外はジェネリック関数です： メソッドは個別に定義することも、Mathgroup ジェネリックを介して定義することもできます。
logb 以外はジェネリック関数：メソッドは個別に定義することも、Mathgroup ジェネリックを介して定義することもできる。
logb 以外はジェネリック関数：メソッドは個別に定義することも、Mathgroup ジェネリックを介して定義することもできる。
logb 以外はジェネリック関数です：メソッドは個別に定義することも、Mathgroup ジェネリックを介して定義することもできます。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  4つとも論理(1)ベクトルである。
NA
name引数は、オブジェクト名を取得する環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または明示的な環境（現在アクティブな関数呼び出しにアクセスするためのingsys.frameの使用を含む）のいずれかの形式で指定することができる。posとenvir引数は、環境を指定するための代替手段ですが、主にバックコンパチビリティのためにあります。
構文上有効な名前は、文字、数字、ドットまたは下線文字で構成され、文字またはドットの後に数字が続かない文字で始まる。  .2way "のような名前は無効であり、予約語でもない。
make.uniqueが使用するアルゴリズムは、make.unique(c(A, B)) == make.unique(c(make.unique(A), B))という特性を持っています。
lockEnvironment関数は、そのenvironment引数をロックします。environmentをロックすると、environmentからの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
initが与えられると、Reduceは論理的にそれをxの開始点（左から右に進む場合）または終了点にそれぞれ追加します。この拡張される可能性のあるベクトルvがn > 1個の要素を持つ場合、Reduceはvの要素に左から右、または右から左にそれぞれfを連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  したがって、fは常に2つの引数で呼び出される。
mapplyは、...の値（長さが0でない限り、最も長い値の長さに再循環される）に対してFUNを呼び出し、その後にMoreArgsで与えられた引数が続く。  ...またはMoreArgsに名前が付けられている場合、呼び出しの中の引数には名前が付けられる。
NA
NA
NA
in%は現在"%in%"として定義されています。
1引数形式のmatch.arg(arg)では、選択肢はmatch.argが呼び出された関数の形式引数argのデフォルト設定から得られます。  (デフォルトの引数マッチングはargを選択肢に設定するので、これは'several.okがTRUEでない限り長さ1'ルールの例外として許可され、最初の要素を返します)。
match.callはプリミティブ関数(引数のマッチングは通常位置指定)をサポートしていません。
match.callはプリミティブ関数（引数のマッチングは通常位置マッチングです）をサポートしません。match.funは呼び出し元の親でマッチングを行うため、トップレベルで使用することは意図されていません。
S3メソッドを書くことができる4つのグループ、すなわち、"Math"、"Ops"、"Summary"、"Complex "グループがあります。  これらはベースRのRオブジェクトではないが、メソッドを提供することができ、ベースRは最初の3つのグループのためのfactor、data.frame、difftimeメソッドを含んでいる。  (Opsのorderedメソッド、MathとOpsのPOSIXtメソッドとDateメソッド、OpsとSummaryのpackage_versionメソッド、そしてstatsパッケージのOpsのtsメソッドもあります)。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使用されていたのはそれほど昔ではありません（イギリスとその植民地では1752年に採用されました）。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のためのメソッドもあります。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
nrowまたはncolのどちらかが与えられていない場合、データの長さと他のパラメータからそれを推測しようとします。  どちらも与えられない場合、1列の行列が返される。
maxとminは、引数に含まれるすべての値の最大値または最小値を、すべてが論理値または整数値の場合は整数値として、すべてが数値値の場合はdoubleとして、それ以外の場合は文字として返します。
ties.method="random "の場合、デフォルトのように、同値はランダムに分割される。  この場合、同値の判定は、エントリが確率であることを前提とします：行の中で最大の（無限大を除いた大きさの）エントリに対して、1e-5の相対的な許容誤差があります。
NA
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となる。  日付は常に現在のグレゴリオ暦の規則に従って表示されるが、その暦が使用されていたのはそれほど昔ではない（イギリスとその植民地では1752年に採用された）。
NA
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
Inf のサイズを指定すると、リミットはそのプラットフォームで可能な最大値に設定されます。
Infのサイズを指定すると、リミットがそのプラットフォームで可能な最大値に設定されます。
type = "none "は入力をそのまま通過させるが、typeが変数の場合は有用である。
type = "none "は入力をそのまま通過させるが、typeが変数であれば有用である。
現在の型とその使用法は、インクルード・ファイル'Rinternals.h'にリストされている。
mergeは、データフレームを主なメソッドとする汎用関数です。デフォルトのメソッドは、引数をデータフレームに強制し、"data.frame "メソッドを呼び出します。
mergeはデータフレームを主なメソッドとする汎用関数です： デフォルトのメソッドは引数をデータフレームに強制し、"data.frame "メソッドを呼び出します。
mergeはデータフレームを主なメソッドとする汎用関数です。デフォルトのメソッドは引数をデータフレームに強制し、"data.frame "メソッドを呼び出します。
messageは、警告でもエラーでもないが、条件として表現される「単純な」診断メッセージを生成するために使用されます。  警告やエラーとは異なり、最後の改行はメッセージの一部とみなされ、省略可能である。デフォルトのハンドラは、stderr()接続にメッセージを送信する。
pos 引数は、オブジェクトを検索する環境を、正の整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするために sys.framet を使用することを含む）として、いくつかの方法で指定することができます。  デフォルトの-1は、toget呼び出しの現在の環境を示す。envir引数は、環境を指定する別の方法です。
maxとminは、引数に存在する全ての値の最大値か最小値を、全てが論理か整数の場合は整数として、全てが数値の場合はdoubleとして、それ以外の場合は文字として返します。
missing(x)は、xが関数に入ってから変更されていない場合のみ信頼できます。特に、x <- match.arg(x)の後は常に偽になります。
複素数ベクトルはcomplexで作成できます。  ベクトルはその長さ、実数部と虚数部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます)。
modeもstorage.modeも、オブジェクトの(記憶)モードを文字列で返します。
modeもstorage.modeも、オブジェクトの（記憶）モードを文字列で返します。
Rには少数の組み込み定数がある。
Rには少数の組み込み定数がある。
NA
NA
NA
attrとは異なり、NULLオブジェクトに属性を設定してもエラーにはなりません。
namesは一般的なアクセサ関数で、names<-は一般的な置換関数です。  デフォルトのメソッドは、ベクトル（リストを含む）またはペアリストの "names" 属性を取得および設定します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストです。
namesは一般的なアクセサ関数で、names<-は一般的な置換関数です。  デフォルトのメソッドは、ベクトル（リストを含む）またはペアリストの "names "属性の取得と設定です。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストです。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではなく（現在はすべてそうなっている）、むしろ'NAMESPACE'ファイルを持っているかどうかを示す。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、そのような使い方は想定されていません。
これはかなり間接的な方法で発生することがあり、例えばx[]が `[.some_method`(x, )]への呼び出しをディスパッチすることがありますが、これは引数が2つあるとみなされます。
文字列の'サイズ'は、（type引数に対応する）3つの方法のいずれかで測定することができる：
NA
NA
もしinitが与えられると、Reduceは論理的にそれをxの先頭（左から右へ進む場合）または末尾にそれぞれ追加する。この拡張される可能性のあるベクトルvがn > 1の要素を持つ場合、Reduceはvの要素に左から右へ、または右から左へそれぞれfを連続して適用する。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  このように、fは常に2つの引数で呼び出されることが保証されている。
環境は、フレームまたは名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境との関連で「parent」を使用しないのが最善です。
breakはfor、while、repeatループから抜け出し、制御はループの最内周の外側にある最初の文に移される。  breakもnextも、入れ子になったループの一番内側だけに適用される。
クラス属性は、オブジェクトが継承するクラスの名前を示す文字ベクトルです。オブジェクトがクラス属性を持たない場合、そのオブジェクトは暗黙のクラスを持ちます。  ほとんどのベクトルはmode(x)の結果がclassになります。ただし、整数ベクトルはclass c("integer", "numeric")、実数ベクトルはclass c("double", "numeric")です。
domain が NULL または "" で、gettext または ngettext がパッケージ pkg の名前空間の関数から呼び出された場合、 domain は "R-pkg" に設定されます。  それ以外の場合、デフォルトのドメインはありません。
これは通常因子に適用されますが、他のオブジェクトがレベルを持つこともあります。
noquote は、引数を "noquote" クラスのオブジェクトとして返します。  c()メソッドと添え字メソッド("[.noquote")があり、サブセットによってクラスが失われないようにします。  print メソッド (print.noquote) は、文字列を引用符なしで表示します ("...." は .... と表示されます)。
norm()の基底メソッドは、LAPACK関数dlangeを呼び出します。
チルダ展開（path.expandを参照）はまずpathに対して行われる。
NA
NA
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続である（ファイルストリームとは限らない）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、 stdout()からの出力を分割することもできる：ヘルプページを参照）。
numericはdouble（およびreal）と同じです。指定された長さの倍精度ベクトルを作成し、各要素は0に等しくなります。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは3つ（メジャー、マイナー、パッチレベル）で構成されます。
packBitsは生入力、整数入力、論理入力を受け付けます。
packBitsは、生入力、整数入力、または論理入力を受け付ける。
文字列の「サイズ」は、3つの方法（type引数に対応）のいずれかで測定できる：
name引数は、オブジェクト名を取得する環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または明示的な環境（現在アクティブな関数呼び出しにアクセスするためのingsys.frameの使用を含む）のいずれかの形式で指定することができます。posとenvir引数は、環境を指定する代替手段であるが、主にバックコンパチビリティのために存在する。
ここでは、いわゆる "S3 "クラス（とメソッド）について説明する。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。
ここでは、いわゆる「S3」クラス（およびメソッド）について説明します。S4 "クラス（およびメソッド）については、以下の'正式なクラス'を参照してください。
タイムゾーンはシステム固有のトピックであるが、最近ではほとんどすべてのRplatformsが同様の基礎コードを使用しており、Linux、macOS、Solaris、AIX、FreeBSDで使用され、WindowsではRと一緒にインストールされる。  (残念ながら、実装にはシステム固有のエラーが多くあります。) Windowsだけでなく、Unix系でもRソースのバージョンのコードを使用することが可能です: macOSではこれがデフォルトで、Solarisではこれが推奨されています。
on.exitに渡されたexpr引数は評価されずに記録される。  その後、同じ関数の別のon.exit呼び出しによって削除/置換されなければ、関数が終了するときに（標準エラー処理中も含めて）その関数のevaluationフレームで評価されます。  そのため、exprの中にある関数や変数は、関数とその環境が終了した時点で検索されます。
最初の11の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptによって作成されたソケット接続とserverSocketによって作成されたサーバソケットコネクションを除く）。
最初の11個の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnection または socketAccept によって作成されたソケットコネクション、および serverSocket によって作成されたサーバーソケットコネクションを除く）、引数 open に空でない値を設定することでオープンされる可能性がある。
これらの関数とクラスは、ソースコード参照を扱います。
これらの関数とクラスはソースコード参照を処理します。
これらの関数とクラスは、ソース・コード参照を処理します。
S3 メソッドを記述できるグループは、"Math"、"Ops"、"Summary"、"Complex" の 4 つです。  これらはベースRのRオブジェクトではありませんが、メソッドを提供することができ、ベースRには最初の3つのグループのためのfactor、data.frame、difftimeメソッドが含まれています。  (Opsのorderedメソッド、MathとOpsのPOSIXtメソッドとDateメソッド、OpsとSummaryのpackage_versionメソッド、statsパッケージのOpsのtsメソッドもあります)。
数値ベクトルとして指定された場合、xは整数である必要はありませんが、Datesのヘルプの小数日に関するコメントを参照してください。
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ(メジャー、マイナー、パッチレベル)です。
ベクトルxの型に制限はなく、as.characterメソッドを持ち、ソート可能（byorder）であればよい。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
引数なしでoptions()を起動すると、オプションの現在の値がリストとして返される。  以下のすべてのオプションが初期設定されているわけではないことに注意。  1つのオプションの値にアクセスするには、長さ1のリストであるoptions("width")ではなく、例えばgetOption("width")を使うべきである。
最初のベクトルで同値の場合は、2番目のベクトルで同値を解消する。  使用されるソートは安定しているので（method = "quick "を除く）、未解決の同値は元の順序のまま残されます。
ベクトルxの型は制限されない。as.characterメソッドを持ち、ソート可能（byorder）でなければならない。
XとYはFUNの適切な引数でなければならない。  FUNが呼び出される前に、XとYの長さの積がrepで拡張される。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなど)は、シーケンスの要素を連結し、.または-文字で区切った文字列として表現される。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは、ちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
setHookは、ユーザーがシステム（またはユーザー）関数から呼び出される関数のリストであるフックを登録するための一般的なメカニズムを提供する。  フックの初期セットは、パッケージ/名前空間上のイベントと関連付けられています。これらのフックは、packageEventの呼び出しによって命名されます。
packageHasNamespaceは、パッケージが名前空間を持っているかどうかを示すものではありません(現在はすべて持っています)。  しかし、それを使うことを意図しているわけではありません。
find.packageは、指定されたパッケージが見つかる場所へのパスを返します。  lib.locがNULLの場合、ライブラリの前にロードされた名前空間が検索されます。  パッケージが複数回見つかった場合は、最初にマッチしたものが使用されます。  quiet = TRUEでない限り、名前付きパッケージが見つからなかった場合は警告が、見つからなかった場合はエラーが表示されます。  verbose = TRUE の場合、複数回見つかったパッケージについての警告が表示されます。  返されるパッケージは、'Meta' サブディレクトリか、有効なバージョンフィールドを含む 'DESCRIPTION' ファイルを含んでいなければならない。
messageは、警告でもエラーでもない、「単純な」診断メッセージを生成するために使用される。  デフォルトのハンドラは、stderr() 接続にメッセージを送信します。
packBitsは生入力、整数入力、論理入力を受け付けます。
Rの内部では、ほとんどすべてのリストがGeneric Vectorsであり、伝統的なドットペア・リスト（LISPのもの）は依然として使用可能ですが、ユーザが目にすることはほとんどありません（関数のフォーマルとして使用する場合を除く）。
環境は、フレームまたは名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境と関連して「parent」を使用しないのが最善です。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  混同しやすいので、（parent.envという関数が存在するにもかかわらず）環境と関連して「parent」を使用しないのが最善です。
.GlobalEnvはフレームのリストで0番を与えられます。それに続く各関数の評価はフレームスタックを1ずつ増やします。その関数の呼び出し、関数定義、評価のための環境は適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
textの長さが0より大きい場合（強制終了後）、fileよりも優先して使用されます。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではありません(現在はすべて持っています)。  しかし、それを使うことを意図しているわけではありません。
pasteは（as.characterで）引数を文字列に変換し、（sepで指定した文字列で区切って）連結します。  引数がベクタの場合、それらを項ごとに連結して文字ベクタの結果を得ます。  ベクトル引数は必要に応じてリサイクルされ、長さ0の引数はrecycle0が真でないかcollapseがNULLでない場合にのみ""にリサイクルされます。
pasteは引数を(as.characterで)文字列に変換し、(sepで指定した文字列で区切って)連結します。  引数がベクタの場合、引数は項ごとに連結され、文字ベクタの結果となります。  ベクトル引数は必要に応じてリサイクルされ、長さ0の引数はrecycle0が真でないかcollapseがNULLでない場合にのみ""にリサイクルされる。
Rのほとんどのビルドでは、先頭の~userはユーザのホームディレクトリに展開されます（R 4.1.0以降ではreadlineも使用されません）。
find.packageは、指定されたパッケージが見つかる場所へのパスを返します。  lib.locがNULLの場合、ライブラリの前にロードされた名前空間が検索されます。  パッケージが複数回見つかった場合は、最初にマッチしたものが使用されます。  quiet = TRUEでない限り、名前付きパッケージが見つからなかった場合は警告が、見つからなかった場合はエラーが表示されます。  verbose = TRUE の場合、複数回見つかったパッケージについての警告が表示されます。  返されるパッケージは、'Meta' サブディレクトリか、有効なバージョンフィールドを含む 'DESCRIPTION' ファイルを含んでいなければならない。
NA
Rには少数の組み込み定数がある。
最初の11個の関数は接続を作成する。  デフォルトでは、コネクションはオープンされない（socketConnectionまたはsocketAcceptによって作成されたソケット接続とserverSocketによって作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することによってオープンされる可能性がある。
2つのステップタイプはx-yの優先順位が異なる：x1<x2で(x1,y1)から(x2,y2)に移動する場合、type = "s "はまず水平に移動し、次に垂直に移動するが、type = "S "はその逆に移動する。
動作はduplicates.okの値によって異なる。まず、これが真の場合を考える。  最初に完全一致が考慮され、最初の完全一致の位置が記録される。次に、一意な部分一致が考慮され、見つかった場合は記録されます。  (部分一致は、xの要素の全体が表の要素の先頭に一致する場合に起こる)。  さらに、空文字列は何もマッチせず、空文字列と完全にマッチすることもない。  これは、例えば文字インデックスの部分一致の場合の適切な動作です。
maxとminは、引数に含まれるすべての値の最大値または最小値を返します。すべてが論理値または整数値の場合は整数値として、すべてが数値の場合はdoubleとして、それ以外の場合は文字として返されます。
max と min は、引数に含まれるすべての値の最大値または最小値を、all が論理値または整数値の場合は integer として、all が数値の場合は double として、それ以外の場合は character として返します。
max と min は、引数に含まれるすべての値の最大値または最小値を、all が論理値または整数値の場合は integer として、all が数値値の場合は double として、それ以外の場合は character として返します。
max と min は、引数に含まれるすべての値の最大値または最小値を、すべてが論理または整数の場合は整数として、すべてが数値の場合は double として、それ以外の場合は文字として返します。
n - 1次の多項式、
環境内のオブジェクトを操作するためのいくつかのR関数（getやlsなど）では、検索パス内の対応する位置から環境を指定することができます。pos.to.envは、これらの位置を対応する環境に変換するプログラマのための便利な関数です。  これはプリミティブです。
もしinitが与えられると、Reduceは論理的にそれをxの開始点（左から右へ進む場合）または終了点にそれぞれ追加します。この拡張される可能性のあるベクトルvがn > 1個の要素を持つ場合、Reduceはvの要素に左から右へ、または右から左へそれぞれfを連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  したがって、fは常に2つの引数で呼び出されることが保証される。
prettyはxの有限でない値を無視する。
prettyはxの非有限値を無視する。
数値の場合、formatC()は必要なときにprettyNum()を呼び出し、それ自身が.format.zeros(*, replace=replace.zero)を呼び出します("必要なとき": zero.printがNULLでないとき、drop0trailingがtrueであるとき、またはbig.mark、small.mark、decimal.markのいずれかがデフォルトでないとき)。
デフォルト・メソッドであるprint.defaultには、それ自身のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。
関数Iには主に2つの使い方がある。
データ・フレームが行ごとに1つ以上の要因の値でサブセットされたデータ・フレームに分割され、関数FUNが各サブセットに順番に適用されます。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するメカニズムを提供する。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。
最初の11の関数はコネクションを作成する。  デフォルトではコネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。
formatを呼び出すと、データフレームが列ごとにフォーマットされ、文字行列に変換されて行列のprintメソッドに出力される。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って印刷されるが、その暦が使用されていたのはそれほど古くはない（イギリスとその植民地では1752年に採用された）。
NAを表示するときのデフォルトは、これが文字NAで quote = FALSE でない限り、NA（引用符なし）を表示する。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示すattributeを持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。
デフォルト・メソッドのprint.defaultには、独自のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用します。
これは、DLLを管理する内部テーブルを照会します。
DLLを管理する内部テーブルに問い合わせます。
これは、R内部によって登録および処理された後の登録情報を取得します。  つまり、拡張情報を使用する。
対称性が指定されていない場合、isSymmetric(x)はその行列が対称であるかどうかを、もっともらしい数値的な不正確さまで判定します。  自分でこの値を設定する方が確実であり、一般的にはるかに高速である。
デフォルトのメソッドprint.defaultには独自のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するにはmethods("print")を使用してください。
デフォルト・メソッドのprint.defaultには独自のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。
クラス "hexmode "は、単に16進数で印刷されることを保証するために使用される、そのクラス属性を持つ整数ベクトルで構成されています。
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、それをarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
デフォルト・メソッドのprint.defaultには、独自のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。
これは、登録され、R内部で処理された後の登録情報を取ります。  つまり、拡張情報を使用します。
noquoteは引数を "noquote "クラスのオブジェクトとして返します。  c()メソッドとsubscriptメソッド("[.noquote")があり、サブセットによってクラスが失われないようになっています。  printメソッド(print.noquote)は、文字列を引用符なしで表示します("...." は .... と表示されます)。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常（パッケージの'DESCRIPTION'ファイルなどでは）、シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンはちょうど3つの整数（メジャー、マイナー、パッチレベル）で構成されます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  サブセット([)も動作する。
library(package)とrequire(package)は、どちらもpackageという名前のパッケージの名前空間をロードし、それをarchリストにアタッチします。requireは、他の関数の内部で使用するように設計されており、パッケージが存在しない場合、FALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表します。
proc.timeは後方互換性のために5つの要素を返すが、そのprintメソッドは長さ3の名前付きベクトルを表示する。最初の2つのエントリは、現在のRプロセスと待機中の子プロセスのユーザーCPU時間とシステムCPU時間の合計であり、3つ目のエントリはプロセスが開始されてからの「実際の」経過時間である。
コンディション・システムは、エラーや警告を含む異常な状態を通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトであるが、これはいずれ変更される可能性がある。
vector'はis.vectorの意味で使われる。
デフォルトのメソッドであるprint.defaultには独自のヘルプページがあります。printジェネリックのすべてのメソッドを取得するにはmethods("print")を使用してください。
これらの関数とクラスは、ソース・コード参照を扱います。
これらの関数とクラスは、ソース・コード参照を処理します。
引数 dnn が指定されない場合、内部関数 list.names が呼び出されて 'dimname name' が計算されます。  ...の引数に名前が付けられている場合は、その名前が使用されます。  残りの引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は、与えられた引数がシンボルであればそれを使用し、deparse.level = 2は、引数をdeparseします。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  要するに、options(warn = 0)でwarningが少なくとも1回呼び出された場合である。
要因については、最初のmaxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは"(その他) "で要約されます（最大maxsumfrequenciesになります）。
デフォルト・メソッドのprint.defaultには、独自のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用します。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  要するに、これはoptions(warn = 0)でwarningが少なくとも1回呼び出された場合である。
prmatrixはprint.matrixの前身で、同名のS関数によく似ている。
proc.timeは後方互換性のために5つの要素を返すが、そのprintメソッドは長さ3の名前付きベクトルを表示する。最初の2つのエントリは、現在のRプロセスと待機している子プロセスの合計ユーザーCPU時間とシステムCPU時間であり、3番目のエントリは、プロセスが開始されてからの「実際の」経過時間である。
na.rmがFALSEの場合、引数のいずれかにNA値があるとNA値が返される。
NA
NA
関数 dimnames と dimnames<- は汎用である。
関数betaとlbetaは、beta関数とbeta関数の自然対数を返します、
複数の文字列が1回または複数回プッシュバックされることがある。このような場合はスタックを形成するので、最初に取り出される行は、最後にpushBackを呼び出したときの最初の文字列になる。  プッシュバックされた行は、readLinesやscanといった通常のテキスト読み取り関数によって、コネクションからの通常の入力の前に読み取られる。
複数の文字列が1回または複数回プッシュバックされることがあります。これらの文字列はスタックを形成するため、最初に取得される行は、最後にpushBackを呼び出したときの最初の文字列になります。  プッシュバックされた行は、readLinesやscanといった通常のテキスト読み取り関数によって、コネクションからの通常の入力の前に読み取られる。
saveには "no"、"yes"、"ask"、"default "のいずれかを指定する。  最初の場合、ワークスペースは保存されず、2番目の場合、保存され、3番目の場合、ユーザーにプロンプトが表示され、終了しないことも決定できる。  対話的な使用では、デフォルトは "ask "であるが、コマンド-線形引数（非対話的な使用では供給されなければならない）によって上書きすることができる。
QR分解は多くの統計的手法で重要な役割を果たしている。  QR分解は、多くの統計的手法で重要な役割を果たします。特に、行列 ∕ボールド{A}とベクトル∕ボールド{b}が与えられたとき、方程式 ∕ボールド{Ax}=∕ボールド{b}を解くのに使用できます。  これは回帰係数の計算やニュートン・ラプソン・アルゴリズムの適用に有用である。
QR分解は多くの統計的手法で重要な役割を果たしている。  特に、与えられた行列｛A｝とベクトル｛b｝に対する方程式｛Ax｝＝｛b｝を解くのに使われます。  これは回帰係数の計算やニュートン・ラプソン・アルゴリズムの適用に有用である。
QR分解は多くの統計的手法で重要な役割を果たしている。  特に、与えられた行列｛A｝とベクトル｛b｝に対する方程式｛Ax｝＝｛b｝を解くのに使われます。  これは回帰係数の計算やニュートン・ラプソン・アルゴリズムの適用に有用である。
QR分解は多くの統計的手法で重要な役割を果たしている。  特に、与えられた行列｛A｝とベクトル｛b｝に対する方程式｛Ax｝＝｛b｝を解くのに使われます。  回帰係数の計算やニュートン・ラプソンアルゴリズムの適用に便利です。
NA
QR分解は多くの統計的手法で重要な役割を果たす。  QR分解は多くの統計的手法で重要な役割を果たし、特に、行列(atmatrix)とベクトル(at vector)が与えられたとき、その方程式(at equation)を解くのに使われます。  これは回帰係数の計算やニュートン・ラプソン・アルゴリズムの適用に有用である。
QR分解は多くの統計的手法で重要な役割を果たしている。  特に、与えられた行列｛A｝とベクトル｛b｝に対する方程式｛Ax｝＝｛b｝を解くのに使われます。  回帰係数の計算やニュートン・ラプソンアルゴリズムの適用に便利です。
NA
QR分解は多くの統計的手法で重要な役割を果たす。  QR分解は多くの統計的手法で重要な役割を果たし、特に、行列(atmatrix)とベクトル(at vector)が与えられたとき、その方程式(at equation)を解くのに使われます。  これは回帰係数の計算やニュートン・ラプソン・アルゴリズムの適用に有用である。
QR分解は多くの統計的手法で重要な役割を果たしている。  特に、与えられた行列｛A｝とベクトル｛b｝に対する方程式｛Ax｝＝｛b｝を解くのに使われます。  回帰係数の計算やニュートン・ラプソンアルゴリズムの適用に便利です。
NA
NA
NA
NA
saveには "no"、"yes"、"ask"、"default "のいずれかを指定する。  最初の場合、ワークスペースは保存されず、2 番目の場合は保存され、3 番目の場合はユーザーにプロンプトが表示され、終了しないことも決定できる。  対話的な使用では、デフォルトは「ask」であるが、コマンド行の引数（対話的でない使用では、引数を与えなければならない）によって上書きすることができる。
以下のmyplotの例では、この機能の簡単な使い方を示している。deparse関数とsubstitute関数を使用して、myplot関数の実際の引数の文字列バージョンであるプロットのラベルを作成している。
数値バージョンは1つ以上の非負整数のシーケンスで、通常（例えばパッケージの'DESCRIPTION'ファイルでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは3つ（メジャー、マイナー、パッチレベル）で構成されます。
Rのホーム・ディレクトリは、実行中のRinstallationのトップ・レベルのディレクトリである。
これはRがビルドされたOSの詳細であり、現在実行されているOSの詳細ではない（OSの詳細についてはSys.infoを参照）。
これは、RがビルドされたOSの詳細であり、現在実行されているOSの詳細ではない（これについてはSys.infoを参照）。
これはRがビルドされたOSの詳細であり、現在実行されているOSの詳細ではない（これについてはseeSys.infoを参照）。
rangeはジェネリック関数です：メソッドは直接定義することも、Summaryグループのgenericを通して定義することもできます。これが正しく動作するためには、引数...は名前を付けなければならず、ディスパッチは最初の引数になります。
rangeはジェネリック関数です：メソッドはそれに対して直接、もしくはSummaryグループのgenericを通して定義することができます。これが正しく機能するためには、引数 ... はunnamedでなければならず、ディスパッチは最初の引数にあります。
全ての成分が異なる（そしてNAがない）場合、順位はseq_along(x)の値でうまく定義される。  いくつかの値が等しい(「同値」と呼ばれる)場合、引数ties.methodは対応する添字での結果を決定する。  first "メソッドは、同値の各インデックスセットで値が増加する並べ替えとなり、同様に "last "は値が減少する並べ替えとなる。  random "メソッドは、これらをランダムな順番に並べる。一方、デフォルトの "average "は、それらを平均値で置き換え、"max "と "min "は、それぞれ最大値と最小値で置き換える。
この関数には2つの基本モードがある。  how = "replace "の場合、それ自身がリスト状でなく、classに含まれるクラスを持つオブジェクトの要素は、その要素に "replace "を適用した結果で置き換えられる。
raw型は生のバイトを保持するためのものである。  バイトのシーケンスを抽出したり、要素を置き換えたりすることができます（ただし、生のベクトルの要素によってのみ）。  関係演算子（バイト表現の数値順序を使用した比較を参照）は、ビット単位の解釈を持つ論理演算子（論理を参照）と同様に機能する。
入力未加工接続がオープンされ、接続オブジェクトが作成された時点で未加工ベクトルがコピーされ、クローズされるとコピーが破棄されます。
入力RAW接続がオープンされ、接続オブジェクトが作成された時点でRAWベクトルがコピーされ、クローズされるとコピーが破棄されます。
packBitsはraw、整数または論理入力を受け付けます。
packBitsはraw、整数または論理入力を受け付けます。
packBitsは、未加工の整数または論理入力を受け付け、最後の2つはNAなしで指定する。
関数cbindとrbindは、データフレーム用のメソッドを持つS3汎用関数である。  データ・フレーム・メソッドは、少なくとも1つの引数がデータ・フレームで、残りがベクトルまたは行列の場合に使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスの場合、つまりisS4(.)がtrueの場合、S4メソッドが求められ、パッケージ・メソッドから隠されたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、deparse.levelはデフォルトのメソッドと同様に従われる。
関数cbindとrbindは、データフレーム用のメソッドを持つS3汎用関数です。  データ・フレーム・メソッドは、少なくとも1つの引数がデータ・フレームで、残りがベクトルまたは行列の場合に使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスである場合、つまりisS4(.)が真である場合、S4メソッドが求められ、パッケージ・メソッドの隠れたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、deparse.levelに従う。
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition numberは、安価な近似によって推定される。  しかし、（svdを使った）正確な計算も十分に速い。
複素数ベクトルはcomplexで作成できます。  ベクトルは、長さ、実部と虚部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数ゼロのベクトルが生成される)。
DCFは、データベースを人間が直接読み書きできるプレーン・テキスト・ファイルに格納するためのシンプルなフォーマットである。  DCFは、パッケージの説明や内容など、Rシステムの情報を格納するためにさまざまな場所で使用されています。
conが文字列の場合、関数はfileを呼び出してバイナリモードのファイル接続を取得し、その接続は関数呼び出しの間オープンされます。
これらの関数は、Cスタイルのゼロ終端文字列を読み書きするreadBinとwriteBinを補完するものです。  これらの関数は、長さが既知の文字列を対象としており、オプションで文字列の終端マークを書き込むことができる。  これらは、現在のロケールで有効な文字列のみを対象としている。
プロンプト文字列は、許容される最大長、通常は256文字（ただしソースコードで変更可能）に切り詰められる。
conが文字列である場合、関数はfileを呼び出してファイル接続を取得し、関数呼び出しの間オープンする。  ファイルパスのチルダ展開はfileによって行われます）。
saveRDSとreadRDSは、1つのRobjectを接続（通常はファイル）に保存し、そのオブジェクトをリストアする手段を提供します。  これは、1つまたは複数の名前付きオブジェクトを環境に保存および復元するsaveおよびloadとは異なります。  パッケージのメタデータを保存したり、help.searchdatabasesを保存したりするなど、R自体で広く使用されている。".rds "というファイル拡張子が最もよく使用される。
NA
NA
もしinitが与えられると、Reduceは論理的にそれをxの先頭（左から右へ進む場合）または末尾にそれぞれ追加します。この拡張される可能性のあるベクトルvがn > 1の要素を持つ場合、Reduceはvの要素に左から右へ、または右から左へそれぞれfを連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ(2 / 3) / 4 = 1/6と2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  このように、fは常に2つの引数で呼び出されることが保証されている。
この関数の主な目的は、外部アイテム（例えば一時ファイル）を参照するオブジェクトがR内部から参照されなくなったときにクリーンアップ処理を実行できるようにすることである。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制される。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではありません(現在はすべて持っています)。むしろ、'NAMESPACE'ファイルを持っているかどうかを示します。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが使うことを意図したものではありません。
invertがFALSE（デフォルト）の場合、regmatchesはマッチデータで指定されたマッチ部分文字列を抽出します。  (regexprから得られる)ベクトルマッチデータの場合、空のマッチは取り除かれます。リストマッチデータの場合、空のマッチは空の成分(長さゼロの文字ベクトル)を与えます。
invertがFALSE(デフォルト)の場合、regmatchesはマッチデータで指定されたマッチ部分文字列を抽出します。  (正規表現から得られる)ベクトルマッチデータの場合、空のマッチは取り除かれます。リストマッチデータの場合、空のマッチは空の成分(長さゼロの文字ベクトル)を与えます。
pos 引数は、オブジェクトを削除する環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするために sys.frame を使用することを含む）として指定することができます。
トップレベルのタスクは、入力行全体ではなく、個々の式である。  したがって、expression1 ; expression2という形の入力行は、2つのトップレベルタスクを生成する。
デフォルトの動作は
デフォルトの動作は、呼び出しが
デフォルトの動作は、呼び出しが
関数 difftime は、2 つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime" のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。
デフォルトの動作は
デフォルトの振る舞いは
数値バージョンは1つ以上の非負整数のシーケンスであり、通常は(パッケージの'DESCRIPTION'ファイルなどでは)シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは3つ(メジャー、マイナー、パッチレベル)で構成されます。
デフォルトの動作は
デフォルトの動作は
breakはfor、while、repeatループから抜け出し、制御は最内周のループの外側にある最初の文に移される。  breakもnextも、入れ子になったループの一番内側だけに適用される。
NA
FUNは、match.funの呼び出しによって検索され、通常、関数、シンボル（バッククォートされた名前など）、またはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定される。
library(package)とrequire(package)は、どちらもpackageという名前のパッケージの名前空間をロードし、それをarchリストに追加します。requireは、他の関数の内部で使用するように設計されており、パッケージが存在しない場合、FALSEを返し、警告を出します（library()がデフォルトで行うエラーではありません）。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  検索リストに追加せずにパッケージをロードしたい場合は、requireNamespace を参照してください。
関数 loadNamespace と attachNamespace は通常、library を使用してネームスペースと必要なインポートをロードするときに暗黙的に呼び出されます。  しかし、これらの関数を直接呼び出すと便利な場合もあります。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知して処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
tracememとuntracememは、Rがメモリ・プロファイリング付きでコンパイルされていない場合にエラーを出しますが、retracememはエラーを出しません（そのため、開発中のコードに残しておくことができます）。
引数リストの名前は、バッククォートされた非標準名（'backquote'を参照）であることができます。
trace 関数は、関数（シグネチャが指定された場合はメソッド）の改訂版を作成し、 元のオブジェクトが見つかった場所に新しいオブジェクトを代入します。
NA
NA
'vector'はis.vectorの意味で使われる。
pos 引数は、いくつかの方法でオブジェクトを削除する環境を指定することができます: 整数(検索リスト内の位置)、検索リスト内の要素の文字列名、または環境(現在アクティブな関数呼び出しにアクセスするためにsys.frameを使用することを含む)。
現在利用可能なRNGの種類を以下に示す。  デフォルトは "Mersenne-Twister "である。
現在利用可能なRNGの種類を以下に示す。  デフォルトは "Mersenne-Twister "です。
これらは汎用関数であり、メソッドは個別に定義することも、Math groupgenericを介して定義することもできます。
時刻は、秒、分、時、日、月、年のいずれかに丸められたり、切り捨てられたりします。  タイムゾーンは、現在のタイムゾーンの真夜中が使用される場合、日以上にのみ関連します。
時刻は、秒、分、時、日、月、年のいずれかに丸められるか、切り捨てられる。  タイムゾーンは、現在のタイムゾーンの深夜が使用される場合、日またはそれ以上にのみ関連する。
NA
データフレームは（定義上）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落も重複もしない。  この要件を満たすためにソフトウェアが行名シーケンスを追加した場合、それらは'自動的'とみなされる。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落も重複もしない。  この要件を満たすためにソフトウェアが行名シーケンスを追加した場合、それらは'自動'とみなされる。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落も重複もしない。  この要件を満たすためにソフトウェアが行名シーケンスを追加した場合、それらは'自動'とみなされる。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落も重複もしない。  この要件を満たすためにソフトウェアが行名シーケンスを追加した場合、それらは'自動'とみなされる。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落も重複もしない。  この要件を満たすためにソフトウェアが行名シーケンスを追加した場合、それらは'自動'とみなされる。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落も重複もしない。  この要件を満たすためにソフトウェアが行名シーケンスを追加した場合、それらは'自動'とみなされる。
これらの関数は、applyにFUN = meanまたはFUN = sumを適切なマージン付きで使用するのと同等であるが、より高速である。  これらの関数はスピードのために書かれているため、NaNとNAの微妙な点がぼやけてしまっている。  もしna.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、これはプラットフォームに依存するかもしれない。
オブジェクトがdimnamestを持つ場合、第1成分が行名として使用され、第2成分（もしあれば）が列名として使用されます。  データフレームの場合、wnamesとcolnamesは最終的にそれぞれrow.namesとnamesを呼び出しますが、後者の方が好ましいです。
オブジェクトがdimnamestを持つ場合、第1成分が行名として使用され、第2成分（もしあれば）が列名として使用されます。  データフレームの場合、wnamesとcolnamesは最終的にそれぞれrow.namesとnamesを呼び出しますが、後者が望ましいです。
デフォルトでは、下の例のようにtapplyと一致するように行を並べ替えます。  並べ替えは、groupの値が非常に多く、xの列数が少ない場合を除き、時間を著しく増加させることはない。
デフォルトは、以下の例のようにtapplyと一致するように行を並べ替える。  並べ替えは、groupの値が非常に多く、xの列数が少ない場合を除き、時間を著しく増加させるものではない。
デフォルトは、以下の例のようにtapplyと一致するように行を並べ替える。  並べ替えは、groupの値が非常に多く、xの列数が少ない場合を除き、時間を著しく増加させることはない。
これらの関数は、applyにFUN = meanまたはFUN = sumを適切なマージン付きで使用するのと同じであるが、より高速である。  これらの関数は高速化のために書かれているため、NaNとNAの微妙な点がぼやけてしまっている。  na.rm = FALSEで、NaNかNAのどちらかが和に現れる場合、結果はNaNかNAのどちらかになるが、プラットフォーム依存かもしれない。
xの長さが1であり、（is.numericの意味で）数値であり、x >= 1である場合、サンプリングは1:xから行われる。  この便利な機能は、sample(x)のような呼び出しでxが様々な長さである場合、望ましくない動作につながる可能性があることに注意してください。  例を参照されたい。
xの長さが1であり、（is.numericの意味で）数値であり、x >= 1である場合、sampleのサンプリングは1:xから行われる。  この便利な機能は、sample(x)のような呼び出しにおいて、 xが様々な長さである場合、望ましくない振る舞いをする可能性があることに 注意すること。  例を参照のこと。
FUNは、match.funの呼び出しによって検出され、通常、関数、シンボル（例えば、バッククォートされた名前）、またはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定されます。
...でシンボル（または文字列）として、またはlistで文字ベクトルとして指定されたオブジェクトの名前は、環境envirからオブジェクトを検索するために使用されます。  デフォルトでは、プロミスは評価されますが、eval.promise = FALSEの場合、プロミスは（評価環境とともに）保存されます（オブジェクトに埋め込まれたプロミスは、常に評価されずに保存されます）。
...でシンボル(または文字列)として、またはlistで文字ベクトルとして指定されたオブジェクトの名前は、envir環境からオブジェクトを検索するために使用されます。  デフォルトでは、プロミスは評価されますが、eval.promise = FALSEの場合、プロミスは(評価環境とともに)保存されます(オブジェクトに埋め込まれたプロミスは常に評価されずに保存されます)。
saveRDSとreadRDSは、1つのRobjectを接続先(通常はファイル)に保存し、そのオブジェクトをリストアする手段を提供します。  これは、1つまたは複数の名前付きオブジェクトを環境に保存および復元するsaveおよびloadとは異なります。  例えば、パッケージのメタデータを保存したり、help.searchdatabasesを保存したりするために使用される。
centerの値は、列のセンタリングをどのように行うかを決定する。  centerがxの列数と同じ長さの数値類似ベクトルである場合、xの各列はcenterから対応する値を差し引かれる。  centerがTRUEの場合、xの各列の平均値(NAは除く)を対応する列から差し引くことでセンタリングが行われ、centerがFALSEの場合、センタリングは行われない。
centerの値は、列のセンタリングをどのように行うかを決定する。  centerがxの列数と同じ長さの数値類似ベクトルである場合、xの各列はcenterから対応する値を差し引かれる。  centerがTRUEの場合、xの各列の平均値(NAは除く)を対応する列から差し引くことでセンタリングが行われ、centerがFALSEの場合、センタリングは行われない。
この場合、canはwhatの要素の型によって与えられる型を持つベクトルのリストを返します。  これは列データを読み取る方法を提供する。  いずれかの型がNULLの場合、対応するフィールドはスキップされます（しかし、結果にはNULLの成分が現れます）。
NA
NA
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します。 現在のところ、(おそらくgz圧縮された)ファイル接続のみがサポートしています。
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します: 現在、(おそらく gz 圧縮された) ファイル接続のみがシークをサポートしています。
数値入力はすべて有限でなければならない(つまり、無限やNaNやNAではない)。
数値入力はすべて有限でなければならない(つまり、無限、NaN、NAではない)。
数値入力はすべて有限であるべきである（つまり、無限でもNaNでもNAでもない）。
はいくつかの方法で指定できる。
数値入力はすべて有限でなければならない（つまり、無限、NaN、NAではない）。
数値入力はすべて有限でなければならない（つまり、無限、NaN、NAではない）。
by はいくつかの方法で指定できる。
sequence(nvec, from, by=0L)はrep(from, each=nvec)と等価である。
sequence(nvec, from, by=0L)は，rep(from, each=nvec)と等価です．
関数serializeは，オブジェクトを指定されたconnectionにシリアライズします．  connectionがNULLの場合、オブジェクトは生のベクトルにシリアライズされ、serializeの結果として返されます。
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptによって生成されたソケットコネクション、およびserverSocketによって生成されたサーバソケットコネクションを除く）。
現在利用可能なRNGの種類を以下に示す。  デフォルトは "Mersenne-Twister "である。
union、intersect、setdiff、setequalの各々は、引数中の重複する値を捨て、引数に.vectorとして適用する（特に文字ベクトルへの係数を強制する）。
union、intersect、setdiff、setequalのそれぞれは、引数の重複する値をすべて破棄し、引数にas.vectorを適用します（特に、文字ベクトルへの係数を強制します）。
setHookは、ユーザーがシステム（またはユーザー）関数から呼び出される関数のリストであるフックを登録するための一般的なメカニズムを提供します。  フックの初期セットはpackage/namespace上のイベントに関連付けられました。これらのフックは、packageEventの呼び出しによって命名されます。
packageHasNamespaceは、パッケージが名前空間を持っているかどうかを示すものではありません(現在はすべて持っています)。  しかし、それを使うことを意図しているわけではありません。
setTimeLimitは、コンソールまたはファイルから入力されたコマンドライン（継続行を含む）の各トップレベル計算に適用される制限を設定する。  計算内から呼び出された場合、制限は計算の残りの部分に適用され、(transient = TRUEでない限り)後続のトップレベル計算にも適用されます。
setTimeLimitは、コンソールまたはファイルから入力されたコマンド行(継続行を含む)の各トップレベル計算に適用される制限を設定する。  計算内から呼び出された場合、制限は計算の残りの部分に適用され、(transient = TRUEでない限り)後続のトップレベル計算にも適用されます。
マークされたエンコーディングのファイルパスがどのように解釈されるかについては、 files を参照のこと。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによってディレ クトすることができる（状況によっては、stdout()からの出力をスプリット することもできる。）
Unix系でサポートされているデフォルトのクォート形式は、ボーンシェルshのものである。  文字列にシングルクォートが含まれていない場合は、シングルクォートで囲むことができます。  そうでない場合、文字列は二重引用符で囲まれ、ドル、バッククォート、バックスラッシュ以外のメタキャラクタの特別な意味はすべて抑制されます。  このタイプの引用符付けは、bash、ksh、zshにも適しています。
これは内部ジェネリック・プリミティブ関数で、メソッドは直接定義することも、Mathグループ・ジェネリックを介して定義することもできます。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
これらはジェネリック関数であり、メソッドは個別に定義することも、Math groupgenericを介して定義することもできる。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトであるが、これはいずれ変更される可能性がある。
FUNはmatch.funの呼び出しによって見つけられ、通常、関数、シンボル（例えば、バッククォートされた名前）、またはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定されます。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。
double は、指定された長さの倍精度ベクトルを作成します。  これは numeric と同じです。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループジェネリックを介して定義することもできます。
sinkはRの出力をコネクションに転送します（転送を終了するには再度使用する必要があります。）  fileが文字列の場合、その名前のファイル接続が流用の間確立されます。
sink は、R の出力を接続に転送します (そして、そのような転送を終了するには、再度使用しなければなりません。以下を参照してください!)。  fileが文字列の場合、その名前のファイル接続が、流用の間確立される。
二つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返す。
MARGINが1つの次元を与える場合、これに関するスライス数iのすべての要素は値iを持つ。一般的に、スライス数は、MARGINが与える次元内のすべてのインデックスの組み合わせを列長順に番号付けすることによって得られる。  すなわち、m_1, ..., m_kはスライスされた次元数(MARGINの要素)、d_{m_1}, ..., d_{m_k}は対応するエクステントであり、n_1 = 1, n_2 = d_{m_1}, ...,n_k = d_{m_1} となる。... d_{m_{k-1}}, 次元m_1が値i_1,..., 次元m_kが値i_kを持つスライスの数は1 + n_1 (i_1 - 1) + ... + n_k (i_k - 1)である。
最初の11の関数はコネクションを作成します。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができます。
最初の11個の関数はコネクションを作成する。  デフォルトではコネクションはオープンされないが（socketConnection または socketAccept によって生成されたソケットコネクション、および serverSocket によって生成されたサーバーソケットコネクションを除く）、引数 open に空でない値を設定することでオープンされる。
socklist と同じ長さの論理ベクトルを構成するために、 write の値は必要に応じて再利用される。ソケット接続は socklist に複数回現れることがある。
最初の11個の関数はコネクションを生成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができる。
aまたはbは複素数でもよいが、これは二重複素数演算を使用するため、プラットフォームによっては利用できない場合がある。
aまたはbは複素数であることができるが、これは二重複素数演算を使用するため、プラットフォームによっては使用できない場合がある。
QR分解は多くの統計手法で重要な役割を果たしている。  QR分解は多くの統計的手法で重要な役割を果たし、特に、与えられた行列 ㊟とベクトル㊟に対して方程式㊟=㊟を解くのに使えます。  回帰係数の計算やニュートン・ラプソンアルゴリズムの適用に便利です。
sortはメソッドが書ける汎用関数で、sort.intは最初の3つの引数だけならSと互換性のある内部メソッドです。
sortはメソッドを書くことができる汎用関数であり、sort.intは最初の3つの引数のみが使用される場合にSと互換性のある内部メソッドである。
sortはメソッドを書くことができる汎用関数であり、sort.intは最初の3つの引数のみが使われる場合にSと互換性のある内部メソッドである。
最初のベクトルで同値の場合、2番目のベクトルで同値を解消する。  使用されるソートは(method = "quick "を除いて)安定しているので、未解決の同値は元の順序のまま残されます。
sortはメソッドを書くことができる汎用関数であり、sort.intは最初の3つの引数のみが使用される場合、Sと互換性のある内部メソッドである。
ソースからのコード実行は、Rコマンドラインからの入力とはいくつかの点で異なることに注意してください。  式はトップ・レベルでは実行されないので、自動プリントは行われません。  そのため、印刷させたいものについては、明示的にprintコールを含める必要があります（これには、FAQ Q7.22のlatticeによるプロットも含まれることを覚えておいてください）。  ファイル全体が実行される前に解析されるため、構文エラーはどのコードも実行されないことになります。  構文的に正しいスクリプトの実行中にエラーが発生した場合、実行されたコードによってワークスペースに割り当てられたものはすべて保持されます（コマンドラインからの場合と同様です）が、astraceback()のような診断情報には、withVisibleの追加呼び出しが含まれます。
splitとsplit<-は、デフォルトとdata.frameメソッドを持つ汎用関数です。  データフレームメソッドは、行列を行列のリストに分割するために使用することもできます。
split と split<- は，デフォルトのメソッドと data.frame メソッドを持つ汎用関数です．  データフレームメソッドは，行列を行列のリストに分割するためにも使用できます．
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、その暦が使用されていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。
splitとsplit<-は、defaultメソッドとdata.frameメソッドを持つ汎用関数である。  データフレームメソッドは，行列を行列のリストに分割するためにも使用できます．
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、日付と時刻を表すベクトルの名前付きリストである。
splitとsplit<-は、defaultメソッドとdata.frameメソッドを持つ汎用関数です。  データフレームメソッドは，行列を行列のリストに分割するためにも使用できます．
split と split<- は，デフォルトのメソッドと data.frame メソッドを持つ汎用関数です．  データフレームメソッドは，行列を行列のリストに分割するためにも使用できます．
split と split<- は，デフォルトのメソッドと data.frame メソッドを持つ汎用関数です．  データフレームメソッドは，行列を行列のリストに分割するためにも使用できます．
sprintfは、システムsprintf Cライブラリ関数のラッパーです。  渡される値のモードが与えられた書式と一致することをチェックし、Rの特殊な値（NA、Inf、-Inf、NaN）が正しく処理されるように試みられている。
これらは内部ジェネリック・プリミティブ関数であり、メソッドは個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。  複素引数（およびデフォルト・メソッド）の z, abs(z) == Mod(z) および sqrt(z) == z^0.5.
これらの関数の目的は、R の出力、例えば警告やエラー・メッセージで使用されるテキストを引用するための簡単なマークアップ手段を提供することです。
これらの関数とクラスは、ソース・コード参照を扱います。
これらの関数とクラスはソース・コード参照を扱います。
これらの関数とクラスはソース・コード参照を処理します。
これらの関数とクラスは、ソース・コード参照を処理します。
standardGeneric は、f という名前の genericfunction に対して定義されたメソッドを、それが呼び出されるフレームの実際の引数を使用してディスパッチします。
startsWith() は
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、 stdout()からの出力を分割することもできる：ヘルプページを参照）。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、 stdout()からの出力を分割することもできる：ヘルプページを参照）。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプページを参照）。
エラーの動作は、実行コード内で確立されたエラー・ハンドラと、options(error=) で設定された現在のデフォルト・エラー・ハンドラによって制御されます。  エラーはまず、ingsignalCondition() を使用するかのようにシグナルされます。  ハンドラがない場合、またはすべてのハンドラが返された場合、エラー・メッセージが出力され（options("show.error.messages")がtrueの場合）、デフォルトのエラー・ハンドラが使用されます。  対話的な使用におけるデフォルトの動作(NULLerrorハンドラ)は、トップ・レベルのプロンプトまたはトップ・レベルのブラウザに戻ることであり、非対話的な使用では(効果的に)q("no", status = 1, runLast = FALSE)を呼び出すことである。  また、コール・スタックのトレースも保存され、traceback() で取得できます。
この関数は、リグレッション・テストや関数の引数チェックで使用することを想定しています。
modeもstorage.modeも、オブジェクトの(ストレージ)モードを文字列で返します。
modeもstorage.modeも、オブジェクトの（記憶）モードを示す文字列を返す。
textの長さが0より大きい場合（強制終了後）、fileよりも優先して使用されます。
もしtextの長さが（強制終了後に）ゼロより大きければ、それはfileを参照して使われる。
formatメソッドとas.characterメソッド、およびstrftimeconvertメソッドは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換します。
formatメソッドとas.characterメソッドとstrftimeconvertオブジェクトは、クラス "POSIXlt "と "POSIXct "から文字ベクトルに変換される。
xとtimesの要素は必要に応じて再利用される（一方に要素がない場合は、空の文字ベクトルが返される）。  xまたはtimesの要素が欠落すると、返り値の要素も欠落する。
引数splitはcharacterに強制されるため、以下の例を含め、split = character(0)を意味するsplit = NULLが使用されます。
変換は C ライブラリ関数 strtol に基づいている。
Width」は等幅フォントでの表示幅として解釈されます。  印字不可能な文字（backspaceやtabなど）がどうなるかは実装依存であり、ロケールにも依存する（例えば、カウントに含まれる場合もあれば、省略される場合もある）。
factor "クラスを追加することで、数値コードに整数の保存モードが与えられるようになります。
入力中の空白文字（スペース、タブ、改行文字）は破棄される。  ピリオド、クエスチョン、説明マーク（文末を表すと考えられる）の後のダブルスペースは保存される。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。
これは汎用の関数で、行列、データフレーム、ベクトル（リストを含む）用のメソッドが提供されています。  パッケージやユーザはさらにメソッドを追加することができます。
これは汎用関数で、行列、データフレーム、ベクトル（リストを含む）用のメソッドが提供されます。  パッケージおよびユーザは、さらにメソッドを追加することができます。
これは汎用関数で、行列、データフレーム、ベクトル（リストを含む）用のメソッドが提供されます。  パッケージおよびユーザは、さらにメソッドを追加することができます。
これは汎用関数で、行列、データフレーム、ベクトル（リストを含む）用のメソッドが提供されます。  パッケージやユーザはさらにメソッドを追加することができます。
以下のmyplotの例では、この機能の簡単な使い方を示しています。deparse関数とsubstitute関数を使用して、myplot関数の実際の引数の文字列バージョンであるプロットのラベルを作成しています。
substringはSと互換性があり、startとstopの代わりにfirstとlastを使用します。ベクトル引数の場合、引数の長さが0でなければ、引数を最長引数の長さまで循環的に展開します。
substringはSと互換性があり、startとstopの代わりにfirstとlastを持つ。ベクトル引数の場合、長さがゼロのものがない限り、引数を循環的に最長の長さまで展開する。
substringはSと互換性があり、startとstopの代わりにfirstとlastを持つ。ベクトル引数の場合、長さがゼロのものがない限り、引数を循環的に最長の長さまで展開する。
substringは、startとstopの代わりにfirstとlastを持つSと互換性があります。ベクトル引数の場合、長さがゼロのものがなければ、引数を循環的に最長の長さまで展開します。
これはジェネリック関数です。メソッドは直接定義することもできますし、Summaryグループのgenericを介して定義することもできます。これが正しく動作するためには、引数...には名前を付けておく必要があり、ディスパッチは最初の引数に対して行われます。
要因の場合、最初のmaxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは"(その他) "で要約されます（最大maxsum頻度になります）。
最初の11個の関数は接続を作成する。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる可能性があります。
要因については、最初のmaxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは"(その他) "で要約される（最大maxsumの頻度になる）。
S3メソッドを書くことができる4つのグループ、すなわち、"Math"、"Ops"、"Summary "および "Complex "グループがある。  これらはベースRのRオブジェクトではないが、メソッドを提供することができ、ベースRは最初の3つのグループのためのfactor、data.frame、difftimeメソッドを含んでいる。  (Opsのorderedメソッド、MathとOpsのPOSIXtメソッドとDateメソッド、OpsとSummaryのpackage_versionメソッド、そしてstatsパッケージのOpsのtsメソッドもあります)。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦のルールに従って表示されますが、その暦が使われていたのはそれほど昔ではありません（イギリスとその植民地では1752年に採用されました）。
日付は1970年1月1日からの日数で表され、それ以前の日付は負の値となる。  日付は常に現在のグレゴリオ暦の規則に従って印刷されるが、その暦は大昔には使われていなかった（グレート・ブリテンおよびその植民地では1752年に採用された）。
因子については、最初の maxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは"(Others) "で要約される（結果として、最大でもmaxsumの頻度になる）。
関数 difftime は、2 つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime" クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。
因子の場合、最初の maxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは "(その他)" で要約されます (最大で maxsum の頻度になります)。
ベクトル x の型は制限されない。as.character メソッドを持ち、ソート可能（byorder）でなければならない。
因子の場合、最初の maxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは "(その他)" に要約されます（結果として、最大で maxsum の頻度になります）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現される。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ(メジャー、マイナー、パッチレベル)です。
ベクトルxの型に制限はなく、as.characterメソッドを持ち、ソート可能（byorder）であればよい。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を表す ベクトルの名前付きリストである。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表します。
proc.timeは後方互換性のために5つの要素を返しますが、そのprintメソッドは長さ3の名前付きベクトルを表示します。最初の2つのエントリーは、現在のRプロセスと待機している子プロセスの合計ユーザーCPU時間とシステムCPU時間であり、3番目のエントリーはプロセスが開始されてからの「実際の」経過時間です。
これらの関数とクラスはソース・コード参照を扱います。
これらの関数とクラスはソース・コード参照を扱います。
引数 dnn が与えられない場合、内部関数 list.names が呼び出されて 'dimname name' が計算されます。  ...の引数に名前が付けられている場合は、その名前が使用されます。  残りの引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は、与えられた引数がシンボルであればそれを使用し、deparse.level = 2は、引数をdeparseします。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  要するに、これはoptions(warn = 0)でwarningが少なくとも1回呼び出された場合である。
messageは、警告でもエラーでもない「単純な」診断メッセージを生成するために使われます。  デフォルトのハンドラは、メッセージをstderr()接続に送ります。
messageは、警告でもエラーでもない「単純な」診断メッセージを生成するために使用されます。  警告やエラーとは異なり、最後の改行はメッセージの一部とみなされ、省略可能です。 デフォルトのハンドラは、メッセージをstderr()接続に送ります。
結果は、options("warn")の値と、実行コードで確立されたハンドラに依存する。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトであるが、これはいずれ変更される可能性がある。
svdとLa.svdは戻り値が異なる2つのインターフェイスを提供する。
FUNはmatch.funを呼び出すことで見つかる。  defaultと同様、二項演算子は引用符で囲むか、バッククォートで囲むかして与えることができる。
switchは、最初の引数が文字列として評価されるか、数値として評価されるかに応じて、2つの異なる方法で動作する。
.GlobalEnvはフレームのリストで0番が与えられます。後続の関数が評価されるたびにフレームスタックは1ずつ増加します。その関数の呼び出し、関数定義、評価のための環境は、適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
.GlobalEnvはフレームのリストで0番を与えられます。それに続く各関数評価はフレームスタックを1つ増やします。その関数の呼び出し、関数定義、評価環境は適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
dir.existsは、（file.existsと同じ意味で）パスが存在し、ディレクトリであることをチェックします。
Sys.timeは、様々なタイムゾーンに変換することができ、異なる日を返すかもしれない絶対日付時刻値を返します。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックが1ずつ増加します。その関数の呼び出し、関数定義、評価環境は、適切なインデックスを持つsys.call、sys.function、sys.frameによって返されます。
.GlobalEnvは、フレームのリストで0番が与えられます。後続の各関数評価によって、フレームスタックが1ずつ増加します。その関数の呼び出し、関数定義、評価環境は、適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
.GlobalEnvはフレームのリストで0番を与えられます。それに続く各関数の評価はフレームスタックを1ずつ増やします。その関数の呼び出し、関数定義、評価環境は、適切なインデックスを持つsys.call、sys.function、sys.frameによって返されます。
必要であれば、両引数は文字に強制される。
ロケールは、プログラムの国際化の側面を記述する。初期状態では、Rのロケールのほとんどの側面は "C "に設定されている（これはC言語のデフォルトであり、"POSIX "としても知られる北米の慣習を反映している）。  Rは "LC_CTYPE "と "LC_COLLATE "を設定する。"LC_CTYPE "と "LC_COLLATE "は、異なる文字セットの使用と、その文字セットでのアルファベット比較（ソートの使用を含む）を許可する。"LC_MONETARY"（Sys.localeconvで使用）と "LC_TIME "は、as.POSIXltとstrptime、およびそれらを使用する関数の動作に影響を与える可能性がある（dateは影響しない）。
NA
ファイルパス中のチルダ（チルダ展開参照）とワイルドカードを展開する。ワイルドカード展開の正確な詳細については、 globシステムコールに関するyoursystemのドキュメントを参照のこと。  POSIX 1003.2標準（https://pubs.opengroup.org/onlinepubs/9699919799/functions/glob.html 参照）があるが、 OSによってはこれを超えるものもある。
これはPOSIXまたはWindowsシステムコールを使用する。  OS名（sysname）は、期待するものと異なる場合があることに注意してください。たとえば、macOSはDarwin、SolarisはSunOSと識別します。
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、基本的に[[ 演算子と同等である。  これは、オブジェクトにデフォルト・メソッドを適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  演算子とは異なり、これらはビルトインであり、特別なものではない（すべての引数が評価される）ので、引数の欠落は許されないことに注意してください。
通常、RはLC_NUMERICの値を見ずに実行されるので、小数点は'.'のままです。  そのため、これらのコンポーネントの最初の3つは、現在のRセッションでSys.setlocaleを使用してロケールカテゴリLC_NUMERICを設定した場合（Rが正しく動作しない可能性がある）にのみ有用です。
.GlobalEnvはフレームのリストで0番が与えられます。それに続く関数の評価ごとにフレームスタックが1ずつ増えます。その関数の呼び出し、関数定義、評価環境はsys.call、sys.function、sys.frameによって適切なインデックスで返されます。
.GlobalEnvは、フレームのリストで0番が与えられます。後続の各関数評価によって、フレームスタックが1ずつ増加します。その関数の呼び出し、関数定義、評価環境は、適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
.GlobalEnvは、フレームのリストで0番が与えられます。後続の各関数評価によって、フレームスタックが1ずつ増加します。その関数の呼び出し、関数定義、評価環境は、適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
.GlobalEnvは、フレームのリストで0番を与えられます。後続の各関数評価によって、フレームスタックが1ずつ増加します。その関数の呼び出し、関数定義、評価環境は、適切なインデックスでsys.call、sys.function、sys.frameによって返されます。
NA
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、本質的に[[ 演算子と同等です。  これは、デフォルト・メソッドをオブジェクトに適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  演算子とは異なり、これらはビルトインであり、特別なものではない（すべての引数は評価される）ので、引数の欠落は許されないことに注意してください。
非標準のR名はSys.setenvで引用しなければならない。  ほとんどのプラットフォーム（およびPOSIX）は"="を含む名前を許さない。  Windowsでは可能だが、Rが提供する機能ではこれらを正しく扱えない場合があるので、避けるべきである。  ほとんどのプラットフォームでは環境変数を""に設定することができるが、Windowsではできない。
これは、ファイル時間を指定された値に設定しようとするものである。
ロケールは、プログラムの国際化の側面を記述する。初期状態では、Rのロケールのほとんどの側面は "C "に設定されている（これは、C言語のデフォルトであり、北米の慣習を反映したもので、"POSIX "としても知られている）。  Rは "LC_CTYPE "と "LC_COLLATE "を設定する。"LC_CTYPE "と "LC_COLLATE "は、異なる文字セットの使用と、その文字セットでのアルファベット比較（ソートの使用を含む）を許可する。"LC_MONETARY"（Sys.localeconvで使用）、"LC_TIME "は、as.POSIXltとstrptime、およびそれらを使用する関数の動作に影響を与える可能性がある（dateは影響しない）。
この関数を使用すると、Rに一時的に非常に低い優先度を与えることができるため、より重要なフォアグラウンド・タスクの邪魔をしないようにすることができる。  典型的な使用法は、Rから起動されたプロセスがRの実行を再開する前に、自分自身をセットアップして入力ファイルを読み込むようにすることである。
大きなファイルの場合、keep.source = FALSE を指定すると、かなりのメモリを節約できる。keep.parse.data=FALSEによって解析データのみを無効にすることで、すでに多くのメモリを節約することができます。評価されるコードが正しい環境を使用するようにするために（例えば、グローバル割り当て）、パッケージ内のソース・コードはtopenv()を呼び出す必要があります。topenv()は、名前空間（もしあれば）、sys.sourceによって設定された環境、または保存されたイメージが使用されている場合はグローバル環境を返します。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価のたびにフレームスタックは1ずつ増加します。その関数の呼び出し、関数定義、評価環境は、適切なインデックスを持つsys.call、sys.function、sys.frameによって返されます。
sys.timeは、様々なタイムゾーンに変換可能な絶対日付時刻値を返し、異なる日を返すこともある。
タイムゾーンはシステム固有のトピックですが、最近ではほとんどすべてのRplatformsが同様の基礎コードを使用しており、Linux、macOS、Solaris、AIX、FreeBSDで使用され、WindowsではRと一緒にインストールされます。  (残念ながら、実装にはシステム固有のエラーが多い。) Windowsだけでなく、Unix系でもRソースのバージョンのコードを使うことができる。
dir.existsは、(file.existsと同じ意味で)パスが存在し、ディレクトリであることをチェックします。
非標準のR名はSys.setenvで引用符で囲む必要がある。  ほとんどのプラットフォーム（およびPOSIX）では、"="を含む名前を許さない。  Windowsでは可能だが、Rが提供する機能ではこれらを正しく扱えない場合があるので、避けるべきである。  ほとんどのプラットフォームでは環境変数を""に設定することができるが、Windowsではできないので、Sys.setenv(FOO = "")はFOOの設定を解除する。
シェルで実行されるような実行ファイル（実行スクリプトを含む）のフルパス名を報告するシステムコマンドで、絶対パスかパス上の検索を受け付ける。
このインターフェイスは、長い年月をかけてかなり複雑になってきた。新しいコードに推奨される、よりポータブルで柔軟なインターフェイスについては、system2 を参照のこと。
これは、file.existsで指定されたファイルの存在をチェックする。  そのため、ファイルのパスは、その存在を確認するのに十分なパーミッションがある場合にのみ返される。
system.timeは関数proc.timeを呼び出し、exprを評価した後、もう一度proc.timeを呼び出し、2回のproc.time呼び出しの差を返します。
systemとは異なり、commandは常にshshQuoteで引用されるため、引数のない単一のコマンドでなければなりません。
これはメソッドを書くことができる汎用関数です。  ここでの説明は、defaultと "data.frame "メソッドに適用されます。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  4つともlogical(1)ベクトルである。
これはメソッドを書くことができる汎用関数です。  ここでの説明はdefaultメソッドと "data.frame "メソッドに適用されます。
これは、メソッドを書くことができる汎用関数です。  ここでの説明は、default および "data.frame" メソッドに適用されます。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname names'が計算されます。  ...の引数に名前が付けられていれば、その名前が使用される。  deparse.level=0は空の名前を与え、deparse.level=1は与えられた引数がシンボルであればそれを使用し、deparse.level=2はその引数を使用します。
tabulateはtable関数の主力である。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)となります。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループジェネリックを介して定義することもできます。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。
FUNがNULLでない場合、FUNはmatch.funに渡されます。したがって、FUNは関数であるか、関数を示す記号または文字列である可能性があります。
NA
NA
結果の長さは3つの引数の長さの最大値である。
より短い引数の値はリサイクルされる。
入力テキスト接続がオープンされ、接続オブジェクトが生成された時点で文字ベクトルがコピーされ、closeでコピーが破棄される。
入力テキスト接続がオープンされ、接続オブジェクトの生成時に文字ベクトルが コピーされ、closeでコピーが破棄される。
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換します。範囲指定はサポートされていますが、文字クラスと繰り返し文字はサポートされていません。  oldの文字数がnewの文字数より多い場合はエラーが通知され、少ない場合はnewの末尾の余分な文字は無視される。
toppenvは、envirとそれを囲む環境を検索したときに最初に見つかったトップレベル環境を返す。トップレベル環境が見つからない場合は、.GlobalEnv が返されます。  環境は、名前空間の内部環境、検索パスのパッケージ環境、または .GlobalEnv である場合にトップレベルと見なされます。
これはメソッドを記述できる汎用関数です。ここでは既定のメソッドのみを説明します。  ほとんどのメソッドは、結果の最大表示幅（nchar(type = "width")によって測定される）を指定するために引数widthを尊重する必要があります。
これは、メソッドを書くことができる汎用関数である。  ほとんどのメソッドは、結果の最大表示幅（nchar(type = "width")によって測定される）を指定する引数widthを尊重すべきである。
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換する。範囲指定はサポートされているが、文字クラスと繰り返し文字はサポートされていない。  oldに含まれる文字数がnewより多い場合はエラーが通知され、少ない場合はnewの末尾の余分な文字は無視される。
trace関数は、関数（シグネチャが指定された場合はメソッド）の改訂版を作成し、新しいオブジェクトを元の場所に代入することで動作します。what引数だけが指定された場合、関数を呼び出すたびに1行のトレース表示が行われます（以前のバージョンのtraceと互換性があります）。
デフォルトの表示は、.Tracebackに呼び出しのリストとして格納されている最後の捕捉されなかったエラーのスタックです。  呼び出しのスタックには、常にすべての関数呼び出しとすべての外部関数呼び出し（.Callなど）が含まれます。プロファイリングが進行中の場合は、いくつかのプリミティブ関数への呼び出しが含まれます。  (組み込み関数への呼び出しは含まれますが、特殊関数への呼び出しは含まれません)。
tracememとuntracememは、Rがメモリ・プロファイリング付きでコンパイルされていない場合にエラーを出しますが、retracememはエラーを出しません（そのため、開発中のコードに残しておくことができます）。
trace関数は、関数(またはシグネチャが与えられている場合はメソッド)の改訂版を構築し、元のオブジェクトが見つかった場所に新しいオブジェクトを代入することで動作します。what引数だけが与えられている場合、関数が呼び出されるたびにトレース印刷の行が生成されます(以前のバージョンのtraceと互換性があります)。
transform.data.frameの...引数はタグ付きベクトル式で、データフレーム_dataで評価されます。  タグはnames(_data)と照合され、一致したものは_data内の対応する変数に置き換えられ、それ以外は_dataに追加される。
transform.data.frameの...引数はタグ付きベクトル式であり、データフレーム_dataで評価される。  タグはnames(_data)と照合され、一致したものは_dataの対応する変数に置き換えられ、それ以外は_dataに追加される。
transform.data.frameの...引数はタグ付きベクトル式であり、データフレーム_dataで評価される。  タグはnames(_data)と照合され、一致したものは_dataの対応する変数に置き換えられ、それ以外は_dataに追加される。
関数 beta と lbeta は、ベータ関数とベータ関数の自然対数を返す、
内部的には、sub(re, "", *, perl = TRUE)、すなわちPCRElibrary正規表現が使用される。移植性のため、デフォルトの「空白」は文字クラス[ \t\r n]（スペース、水平タブ、キャリッジリターン、改行）である。  あるいは、[˶h ˶v]は、すべてのUnicodeの水平と垂直の空白文字にマッチする良い(PCRE)一般化である。
これらは汎用関数であり、メソッドは個別に定義することも、Mathグループgenericを介して定義することもできる。
時刻は、秒、分、時、日、月、年のいずれかに丸められたり切り捨てられたりします。  タイムゾーンは、現在のタイムゾーンの真夜中が使用される場合、日以上にのみ関連します。
時刻は、秒、分、時、日、月、年のいずれかに丸められるか、切り捨てられる。  タイムゾーンは、現在のタイムゾーンでmidnightが使用される場合、日またはそれ以上にのみ関連する。
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します: 現時点では、(おそらくgz圧縮された)ファイル接続のみがサポートしています。
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します: 現在、(gz圧縮されている可能性のある)ファイル接続のみがシークをサポートしています。
tryは式を評価し、評価中に発生したエラーをトラップします。  エラーが発生した場合、options("show.error.messages")がfalseであるか、silent = TRUEが指定されていない限り、エラーメッセージが標準エラー出力に出力されます。  エラーメッセージはバッファにも保存され、geterrmessageで取得できる。(エラーの場合に返される値にはエラーメッセージが含まれているので、これは必要ないはずである)。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。
NA
ここでは、いわゆる "S3 "クラス（とメソッド）について説明する。S4 "クラス（とメソッド）については、後述の "正式なクラス "を参照してください。
デバッグ用のフラグが付けられた関数に入ると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  各ステップごとに新しいブラウザコンテキストが開始されます（前のコンテキストは破棄されます）。
union、intersect、setdiff、setequalのそれぞれは、引数の重複値を破棄し、引数にas.vectorを適用します（特に文字ベクトルにはcoerce係数を適用します）。
これはベクトル、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これはベクトル、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これは、ベクトル、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これは、ベクトル、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。
これは、ベクトル、データ・フレーム、配列（行列を含む）用のメソッドを備えた汎用関数です。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなどでは)、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  Rパッケージのバージョンは少なくとも2つの整数で構成され、Rシステムのバージョンは正確に3つ（メジャー、マイナー、パッチレベル）で構成されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、1970年からの(UTC時間帯における)秒数を表す ベクトルの名前付きリストである。
last.warningオブジェクトが存在し、warnings()が使われる状況については、 options("warn")の説明を参照のこと。  要するに、これはoptions(warn = 0)でwarningが少なくとも1回呼び出された場合である。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示すattributeを持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。
基本パッケージ以外の標準パッケージの関数は、help("pkg-deprecated") にリストされています。
recursive = FALSE の場合、ディレクトリは削除されません。
unlistは汎用的です。オブジェクトの特定のクラスを扱うメソッドを書くことができます。InternalMethodsを参照してください。
関数loadNamespaceとattachNamespaceは通常、libraryを使用してネームスペースと必要なインポートをロードするときに暗黙的に呼び出されます。  しかし、これらの関数を直接呼び出すと便利な場合もあります。
環境をロックすることで、環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  名前空間を持つパッケージの名前空間環境は、ロード時にロックされます。
NA
関数serializeは、オブジェクトを指定されたconnectionにシリアライズします。  connectionがNULLの場合、オブジェクトは生のベクトルにシリアライズされ、serializeの結果として返されます。
splitとsplit<-は，デフォルトメソッドとdata.frameメソッドを持つ汎用関数です．  データフレームメソッドは，行列を行列のリストに分割するためにも使用できます．
trace関数は、関数（シグネチャが指定された場合はメソッド）の改訂版を作成し、元のオブジェクトが見つかった場所に新しいオブジェクトを代入することで動作します。what引数だけが指定された場合、関数が呼び出されるたびに1行のトレース印刷が生成されます（以前のバージョンのtraceと互換性があります）。
tracememとuntracememは、Rがメモリ・プロファイリング付きでコンパイルされていない場合にエラーを出しますが、retracememはエラーを出しません（そのため、開発中のコードに残しておくことができます）。
最初の11の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptによって作成されたソケット接続とserverSocketによって作成されたサーバソケットコネクションを除く）。
NA
最初の11個の関数はコネクションを作成します。  デフォルトではコネクションはオープンされないが（socketConnection または socketAccept によって作成されたソケットコネクション、および serverSocket によって作成されたサーバーソケットコネクションを除く）、引数 open に空でない値を設定することでオープンされる。
クラス属性は、オブジェクトが継承するクラスの名前を示す文字ベクトルである。  ほとんどのベクトルはmode(x)の結果がclassになります。ただし、整数ベクトルはclass c("integer", "numeric")、実数ベクトルはclass c("double", "numeric")です。
これらは、マルチバイト文字セットをサポートしていないプラットフォームを含め、どのロケールでも動作する。
これらは、grepなどの関数で使用されるものと同様のチェックを使用します。
これらは、asgrepのような関数で使用されるものと同様のチェックを使用する。
FUNは、match.funの呼び出しによって検出され、通常、関数またはシンボル（バッククオートされた名前など）として指定されるか、lapplyの呼び出しの環境から検索される関数を指定する文字列として指定される。
アトミックモードには、"logical"、"integer"、"numeric"（同義語の "double"）、"complex"、"character"、"raw "がある。
Vectorizeのvectorize.args引数で指定される引数は、applyの...リストで渡される引数です。  実際に渡されたものだけがベクトル化され、デフォルト値はベクトル化されません。  デフォルト値ではベクトル化されません。
これはRがビルドされたOSの詳細を示すものであり、現在動作しているOSの詳細を示すものではない（OSの詳細についてはSys.infoを参照のこと）。
結果は、options("warn")の値と、実行中のコードで確立されたハンドラに依存する。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  要するに、これはoptions(warn = 0)でwarningが少なくとも1回呼び出された場合である。
NA
NA
NA
NA
NA
NA
breakはfor、while、またはrepeatループから抜け出し、制御はループの最内部の外側の最初のステートメントに移る。  breakもnextも、入れ子になったループの一番内側だけに適用される。
withは、データから構築されたローカル環境でexprを評価する汎用関数である。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを単純化するのに便利である。  (注意: dataがすでに環境である場合、これは既存の親と一緒に使用されます)。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持ちます。  これはモデリング関数の呼び出しを簡略化するのに便利です。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます)。
ソースからのコード実行は、Rコマンドラインからの入力とはいくつかの点で異なることに注意してください。  式はトップレベルでは実行されないので、自動プリントは行われません。  そのため、印刷させたいものについては、明示的にprintを呼び出す必要があります（これには、FAQ Q7.22の格子によるプロットも含まれることを覚えておいてください）。  ファイル全体が実行される前に解析されるため、構文エラーはどのコードも実行されないことになります。  構文的に正しいスクリプトを実行する際にエラーが発生した場合、実行されたコードによってワークスペースに割り当てられたものはすべて保持されます（コマンドラインから実行した場合と同様です）が、astraceback()などの診断情報には、withVisibleの呼び出しが追加されます。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを単純化するのに便利です。  (注意: dataがすでに環境である場合、これは既存の親と一緒に使用されます)。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持ちます。  これはモデリング関数の呼び出しを簡略化するのに便利です。  (注意: dataがすでに環境である場合、これは既存の親と一緒に使用されます)。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持ちます。  これはモデリング関数の呼び出しを簡略化するのに便利です。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます)。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更されるかもしれません。
引数は式オブジェクトではなく、（評価されていない関数）呼び出しであり、呼び出し元のコンテキストで評価される。
NA
DCFは、データベースを人間が直接読み書きしやすいプレーンテキストファイルに格納するためのシンプルなフォーマットである。  DCFは、パッケージの説明や内容など、Rシステムの情報を格納するためにさまざまな場所で使用されます。
conが文字列の場合、関数はfileを呼び出してバイナリモードのファイル接続を取得し、その接続は関数呼び出しの間オープンされます。
これらの関数は、Cスタイルのゼロ終端文字列を読み書きするreadBinとwriteBinを補完するものです。  これらの関数は、長さが既知の文字列を対象としており、オプションで文字列の終端マークを書き込むことができる。  これらは、現在のロケールで有効な文字列のみを対象としている。
conが文字列の場合、この関数はfileを呼び出してファイル接続を取得し、そのファイル接続は関数呼び出しの間オープンされる（ファイルパスのチルダ展開はfileが行う）。
は論理否定(NOT)を示します。
xpdrows.data.frameは、データフレームの行を展開する補助関数です。  これは、[<-と[[<-のデータフレームメソッド(データフレームの添え字代入を行う)によって使用され、直接呼び出されることは意図されていません。
これはランキングの特殊なケースですが、rank よりも汎用性の低い関数であるため、汎用化する方が適しています。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常は（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現される。  Rパッケージのバージョンは、少なくとも2つの整数で構成され、Rシステムのバージョンは3つ（メジャー、マイナー、パッチレベル）で構成されます。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられる。
これはランキングの特殊なケースであるが、rankよりも汎用性の低い関数であるため、汎用化するのに適している。  defaultmethodはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、alltiedの値には等しい整数ランクが与えられる。
最初の11の関数は接続を作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができる。
NA
典型的な使用例
各 i について、点(x0[i], y0[i])と点(x1[i], y1[i])の間に矢印が引かれる。  座標ベクトルは，最も長い長さに再利用される．
二元分割表では、セルi, jのPearson'schi^2への符号付き寄与はd_{ij} = (f_{ij} - e_{ij}) / sqrt(e_{ij})であり、ここでf_{ij}とe_{ij}はセルに対応する観察数と期待数である。  Cohen-Friendly associationplotでは、各セルは、高さがd_{ij}に比例し、幅がsqrt(e_{ij})に比例する（符号付き）長方形で表現され、ボックスの面積は、観察された頻度と期待される頻度の差に比例する。  あるセルの観察された頻度が期待された頻度より大きい場合、ボックスはベースラインより上に上がり、colの1番目の要素で指定された色（デフォルトは黒）で陰影付けされる；そうでない場合、ボックスはベースラインより下に下がり、colの2番目の要素で指定された色（デフォルトは赤）で陰影付けされる。
軸線はatの最小値から最大値まで引かれるが、プロット領域で切り取られる。  デフォルトでは、（丸め誤差の許容範囲内で）プロット領域内の点から描画された目盛りのみがプロットされるが、目盛りとそのラベルはプロット領域の外にはみ出す可能性がある。  xpd=TRUEまたはxpd=NAを使用すると、軸がそれ以上広がることができます。
これは汎用関数です。  xが供給され、NULLでない場合、xに対してディスパッチされ、atが供給され、NULLでない場合、atに対してディスパッチされます。
axis.POSIXctとaxis.Dateは、適切な時間単位（年、月、日、時、分、または秒）と賢明な出力形式を選択するために非常に懸命に働きますが、これは形式指定を与えることで上書きすることができます。
axis.POSIXctとaxis.Dateは、適切な時間単位（年、月、日、時、分、秒）と適切な出力形式を選択するようにかなり努力するが、これは形式指定を与えることで上書きすることができる。
axp、usr、logの引数は、デフォルト値（par(...)の結果）と同じように一貫性がなければならない。  この3つすべてを（NULL以外で）指定した場合、グラフィックス環境はまったく使用されません。  logがTRUEの場合、axpの意味が大きく異なることに注意してください。par(xaxp = .)のドキュメントを参照してください。
NA
NA
色の選択は複雑である。  col が供給され、NAでなければ、それが使われる。  そうでない場合は、fg が供給され、NA でない場合、それが使用される。  最終的なデフォルトはpar("col")である。
ジェネリック関数boxplotには現在、デフォルト・メソッド(boxplot.default)と数式インタフェース(boxplot.formula)があります。
ジェネリック関数 boxplot は現在、デフォルト・メソッド(boxplot.default)と数式インタフェース(boxplot.formula)を持っています。
NA
NA
cdplotは、yの周辺分布によって重み付けされたyの水準に対するxの条件付き密度を計算します。
クリッピング矩形がどのように設定されるかは、par("xpd")の設定に依存する: この関数は、次の高レベルのプロットコマンドがそれをリセットするまで、現在の設定を変更する。
split.screenを最初に呼び出すと、Rは分割画面モードになる。  他の分割画面関数は、このモードでのみ動作します。このモードでは、他の特定のコマンドは使用しないようにしてください（下記の警告セクションを参照してください）。  分割画面モードは、commandclose.screen(all = TRUE)で終了する。
単一の条件変数aの場合、rowsとcolumnsの両方が指定されていないときは、columns >= rowsの'close tosquare'レイアウトが選択される。
contour は、ベースRのデフォルトメソッドのみを持つ汎用関数です。
contour は、ベースRのデフォルトメソッドのみを持つ汎用関数である。
単一の条件変数aの場合、rowsとcolumnsの両方が指定されていないときは、columns >= rowsの'close tosquare'レイアウトが選択される。
関数または式expr（曲線の場合）または関数x（プロットの場合）は[from, to]の範囲に等間隔に配置されたn点で評価される。  このようにして決定された点がプロットされる.
NA
split.screenを最初に呼び出すと、Rは画面分割モードになる。  他の分割画面関数は、このモードでのみ動作する。このモードでは、他の特定のコマンドは使用しないこと（後述の警告セクションを参照）。  分割画面モードはcommandclose.screen(all = TRUE)で終了する。
プロットされる値にはNAを含めることができます。  2つ以上の角の値がNAである矩形は、完全に省略されます: NA値が1つの場合は、NAの反対側の三角形が省略されます。
4重表示は、2×2×k個の表を表示するために設計されている。
新しいページは背景色(par("bg"))で描かれ、多くの場合透明である。  キャンバスカラーを持つデバイス（オンスクリーンデバイス X11、windows、quartz）の場合、ウィンドウはまずキャンバスカラーで塗られ、次に背景色で塗られる。
座標系は
座標系は
NA
ヒストグラムの定義はソースによって異なります（国特有のバイアスがあります）。  等間隔に区切られたRのデフォルト（これもデフォルト）では、区切りで定義されたセルにカウントがプロットされます。  したがって、矩形の高さは、区切りが等間隔である場合の面積と同様に、セルに入る点の数に比例します。
ヒストグラムの定義はソースによって異なります（国特有のバイアスがあります）。  等間隔に区切りがある場合のRのデフォルト（これもデフォルト）は、区切りで定義されたセル内のカウントをプロットする。  したがって、矩形の高さは、区切りが等間隔である場合の面積と同様に、セルに入る点の数に比例します。
identifyは汎用関数であり、ここではデフォルトの方法のみを説明する。
x の長さは nrow(z)+1 ornrow(z) に等しくなければならない。  最初の場合、xはセル間の境界を指定し、2番目の場合、xはセルの中点を指定する。  同じような理屈がyにも当てはまる。おそらく、等間隔に配置されたグリッドの中点を指定することだけが理にかなっている。  行または列を1つだけ指定し、xまたはyの長さを1つにすると、対応する方向のユーザー領域全体が満たされる。対数のx軸またはy軸の場合は、セル間の境界を指定しなければならない。
x の長さは nrow(z)+1 ornrow(z) と等しくなければならない。  最初のケースでは x はセル間の境界を指定し、2 番目のケースでは x はセルの中点を指定する。  同じような理屈がyにも当てはまる。おそらく、等間隔に配置されたグリッドの中点を指定することだけが理にかなっている。  行または列を1つだけ指定し、xまたはyの長さを1つにすると、対応する方向のユーザー領域全体が満たされる。対数の x 軸または y 軸の場合は、セル間の境界を指定する必要がある。
図 i は、mat で i が出現する行と列に基づいて、これらの行と列のサブセットから構成される領域が割り当てられる。
図 i は、mat で i が出現する行と列に基づいて、これらの行と列のサブセットから構成される領域が割り当てられる。
図 i は、mat 内で i が出現する行と列に基づいて、これらの行と列のサブセットから構成される領域が割り当てられる。
引数 x, y, legend は、座標を1つまたは2つの引数で指定できるように、非標準的な方法で解釈される。  legend がなく、y が数値でない場合、2番目の引数はlegend であり、1番目の引数は座標を指定するものであると仮定される。
座標はプロット構造体(x成分とy成分を持つリスト)、2列の行列、時系列、...で渡すことができます。  xy.coordsを参照。  別々に渡す場合は、同じ長さでなければなりません。
座標は, プロット構造体(x成分とy成分を持つリスト), 2列の行列, 時系列, ...で渡すことができます.  xy.coordsを参照。  別々に渡す場合は、同じ長さでなければなりません。
locatorは、X11、windows、quartzのようなスクリーンデバイスでのみサポートされています。  その他のデバイスでは、このコールは何もしません。
matplot(x,y, ...) は、基本的に
matplot(x,y, ...) は基本的に
のラッパーです。
これは汎用関数です。  現在、デフォルト・メソッド(mosaicplot.default)と数式インターフェース(mosaicplot.formula)を持っています。
外側の余白のユーザー座標は常に0から1の範囲であり、図領域のユーザー座標には影響されません。
ij番目の散布図には、x[,j]に対してプロットされたx[,i]が含まれます。  この散布図は、パネル関数を設定してカスタマイズすることができます。非対角パネル関数にはxとyとしてxの適切な列が渡されます。対角パネル関数（もしあれば）には1つの列が渡され、text.panel関数には1つの(x, y)位置と列名が渡されます。
ij番目の散布図にはx[,j]に対してプロットされたx[,i]が含まれます。  この散布図は、パネル関数を設定することでカスタマイズすることができます。非対角パネル関数にはxとyとしてxの適切な列が渡されます。対角パネル関数（もしあれば）には1つの列が渡され、text.panel関数には1つの（x, y）位置と列名が渡されます。これらのパネル関数のいくつかをNULLに設定することは、そこに何も描画しないことと等価です。
NA
各デバイスは、独自のグラフィカル・パラメータのセットを持つ。  現在のデバイスがNULLデバイスの場合、parはパラメータを照会/設定する前に新しいデバイスを開きます。  (どのデバイスかはoptions("device")によって制御されます）。
プロットは、まず、(x,y,z)座標を[0,1]区間に変換することによって生成されます。  曲面は、θとφで定義された方向から原点を見ることによって表示されます。  θとφがともに0の場合、見る方向は負のy軸の真下になります。θを変えると方位角が変わり、φを変えるとコラチチュードが変わります。
NA
一般的に使用されるグラフパラメータは以下の通り：
一般的に使用されるグラフパラメータは以下の通り：
提供された関数は、デザイン内の各要因のレベルごとに1回呼び出され、プロットはこれらの要約値を表示します。  特定の因子の水準が縦線で表示され，応答のfun()の全体値が横線で描画される．
関数または式 expr (曲線の場合)または関数x (プロットの場合)は，範囲 [from, to]に等間隔に置かれたn 個の点で評価される．  このようにして決定された点がプロットされる。
新しいページは、背景色(par("bg"))で描かれる。  キャンバスカラーを持つデバイス（オンスクリーンデバイスX11、windows、quartz）の場合、ウィンドウはまずキャンバスカラーで塗られ、次に背景色で塗られる。
aspが有限の正の値である場合、y方向の1データユニットの長さがasp * x方向の1データユニットの長さに等しくなるようにウィンドウが設定される。
引数pch,col,bg,cex,lwdはベクトルであり、タイプによってはリサイクルされる。  特に、 lwd は点の場合はベクトルとして扱われ、線の場合は単一の（最初の）値として扱われることに注意してください。
座標はプロット構造体(x成分とy成分を持つリスト)、2列の行列、時系列...で渡すことができます。  xy.coordsを参照。  別々に渡す場合は、同じ長さでなければなりません。
座標は, プロット構造体(x成分とy成分を持つリスト), 2列の行列, 時系列, ...で渡すことができます.  xy.coordsを参照。  別々に渡す場合は、同じ長さでなければなりません。
座標はプロット構造体(x成分とy成分を持つリスト)、2列の行列、...で渡すことができます。  xy.coordsを参照。
座標は、プロット構造体（x成分とy成分を持つリスト）、2列の行列、...で渡すことができます。  xy.coordsを参照。
xleft, ...の位置は、現在の描画領域からの相対位置です。  x軸が100から200までなら、xleftは100より大きく、xrightshは200より小さくなければならない。  位置ベクトルは最も長い長さにリサイクルされる。
与えられた位置、すなわち xleft, ...は、現在のプロット領域からの相対位置である。  x軸が100から200までなら、xleftは100より大きく、xrightは200より小さくなければならない。  位置ベクトルは、最も長い長さにリサイクルされる。
rug の実装方法のため、プロット領域内にある x の値のみが含まれます。  有限の値が省略されると警告が出るが、有限でない値は黙って省略される。
split.screenを最初に呼び出すと、Rは画面分割モードになる。  他の分割画面関数は、このモードでのみ動作する。このモードでは、他の特定のコマンドは使用しないこと（以下の警告セクションを参照）。  分割モードは、commandclose.screen(all = TRUE) で終了する。
それぞれのiについて、点(x0[i], y0[i])と点(x1[i], y1[i])の間に線分が引かれる。  座標ベクトルは、最も長い長さに再利用される。
2次元（カーネル密度）平滑化は、KernSmoothパッケージのbkde2Dによって実行されます。この関数をpairsと組み合わせて使用する方法については、サンプルを参照してください。
spineplot はスピノグラムまたはスパインプロットを作成します。  spineplot(x,y)または spineplot(y ~ x)で呼び出すことができ、yは従属変数（そしてカテゴリ変数でなければならない）、xは説明変数であると解釈されます。  さらに、spineplotは、table(x, y)に対応するように解釈される2元表でなければならない1つの引数のみで呼び出すこともできる。
split.screenを最初に呼び出すと、Rは画面分割モードになる。  他の分割画面関数は、このモードでのみ動作する。このモードでは、他の特定のコマンドは使用しないこと（以下の警告セクションを参照）。  分割モードは、commandclose.screen(all = TRUE)で終了する。
欠損値は 0 として扱われる。
xの値が無限大または欠損している場合は破棄される。
文字列の「高さ」は、その文字列が含む改行数("˶")によってのみ決定される ことに注意してください: それは、(改行数 - 1) 倍の行間隔に、選択されたフォントの "M" の高さを加えたものです。  式の場合は、plotmathによって計算されたバウンディング・ボックスの高さである。  したがって、どちらの場合も、これは組版オブジェクトが最終ベースラインからどのくらい上まで伸びているかの推定値である。  (行間は、cex,par("lheight")と'ポイントサイズ'によって制御される（ただし、実際に使用されるフォントではない）。
この種のプロットの使用例は、Box, Hunter and Hunter または Seber and Wildに豊富にある。
文字列の「高さ」は、その文字列が含む改行数("˶")によってのみ決定されることに注 意：それは、(改行数-1)×行間＋選択されたフォント内の "M "の高さである。  式の場合は、plotmathによって計算されたバウンディング・ボックスの高さである。  したがって、どちらの場合も、これは組版オブジェクトが最終ベースラインからどのくらい上まで伸びているかの推定値である。  (行間は、cex,par("lheight")および'ポイントサイズ'によって制御されます（ただし、実際に使用されるフォントではありません）。
これは、デフォルト・メソッドと数式メソッドを持つ汎用関数です。
座標が欠落していたり、サイズパラメータが欠落している観測はプロットされません。  その場合、NAの光線の長さはゼロにリセットされる。
後者の場合、下付き文字や上付き文字、ギリシャ文字、分数など、多くの数学的表記が利用できる。
後者の場合、下付き文字や上付き文字、ギリシャ文字、分数など、かなり多くの数学的表記が利用できる。
titleに渡されるラベルは、文字列、言語オブジェクト（名前、呼び出し、式）、またはプロットされる文字列を含むリスト、およびオプションのグラフィカルパラメータを変更するcex=、col=、font=の選択である。 その他のオブジェクトは、as.graphicsAnnot.NOで強制される。
NA
Xスプラインは、制御点に対して相対的に描かれた線です。  各制御点に対して、線は制御点を通過（補間）することもあれば、制御点に接近（近似）することもある。
NA
NA
サーストンスケーリングなどの問題で使われる．  技術的には行列の加算ではないが，Krusが指摘したように，2つのベクトルや行列の和や差が有用な演算となるアプリケーションは多い．  ベクトルに対する代替演算は outer(x ,y , FUN="+")であるが、これは行列に対しては機能しない。  
lowerCor は，対角行列の下側を丸め，列名を桁数 + 3文字に省略したものを出力します．  デフォルトでは、変数の対削除を使用します。  その結果
アルファは、テストの内部一貫性の信頼性を推定するいくつかの推定値の1つです。
Alpha は、テストの内部一貫性の信頼性の推定値の1つです。
setCor は SE.残差と自由度を返します。  これらはSSRに変換され，2つ（またはそれ以上）のモデルを比較するために分散分析が使用される．omega または fa については、dfの変化の関数としてのMLカイ2乗統計量の変化が報告されます。
世界の状態について2値決定を行う問題は、どこにでもあります。  これは、帰無仮説有意性検定（NHST）、医療診断、職業選択などで見られます。  NHST、シグナル検出理論、臨床アセスメント、大学入試など様々に知られているが、これらの領域はすべて同じ2×2の決定課題を共有している。
被験者内の複数の尺度を検討するとき、試行間の変動に加えて、試行ごとのオブザベーションの変動を考慮することが有用なことがある。  連続した差の2乗平均（mssd）と連続した差の2乗平均平方根（rmssd）は、ちょうど次のようなものです。
これは本質的にfa関数とpca関数をfaCor関数と組み合わせたラッパーです。  これらは繰り返し呼び出され、得られた解からの重みが因子/成分相関を求めるために使われます。
これは本質的に、faCor関数と組み合わされたfaとpcaのラッパーです。  これらは繰り返し呼び出され、得られた解からの重みが因子/成分相関を求めるために使われます。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入した。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造のすばらしい実証データセットである。二因子モデルは、認知能力の測定で典型的に使用される。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造の素晴らしい実証データセットである。二因子モデルは、認知能力の測定で典型的に使用される。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造の素晴らしい実証データセットである。二因子モデルは、一般的に認知能力の測定に使用されます。
予測変数の集合から基準を予測するために使用できる多くの手順があります。  この総称は "機械学習 "または "統計学習 "である。  これらの手順の基本的な論理は，ある適合統計量に従って基準を最もよく予測する項目の集合を見つけ，次にこれらの項目を何回も交差検証することである．  「bestScalesは、回帰のように部分相関に重み付けをするのではなく、基準とのゼロ次相関から選択された項目に単位重み付けをすることで、これらの手続きとは異なります。  これは、よく知られている発見（Wilks, 1938; Wainer, 1976; Dawes, 1979; Waller, 2008）を考慮した、単純な手順で、回帰の重みは、どのような特定のデータ集合に対しても最適であるが、単位重みは、ほぼ同等（カンジブル）で、標本のばらつきに対してよりロバストである。  
予測変数の集合からクライテリアを予測するために使用できる多くの手順がある．  これの総称は，"機械学習 "または "統計的学習 "である．  これらの手順の基本的なロジックは，ある適合統計量に従ってクライテリアを最もよく予測する項目の集合を見つけ，次にこれらの項目を何回も交差検証することである．  「bestScalesは、回帰のように部分相関に重み付けをするのではなく、基準とのゼロ次相関から選択された項目に単位重み付けをすることで、これらの手続きとは異なります。  これは、よく知られている発見（Wilks, 1938; Wainer, 1976; Dawes, 1979; Waller, 2008）を考慮した、単純な手順で、回帰の重みは、どのような特定のデータ集合に対しても最適であるが、単位重みは、ほぼ同等（カンジブル）で、標本のばらつきに対してよりロバストである。  
このデータセットは非推奨であり、ユーザーはbfiを使うことが推奨される。
このデータセットは非推奨であり、ユーザーはbfiを使うことが推奨される。
ヒストグラム/棒グラフを背中合わせに描画する些細な、しかし便利な関数。各グループに1つずつ。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装したbiquartiminの2つであろう。もう1つはTargetQで、これはターゲットの欠損NA値を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようだ。
データはsize=sizeの部分集合に分割される。  そして、各サブセットとサブセットのペアについて相関が求められる。基本的なループは部分集合をループします。サイズが変数数の整数部分集合であり、コア数の倍数である場合、マルチコアがより多く使用されます。  660/80と660/100では、660/80の方が有利であることに注目してほしい。  しかし、660/165を試してみると、これは破綻する。  さらに、より小さいサブセット（55）を使用した場合の利点に注目してほしい。  
因子分析fa、fa.polyまたは主成分分析principalの出力を取り込み、因子/成分負荷量とともに因子/成分得点をプロットする汎用biplot関数を使用します。
これらの関数の中で最も有用な2つの関数は、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装するbiquartiminであろう。2番目はTargetQで、ターゲット中の欠損NA値を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
四分木相関は、二変量正規性を仮定して、2×2の度数表から潜在的なピアソン相関を推論します。  推定手順は2段階のMLです。  各組の項目のセル度数が求められる．テトラコリックスの場合，カウントがゼロのセルは，連続性の補正として0.5に置き換えられる（correct=TRUE）．
NA
lsat6データセットはMcDonald (1999)と同様にltmパッケージで分析されている。どちらのデータセットもBock and Lieberman (1970)によって説明されています。どちらのセットも、IRT手順をテストし、irt.fa関数を用いたテトラコリック相関と項目因子分析の使用を示す有用な例です。
Cattell (1963) は、Thurstoneからの8つの認知変数とInstitute for Personality Assessment Test (IPAT)からの4つの認知変数について報告しました。  Rindskopf and Rose (1988) は、このデータ集合を2次因子分析の例として使用しています。したがって、二因子回転、オメガ階層、esem因子分析、バッテリー間因子分析などの代替解を検証するのに適したセットです。
lowerCor は、対角行列の下側を丸めたものを出力し、列名は桁数+3文字に省略されます。  デフォルトでは、変数の対削除を使用する。  その結果
 Schmid and Leiman (1957)の2つの人工相関行列。Chen et al. (2006)の実共分散行列と人工共分散行列。
NA
このシミュレーションは元々、影響の測定におけるスキューの効果を比較するために開発された（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
「心理データを表現する一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造化されます（Revelle & Rocklin, 1979）。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サークンプレックス（Guttman, 1954）は、単純構造が欠けているモデルの一種である。
「心理学的データを表現するための一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造である(Revelle & Rocklin, 1979)。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サークンプレックス（Guttman, 1954）は、単純構造が欠けているモデルの一種である。
「心理学的データを表現するための一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造である(Revelle & Rocklin, 1979)。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サークンプレックス（Guttman, 1954）は、単純構造が欠けているモデルの一種である。
データが角度（日中の覚醒度のピークの時間や緊張度のピークの時間など）を表す場合、より通常の線形統計ではなく、円形統計を適用する必要がある（円形統計の非常に明確な例についてはJammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックの周りに一様に分布しているときに最小値（0）になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックの周りに一様に分布しているときに最小値（0）になる。  
これらは、合成相関行列を形成するSAPA (https://www.sapa-project.org/)手順で使用される関数の3つである。  項目の相関行列があれば、それらの項目からなる尺度の相関行列を求めるのは簡単である。これは、元のデータ行列から行うこともできますし、 scoreItems を使って相関行列から行うこともできます。  SAPAデータでは、尺度相関は生データではなく項目相関から見つけるべきであることを覚えておくことが重要です。
クラスター・モデルは、因子モデルに似ています：RはC'Cによって適合される。ここで C <- クラスター定義行列 x ローディング行列.  このモデルは元の相関行列をどの程度近似し，因子モデルとどのように比較するか?
おそらく重複している）クラスタとしてスコア付けされる項目の集合と項目の相互相関行列が与えられたとき，クラスタを求め，次に各クラスタと各項目の相関を求める．  項目の分散をクラスタ内の平均項目間相関に置き換えることで、項目の重複を修正する。  
因子分析またはクラスター分析の結果がプロットされる。  各項目は、その最も負荷の高い因子に割り当てられ、変数名とクラスタ（色）で識別されます。クラスターの割り当ては、負荷による自動クラスタリングを上書きするように指定することができます。これらの関数は両方とも、直接呼び出すか、汎用 plot 関数を呼び出すことによって呼び出すことができます。  (例参照)。
kmeansはアイテムを逆スコアしないので、kmeansによって定義されたクラスタは、同じ数のクラスタが抽出されたICLUSTのクラスタと必ずしも一致しないことに注意してください。
2つのグループがどのように異なるかを報告する方法はたくさんある．  Cohen の d 統計量は，単に平均の差をプールされたグループ内標準偏差で表現したものである．  rは、効果量の普遍的な指標で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされたグループ内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされたグループ内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
カテゴリー判断が2つのカテゴリーでなされる場合、関係の尺度はファイ係数である。  しかし、いくつかのカテゴリー判断は2つ以上の結果を用いてなされる。  例えば、2人の診断士が患者を3通りに分類するように求められたり（例えば、パーソナリティ障害、神経症、精神病）、病気の病期を分類するように求められたりする。  塩基率が2×2表で観察されるセルの度数に影響するように、n-way表でも考慮する必要がある(Cohen, 1960)。
合同は、行列によって定義され、原点を基点とするベクトルの対の余弦である。  したがって、スケーラーによってのみ異なる値の場合、合同は1になる。
NA
このシミュレーションはもともと、影響の測定におけるゆがみの効果を比較するために開発されました（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
信頼性分析のために例を構築する場合、共属データ構造をシミュレートするのが便利です。  これは最も単純な項目構造で、ただ1つの因子を持つだけです。主に信頼性理論の議論や因子得点の推定に用いられます。
合同は，行列によって定義され，原点を基点とするベクトルの対の余弦である．  したがって、スケーラーによってのみ異なる値の場合、合同は1になる。
相関行列が与えられた場合、信頼区間は、従来のr2z fisherz 変換（fisherz と正規分布。
大規模なデータ・ベースの相関を要約するとき、または因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示すると便利です。  これは画像関数を使った簡単なグラフ表示です。
大規模なデータ・ベースの相関を要約するとき、あるいは因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示することは有用である。  これはimage関数を使った簡単なグラフ表示です。
平滑化は固有値分解によって行われ、固有値 < eig.tolは100 * eig.tolに変更されます。  正の固有値は、項目数の合計になるように再スケーリングされます。  行列は再計算され(eigen.vectors %*% diag(eigen.values) %*% t(eigen.vectors))、cov2corを用いて強制的に相関行列に変換されます。(Bock, Gibbons and Muraki, 1988 および Wothke, 1993を参照)。
固有値＜eig.tolは100 * eig.tolに変更されます。  正の固有値は，項目数の合計になるようにスケールし直される．  行列は再計算され(eigen.vectors %*% diag(eigen.values) %*% t(eigen.vectors))、cov2corを用いて強制的に相関行列に変換されます。(Bock, Gibbons and Muraki, 1988 and Wothke, 1993を参照)。
重み付き相関は、単に∑ (wt_k * (x_ik - x_jk)) です。/sqrt[wt_k ∑(x^2_ik) wt_k ∑(x^2_jk)] ここで x_ik は加重平均からの偏差です。  
lowerCor は, 対角行列の下側を丸めたものを出力し, 列名は桁数 + 3 文字に省略されます.  デフォルトでは、変数の対削除を使用する。  その結果
NA
NA
相関行列が与えられた場合、信頼区間が従来のr2z fisherz 変換（fisherz と正規分布。
欠損データがある場合、完全情報最尤法(FIML)は、単純に対相関を使用する代わりに使用できます。構造方程式モデリング用のlavaanパッケージの実装は、相関または共分散を求めるだけの単純なケースに適応されています。  
大規模なデータ・ベースの相関を要約するとき、または因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示すると便利です。  これは画像関数を使った簡単なグラフ表示です。
大規模なデータ・ベースの相関を要約するとき、あるいは因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示することは有用である。  これはimage関数を使った簡単なグラフ表示です。
corr.testはcor関数を用いて相関を求め、次式で個々の相関にt検定を適用します。
corr.testはcor関数を使って相関を求め、式を使って個々の相関にt検定を適用します。
減衰相関は、観察変数の集合によって測定される潜在変数の間の相関と考えることができる。つまり，両方の変数が完全に信頼性をもって測定された場合，2つの（信頼できない）変数の間の相関はどうなるかということである．
行列が恒等行列であるかどうかを検定する方法がいくつかある．最もよく知られているのは，Bartlett (1951) と Box (1949)のカイ2乗検定である．Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の合計またはフィッシャー変換相関の2乗の合計を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normal に実装されている。
実際の応用よりも教育目的に有用である。Bartlett検定は漸近的にカイ2乗分布する。
行列が恒等行列であるかどうかを検定する方法はいくつかある。最もよく知られているのは，Bartlett (1951) と Box (1949)のカイ2乗検定である．Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の和またはフィッシャー変換相関の2乗の和を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normal で実装されている。
行列が恒等行列であるかどうかを検定する方法はいくつかある。最もよく知られているのは，Bartlett (1951) と Box (1949)のカイ2乗検定である．Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の和またはフィッシャー変換相関の2乗の和を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normal で実装されている。
行列が恒等行列であるかどうかを検定する方法はいくつかある。最もよく知られているのは，Bartlett (1951) と Box (1949)のカイ2乗検定である．Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の和またはフィッシャー変換相関の2乗の和を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normal で実装されている。
データが角度（日中の覚醒度のピークや緊張度のピークの時間など）を表す場合、より標準的な線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例についてはJammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
データが角度を表すとき（日中の注意力のピークの時間や緊張のピークの時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じであれば最大値(1)になり、位相角がクロックの周りに一様に分布していれば最小値(0)になる。  
SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）設計を使用するときは、ペアワイズ・オブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個またはそれ以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
生データから重回帰や正準相関を計算することがより一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられた場合，この関数は相関を求める．
lowerCor は，列名を桁数+3文字に省略し，桁数に丸められた対角行列の下側の行列を出力するが，丸められない完全な行列も返す．  デフォルトでは、変数の対削除を使用する。  次に
CTAモデルの徹底的な議論は、Revelle (2008)にある。このモデルの応用は、Revelle and Condon (2015)で議論されている。
CTAモデルについては、Revelle (2008)に詳しい。このモデルの応用はRevelle and Condon (2015)で議論されている。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差だけである。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界がある。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされたグループ内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされたグループ内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされたグループ内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされた群内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされた群内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされた群内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされた群内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
バイオリン・プロットを用いてデータを記述する。アルファ値を変えて陰影を修正する。  grp変数は、複数のグループごとに別々のバイオリンプロットを描くのに使えます。
基本的なデータ分析では、基本的な記述統計量を得ることが重要です。summaryやHmisc::describeのような手続きはそれを行います。  psychパッケージのdescribe関数は、心理測定や心理学の研究で最も頻繁に要求される統計量を生成し、読みやすいdata.frameで生成することを目的としています。グループ化変数が数式モードで呼び出された場合、その処理に対して describeBy も呼び出されます。describeの結果は、グラフィック関数（例えば、error.crosses）で使用することができます。
複数の異なるグルーピング変数の記述統計量を得るには、group がリストであることを確認してください。  複数のグループ化変数を持つ行列出力の場合、グループ化変数の値が出力に追加されます。
複数の異なるグルーピング変数の記述統計量を得るには、group がリストであることを確認してください。  複数のグルーピング変数を持つ行列出力の場合、グルーピング変数の値が出力に追加されます。
基本的なデータ分析では、基本的な記述統計量を得ることが重要です。summaryやHmisc::describeのような手続きはそれを行います。  psychパッケージのdescribe関数は、心理測定や心理学の研究で最も頻繁に要求される統計量を生成し、読みやすいdata.frameで生成することを目的としています。グループ化変数が数式モードで呼び出された場合、その処理に対して describeBy も呼び出されます。describeの結果はグラフィック関数（例えばerror.crosses）で使用することができる。
基本的なデータ分析では、基本的な記述統計量を得ることが重要です。summaryやHmisc::describeのような手続きはそれを行います。  psychパッケージのdescribe関数は、心理測定や心理学の研究で最も頻繁に要求される統計量を生成し、読みやすいdata.frameで生成することを目的としています。グループ化変数が数式モードで呼び出された場合、その処理に対して describeBy も呼び出されます。describeの結果はグラフィック関数（例えばerror.crosses）で使用することができる。
diagram関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
"多くの尺度は、開発者やユーザによって、主に1つの潜在変数の尺度であると仮定されている。尺度が測定の効果指標モデルに適合することも仮定されている場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が潜在変数を共通に測定しているかどうかに関係します。
合同は，行列によって定義され，原点に基づくベクトルの対の余弦である．  したがって，スケーラーによってのみ異なる値では，合同は1になる．
テトラコリコリレーションを図式化したもの。教育目的で使用される。  デフォルト値は相関が0.5で、1と1でカットしている。  このコードは、ベース・グラフィックスを使った複雑なグラフィックスに対するレイアウト機能の使い方のデモンストレーションでもある。
テトラコリック相関のグラフィック・デモンストレーション。教育目的に使用。  デフォルト値は相関0.5で、1と1でカットしています。  このコードは、ベース・グラフィックスを使った複雑なグラフィックスのレイアウト機能の使い方のデモンストレーションでもある。
dummy.codeは、これらのカテゴリをn個の異なるダミー・コード化された変数に変換します。
NA
NA
楕円の次元は、x 変数と y 変数の相関から計算され、sqrt(1+r) および sqrt(1-r) としてスケーリングされる。そして、size[1]およびsize[2]標準偏差単位としてスケーリングされる。   95%および99%の信頼度でスケーリングするには、c(1.64,2.32) を使用します。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装したbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
平均±信頼区間の描画は、実験結果を報告する際に頻繁に使用される機能です。デフォルトでは、信頼区間はt分布の1.96標準誤差である。  
平均 +/- 信頼区間を描くことは、実験結果を報告するときによく使われる関数である。デフォルトでは、信頼区間は1.96標準誤差（t分布で調整）である。
平均 +/- 信頼区間の描画は、実験結果を報告するときによく使われる関数である。デフォルトでは、信頼区間はt分布の1.96標準誤差である。  
肯定的感情および否定的感情に対する気分操作の効果を説明する2方向のエラーバーの例については、https://personality-project.org/revelle/publications/happy-sad-appendix/FIG.A-6.pdf を参照。
複数のプロットを高速化するために、この関数は前の実行の出力から作業することができます。  したがって、describeByが実行され、その結果を複数の変数について表示することができる。
実験操作の効果や複数のグループの関係を可視化する場合、それらの平均や信頼領域を2次元空間にプロットするのが便利である。  
faに実装されている因子分析は，変数の集合の共分散（相関）構造を，小さな潜在変数または「因子」の集合で要約しようとするものである．  この解は、元の解を変更することなく、より多くの変数を含むより大きな空間に「拡張」することができる（fa.extension.F因子の拡張を参照）。  同様に，2番目の変数集合（Y 集合）の因子は，元の（X ）集合に拡張することができる．  そして，潜在変数のこれらの2つの集合は，探索的構造方程式モデルのために相関させることができる．  (これは， sem, lavaan, Mx などの伝統的な構造方程式モデリング・パッケージを用いた確証的因子モデル（CFA）ではなく，探索的因子分析（EFA）に基づくので，探索的である）．
faに実装されている因子分析は、変数の集合の共分散（相関）構造を、小さな潜在変数または「因子」の集合で要約しようとします。  この解は、元の解を変更することなく、より多くの変数を含むより大きな空間に「拡張」することができる（fa.extension.Factorを参照）。  同様に，2番目の変数集合（Y 集合）の因子は，元の（X ）集合に拡張することができる．  そして，潜在変数のこれらの2つの集合は，探索的構造方程式モデルのために相関させることができる．  (これは， sem，lavaan，Mx などの伝統的な構造方程式モデリング・パッケージを用いた確証的因子モデル（CFA）ではなく，探索的因子分析（EFA）に基づくので探索的である）．
パス図の表現は，確証的因子分析では標準になっているが，探索的因子分析ではまだ一般的でない．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．
因子分析は，相関行列または共分散行列をより低いランクの行列で近似する試みである．  基本的なモデルは， nRn = nFk kFn' + U2 (kはnよりずっと小さい)である．因子分析を行うには多くの方法があり，最尤法はおそらく最も一般的に好まれる方法であろう（factanalを参照）．  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分はデータの最も簡潔な記述を提供する．  
2組の因子負荷量の間の因子一致係数を求めます。
パス図の表現は，確証的因子分析では標準的になっているが，探索的因子分析ではまだ一般的ではない．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．
因子が変数の集合（Fo 因子負荷量）から導出され，拡張された変数の集合（Fe）の負荷量がどうなるかを見たい場合がある．オリジナルの相関行列Ro とRoeの拡張変数とのこれらのオリジナル変数の相関があれば、オリジナル因子での拡張変数の負荷量Fe を見つけるのは簡単な計算です。  この手法は，すべての作業をやり直すことなく，因子分析に新しい変数を追加するケースのために，Dwyer (1937)によって開発された．しかし，Horn (1973)によって議論されたように，因子拡張は，拡張変数を元の因子分析に含めたくないが，とにかく負荷量がどうなるかを見たい場合にも適切である．
因子が変数の集合（Fo 因子負荷量）から導出され、拡張された変数の集合（Fe）の負荷量がどうなるかを見たい場合があります。オリジナルの相関行列Ro とRoeの拡張変数とのこれらのオリジナル変数の相関があれば、オリジナル因子での拡張変数の負荷量Fe を見つけるのは簡単な計算です。  この手法は，すべての作業をやり直すことなく，因子分析に新しい変数を追加するケースのために，Dwyer (1937)によって開発された．しかし，Horn (1973)によって議論されたように，因子拡張は，拡張変数を元の因子分析に含めたくないが，とにかく負荷量がどうなるかを見たい場合にも適切である．
パス線図の表現は，確認的因子分析では標準になっているが，探索的因子分析ではまだ一般的ではない．  因子構造をグラフィカルに表現することは、その構造を理解するのに役立つ人もいます。
fa.lookupとlookupは、相関行列または因子負荷行列を要約するための単純なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例bfi.dictionaryを参照）。
因子分析および 1 つの高次因子の場合については、fa および omega を参照してください。
因子分析および1つの高次因子の場合については、fa および omega を参照。
fa.results$loadingsは，並べ替えられた負荷量に置き換えられる．
Cattellの "scree" 検定は，因子数の問題のための最も簡単な検定の1つである．  Horn (1965) の "並列 "分析は，同様に説得力のある手順である．  最も最適な因子数を決定するための他の手順は，VSS（Very Simple Structure）基準（VSS ）とVelicerのMAP 手順（VSS に含まれる）を見つけることを含む．fa.parallelは，主成分と因子解（デフォルトではminres）の固有値をプロットし，元のデータ行列と同じサイズのランダム行列に対しても同じことを行います．  生データの場合、ランダム行列は、1)一変量正規データの行列、2)元データのランダム標本（行をまたいでランダム）です。
Cattellの "scree" 検定は，因子数の問題に対する最も簡単な検定の1つである．  Horn (1965) の "並列 "分析も同様に説得力のある手順である。  最も最適な因子数を決定するための他の手順には，VSS（Very Simple Structure）基準（VSS ）とVelicerのMAP手順（VSSに含まれる）を見つけることが含まれる．fa.parallelは，主成分と因子解（デフォルトではminres）の固有値をプロットし，元のデータ行列と同じサイズのランダム行列に対しても同じことを行います．  生データの場合、ランダム行列は、1)一変量正規データの行列、2)元データのランダム標本（行をまたいでランダム）です。
因子分析またはクラスター分析の結果がプロットされる．  各項目は、その最も負荷の高い因子に割り当てられ、変数名と（色による）クラスタで識別されます。クラスタの割り当ては、ローディングによる自動クラスタリングを上書きするように指定することができます。これらの関数は両方とも、直接呼び出すか、一般的なplot関数を呼び出すことによって呼び出すことができます。  (例参照)。
これらの古い関数のすべての機能については、faの記述を参照してください。
因子分析とは、相関行列や共分散行列をより小さいランクの行列で近似する試みです。  基本的なモデルは、nRn = nFk kFn' + U2 (kはnよりはるかに小さい)です。因子分析を行うには多くの方法がありますが、最尤法がおそらく最も一般的でしょう（factanalを参照）。  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分はデータの最も簡潔な記述を提供する．  
この関数は、profileRパッケージのwprifm関数にインスパイアされており、Davison, Kim and Close (2009)の論文が引用されています。  基本的なロジックは、各被験者から平均ベクトルを抽出し、得られたipsatizedデータ行列を分析することです。  これは、パーソナリティ項目であればアクセシビリティを、能力項目であれば一般因子を除去していると見ることができる。  すべて同じようにキー設定された項目からなる因子（例えば、bfiデータセットにおける神経症）は、この手法によって最も影響を受ける。
パス図の表現は，確証的因子分析では標準的になっているが，探索的因子分析ではまだ一般的ではない．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．
因子分析は，相関行列または共分散行列をより低いランクの行列で近似する試みである．  基本的なモデルは， nRn = nFk kFn' + U2 (kはnよりずっと小さい)である．因子分析を行うには多くの方法があり，最尤法はおそらく最も一般的に好まれる方法であろう（factanalを参照）．  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分はデータの最も簡潔な記述を提供する．  
fa.results$loadings は、ソートされた負荷量に置き換えられます。
faとprincipalで使用される適合度検定を1つの関数に統合。  行列が特異な場合、適合関数を求める前に相関行列を平滑化する。SEM関数と同様に、RMSEA（近似の二乗平均平方根誤差）とアルファ信頼区間を求めます。  また、二乗平均平方根残差も表示します。
irt.faは、項目反応分析のプロセスを簡単にするために、いくつかの関数を1つにまとめたものです。  相関は、テトラコリックまたはポリコリックのいずれかを使用して求められます。  すべての正規オプションを用いた探索的因子分析は、faを使用して行われます。  そして、その結果は、IRTパラメータ（困難度と識別度）の観点で報告されるように整理され、より従来の因子分析のアウトプットと同様になります。さらに、相関ステップはやや時間がかかるので、最初のステップで発見された相関行列を用いて再分析を行うことができる。  この場合、fm="minchi" 因子分解法を使用したい場合は、オブザベーションの数を pairwiseCount の結果の行列として指定する必要があります。
マルチレベル・データは、心理学研究で一般的です。マルチレベル・データでは、オブザベーションは、ある上位レベルのグループ化変数に入れ子になっている被験者について取られます。  データは、実験的（参加者が実験条件に入れ子になっている）かもしれないし、観察的（学生が教室に、学生が大学の専攻に入れ子になっている）かもしれません。この種のデータを分析するには、ランダム効果モデルや混合効果モデル、より一般的にはマルチレベル・モデルを使用します。  少なくとも2つの非常に強力なパッケージ（nlmeとmultilevel）があり、階層（マルチレベル）データ構造の複雑な分析を可能にします。  これは真のマルチレベル・モデリングを補足するためのものです。
因子分析は、相関行列や共分散行列をより小さいランクのもので近似する試みです。  基本的なモデルは， nRn = nFk kFn' + U2 (kはnよりずっと小さい)である．因子分析を行うには多くの方法があり，最尤法はおそらく最も一般的に好まれる方法であろう（factanalを参照）．  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分はデータの最も簡潔な記述を提供する．  
因子相関は，Gorsuch (1983)によって議論されたアプローチを用いて求められ， w=S R^{-1} および r = w' R w によって求められる重み行列を使用する．
2組の因子負荷量の間の因子適合係数を求めます。
おそらく、心理測定学者の数だけ適合指標がある。  この適合度は、因子モデルが与えられたときの相関行列の削減量のもっともらしい推定値である。  これは元の相関の大きさに敏感であることに注意してください。  つまり、残差が小さくても元の相関が小さければ、それは悪い適合です。
これらの古い関数のすべての機能については、faの記述を参照してください。
NA
これらの古い関数のすべての機能については、faの記述を参照してください。
因子分析またはクラスター分析の結果がプロットされている。  各項目は、最も負荷の高い因子に割り当てられ、変数名とクラスタ（色）で識別されます。クラスターの割り当ては、負荷による自動クラスタリングを上書きするように指定することができます。これらの関数は両方とも、直接呼び出すか、汎用 plot 関数を呼び出すことによって呼び出すことができます。  (例を参照)。
基本因子方程式は nRn = nFk kFn' + U2 です。残差はR* = R - F'Fです。残差は，因子分析の妥当性を理解するために調査されるべきである（しかし，実際にはおそらくめったに調査されない）．  因子分析や主成分分析を行う場合，通常，残差がランダム行列から期待される残差と異ならないまで，因子/成分を抽出し続ける．
factor.rotateは，回転がどのように機能するかのデモンストレーションとしての意味もあり，GPArotationのようなより高度なパッケージでは利用できない特定の回転を必要とする場合に有用である．  plot オプションを TRUE に設定すると、元の軸が破線で表示されます。
因子分析モデルは構造レベルでは定義されていますが、データレベルでは未定義です。  これは因子分析のよく知られた問題ですが、あまり議論されていません。  
faとprincipalで使用される適合度検定を1つの関数に統合。  行列が特異な場合、適合関数を求める前に相関行列を平滑化します。SEM関数と同様に、RMSEA（近似の二乗平均平方根誤差）とアルファ信頼区間を求めます。  また、二乗平均平方根残差も計算します。
これらの古い関数のすべての機能については、faの記述を参照してください。
因子/主成分分析の負荷行列は、各項目が1つのクラスタに割り当てられるクラスタ(-1,0,1)定義行列に変換されます。  これは、クラスタ合成を形成するために単位重み付けされる項目を抽出する高速な方法です。  これらの複合スコアの相関を求めるには、この関数を cluster.cor と組み合わせて使用します。
これらの関数の中で最も有用なのは、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装するbiquartiminでしょう。もう1つはTargetQで、これはターゲットの欠損NA値を許容する。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようだ。
NguyenとWallerは、因子分析における局所最小値の問題をレビューしている。  faRotateは、異なる開始値を用いてn.rotationを生成し、複数の開始値を用いて元の負荷量に指定された回転を適用する。  超平面数と複雑度指数が各開始行列について報告され、最も高い超平面数と最も低い複雑度を持つものが返される。
NA
NA
DV1 + DV2 ~ IV1 + IV2 + (IV3) + I(IV4^2) - IV5 として与えられた基本的な数式入力は、2つのDV (1と2)、2つの通常のIV (1と2)、調停子 (IV3)、2次関数 (IV4)、および部分化される変数 (IV5) を返すように解析されます。setCor と mediate の様々な例を参照してください。
lowerCor は，対角行列の下側を丸めたものを出力し，列名は桁数 + 3 文字に省略されます．  デフォルトでは、変数のペアワイズ削除が使用される。  その結果
NA
差別待遇に抗議する女性に対する女性の反応は、Garciaら(2010)によって報告された実験で調べられた。129人の女性に、職場での性差別（男性弁護士が、明らかに有能な女性弁護士よりも昇進した）の説明が与えられた。  被験者はその後、対象の弁護士がその決定を不当だと感じていることを読んだ。  その後、被験者は無作為に3つの条件に割り当てられた：コントロール（抗議なし）、個人的抗議（「彼らは私を不公平に扱っている」）、集団的抗議（「事務所は女性を不公平に扱っている」）。
関数の書き方を教えるのに便利で，中心傾向を推定するさまざまな方法を示すのにも役立つ。
驚いたことに、スピアマン（1904年）が信頼性の概念を心理学者に紹介してから1世紀以上経った今でも、信頼性を測定するための複数のアプローチが存在する。非常にポピュラーですが、クロンバックのα (1951) はテストの信頼性を過小評価し、第1因子の飽和を過大評価します。16項目以下のテストにsplitHalfを使用すると、すべての可能な分割をかなり簡単に見つけることができます。  17項目以上のテストでは、n.sample分割がランダムに発見されます。したがって、16 個以下の項目の場合、上限値と下限値は正確です。  17項目以上の場合、それらは近いですが、おそらく最も高い信頼性をわずかに過小評価し、最も低い信頼性を過大評価するでしょう。  
Cをp * p共分散行列、v = diag(C)をその対角行列（すなわち分散v_i = c_{ii}のベクトル）、C0 = C - Diag(v)を対角に0を代入した共分散行列、x = ベクトル(x1, ... , xp)とすると、教育テストの問題は次のようになる（Al-Homidan 2008など参照）。
意外なことに、スピアマン（1904）が信頼性の概念を心理学者に紹介してから1世紀以上経った今でも、信頼性を測定するためのアプローチは複数存在する。Cronbachのα（1951）は、非常にポピュラーですが、テストの信頼性を過小評価し、第1因子の飽和を過大評価します。16項目以下のテストにsplitHalfを使用すると、すべての可能な分割をかなり簡単に見つけることができます。  17項目以上のテストでは、n.sample分割がランダムに発見されます。したがって、16 個以下の項目の場合、上限値と下限値は正確です。  17項目以上の場合、それらは近いですが、おそらく最も高い信頼性をわずかに過小評価し、最も低い信頼性を過大評価するでしょう。  
一般化可能性理論は、信頼性の分析に分散成分のアプローチを適用したものです。  G研究（一般化可能性）で成分が推定され、D研究（決定）で使用される。  特定のD研究に適したさまざまな比率が形成される。
Gorsuc (1997) は，因子拡張の代替モデルを提案した．  彼の手法は，反復変数の場合に適している．  これは，correct=FALSEのlink{fa.extension} で扱われる．
驚くことに、Spearman (1904)が信頼性の概念を心理学者に紹介してから1世紀以上経った今でも、信頼性を測定するための複数のアプローチがあります。Cronbachのα (1951) は非常によく使われていますが、テストの信頼性を過小評価し、第1因子の飽和を過大評価します。16項目以下のテストにsplitHalfを使用すると、すべての可能な分割をかなり簡単に見つけることができます。  17項目以上のテストでは、n.sample分割がランダムに発見されます。したがって、16 個以下の項目の場合、上限値と下限値は正確です。  17項目以上の場合、それらは近いですが、おそらく最も高い信頼性をわずかに過小評価し、最も低い信頼性を過大評価するでしょう。  
 Harman.Holzinger：能力検査の9×9相関行列、N = 696.
 Harman.Holzinger：能力テストの9×9相関行列、N = 696.
 Harman.Holzinger：能力検査の9×9相関行列，N=696.
 Harman.Holzinger：能力検査の9×9相関行列，N=696.
 Harman.Holzinger：能力テストの9 x 9相関行列，N = 696．
関数について教えるための例として含まれている。また、調和平均で重み付けするためにstatsByで使用される。
NA
NA
パス図の表現は、確証的因子分析では標準的になっていますが、探索的因子分析ではまだ一般的ではありません。  因子構造をグラフィカルに表現することは、その構造を理解するのに役立つ人もいる。
これは，複数の分布を素早く要約することを可能にする．  信頼性関数から得られる多重分割の半分の結果を調べるときに特に有用である．  
Holzinger and Swineford (1937) は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入した。  これは、オメガ関数やsemを用いて分析できる階層的な因子構造の素晴らしい実証データセットである。二因子モデルは、認知能力の測定で典型的に使用される。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造の素晴らしい実証データセットである。二因子モデルは，認知能力の測定で典型的に使用される．
Shrout and Fleiss (1979) は，n個のターゲットについてk人の評価者が行った評価の信頼性について6つのケースを考察している．McGraw and Wong (1996)は、10個のケースを検討しており、そのうちの6個はShrout and Fleissと同じで、4個は概念的に異なるが、Shrout and Fleissの6個と同じ式を使用している。
 アルゴリズムの広範な文書化と正当化は、オリジナルのMBR 1979 https://personality-project.org/revelle/publications/iclust.pdf の論文で入手可能である。  アルゴリズムとサンプル出力のさらなる議論は、personality-project.orgのウェブ・ページhttps://personality-project.org/r/r.ICLUST.html。
 アルゴリズムの広範なドキュメンテーションと正当化は、オリジナルのMBR 1979 https://personality-project.org/revelle/publications/iclust.pdf ペーパーで利用可能です。  アルゴリズムとサンプル出力のさらなる議論は、personality-project.orgのウェブページhttps://personality-project.org/r/r.ICLUST.html。
ICLUSTを参照
iclust.diagramは、Rgraphvizをインストールすることなく、ICLUST.rgraphのほとんどの機能を提供します。 ICLUSTから自動的に呼び出されます。
出力ファイルを作成（または上書き）し、クラスター構造を示すドットコードを出力する。このドットファイルは、ドットビューワ（例：https://www.graphviz.org/）に直接インポートすることができる。  dot "言語は強力なグラフィック記述言語であり、特にクラスター出力の表示に適している。  市販のグラフィックプログラム（OmniGraffleなど）もドットファイルを読み込む（そしてクリーンアップする）ことができる。  
OmniGraffleは出力ファイルを作成（または上書き）し、クラスター構造を示すドットコードを印刷します。このドットファイルは、ドットビューア（例：https://www.graphviz.org/）に直接インポートすることができる。  dot "言語は強力なグラフィック記述言語であり、特にクラスター出力の表示に適している。  市販のグラフィックプログラム（OmniGraffleなど）でもドットファイルを読み込む（そしてクリーンアップする）ことができる。  
クラスターまたは因子分析の出力を解釈するとき、各因子/クラスターに最大の負荷がかかる項目がどれかという観点で項目をグループ化し、次に絶対的な因子負荷の大きさで項目を並べ替えると便利です。
クラスター分析または因子分析の出力を解釈するとき、どの項目が各因子/クラスターに最大の負荷を持っているかという観点から項目をグループ化し、次に絶対的な因子負荷の大きさによって項目を並べ替えることが有用である。
fa に実装されている因子分析は，変数の集合の共分散（相関）構造を，潜在変数または「因子」の小さな集合で要約しようとするものである．  この解は、元の解を変更することなく、より多くの変数を持つより大きな空間に「拡張」することができる（fa.extension.Factorを参照）。  同様に，2番目の変数集合（Y 集合）の因子は，元の（X ）集合に拡張することができる．  そして，潜在変数のこれらの2つの集合は，探索的構造方程式モデルのために相関させることができる．  (これは， sem，lavaan，Mx などの伝統的な構造方程式モデリング・パッケージを用いた確証的因子モデル（CFA）ではなく，探索的因子分析（EFA）に基づくので探索的である）．
回答の総数が N で、中央値が M、中央値での回答数が Nm >1、Nb= 中央値未満の回答数である場合、回答がカテゴリ内で一様に分布しているという仮定で、補間された中央値は M - .5w + w*(N/2 - Nb)/Nm となります。
回答の総数がNで、中央値がM、中央値の回答数がNm >1、Nb=中央値未満の回答数である場合、回答がカテゴリー内で一様に分布しているという仮定で、補間された中央値はM - .5w + w*(N/2 - Nb)/Nm となります。
回答の総数がNで、中央値がM、中央値の回答数がNm >1、Nb=中央値未満の回答数である場合、回答がカテゴリー内で一様に分布しているという仮定で、補間された中央値はM - .5w + w*(N/2 - Nb)/Nm となります。
回答の総数がNで、中央値がM、中央値の回答数がNm >1、Nb=中央値未満の回答数である場合、回答がカテゴリー内で一様に分布しているという仮定で、補間された中央値はM - .5w + w*(N/2 - Nb)/Nm となります。
回答の総数がNで、中央値がM、中央値の回答数がNm >1、Nb=中央値未満の回答数である場合、回答がカテゴリー内で一様に分布しているという仮定で、補間された中央値はM - .5w + w*(N/2 - Nb)/Nm となります。
回答の総数がNで、中央値がM、中央値の回答数がNm >1、Nb=中央値未満の回答数である場合、回答がカテゴリー内で一様に分布しているという仮定で、補間された中央値はM - .5w + w*(N/2 - Nb)/Nm となります。
回答の総数がNで、中央値がM、中央値の回答数がNm >1、Nb=中央値未満の回答数である場合、回答がカテゴリー内で一様に分布しているという仮定で、補間された中央値はM - .5w + w*(N/2 - Nb)/Nm となります。
回答の合計数がNで、中央値がM、中央値での回答数がNm >1、Nb= 中央値より小さい回答数である場合、回答がカテゴリ内で一様に分布しているという仮定で、補間された中央値は M - .5w + w*(N/2 - Nb)/Nm となります。
古典的テスト理論では、項目の難易度を無視し、能力を期待得点として定義します： abilityi = theta(i) = x(i.)ゼロ・パラメータ・モデルでは、0から1までのこれらの平均得点を、-4から4までの準ロジスティック・スケールに再スケーリングしますこれは、ロジスティック・マッピングを反映するための生データの非線形変換にすぎません。
古典的テスト理論では、項目の難易度を無視し、能力を期待得点として定義します： abilityi = theta(i) = x(i.)ゼロ・パラメータ・モデルでは、これらの平均得点を0から1まで、-4から4までの準ロジスティック尺度に再スケーリングしますこれは、ロジスティック・マッピングを反映するために、生データを非線形変換しているにすぎません。
古典的テスト理論では、項目の難易度を無視し、能力を期待得点として定義します： abilityi = theta(i) = x(i.)ゼロ・パラメータ・モデルでは、これらの平均得点を0から1まで、-4から4までの準ロジスティック尺度に再スケーリングします。
項目反応理論（別名 "新しい心理測定"）は、ロジスティック関数と個人（θ）および項目の難易度（diff）パラメータを用いて、項目に対する個人の反応をモデル化します。
irt.faは、項目反応分析のプロセスを簡単にするために、いくつかの関数を1つにまとめたものです。  相関は、テトラコリックまたはポリコリックのいずれかを使用して求められます。  すべての正規オプションを用いた探索的因子分析は、faを使用して行われます。  そして、その結果は、IRTパラメータ（困難度と識別度）の観点で報告されるように整理され、より従来の因子分析のアウトプットと同様になります。さらに、相関ステップはやや時間がかかるので、最初のステップで発見された相関行列を用いて再分析を行うことができる。  この場合、fm="minchi" 因子分解法を使用したい場合は、オブザベーションの数を pairwiseCount の結果の行列として指定する必要があります。
項目反応理論（別名 "新しい心理測定"）は、ロジスティック関数と個人（θ）と項目困難度（diff）パラメータを用いて、項目に対する個人の反応をモデルします。
古典的テスト理論では、項目の難易度を無視し、能力を期待得点として定義します： abilityi = theta(i) = x(i.)ゼロ・パラメータ・モデルは、0から1までのこれらの平均得点を、-4から4までの準ロジスティック・スケールに再スケーリングしますこれは、ロジスティック・マッピングを反映するための生データの非線形変換にすぎません。
この関数は、多肢選択能力テストにおける項目の選択肢の質を分析する便利な方法です。  典型的な使用法は、まずテストを採点し（例えば、score.multiple.choiceを使用して）、ある採点キーにしたがって、score.irtに基づく得点を求めることである。  そして、各選択肢の回答頻度を総得点に対してプロットします。  理想的な項目とは、1つの選択肢（正しい選択肢）の回答確率が単調増加するものです。
項目の位置（難易度）と識別のセットがあれば、よりエレガントな方法で被験者の得点を求めることができますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、合計得点よりも多くの情報を得ることができます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
irt.faは項目反応分析のプロセスを簡単にするために、いくつかの関数を1つにまとめたものです。  相関は、テトラコリックまたはポリコリックのいずれかを使用して求められます。  すべての正規オプションを用いた探索的因子分析は、faを使用して行われます。  そして、その結果は、IRTパラメータ（困難度と識別度）の観点で報告されるように整理され、より従来の因子分析のアウトプットと同様になります。さらに、相関ステップはやや時間がかかるので、最初のステップで発見された相関行列を用いて再分析を行うことができる。  この場合、fm="minchi" 因子分解法を使用したい場合は、オブザベーションの数を pairwiseCount の結果の行列として指定する必要があります。
項目の位置（難易度）と識別の集合を与えて被験者得点を求めるよりエレガントな方法もあるが，得点ベクトルXと位置δと識別βについて，P(x|θ) = 1/(1+exp(β(δ - θ) ) という式に最も適合するθの値を見つけるだけで，合計得点よりも多くの情報を提供する．  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
項目の位置（難易度）と識別のセットがあれば、よりエレガントな方法で被験者の得点を求めることができますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、合計得点よりも多くの情報が得られます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
lowerCor は対角行列の下側を丸めたものを出力し、列名は桁数 + 3 文字に省略されます。  デフォルトでは、変数の対削除を使用する。  次に
lowerCor は，対角行列の下側の行列を，列名を桁数 + 3 文字に省略した数字に丸めたものを出力しますが，丸めずに完全な行列も返します．  デフォルトでは、変数の対削除を使用する。  次に
このシミュレーションは、もともと影響の測定におけるゆがみの効果を比較するために開発されました（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
fa.lookupおよびlookupは、相関行列または因子負荷行列を要約するための単純なヘルパー関数です。 bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例bfi.dictionaryを参照）。
このシミュレーションは、もともと、影響の測定におけるゆがみの効果を比較するために開発された（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは，単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするように拡張された．  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
尺度に形成された一連の項目から基準を予測する場合、尺度の妥当性（つまり、各基準と尺度の相関）は、平均項目の妥当性（r_y）、尺度の項目の平均相互相関（r_x）、尺度の項目数（n）の関数である。  妥当性の限界はr_y/sqrt(r_x)である。  
回転していない解から呼び出すと最高の結果が得られる。  回転した解を使用して繰り返し呼び出すと、因子間の相関の推定が不正確になる。
fa.lookupとlookupは、相関行列または因子負荷行列を要約するための単純なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例 bfi.dictionary を参照）。
scoreItems, scoreOverlap, scoreIrt.1pl, scoreIrt.2pl のキーを用意する最も簡単な方法は、keys.list を指定することです。  これは単に得点となる尺度の名前と使用する項目の方向を指定するリストです。
能力やパーソナリティの他の側面を測定するために使用される項目は、一般的にあまり信頼できません。  1つの提案として、項目を均質な項目複合（HIC）、因子的に均質な項目次元（FHID）、またはミニ尺度（パーセル）に形成することがあります。  link{parcels}は、score.itemsで使用するのに適したキー行列を形成することで、パーセルの発見を容易にします。  これらのキーは n/2 個の最も類似したペア、または n/3 個の最も類似したトリプレットを表します。
S^2 = diag(R^{-1})^{-1}, Q = SR^{-1}S とする。  そしてQは反画像相互相関行列という。  RとQのすべての対角外要素をsumr2=∑{R^2}、sumq2=∑{Q^2}とすると、SMA=sumr2/(sumr2 + sumq2)となる。  元々MSAは1 - sumq2/sumr2 (Kaiser, 1970)であったが、Kaiser and Rice, (1974)でSMA=sumr2/(sumr2 + sumq2)に修正された。  これはDziuban and Shirkey (1974)やSPSSで使用されている式です。
行列またはdata.frame xが与えられた場合、各列のスキューまたは尖度（スキューと尖度の場合）、または多変量スキューと尖度（マルディアの場合）を求めます。
推奨される関数はstructure.diagramで、Rgraphvizを使用しませんが、ドットコードも生成しません。  
lowerCorは対角行列の下側を丸めたものを出力し、列名は桁数+3文字に省略されます。  デフォルトでは、変数の対削除を使用する。  次に
これら3つの関数は、項目応答理論のデモンストレーションのための単純なヘルパー関数として提供されています。1パラメータ・ロジスティック（1PL）モデルは、Raschモデルとしても知られています。  1PL、2PL、3PL、4PL曲線は、適切なd (デルタまたは項目難易度)、a (識別または傾き)、c (ガンマまたは推測)、およびz (ゼータまたは上方漸近線)を選択することによって描くことができる。
これらの3つの関数は、項目反応理論のデモンストレーションのための簡単なヘルパー関数として提供されています。1パラメータ・ロジスティック（1PL）モデルは，ラッシュ・モデルとしても知られている．  1PL、2PL、3PL、4PL曲線は、適切なd (デルタまたは項目難易度)、a (識別または傾き)、c (ガンマまたは推測)、およびz (ゼータまたは上限漸近線)を選択することによって描かれます。
これらの3つの関数は、項目反応理論のデモンストレーションのための簡単なヘルパー関数として提供されています。1パラメータ・ロジスティック（1PL）モデルは，ラッシュ・モデルとしても知られている．  1PL、2PL、3PL、4PL曲線は、適切なd (デルタまたは項目難易度)、a (識別または傾き)、c (ガンマまたは推測)、およびz (ゼータまたは上限漸近)を選択することによって描くことができます。
fa.lookupおよびlookupは、相関行列または因子負荷行列を要約するための単純なヘルパー関数です。 bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例bfi.dictionaryを参照）。
fa.lookupとlookupは、相関行列や因子負荷行列を要約するための単純なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例bfi.dictionaryを参照）。
fa.lookupとlookupは、相関行列や因子負荷行列を要約するための単純なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例 bfi.dictionary を参照）。
lowerCorは、列名を桁数+3文字に省略し、桁数を丸めた対角行列を出力しますが、丸めずに完全な行列も返します。  デフォルトでは、変数の対削除を使用します。  次に
lowerCor は，対角行列の下側の行列を，列名を桁数 + 3 文字に省略した数字に丸めたものを出力しますが，丸めずに完全な行列も返します．  デフォルトでは、変数の対削除を使用する。  次に
行列が1つだけ提供された場合（つまり upper がない場合）、その行列は2つの正方行列に分解され、1つは対角の下側のエントリと等しく、もう1つは対角の上側のエントリと等しくなる。通常の場合、2つの対称行列が提供され、1つの非対称行列に結合される。対角の下側の行列は下側の行列を表し、対角の上側の行列は上側の行列を表す。
lsat6データセットは、McDonald (1999)と同様にltmパッケージで分析されている。どちらのデータセットもBock and Lieberman (1970)によって説明されています。どちらのデータセットも、IRT手順をテストし、irt.fa関数を用いたテトラコリック相関と項目因子分析の使用を示す有用な例です。
lsat6データセットは、McDonald (1999)と同様にltmパッケージで分析されています。どちらのデータセットもBock and Lieberman (1970)によって説明されています。どちらのセットも、IRT手順をテストし、irt.fa関数を用いたテトラコリック相関と項目因子分析の使用を示す有用な例です。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenの d 統計量は、プールされたグループ内標準偏差で表現された平均の差に過ぎない。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
信頼性分析の例を構築するとき、共属データ構造をシミュレートするのが便利です。  これは最も単純な項目構造で、ただ1つの因子を持つだけです。主に信頼性理論の議論や因子得点の推定に用いられます。
多くの性格テストや認知テストは、階層的な因子構造を持っています。  実証目的では，母集団値または標本値のいずれかで，このような行列を作成できると便利である。
項目の位置（難易度）と識別のセットがあれば、被験者の得点を求めるよりエレガントな方法がありますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、総得点以上の情報が得られます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合には、irt推定値の方がはるかに多くの情報を提供する。
scoreItems, scoreOverlap, scoreIrt.1pl, scoreIrt.2pl のキーを用意する最も簡単な方法は、keys.list を指定することである。  これはスコアとなる尺度の名前と使用する項目の方向を指定する単なるリストです。
scoreItems、scoreOverlap、scoreIrt.1pl、scoreIrt.2plのキーを用意する最も簡単な方法は、keys.listを指定することです。  これは、得点となる尺度の名前と、使用する項目の方向を指定するだけのリストです。
  さまざまな尺度に渡る項目の分布の感覚を得るために、スケール・キーの集合によってグループ化されたそれらの相関（または確率の対数）を表示できます。入力として相関が与えられた場合（raw=FALSE）、基準（列）を持つ相関（行）を表示し、並べるために使用することもできます。
行列またはdata.frame xが与えられた場合、（skewとkurtosisの場合は）各列のskewまたはkurtosisを求め、mardiaの場合は多変量のskewとkurtosisを求める。
生データから重回帰や正準相関を計算する方が一般的であるが、相関や共分散の行列から計算することももちろん可能である。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられた場合，この関数は相関を見つける．
因子分析の出力は，各変数の最大の因子負荷のサイズによってソートされ，行列の項目がそれらの負荷によって編成される．  デフォルトは、第1因子への負荷量によって並べ替えられる。  代替では，任意のベクトルまたは行列に基づいて並べ替えることができる．
生データから重回帰や正準相関を計算することがより一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられた場合，この関数は相関を見つける．
生データから重回帰や正準相関を計算することがより一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられた場合，この関数は相関を見つける．
因子分析の出力は，各変数の最大の因子負荷のサイズによってソートされ，行列の項目がそれらの負荷によって編成される．  デフォルトは、第1因子への負荷量によって並べ替えられる。  代替では、任意のベクトルまたは行列に基づいて並べ替えることができます。
線形モデリングを行うとき，メディエータの間接効果をコントロールする予測変数の直接効果を推定することは，しばしば便利である．  媒介に関する徹底的な議論は，Preacher and Hayes (2004)を参照．  mediate関数は，ブートストラップされた媒介/媒介効果の信頼区間を持つ，いくつかの基本的な媒介および媒介モデルを実行します．
線形モデリングを行うとき，メディエータの間接効果をコントロールする予測変数の直接効果を推定することは，しばしば便利です．  媒介に関する徹底的な議論は，Preacher and Hayes (2004)を参照．  mediate関数は，ブートストラップされた媒介/媒介効果の信頼区間を持つ，いくつかの基本的な媒介および媒介モデルを実行する．
楕円の寸法は、x変数とy変数の間の相関から計算され、sqrt(1+r) および sqrt(1-r) としてスケーリングされます。そして，それらは size[1] および size[2] 標準偏差単位としてスケーリングされる．   95%および99%の信頼度でスケーリングするには、c(1.64,2.32) を使用します。
この関数は、Synthetic Apeture Personality Assessment (SAPA) (https://www.sapa-project.org/)のデータセットの一部として特に有用で、連続変数（年齢、SAT V、SAT Qなど）と、International Personality Item Pool (IPIP)から取られた多値パーソナリティ項目、およびSAPAの一部として開発された二値実験IQ項目が混在している（例えば、Revelle, Wilt and Rosenthal, 2010またはRevelle, Dworak and Condon, 2020.を参照）。  
この機能は、SAPA（Synthetic Apeture Personality Assessment）（https://www.sapa-project.org/）のデータセットの一部として、連続変数（年齢、SAT V、SAT Qなど）と、IPIP（International Personality Item Pool）から採取された多項式性格項目、およびSAPAの一部として開発された二項式実験IQ項目（Revelle, Wilt and Rosenthal, 2010またはRevelle, Dworak and Condon, 2020などを参照）が混在している場合に、特に有用である。  
古典的な信頼性理論は，被験者によって異なる真のスコアによるオブザベーションの集合の分散の量を推定する．  一般化可能性理論は、このモデルを他の分散源、特に時間を含むように拡張します。  このアプローチを用いた古典的な研究は、複数の項目で複数の時点にわたって測定された人々である。  そこで問題となるのは、様々な個人差がどの程度安定しているかということである。クラス内相関(ICC)は、各被験者について項目ごとに、また各被験者について時間ごとに求められます。アルファ信頼度は、各被験者について、時系列にわたって項目ごとに求められる。   
古典的な信頼性理論は、被験者によって異なる真のスコアに起因するオブザベーションの集合における分散の量を推定する。  一般化可能性理論は、このモデルを他の分散源、特に時間を含むように拡張します。  このアプローチを用いた古典的な研究は、複数の項目で複数の時点にわたって測定された人々である。  そこで問題となるのは、様々な個人差がどの程度安定しているかということである。クラス内相関(ICC)は、各被験者について項目ごとに、また各被験者について時間ごとに求められます。アルファ信頼度は、各被験者について、時系列にわたって項目ごとに求められる。   
古典的な信頼性理論は、被験者によって異なる真のスコアに起因するオブザベーションの集合における分散の量を推定する。  一般化可能性理論は、このモデルを他の分散源、特に時間を含むように拡張します。  このアプローチを用いた古典的な研究は、複数の項目で複数の時点にわたって測定された人々である。  そこで問題となるのは、様々な個人差がどの程度安定しているかということである。クラス内相関(ICC)は、各被験者について項目ごとに、また各被験者について時間ごとに求められます。アルファ信頼度は、各被験者について、時系列にわたって項目ごとに求められる。   
線形モデリングを行うとき、メディエータの間接効果をコントロールする予測変数の直接効果を推定することは、しばしば便利です。  媒介に関する徹底的な議論は，Preacher and Hayes (2004)を参照．  mediate関数は，ブートストラップされた媒介/媒介効果の信頼区間とともに，いくつかの基本的な媒介および媒介モデルを実行する．
被験者内の複数の尺度を調査する場合、すべての試行間の変動に加えて、試行ごとのオブザベーションの変動を考慮することが有用な場合があります。  連続した差の2乗平均（mssd）および連続した差の2乗平均平方根（rmssd）は、ちょうど次のようなものです
diagram関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
これにより、複数の分布を素早く要約することができます。  特に、信頼性関数から得られる複数に分割された半分の結果を調べるときに便利です。  
diagram関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
diagram 関数は、適合入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、または bassAckward.diagram を呼び出します。  特定のパラメータ値については、これらの関数を参照してください。
古典的な信頼性理論は、被験者によって異なる真のスコアによるオブザベーション集合の分散量を推定する。  一般化可能性理論は、このモデルを他の分散源、特に時間を含むように拡張します。  このアプローチを用いた古典的な研究は、複数の項目で複数の時点にわたって測定された人々である。  そこで問題となるのは、様々な個人差がどの程度安定しているかということである。クラス内相関(ICC)は、各被験者について項目ごとに、また各被験者について時間ごとに求められます。アルファ信頼度は、各被験者について、時系列にわたって項目ごとに求められる。   
lowerCor は、列名を桁数 + 3 文字に省略し、桁数に丸められた対角行列の下側の行列を出力しますが、丸められない完全な行列も返します。  デフォルトでは、変数の対削除を使用する。  次に
因子分析から最も解釈しやすい因子の数を決定することは、おそらく因子分析における最大の課題の1つです。  この問題には多くの解決策がありますが、どれも一様にベストではありません。  "因子数の問題を解くのは簡単だ、毎日朝食前にやっている"。  しかし、正しい解を知ることは難しい。(Horn and Engstrom, 1979) (Henry Kaiser in personal communication with J.L. Horn, as cited by Horn and Engstrom, 1979, MBR p 283).  
"多くの尺度は、その開発者と使用者によって、主に1つの潜在変数の測定であると仮定されています。尺度が測定の効果指標モデルに適合することも仮定される場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が共通に潜在変数を測定しているかどうかに関係します。
omega.graphはRgraphvizパッケージを必要としますが、omega.diagramは必要としません。codeomegaはGPArotationパッケージを必要とします。
omega.graphはRgraphvizパッケージを必要とするが、omega.diagramは必要としない。codeomegaはGPArotationパッケージを必要とする。
"多くの尺度は、開発者やユーザによって、主に1つの潜在変数の尺度であると仮定されています。また、尺度が測定の効果指標モデルに準拠していると仮定される場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が共通に潜在変数を測定しているかどうかに関連します。
「多くの尺度は、その開発者や使用者によって、主に1つの潜在変数を測定するものと仮定されています。尺度が測定の効果指標モデルに準拠していることも仮定されている場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が共通に潜在変数を測定しているかどうかに関連します。
「多くの尺度は、その開発者や使用者によって、主に1つの潜在変数を測定するものと仮定されています。尺度が測定の効果指標モデルに準拠していることも仮定されている場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が共通に潜在変数を測定しているかどうかに関連します。
「多くの尺度は、その開発者や使用者によって、主に1つの潜在変数を測定するものと仮定されています。尺度が測定の効果指標モデルに準拠していることも仮定されている場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が共通に潜在変数を測定しているかどうかに関するものです。
statsのマハラノビス関数とヘルプ・ページからの引用です。
従来の帰無仮説有意性検定(NHST)は、効果がないという帰無仮説が与えられたときのデータを観察する可能性です。  しかし、これは帰無仮説の確率については何も教えてくれません。  Peter Killeen (2005)は、より有用な尺度として再現確率（probability of replication）を紹介した。  再現確率とは、正確な再現研究が元の結果と同じ方向の結果を見つける確率である。
従来の帰無仮説有意性検定（NHST：Null Hypothesis Significance Test）は、効果がないという帰無仮説が与えられた場合に、そのデータが観察される可能性である。  しかし、これは帰無仮説の確率については何も教えてくれません。  Peter Killeen (2005)は、より有用な尺度として再現確率（probability of replication）を紹介した。  再現確率とは、正確な再現研究が元の結果と同じ方向の結果を見つける確率である。
従来の帰無仮説有意性検定（NHST：Null Hypothesis Significance Test）は、効果がないという帰無仮説が与えられた場合に、そのデータが観察される可能性である。  しかし、これは帰無仮説の確率については何も教えてくれません。  Peter Killeen (2005)は、より有用な尺度として再現確率（probability of replication）を紹介した。  再現確率とは、正確な再現研究が元の結果と同じ方向の結果を見つける確率である。
従来の帰無仮説有意性検定（NHST：Null Hypothesis Significance Test）は、効果がないという帰無仮説が与えられた場合に、そのデータが観察される可能性である。  しかし、これは帰無仮説の確率については何も教えてくれません。  Peter Killeen (2005)は、より有用な尺度として再現確率（probability of replication）を紹介した。  再現確率とは、正確な再現研究が元の結果と同じ方向の結果を見つける確率である。
2つの独立した相関の差のzを求めるには、まずFisher r-z変換を用いてzスコアに変換し、2つの相関の差のzを求めます。  デフォルトの仮定は、グループのサイズが同じであるということですが、n2 を指定することで、異なるサイズのグループでも検定できます。
恥ずかしげもなくpairsのヘルプページから引用した。  panel.cor、panel.cor.scale、panel.histはすべてpairsのヘルプページから引用しています。John Foxのcarパッケージの楕円関数も使っています。
SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個またはそれ以下のペアがある場合、これらは相関にNA値を生成し、その後の因子分析faや信頼性分析omegaやscoreOverlapを不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個またはそれ以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個またはそれ以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  オブザベーションが1個以下のペアがある場合、これらは相関にNAの値を生成し、その後の因子分析 fa や信頼性分析 omega や scoreOverlap を不可能にします。
能力またはパーソナリティの他の側面の測定に使用される項目は、一般的にあまり信頼できません。  1つの提案として、項目を均質な項目複合（HIC）、因子的に均質な項目次元（FHID）、またはミニ尺度（パーセル）に形成することがあります。  link{parcels}は、score.itemsで使用するのに適したキー行列を形成することで、パーセルの発見を容易にします。  これらのキーは、n/2の最も類似したペア、またはn/3の最も類似したトリプレットを表します。
1つは完全な偏相関行列を求める方法です（つまり、各変数から他のすべての変数を偏相関させます）。  これは単に生データまたは相関行列を指定することで行うことができる。  (生データの場合、相関は用途と方法によって求められる)。  この場合、データ行列を指定するだけでよい。
相関行列が（おそらくSAPA手法のために）不適切な場合に便利です。
多くの予測状況では，2値予測変数（accept/reject）が2値基準（success/failure）に対して検証される．  多項相関は，予測変数と規準が連続的で2変量正規変数であるかのように基礎となるピアソン相関を推定し，xとyの両方が2分正規分布であると仮定すると4項相関になるが，ファイ係数は，0と1の行列に適用されるピアソンである．
ファイ相関における異なる基本率の問題と、それらがポリコレ相関を使うことによって部分的に解決される方法のデモンストレーション。私のデモの中ではあまり面白いものではない。  https://personality-project.org/r/simulating-personality.html、https://personality-project.org/r/r.datageneration.html。
これはほとんど自明のことです。  例を見てください。
以前はmvtnormパッケージが必要でしたが、現在はmnormtに置き換えられています。
これらの関数は、行列の各セルに対して Yule2poly、Yule2phi または phi2poly を呼び出します。詳細はこれらの関数を参照してください。  例については phi.demo を参照してください。
以前は mvtnorm パッケージが必要でしたが, 現在は mnormt に置き換えられています。
 行列 X の特異値分解は UdV であり, フルランク行列の場合, d は固有値のベクトル, U と V は固有ベクトルの行列です.逆行列は U/d だけである。  したがって、フルランク未満の行列方程式（例えば、シュミッド・シュミッド・ライマン解）を解くには、一般化逆行列を求める必要があります。
プロットするために適切な値を渡す。  type="IIC"（デフォルト）は項目特性応答関数をプロットします。 type="IIC "は項目情報関数をプロットし、type="test "はテスト情報関数をプロットします。
プロットする適切な値を渡します。  type="IIC"（デフォルト）は，項目特性応答関数をプロットする．type="IIC "は項目情報関数をプロットし，type="test "はテスト情報関数をプロットする．
Cattell の "scree" 検定は，因子数の問題に対する最も単純な検定の1つである．  Horn (1965) の「並列」分析も同様に説得力のある手順です。  最も最適な因子数を決定するための他の手順には、VSS（Very Simple Structure）基準（VSS ）とVelicerのMAP手順（VSSに含まれる）を見つけることが含まれる。fa.parallelは，主成分と因子解（デフォルトではminres）の固有値をプロットし，元のデータ行列と同じサイズのランダム行列に対しても同じことを行います．  生データの場合、ランダム行列は、1)一変量正規データの行列、2)元データのランダムサンプル（行をまたいでランダム）です。
プロットするために適切な値を渡す。  type="IIC"（デフォルト）は項目特性応答関数をプロットし、type="IIC "は項目情報関数をプロットし、type="test "はテスト情報関数をプロットします。
reliability は，基本的に omegah, unidim, splitHalf のラッパーです．Revelle and Condon (2019) は、任意の尺度について少なくとも3つの信頼性統計量を報告することを推奨しています。
プロットするために適切な値を渡す。  irt.fa の結果をプロットするために、3つのオプションがあります: type = "IIC" （デフォルト）は、項目特性応答関数をプロットします。
因子分析/クラスター分析の多くの用途は、項目が1つの大きな負荷だけを持つ単純な構造を仮定していますが、パーソナリティや感情項目のようないくつかの領域は、より複雑な構造を持ち、いくつかの項目は2つの因子に高い負荷を持っています。  (これらの項目は複雑度2であると言われています。）  因子負荷量を極座標で表現することで、この構造をより容易に認識することができる。
テトラコリコリック相関は，2変量正規性の仮定で，度数の2 x 2 表から潜在的なピアソン相関を推論する．  推定手順は2段階のML．  各組の項目のセル度数が求められる．テトラコリックの場合、カウントがゼロのセルは、連続性の補正として0.5に置き換えられる（correct=TRUE）。
テトラコリック相関は，2変量正規性を仮定して，度数の2 x 2表から潜在的なピアソン相関を推論する．  推定手順は2段階のML．  各組の項目のセル度数が求められる．テトラコリックの場合、カウントがゼロのセルは、連続性の補正として0.5に置き換えられる（correct=TRUE）。
テトラコリック相関は，2変量正規性を仮定して，度数の2 x 2表から潜在的なピアソン相関を推論する．  推定手順は2段階のML．  各組の項目のセル度数が求められる．テトラコリックの場合、カウントがゼロのセルは、連続性の補正として0.5に置き換えられる（correct=TRUE）。
テトラコリック相関は，2変量正規性を仮定して，度数の2 x 2表から潜在的なピアソン相関を推論する．  推定手順は2段階のML．  各組の項目のセル度数が求められる．テトラコリックスの場合，カウントがゼロのセルは，連続性の補正として0.5に置き換えられる（correct=TRUE）．
NA
尺度に形成された項目の集合から基準を予測する場合，尺度の有効性（すなわち，各基準との尺度の相関）は，平均項目の有効性（r_y），尺度の項目の平均相互相関（r_x），尺度の項目数（n）の関数である．  妥当性の限界はr_y/sqrt(r_x)である。  
相関行列が（おそらくSAPA手法のために）不適切な場合に有用である．
print.psychとsummary.psychは、ハイライトだけを表示する汎用的なメソッドを使用する。  他に何が利用できるかを確認するには、特定のオブジェクトの構造を求めてください：(str(theobject) )。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装したbiquartiminであろう。もう1つはTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようです。
lowerCor は，列名を桁数 + 3 文字に省略し，桁数に丸められた対角行列の下側の行列を出力します．  デフォルトでは，変数のペアワイズ削除が使用される．  この関数は
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装したbiquartiminの2つであろう。もう1つはTargetQで、これはターゲットにNA値が欠けていることを許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようだ。
3つのビネット(overview.pdfとpsych_for_sem.pdf)は、パッケージの有用な紹介です。これらはRのビネットとして見つけることができ、また https://personality-project.org/r/psych/intro.pdf https://personality-project.org/r/psych/overview.pdf と https://personality-project.org/r/psych/psych_for_sem.pdf からダウンロードすることもできる。  さらに、https://personality-project.org/r/ に多くの「HowTo」があります。
lowerCor は、対角行列の下側を丸め、列名を桁数 + 3 文字に省略したものを出力します。  デフォルトでは、変数の対削除を使用する。  その結果
NA
NA
入力に応じて、4つの異なる相関の検定のうちの1つが行われる。
NA
NA
2つのグループがどのように異なるかを報告する方法はたくさんある。  コーエンのd統計量は、プールされた群内標準偏差で表現された平均値の差だけである。  r は効果量の普遍的な尺度で、dの単純な関数であるが、-1 から 1の境界である。   
NA
多変量プロフィールの表示は、一連の線（例えば、matplotを参照）、色（例えば、corPlotを参照）、またはレーダープロットやスパイダープロットで行うことができます。スパイダーは、円周構造を持つと考えられるデータを表示するのに特に適している。
調査の参加者が1つの変数で選ばれると、その変数の分散と結果の相関が減少します。  Thorndike (1949) は、範囲制限の4つのケースを検討しました。  他の人たちは、この議論を続けていますが、ケース番号を変えています。  
lowerCor は、列名を桁数+3文字に省略し、桁数に丸められた対角行列の下側の行列を出力しますが、丸められてない完全な行列も返します。  デフォルトでは、変数の対削除を使用する。  次に
Holzinger and Swineford (1937) は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、omega関数またはsemを用いて分析できる階層的因子構造のすばらしい実証データ・セットです。二因子モデルは、一般的に認知能力の測定に使用されます。
信頼性は、基本的にomega、unidim、splitHalfのラッパーに過ぎない。Revelle and Condon (2019)は、どの尺度についても少なくとも3つの信頼性統計量を報告することを推奨しているが、ここでは簡単にできるようにする。
NA
現在、fa、principal、omega、irt.fa、fa.extensionに対して実装されている。
現在、fa、principal、omega、irt.fa、fa.extensionに実装されています。
より大きな項目の集合から尺度の集合の合計点または平均点を求めるプロセスは、応用心理測定学および心理測定研究における典型的な問題である。  項目の相互相関から尺度の構造を決定することはできますが、尺度の平均値や分散を求め、さらに分析を行うには、合計点または平均点に基づいて得点を求めるのが一般的です。  奇妙なことに、パーソナリティ尺度のスコアは通常合計で与えられますが、態度のスコアは平均で与えられます。  scoreItems のデフォルトは平均値です。項目の尺度でスケールスコアを報告する方が理にかなっているように思われるからです。  
より大きな項目の集合から尺度の集合の合計または平均点を求めるプロセスは、応用心理測定学および心理測定研究における典型的な問題です。  尺度の構造は項目の相互相関から求めることができますが、尺度の平均値や分散を求め、さらに分析を行うためには、項目の合計点または平均点に基づいて得点を求めるのが一般的です。  奇妙なことに、パーソナリティ尺度のスコアは通常合計で与えられますが、態度のスコアは平均で与えられます。  scoreItems のデフォルトは平均値です。項目の尺度でスケールスコアを報告する方が理にかなっているように思われるからです。  
あまり複雑な関数ではありませんが、ltmやeRMパッケージのIRT関数を使用する前に項目を反転させる必要がある場合に便利です。ほとんどの心理関数は、分析の前に反転する必要はなく、関数内で反転します。
被験者内の複数の尺度を調査するとき、すべての試行間の変動に加えて、試行ごとのオブザベーションの変動を考慮することが有用な場合があります。  連続差の2乗平均(mssd)と連続差の2乗平均平方根(rmssd)は、ちょうど次のようなものです。
これらの項目は、オンライン能力測定法を開発するSAPAプロジェクト（https://www.sapa-project.org/）の一環として収集された（Revelle, Wilt and Rosenthal, 2009）。  得点の平均値は、全国的な標準値よりも高く、オンライン性格・能力テストを受ける人の自己選択と、得点の自己報告バイアスの両方を示唆している。
モデルがデータにどの程度適合するかは、統計学の古典的な問題である。  スケーリングの適合統計量の1つは、元の推定値と比較した残差行列の大きさである。
pairs.panelからいくつかのトリックを取り入れた、レイアウトとbarplotの単純なアプリケーションです。  様々なオプションにより、相関楕円（平均から1シグマと2シグマ）、lowessスムース、線形フィット、ヒストグラム上の密度曲線、相関の値を指定することができます。 ellipse = TRUEはsmooth = TRUEを意味します。  grid オプションは散布図に背景グリッドを提供します。
pairs.panelからいくつかのトリックを取り入れた、layoutとbarplotの単純な応用です。  ellipse=TRUEはsmooth=TRUEを意味します。  grid オプションは散布図に背景グリッドを提供します。
Schmid Leiman直交化は、能力領域では典型的ですが、非認知パーソナリティ領域ではあまり見られません。  S-Lは，オメガを推定するための一般因子への項目の負荷量を見つける1つの方法である．
 Schmid and Leiman (1957)の2つの人工相関行列。Chen et al. (2006)からの1つの実共分散行列と1つの人工共分散行列。
 Schmid and Leiman (1957)からの2つの人工相関行列。Chen et al. (2006)の実共分散行列と人工共分散行列。
この関数は，（複数の尺度については）scoreItems に，単一の尺度については alpha に置き換えられている．
項目の位置（難易度）と識別のセットが与えられた被験者スコアを求めるよりエレガントな方法がありますが、スコアベクトルX、位置δと識別βに対して、P(x|θ)=1/(1+exp(β(δ - θ) ) の式に最もフィットするθの値を見つけるだけで、総スコアよりも多くの情報を提供します。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
項目の位置（難易度）と識別のセットがあれば、よりエレガントな方法で被験者の得点を求めることができますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、合計得点よりも多くの情報が得られます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
項目の位置（難易度）と識別のセットがあれば、よりエレガントな方法で被験者の得点を求めることができますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、合計得点よりも多くの情報が得られます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合には、irt推定値の方がはるかに多くの情報を提供する。
より大きな項目集合がある場合、尺度集合の総得点または平均得点を求めるプロセスは、応用心理測定学および心理測定研究における典型的な問題である。  項目の相互相関から尺度の構造を決定することはできますが、尺度の平均値や分散を求め、さらに分析を行うためには、項目の合計スコアまたは平均スコアに基づいてスコアを求めるのが一般的です。  奇妙なことに、パーソナリティ尺度のスコアは通常合計で与えられますが、態度のスコアは平均で与えられます。  scoreItems のデフォルトは平均値です。項目の尺度でスケールスコアを報告する方が理にかなっているように思われるからです。  
基本的にはscore.itemsと多肢選択式から正誤判定への変換を組み合わせたものです。
これらはSAPA (https://www.sapa-project.org/)手続きで合成相関行列を形成するために使用される関数の3つです。  項目の相関行列があれば、それらの項目からなる尺度の相関行列を求めるのは簡単です。これは元のデータ行列から行うこともできますし、 scoreItems を使って相関行列から行うこともできます。  SAPAデータでは、尺度相関は生データではなく項目相関から求めるべきであることを覚えておくことが重要です。
より大きな項目の集合から尺度の集合の合計スコアまたは平均スコアを求めるプロセスは、応用心理測定学および心理測定研究における典型的な問題です。  項目の相互相関から尺度の構造を決定することはできますが、尺度の平均値や分散を求め、さらに分析を行うためには、項目の合計スコアや平均スコアに基づいてスコアを求めるのが一般的です。  奇妙なことに、パーソナリティ尺度のスコアは通常合計値で与えられますが、態度のスコアは平均値で与えられます。  scoreItems のデフォルトは平均値です。項目の尺度でスケールスコアを報告する方が理にかなっているように思われるからです。  
項目の位置（難易度）と識別のセットがあれば、よりエレガントな方法で被験者のスコアを求めることができますが、スコアベクトルX、位置δ、識別βに対して、P(x|θ) = 1/(1+exp(β(δ - θ) ) の式に最もフィットするθの値を見つけるだけで、合計スコアよりも多くの情報を得ることができます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
項目の位置（難易度）と識別のセットがあれば、よりエレガントな方法で被験者の得点を求めることができますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、合計得点よりも多くの情報が得られます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合、irt推定値はより多くの情報を提供する。
項目の位置（難易度）と識別のセットがあれば、被験者の得点を求めるよりエレガントな方法がありますが、得点ベクトルX、位置δ、識別βに対して、P(x|θ)=1/(1+exp(β(δ-θ) ) の式に最も適合するθの値を見つけるだけで、合計得点よりも多くの情報が得られます。  完全なデータでは、総得点とirt推定値はほぼ完全に相関する。  しかし、欠損データがある場合には、irt推定値の方がはるかに多くの情報を提供する。
より大きな項目集合がある場合、尺度集合の総得点または平均得点を求めるプロセスは、応用心理測定学および心理測定研究における典型的な問題である。  項目の相互相関から尺度の構造を決定することはできますが、尺度の平均値や分散を求め、さらに分析を行うためには、項目の合計スコアまたは平均スコアに基づいてスコアを求めるのが一般的です。  奇妙なことに、パーソナリティ尺度のスコアは通常合計で与えられますが、態度のスコアは平均で与えられます。  scoreItems のデフォルトは平均値です。項目の尺度でスケールスコアを報告する方が理にかなっているように思われるからです。  
これらはSAPA (https://www.sapa-project.org/)手続きで合成相関行列を形成するために使用される関数の3つである。  項目の相関行列があれば、それらの項目からなる尺度の相関行列を求めるのは簡単です。これは、元のデータ行列から行うこともできますし、 scoreItems を使って相関行列から行うこともできます。  SAPAデータでは、尺度相関は生データではなく項目相関から求めるべきであることを覚えておくことが重要です。
より大きな項目の集合から尺度の集合の合計スコアまたは平均スコアを求めるプロセスは、応用心理測定学および心理測定研究における典型的な問題です。  項目の相互相関から尺度の構造を決定することはできますが、尺度の平均値や分散を求め、さらに分析を行うためには、項目の合計スコアや平均スコアに基づいてスコアを求めるのが一般的です。  奇妙なことに、パーソナリティ尺度のスコアは通常合計で与えられますが、態度のスコアは平均で与えられます。  scoreItems のデフォルトは平均値です。項目の尺度でスケールスコアを報告する方が理にかなっているように思われるからです。  
bestScalesのウェイトを使用して相関重み付けされたスコアを求めるためのものですが、lmの係数によって返されるような別のウェイト行列を使用することも可能です。   
最適な因子数を選択する多くの方法の中に、scree検定があります。  screeを表示し、ランダムに並列化された解と比較するためのより良い関数が fa.parallel にある。
直接行うこともできるが、時に厄介な問題を解決する。  指定された値をNAに置き換えるか、範囲内の値に再コード化する。
ベクトル、行列、data.frameの標準偏差を求めます。  該当がない場合は NA を返します。
scoreItems, scoreOverlap, scoreIrt.1pl, scoreIrt.2pl のキーを用意する最も簡単な方法は、keys.list を指定することです。  これは単に得点となる尺度の名前と使用する項目の方向を指定するリストです。
推奨される関数はstructure.diagramで、これはRgraphvizを使用しませんが、ドットコードも生成しません。  
推奨される関数は、Rgraphvizを使用しないがドットコードも生成しないstructure.diagramである。  
生データから重回帰や正準相関を計算する方が一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられると，この関数は相関を見つける．
生データから重回帰や正準相関を計算することがより一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられると，この関数は相関を見つける．
生データから重回帰や正準相関を計算することがより一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．生データが与えられた場合、この関数は相関を求めます。
fa.lookupとlookupは、相関行列または因子負荷行列を要約するための単純なヘルパー関数です。 bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例 bfi.dictionary を参照）。
lowerCorは、列名を桁数+3文字に省略し、桁数を丸めた対角行列を出力しますが、丸めずに完全な行列も返します。  デフォルトでは、変数の対削除を使用します。  その結果
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、添付のビネットを参照してください。  
ANOVA，回帰，信頼性について教えるための簡単なシミュレーション．  ANOVAとLMの関係のさまざまなデモンストレーションを示すことができます。
多くの性格テストや認知テストは，階層的な因子構造を持つ．  デモンストレーションの目的には，母集団値または標本値のいずれかで，そのような行列を作成できることが有用である．
このシミュレーションは、もともとは影響の測定におけるゆがみの効果を比較するために開発されたものである（Rafaeli and Revelle, 2005参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
信頼性分析のために例を構築する場合、共属データ構造をシミュレートするのが便利です。  これは最も単純な項目構造で、ただ1つの因子を持つだけです。主に信頼性理論の議論や因子得点の推定に用いられます。
測定モデル fx と構造モデル Phi を考えると，モデルは f %*% Phi %*% t(f).   信頼性はf %*% t(f)であり、f φ f'、各テストの信頼性は項目の共同性、またはモデルのダイアグだけである。
このシミュレーションは、もともと影響の測定におけるスキューの効果を比較するために開発された（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用に関するもっと長い議論については、添付のビネットを参照してください。  
多くの性格テストや認知テストは、階層的な因子構造を持っている。  実証のためには、母集団値または標本値でそのような行列を作成できると便利です。
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用に関するもっと長い議論については、添付のビネットを参照してください。  
このシミュレーションは、もともとは影響の測定におけるスキューの効果を比較するために開発されたものである（Rafaeli and Revelle, 2005参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用に関するもっと長い議論については、添付のビネットを参照してください。  
グループ内相関とグループ間相関の独立性という基本的な概念については、Pedhazur (1997)やBliese (2009)が非常に明確に論じています。sim.multiは、伝統的なマルチレベルデータの2レベル構造をモデル化するために、被験者内データを生成します。
グループ内相関とグループ間相関の独立性に関する基本的な概念は、Pedhazur (1997)やBliese (2009)によって非常に明確に議論されています。sim.multiは、マルチレベルデータの伝統的な2レベル構造をモデル化するために、被験者内データを生成します。
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることで、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用に関するもっと長い議論については、添付のビネットを参照してください。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用については、付属のヴィネットを参照。  
データ構造のシミュレーションは、心理測定研究や教育において非常に有用なツールである。  真理」を知ることによって、様々なアルゴリズムがどの程度真理を捉えることができるかを見ることができる。  心理測定におけるシミュレーションの使用に関するもっと長い議論については、付属のヴィネットを参照。  
このシミュレーションは、もともとは影響の測定におけるスキューの効果を比較するために開発されたものである（Rafaeli and Revelle, 2005参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が(例えば1)であっても、これらの範囲に制限することで項目を歪めることができる。  
測定モデル fx と構造モデル Phi を考えると，モデルは f %*% Phi %*% t(f).   信頼性は f %*% t(f). f φ f' で、各テストの信頼性は、項目の共同性、またはモデルのダイアグだけです。
測定モデル fx と構造モデル Phi を考えると，モデルは f %*% Phi %*% t(f).   信頼性は f %*% t(f). f φ f' で、各テストの信頼性は項目の共同性またはモデルのダイアグだけである。
NA
測定モデル fx と構造モデル Phi が与えられると、モデルは f %*% Phi %*% t(f).   信頼性は f %*% t(f). f φ f' で、各テストの信頼性は、項目の共同性またはモデルのダイアグだけ。
"心理データを表現する一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造である(Revelle & Rocklin, 1979)。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サークンプレックス（Guttman, 1954）は、単純構造が欠けているモデルの一種である。
行列またはdata.frame xが与えられた時、各列のskewまたはkurtosis（skewとkurtosisの場合）、またはmardiaの場合の多変量skewとkurtosisを求めよ。
NA
多変量プロファイルの表示は、一連の線（例えば、matplotを参照）、色（例えば、corPlotを参照）、またはレーダープロットやスパイダープロットで行うことができる。スパイダーは、特に円周構造を持つと考えられるデータを表示するのに適している。
驚くことに、スピアマン(1904)が信頼性の概念を心理学者に紹介してから1世紀以上経った今でも、信頼性を測定するための複数のアプローチが存在する。クロンバックのα(1951)は、非常にポピュラーですが、テストの信頼性を過小評価し、第1因子の飽和を過大評価します。16項目以下のテストにsplitHalfを使用すると、すべての可能な分割をかなり簡単に見つけることができます。  17項目以上のテストでは、n.sample分割がランダムに発見されます。したがって、16 個以下の項目の場合、上限値と下限値は正確です。  17項目以上の場合、それらは近いですが、おそらく最高信頼度をわずかに過小評価し、最低信頼度を過大評価するでしょう。  
マルチレベル・データは、心理学研究では一般的である。マルチレベル・データでは、上位のグループ化変数に入れ子になっている被験者についてオブザベーションが行われます。  データは実験的（参加者は実験条件に入れ子になっている）かもしれないし、観察的（学生は教室に、学生は大学の専攻に入れ子になっている）かもしれない。この種のデータを分析するには、ランダム効果モデルや混合効果モデル、より一般的にはマルチレベル・モデルを使用します。  少なくとも2つの非常に強力なパッケージ（nlmeとmultilevel）があり、階層（マルチレベル）データ構造の複雑な分析を可能にします。  これは真のマルチレベル・モデリングを補足するものです。
マルチレベル・データは、心理学研究では一般的です。マルチレベル・データでは、オブザベーションは、より高いレベルのグループ化変数に入れ子になっている被験者について行われます。  データは実験的（参加者が実験条件に入れ子になっている）かもしれないし、観察的（学生が教室に、学生が大学の専攻に入れ子になっている）かもしれない。この種のデータを分析するには、ランダム効果モデルや混合効果モデル、より一般的にはマルチレベル・モデルを使用します。  少なくとも2つの非常に強力なパッケージ（nlmeとmultilevel）があり、階層（マルチレベル）データ構造の複雑な分析を可能にします。  これは真のマルチレベル・モデリングを補足するものです。
マルチレベル・データは、心理学研究では一般的です。マルチレベル・データでは、オブザベーションは、より高いレベルのグループ化変数に入れ子になっている被験者について行われます。  データは実験的（参加者が実験条件に入れ子になっている）かもしれないし、観察的（学生が教室に、学生が大学の専攻に入れ子になっている）かもしれない。この種のデータを分析するには、ランダム効果モデルや混合効果モデル、より一般的にはマルチレベル・モデルを使用します。  少なくとも2つの非常に強力なパッケージ（nlmeとmultilevel）があり、階層（マルチレベル）データ構造の複雑な分析を可能にします。  これは、真のマルチレベル・モデリングを補足するためのものです。
お勧めの関数はstructure.diagramで、Rgraphvizを使用しませんが、ドットコードも生成しません。  
推奨される関数はstructure.diagramで、Rgraphvizは使用しませんが、ドットコードも生成しません。  
これは、ほとんど自明である。  例を見てください。
推奨される関数は、Rgraphvizを使用しないが、ドットコードも生成しないstructure.diagramである。  
print.psychとsummary.psychは、ハイライトだけを表示する汎用的なメソッドです。  他に何が利用できるかは、特定のオブジェクトの構造を求めてください：(str(theobject) )。
いくつかの関数、例えばsim.structural,structure.graph,make.keysは、部分行列の集合から形成されると考えることができる行列を使用します。  特に、アイテムの集合に得点をつけたり（scoreItemsやscoreOverlap）、指定したクラスタを形成したり（cluster.cor）するためにmake.keysを使用する場合、異なるアイテムの集合に対して異なる得点キーの集合を定義し、これらの得点キーを1つのスーパーキーに結合するのが便利である。
sim.structural,structure.graph,make.keysなどのいくつかの関数は、部分行列の集合から形成されると考えることができる行列を使用します。  特に、アイテムの集合をスコアリングしたり（scoreItemsやscoreOverlap）、指定したクラスタを形成する（cluster.cor）ためにmake.keysを使用する場合、異なるアイテムの集合に対して異なるスコアリングキーのセットを定義し、これらのスコアリングキーを1つのスーパーキーに結合することが便利です。
sim.structural,structure.graph,make.keysなどのいくつかの関数は、部分行列の集合から形成されると考えることができる行列を使用します。  特に、make.keysを使用してアイテムのセットを採点したり（scoreItemsやscoreOverlap）、指定したクラスタを形成したり（cluster.cor）する場合、アイテムのセットごとに異なる採点キーのセットを定義し、これらの採点キーを1つのスーパーキーにまとめると便利です。
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenのd統計量は、単に平均値の差をプールされたグループ内標準偏差で表現したものである。  rは、効果量の普遍的な尺度で、dの単純な関数であるが、-1から1に境界がある。t統計量は、単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   
NA
キュビット（腕の長さ）による身長の元のGalton (1888)は表形式である。これを相関として、または散布図として示すには、表を2列の行列またはデータ・フレームに変換するのが便利である。  
身長とキュビット（腕の長さ）の元のGalton (1888)は表形式である。これを相関や散布図として示すには、表を2列の行列やデータ・フレームに変換するのが便利である。  
lowerCorは、対角行列の下側を丸めたものを出力し、列名は数字+3文字に省略される。  デフォルトでは、変数の対削除を使用する。  その結果
Tal-Or et al. (2010)は、2つの実験的研究でメディアの推定効果を調査しました。  これらのデータは、研究2からのものである。...予想される砂糖の不足に関するニュースの影響に関する知覚は、ニュース記事への曝露の知覚を操作することによって間接的に操作され、その結果、記事から生じる行動意図が測定された。(p 801).
Tal-Orら（2010）は、2つの実験的研究でメディアの推定効果を検証した。  これらのデータは研究2のものである。砂糖の不足が予想されるというニュース記事の影響に関する認識を、ニュース記事への曝露の認知を操作することによって間接的に操作し、その結果、ニュース記事から生じる行動意図を測定した。(p 801).
これらの関数の中で最も有用な2つは、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装するbiquartiminであろう。もう1つはTargetQで、これはターゲットのNA値の欠損を許容する。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
これらの関数の中で最も有用なのは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装するbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
これらの関数の中で最も有用なのは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装するbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようだ。
驚いたことに、スピアマン（1904）が信頼性の概念を心理学者に紹介してから1世紀以上経った今でも、信頼性を測定するための複数のアプローチが存在する。クロンバックのα（1951）は、非常にポピュラーですが、テストの信頼性を過小評価し、第1因子の飽和を過大評価します。16項目以下のテストにsplitHalfを使用すると、すべての可能な分割をかなり簡単に見つけることができます。  17項目以上のテストでは、n.sample分割がランダムに発見されます。したがって、16 個以下の項目の場合、上限値と下限値は正確です。  17項目以上の場合、それらは近いですが、おそらく最も高い信頼性をわずかに過小評価し、最も低い信頼性を過大評価するでしょう。  
lowerCor は、列名を桁数+3文字に省略し、桁数に丸められた対角行列の下側の行列を出力しますが、丸められない完全な行列も返します。  デフォルトでは、変数の対削除を使用する。  次に
n.obs nvar 変数のオブザベーション（0/1）が、ロジスティックまたは正規理論モデルを用いてシミュレートされます。  そして、多くの異なるスコアリング・アルゴリズムが適用され、グラフィカルに表示されます。  ltmスコアを比較するために、ldmパッケージがインストールされている必要があります。
psych パッケージを修正する場合、あるコードを追加しても他のコードが壊れないことを確認するのが便利です。  test.psych関数は、様々な標準的なデータセットで主要な関数をテストします。  また、psych パッケージの多くの機能を披露しています。
信頼性を測定する方法はたくさんある。テスト-再テストは1つの方法である。  時間間隔が非常に短い（または即時）場合、これは信頼性相関として知られ、時間間隔が長い場合は安定性係数となる。  いずれの場合も、これは異なる時点における2つの測定値間の相関である。  これらのデータの多段階性を考えると、個人、時間、項目、項目ごとの時間などに関連する分散成分を見つけることが可能である。  これは信頼性のいくつかの異なる推定につながります（議論と参考文献はmultilevel.reliabilityを参照）。
四分位相関は，2×2の度数表から，2変量正規性の仮定で潜在ピアソン相関を推定する．  推定手順は，2段階のMLである．  各組の項目のセル度数が求められる．テトラコリックの場合、カウントがゼロのセルは、連続性の補正として0.5に置き換えられる（correct=TRUE）。
ルイス・L・サーストンは、心理測定理論と態度、興味、能力の測定のパイオニアである。  彼の多くの貢献の中に、比較判断のプロセスの体系的分析がある（thurstone, 1927）。  彼は、被験者に一対の物体を連続して比較させる場合を考えた。サーストンは、2つの物体の値の比較は、物体間の差の標準偏差と比較した各物体の平均値の差を表すものとして表現できると提案した。  基本的なモデルは、各項目は回答強度の正規分布を持ち、選択肢は2つの回答強度のうち強い方を表すというものである。  正規性の仮定を正当化する根拠は、各決定は多くの独立した入力の合計を表し、したがって中心極限定理によって正規分布することである。
Holzinger and Swineford (1937) は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入した。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造の素晴らしい実証データセットである。二因子モデルは、認知能力の測定で典型的に使用される。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造の素晴らしい実証データセットである。二因子モデルは、認知能力の測定で典型的に使用される。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、オメガ関数またはsemを用いて分析できる階層的因子構造の素晴らしい実証データセットである。二因子モデルは、通常、認知能力の測定に使用される。
NA
tr関数は、様々な行列演算で使用され、行列の対角要素の和である。
Tucker (1958)の相関行列は、Tucker and Lewis (1973)でファクタリング信頼性のTucker-Lewis指数に使用された。
これはまだ開発中の探索的指標のセットである。  多くのテストケースから、uはデータが実際に一次元であるときに高い値を提供し、そうでないときに低い値を提供することが示唆されている。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装したbiquartiminの2つであろう。もう1つはTargetQで、これはターゲットのNA値の欠落を許容する。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
これらの関数の中で最も有用なのは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装するbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
これらの関数の中で最も有用なのは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装するbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
これらの関数の中で最も有用なのは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装するbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれも（まだ）GPArotationには実装されていないようです。
バイオリンプロットを使ってデータを記述します。alphaを変更して陰影を変更する。  grp変数を使用すると、複数のグループごとに別々のバイオリンプロットを描くことができます。
バイオリンプロットを使ってデータを記述する。アルファ値を変更して陰影を変更する。  grp変数を使用して、複数のグループごとに別々のバイオリンプロットを描くことができる。
因子分析から最も解釈しやすい因子の数を決定することは、おそらく因子分析における最大の課題の1つです。  この問題には多くの解決策があるが，どれも一様にベストではない．  "因子数の問題を解くのは簡単だ、毎日朝食前にやっている"。  しかし、正しい解を知ることは難しい。(Horn and Engstrom, 1979) (Henry Kaiser in personal communication with J.L. Horn, as cited by Horn and Engstrom, 1979, MBR p 283).  
因子分析から最も解釈可能な因子の数を決定することは，おそらく因子分析における最大の課題の1つである．  この問題には多くの解決策があるが，どれも一様に最良ではない．  "因子数の問題を解くのは簡単だ、毎日朝食前にやっている"。  しかし、正しい解を知ることは難しい。(Horn and Engstrom, 1979) (Henry Kaiser in personal communication with J.L. Horn, as cited by Horn and Engstrom, 1979, MBR p 283).  
NA
項目要因モデルは、その「複雑さ」で異なる。  複雑度 1 は，項目に対する最大の（絶対的な）負荷以外は無視されることを意味する．基本的にクラスター・モデル（例：ICLUST）。複雑度 2 は、最大の2つなどを除くすべてを意味する。  
最適な因子数を選択する多くの方法の中に，scree検定がある．  scree を表示するだけでなく，ランダムに並列化された解と比較するためのより良い関数が fa.parallel にある．
NA
NA
 Schmid and Leiman (1957)の2つの人工相関行列。Chen et al. (2006)の実共分散行列と人工共分散行列。
中心傾向の多くのロバスト推定値の中で、Winsorized 平均を推奨するものもある。  最上位と最下位のトリム・パーセントを削除するのではなく、これらの極値をトリム分位点と1-トリム分位点の値で置き換える。
中心傾向の多くのロバスト推定値の中で、ウィンソライズ平均を推奨するものがある。  単に上下のトリム・パーセントを削除するのではなく、これらの極端な値をトリム分位点および1-トリム分位点の値に置き換える。
中心傾向の多くのロバスト推定値の中で、ウィンソライズ平均を推奨するものがある。  単に上下のトリム・パーセントを削除するのではなく、これらの極端な値をトリム分位点および1-トリム分位点の値に置き換える。
中心傾向の多くのロバスト推定値の中で、ウィンソライズ平均を推奨するものがある。  単に上下のトリム・パーセントを削除するのではなく、これらの極端な値をトリム分位点および1-トリム分位点の値に置き換える。
中心傾向の多くのロバスト推定値の中で、ウィンソライズ平均を推奨するものがある。  上位と下位のトリム・パーセントを削除するのではなく、これらの極端な値をトリム分位点と1-トリム分位点の値に置き換える。
異なる自然グループ（例えば、民族、年齢、性別、大学の専攻、国など）に属する個人間の相関は、これらのグループの平均の相関と同様に、各グループ内のプールされた相関の未知の混合を反映する。これら2つの相関は独立しており、一方のレベル（グループ）から他方のレベル（個人）への推論はできません。  このデータ・セットはこの独立性を示している。  9変数間のグループ内相関は、1, 0, -1に設定され、グループ間相関も1, 0, -1に設定されます。 V1, V4, V7は、グループ内相関が1であり、V2, V5, V8、V3, V6, V9もそうであるように、相関のこれらの2つのセットは交差しています。  V1はV2、V5、V8とのグループ内相関が0、V3、V6、V9とのグループ内相関が-1。  V1、V2、V3は、V4、V5、V6、V7、V8、V9と同様に群間相関が1である。  第1グループは第2グループとのグループ間相関が0であり、第3グループとの相関は-1である。  
カテゴリー判断が2つのカテオリーで行われる場合、関係を表す尺度はファイ係数である。  しかし、カテゴリー判断の中には2つ以上の結果を用いて行われるものもある。  例えば、2人の診断士が患者を3通りに分類するよう求められたり（例えば、人格障害、神経症、精神病）、病気の病期を分類するよう求められたりする。  2×2の表で観察されるセルの度数に基率が影響するように、n-way表でも考慮する必要がある(Cohen, 1960)。
Yuleは、2×2表について2つの関連性の尺度を開発した。  どちらもオッズ比の関数である
Yule は，2×2表について2つの関連尺度を開発した．  両方ともオッズ比の関数である
Yule は2×2表について2つの関連尺度を開発した．  どちらもオッズ比の関数である
これらの関数は，行列の各セルに対して Yule2poly，Yule2phi，または phi2poly を呼び出します．詳細はこれらの関数を参照してください。  例については phi.demo を参照。
Yuleは2×2の表に対して2つの関連尺度を開発しました。  どちらもオッズ比の関数です
これらの関数は，行列の各セルに対して Yule2poly，Yule2phi，または phi2poly を呼び出します。詳細はこれらの関数を参照してください。  例については phi.demo を参照。
Yuleは2×2の表に対して2つの関連尺度を開発しました。  どちらもオッズ比の関数です
Yule は2×2の表について2つの関連尺度を開発した。  どちらもオッズ比の関数
Yuleは2×2の表について2つの関連尺度を開発した。  両方ともオッズ比の関数である
type = "correlation" および "covariance" の場合，推定は標本の共分散に基づく．(ラグ0の自己相関は，慣例により1に固定される)．
NA
factor.scope は、ユーザーが直接呼び出すことを意図していない。
drop1 メソッドでは、スコープが見つからない場合は、モデル内のすべての項とみなされます。追加または削除される項を考慮する際には、階層が尊重される。すなわち、2次の相互作用に含まれる主効果はすべて残さなければならない。
マージンを形成するために使用される関数が可換でない場合、結果はマージンが計算される順序に依存する。  マージンの注釈は、FUNリストに名前を付けることで行う。
aggregateは、データフレームと時系列用のメソッドを持つ汎用関数である。
aggregateは、データフレームと時系列用のメソッドを持つ汎用関数です。
aggregateは、データフレームと時系列用のメソッドを持つ汎用関数です。
同じデータに対して最尤法でフィットしたモデルを比較する場合、AICまたはBICが小さいほど適合度が高い。
完全エイリアシングとは、線形モデルにおいて、モデル内の早い段階で現れる項とは独立に推定することができず、そのためフィットから係数が省略される効果のことです。部分的エイリアシング（Partial Aliasing）とは、デザインによって誘発される相関のために、より正確に推定できない効果をいう。
NA
xとyがそれぞれ密度f((t-m)/s)/sとf(t-m)を持つ分布から独立した標本であり、mは未知の厄介なパラメータで、s（スケールの比）は関心のあるパラメータであるとする。  アンサリ・ブラドレー検定は、sが1に等しいという帰無値を検定するために使用され、両側対立選択肢は、s != 1（分布は分散だけが異なる）であり、片側対立選択肢は、s > 1（xの基礎となる分布は大きな分散を持つ、"より大きい"）またはs < 1（"より小さい"）である。
これは、バランスまたはアンバランス実験デザインに線形モデルをフィットするためのlmのラッパーを提供します。
入力には欠損値が含まれることがあり、（na.rmがtrueの場合、つまりデフォルトの場合）欠損値は削除されるので、少なくとも2つの完全な（x, y）ペアが必要である（method = "linear "の場合、それ以外は1つ）。  重複した（同値の）x値があり、tiesに関数が含まれている場合は、一意なxを持つ(x,y)ペアを生成するために、それぞれの異なるx値に対してy値に適用されます。
(na.rmがtrueの場合、つまりデフォルトの場合)入力には欠損値が含まれることがあるので、少なくとも2つの完全な(x,y)ペアが必要である(method = "linear "の場合、それ以外の場合は1つ)。  重複した（同値の）x値があり、tiesに関数が含まれている場合は、一意なxを持つ(x,y)ペアを生成するために、それぞれの異なるx値に対してy値に適用される。
この文脈で有用な関数には mean, min, max がある。
明確であるためには、AR係数は次の符号を持つことに注意。
明確であるためには、AR係数の符号は
ar.olsは、系列xの非定常・多変量の可能性のある系に一般ARモデルを当てはめる。結果の非制約最小2乗推定値は、系列の一部が非定常および/または共統合であっても一貫している。
明確性のために、AR係数は次の符号を持つことに注意。
ARMAモデルの定義によって、AR係数やMA係数の符号は異なる。  ここで使われている定義では
ARIMAモデルの正確な定義についてはarimaを参照。
ARMAモデルの異なる定義では、ARおよび/またはMA係数の符号が異なる。ここでの定義は
chisq()関数はオプションで非中心性引数を取るようになったので、*nchisq()関数は必要なくなりました。
使用する手法は Brockwell & Davis (1991, section 3.3)に従う。  式(3.3.8)は、ラグ0, ..., max(p, q+1)における自己共分散について解かれ、残りの自己相関は再帰的フィルタによって与えられる。
NA
デンドログラムは，各成分が木の枝に対応する入れ子リストとして直接表現される．  したがって，木zの最初の枝はz[[1]]であり，対応する部分木の2番目の枝はz[[1]][[2]]，またはより短いz[[c(1,2)]]などである．  木の各ノードは，効率的なプロットや切断に必要な情報を属性として持ち，そのうち，葉については，メンバ，高さ，葉だけが必須である．
利用可能な距離尺度は（2つのベクトルxとyについて書かれたもの）である：
このようなモデルは、+演算子で区切られた一連の項から構成されます。項自体は、:演算子で区切られた変数名と因子名から構成されます。このような項は、項に現れるすべての変数と因子の相互作用として解釈されます。
現在のところ、パッケージclusterの関数dianaとagnesが生成するクラス "twins "のオブジェクトの変換のみがサポートされています。  デフォルトのメソッドは、"hclust "オブジェクトが渡されない限りエラーをスローします。
NA
ts関数は、時系列オブジェクトを作成するために使用されます。  これは "ts "のクラス(および追加属性)を持つベクトルまたは行列であり、時間的に等しい間隔でサンプリングされたデータを表します。  行列の場合、行列データの各列は1つの（単変量の）時系列を含むと仮定されます。時系列は少なくとも1つの観測値を持つ必要があり、数値である必要はありませんが、数値以外の時系列のサポートは非常に限られています。
NA
NA
カーネルは、一般的なカーネルまたは指定されたカーネルを構築するために使用される。  修正Daniellカーネルは(S-PLUSで使用されるように)終端係数を半分にする。
x がリストの場合、その要素は分散の同質性について比較される標本または適合線形モデルとみなされる。  この場合、要素はすべて数値データベクトルか適合線形モデルオブジェクトでなければならず、gは無視され、単純にbartlett.test(x)を使って検定を行うことができます。  サンプルがリストに含まれていない場合は、bartlett.test(list(x, ...)) を使用します。
同じデータに対して最尤法でフィットされたモデルを比較する場合、AICまたはBICが小さいほど適合がよい。
信頼区間は、Clopper and Pearson (1934)で最初に与えられた手順で得られる。  これは信頼水準が少なくともconf.levelであることを保証するが、一般に最短の信頼区間は得られない。
familyは "glm "と "lm"（後者はgaussian()を返す）のクラスのメソッドを持つ汎用関数である。
biplot は、多変量データの行列のオブザベーションと変数の両方を同じプロット上に表現することを目的としたプロットです。biplot.default関数は、2組の変数を同じ図にプロットするための基本コードを提供するだけです。
これらの検定は、ARMA(p, q)フィットの残差に適用されることもありますが、その場合、lag > fitdfであれば、fitdf = p+qと設定することで、ヌル仮説分布により近似した結果が得られることが示唆されています。
bw.nrd0は、ガウシアンカーネル密度推定量の帯域幅を選択するための経験則を実装しています。デフォルトは、標準偏差と四分位範囲をサンプルサイズの1.34倍で割った値の負の5乗の最小値の0.9倍です（= Silvermanの「経験則」、Silverman (1986, page 48, eqn (3.31))。
bw.nrd0は、ガウシアンカーネル密度推定量の帯域幅を選択するための経験則を実装しています。デフォルトは、正の結果が保証される場合に四分位数が一致しない限り、標準偏差と四分位範囲の最小値の0.9倍をサンプルサイズの1.34倍の負の5乗で割った値（= Silvermanの「経験則」、Silverman (1986, page 48, eqn (3.31))です。
bw.nrd0は、ガウシアンカーネル密度推定量の帯域幅を選択するための経験則を実装しています。デフォルトは、正の結果が保証される場合に四分位数が一致しない限り、標準偏差と四分位範囲の最小値の0.9倍をサンプルサイズの1.34倍の負の5乗で割った値（= Silvermanの「経験則」、Silverman (1986, page 48, eqn (3.31))です。
bw.nrd0は、ガウシアンカーネル密度推定量の帯域幅を選択するための経験則を実装しています。デフォルトは、正の結果が保証される場合に四分位数が一致しない限り、標準偏差と四分位範囲の最小値の0.9倍をサンプルサイズの1.34倍の負の5乗で割った値（= Silvermanの「経験則」、Silverman (1986, page 48, eqn (3.31))です。
bw.nrd0は、ガウシアンカーネル密度推定量の帯域幅を選択するための経験則を実装しています。デフォルトは、正の結果が保証される場合に四分位数が一致しない限り、標準偏差と四分位範囲の最小値をサンプルサイズの1.34倍で割った値の負の5乗の0.9倍です（= Silvermanの「経験則」、Silverman (1986, page 48, eqn (3.31))。
Sとの互換性のために、contrはtreatment,helmert,sumまたはpoly（引用符なし）で、contr.treatmentなどの略記法とすることができる。
正準相関分析は，x変数の線形結合によってよく説明されるthey変数の線形結合を求める．よく説明される」は相関によって測定されるので、関係は対称的である。
NA
タイプ = "相関" および "共分散" の場合、推定は標本の共分散に基づく。(ラグ0の自己相関は慣例により1に固定される)。
x が1行または1列の行列の場合、または x がベクトルで y が与えられない場合、適合度検定が実行される（x は1次元分割表として扱われる）。  xの項目は非負整数でなければならない。  この場合、検定される仮説は、母集団の確率がpの確率と等しいか、またはpが与えられない場合はすべて等しいかである。
多次元スケーリングは、非類似度の集合を取り、点間の距離が非類似度とほぼ等しくなるような点の集合を返す。  (これは、生態学者が「順序付け」と呼ぶものの主要な部分である）。
モデルフィッティング関数によって返されるすべてのオブジェクトクラスは、 coef メソッドを提供するか、デフォルトのメソッドを使用する必要があります(このメソッドは coef のためのものであり、係数のためのものではないことに注意してください)。
モデルフィット関数によって返されるすべてのオブジェクトクラスは、 coef メソッドを提供するか、デフォルトのメソッドを使用する必要がある(このメソッドは coef 用であり、係数用ではないことに注意)。
NA
confintは汎用関数です。  デフォルトのメソッドは正規性を仮定しており、適切なcoefメソッドとvcovメソッドが利用可能である必要があります。  デフォルトのメソッドは、他のメソッドと比較するために直接呼び出すことができます。
confint は汎用関数です。  デフォルトのメソッドは、正規性を仮定し、適切な coef および vcov メソッドが利用可能である必要があります。  デフォルトのメソッドは、他のメソッドと比較するために直接呼び出すことができます。
confintは汎用関数です。  デフォルトのメソッドは、正規性を仮定し、適切な coef および vcov メソッドが利用可能である必要があります。  デフォルトの手法は、他の手法と比較するために直接呼び出すことができる。
実行可能領域は ui %*% theta - ci >= 0 で定義される.開始値は実行可能領域の内部になければならないが, 境界に最小値があってもよい.
これらの関数は、分散分析および回帰モデルの推定に使用するコントラスト行列の作成に使用されます。  結果の行列の列には、n個の水準を持つ因子を符号化するために使用できる対比が含まれます。  返される値には、計算された対比が含まれます。  引数contrastsがFALSEの場合、contr.poly（contrasts = FALSEの場合、0次、つまり定数の多項式を含む）を除き、正方形の指標行列（ダミー符号化）が返されます。
これらの関数は、分散分析や回帰モデルに使用するためのコントラスト行列を作成するために使用されます。  結果の行列の列には、n個の水準を持つ因子のコーディングに使用できる対比が含まれます。  返される値には、計算された対比が含まれます。  引数contrastsがFALSEの場合、contr.poly（contrasts = FALSEの場合、0次、つまり定数の多項式を含む）を除き、正方形の指標行列（ダミー符号化）が返されます。
これらの関数は、分散分析および回帰モデルに使用するコントラスト行列を作成するために使用されます。  結果の行列の列には、n個の水準を持つ因子を符号化するために使用できる対比が含まれます。  返される値には、計算された対比が含まれます。  引数contrastsがFALSEの場合、contr.poly（contrasts = FALSEの場合、0次、つまり定数の多項式を含む）を除き、正方形の指標行列（ダミー符号化）が返されます。
これらの関数は、分散分析および回帰モデルに使用するコントラスト行列を作成するために使用されます。  結果の行列の列には、n個の水準を持つ因子を符号化するために使用できる対比が含まれます。  返される値には、計算された対比が含まれます。  引数contrastsがFALSEの場合、contr.poly（contrasts = FALSEの場合、0次、つまり定数の多項式を含む）を除き、正方形の指標行列（ダミー符号化）が返されます。
これらの関数は、分散分析および回帰モデルに使用するコントラスト行列を作成するために使用されます。  結果の行列の列には、n個の水準を持つ因子を符号化するために使用できる対比が含まれます。  返される値には、計算された対比が含まれます。  引数contrastsがFALSEの場合、contr.poly（contrasts = FALSEの場合、0次、つまり定数の多項式を含む）を除く正方指標行列（ダミー符号化）が返される。
contrastsが要因に設定されていない場合は、options("contrasts")のデフォルト関数が使用されます。
factor に contrasts が設定されていない場合は、デフォルトの関数 fromoptions("contrasts") が使用されます。
高速フーリエ変換 fft は、効率化のために使用されます。
主な高レベル関数は、influence.measuresで、各モデル変数のDFBETAS、DFFITS、共分散比、クックの距離、ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します。  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされる。
クラスタ化された2つのオブザベーション間の共分散距離は，2つのオブザベーションが最初に1つのクラスタに結合されるグループ間非類似度と定義される．
covとcorでは，xに行列の順序データ・フレームを与えるか，xとyの両方を与えなければならない．
3つの手法は、それぞれ対になった標本間の関連を推定し、その値がゼロであることの検定を計算する。  これらは異なる関連性の尺度を使用し、すべて[-1, 1]の範囲で、0は関連性がないことを示す。  これらは無相関の検定と呼ばれることもあるが、この用語はデフォルトの手法に限定されることが多い。
covとcorについては、xに行列の順序フレームを与えるか、xとyの両方を与えなければならない。
デフォルトでは、method = "unbiased" で、共分散行列は重み付けの2乗和を差し引いた値で除算されるので、重みがデフォルト（1/n）の場合、除数（n - 1）の共分散行列の従来の不偏推定値が得られます。  これは、method = "ML "に対応し、除算を行わないS-PLUSの動作とは異なります。
covとcorについては、xに行列の序数フレームを与えるか、xとyの両方を与えなければならない。
主な高レベル関数はinfluence.measuresで、各モデル変数のDFBETAS、DFFITS、共分散比、Cookの距離、ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します。  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされます。
NA
与えられた高さで木を切ることは、ウルトラメトリック木（単調なクラスタリングの高さを持つ）に対してのみ可能である。
これらはすべて汎用関数であり、xのtsp属性が存在すればそれを使用する。timeとcycleには、結果をそのクラスに強制するクラスtsのメソッドがある。
Dは、単純な記号的導関数を取るために、Sに倣ってモデル化されています。
パラメータshape1 = aおよびshape2 = bを持つベータ分布は、密度を持つ。
size = n、prob = pの2項分布は密度を持つ。
locationとscaleが指定されない場合、それぞれデフォルト値の0と1となる。
df= n ≥ 自由度0のカイ2乗分布には密度がある
使用される加法モデルは
NA
これらはすべて汎用関数であり、x の tsp 属性が存在すればそれを使用します。time と cycle には、結果をそのクラスに強制するクラス ts 用のメソッドがあります。
NA
density.defaultで使用されるアルゴリズムは、経験分布関数の質量を少なくとも512点の規則的なグリッド上に分散させ、高速フーリエ変換を使用してこの近似値を離散化されたバージョンのカーネルと畳み込み、指定された点での密度を評価するために線形近似を使用します。
density.defaultで使用されるアルゴリズムは，経験分布関数の質量を少なくとも512ポイントの規則的なグリッド上に分散させ，高速フーリエ変換を使用してこの近似値を離散化されたバージョンのカーネルと畳み込み，指定された点での密度を評価するために線形近似を使用します．
Dは、単純な記号導関数を取るために、そのS名に倣ってモデル化されています。
Dは，単純な記号導関数を取るために，そのS名に倣ってモデル化されている．
これは、フィットしたモデルの偏差を抽出するために使用できる汎用関数です。  この関数の使い方の詳細については、各モデリング関数を参照してください。
rateが指定されない場合、デフォルト値の1となる。
自由度 df1 = n1 および df2 =n2 の F 分布は密度
カーネルは、一般的なカーネルまたは指定されたカーネルを構築するために使用されます。  修正Daniellカーネルは末端係数を半分にする（S-PLUSで使用）。
これは、フィットしたモデルの残差自由度を抽出するために使用できる汎用関数です。  この関数の使い方の詳細については、各モデリング関数を参照してください。
このようなモデルは、+演算子で区切られた一連の項から構成されます。項自体は、 : 演算子で区切られた変数名と因子名から構成されます。
主要な高レベル関数は influence.measures で、各モデル変数の DFBETAS、DFFITS、共分散比、クック距離、ハット行列の対角要素を示すクラス "infl" オブジェクトの表形式表示を生成します。  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされます。
主な高レベル関数は，influence.measuresで，各モデル変数のDFBETAS，DFFITS，共分散比，クックの距離，ハット行列の対角要素を示すクラス "infl" オブジェクトの表形式表示を作成します．  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされます。
主な高レベル関数は，influence.measuresで，各モデル変数のDFBETAS，DFFITS，共分散比，クックの距離，ハット行列の対角要素を示すクラス "infl" オブジェクトの表形式表示を作成します．  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされる。
scale が省略された場合は，デフォルト値 1 となる．
確率 = p の幾何分布は，密度
超幾何分布は，置換なしのサンプリングに使用される．  この分布の密度は，パラメータm，n，k（以下の参考文献ではそれぞれNp，N-Np，nと命名されている。
diffinvは "ts "クラスのメソッドを持つ汎用関数で、ベクトルや行列に対するデフォルトのメソッドです。
利用可能な距離尺度は以下の通りである（2つのベクトル x と y に対して記述）：
対数正規分布の密度
location と scale が省略された場合，それぞれデフォルトの値 0 と 1 となります．
x が K 成分ベクトルである場合， dmultinom(x, prob)は確率である．
サイズ = n、prob = p の負の2項分布は、密度
mean と sd が指定されない場合は、それぞれデフォルトの値 0 と 1 となる。
ポアソン分布は密度
factor.scope は、ユーザーが直接呼び出すことを意図していません。
NA
drop1 メソッドでは、スコープがない場合はモデル内のすべての項とみなされます。追加または削除される項を考慮する場合、階層が尊重される：2次の相互作用に含まれる主効果はすべて残さなければならない、など。
この分布は次のように得られる。  x を原点について対称な連続分布からのサイズ n の標本とする。  そして，Wilcoxon 符号順位統計量は，x[i]が正である絶対値x[i]の順位の合計である．  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24である。
df = n自由度を持つ t 分布は，密度を持つ
適合線形モデルは，因子項の対比の係数を持ち，通常，水準数より1つ少ない．  この関数は、元のコーディングで係数を再表現します。係数は、縮小ベースでフィットされているので、暗示された制約（例えば、 contr.helmertやcontr.sumのゼロ和）は、尊重されます。  contr.treatment対比でdummy.coefを使用する意味はほとんどありません。なぜなら、欠落係数は定義上ゼロだからです。
適合線形モデルは、因子項の対比の係数を持ち、通常、水準数より1つ少ない数です。  この関数は、元のコーディングで係数を再表現します。係数は、縮小ベースでフィットされているので、暗示された制約（例えば、contr.helmertやcontr.sumのゼロ和）は尊重されます。  contr.treatmentの対比にdummy.coefを使用する意味はほとんどありません。
minまたはmaxが指定されない場合、それぞれデフォルト値の0および1となる。
形状パラメータ a とスケール・パラメータ b を持つワイブル分布は，次式で与えられる密度を持つ．
この分布は次のように得られる。  xとyを大きさmとnの2つの無作為な独立標本とすると、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数である。  この統計量は，0 から m * n の間の値をとり，その平均と分散は，それぞれ m * n / 2 と m * n * (m + n + 1) / 12である．
e.c.d.f.（経験的累積分布関数）Fn は、i がその値での同値オブザベーションの数であるオブザベーション値でジャンプ i/n を持つステップ関数である。  欠損値は無視される．
多層を持つ分散分析モデルの固定効果項は，複数の層で推定可能であることがあり，その場合，それぞれの層では完全な情報よりも少ない．  ある項の効率は，その層だけで推定することによって得られる最大可能精度（逆分散）の割合である．  均衡の仮定の下では，これはその項を含むすべての対比で同じである．
lmまたはaovによってフィットされた線形モデルの場合、効果は、フィッティングプロセス中にQR分解によって生成された連続する直交部分空間にデータを射影することによって得られる無相関の1自由度値である。最初のr行（モデルのランク）は係数に関連し、残りは残差空間にまたがる（ただし、特定の残差には関連しない）。
結果の行列の各行は，シーケンスx[t]，x[t-1]，...，x[t-dimension+1]からなり，ここでtはxの元のインデックスである．xが行列の場合，すなわち，xが複数の変数を含む場合，x[t]は各変数のt番目のオブザベーションからなる．
これらはジェネリック関数で、xのtsp属性が存在すればそれを使用します。デフォルトのメソッドは、元の時間単位から開始時間をデコードするので、月系列1995.5はc(1995, 7)と表現されます。頻度fの系列では、timen+i/fはc(n, i+1)と表現される（i = 0, f = 1の場合でも）。
NA
na.expand=FALSEの場合、余分な変数のNA値はモデルで使用されるna.action関数に渡されます。  その結果、データフレームが短くなったり（na.omitの場合）、エラーになったり（na.failの場合）します。  na.expand=TRUEの場合、返されるデータフレームはmodel.frame(model)と全く同じ行を持ちますが、余分な変数に対応する列にはNAが含まれる可能性があります。
これは汎用の関数であり、"aov"、"glm"、"lm"、"negbin" (MASSパッケージ)、"coxph"、"survreg" (survivalパッケージ)のメソッドがあります。
因子分析モデルは
factor.scopeは、ユーザーが直接呼び出すことを意図していない。
familyは "glm "と "lm"（後者はgaussian()を返す）クラスのメソッドを持つ汎用関数である。
NA
欠損値はxでは許されるが、filterでは許されない（出力中のいたるところで欠損値が発生する）。
xが行列の場合、それは2次元分割表として扱われるので、そのエントリは非負整数でなければならない。  不完全なケースは取り除かれ、ベクトルは因子オブジェクトに強制され、分割表はこれらから計算される。
NA
NA
NA
xがリストの場合、その要素は分散の同質性のために比較される標本とみなされるので、数値データベクトルでなければならない。  この場合、gは無視され、単純にfligner.test(x)を使って検定を行うことができる。  サンプルがまだリストに含まれていない場合は、fligner.test(list(x, ...)) を使用する。
このようなモデルは、+演算子で区切られた一連の項から構成されます。項自体は、:演算子で区切られた変数名と因子名から構成されます。
これらはすべて汎用関数であり、xのtsp属性が存在すればそれを使用します。timeとcycleには、結果をそのクラスに強制するクラスts用のメソッドがあります。
ffriedman.testは、正規性の仮定に違反する可能性のある、再現性のない完全ブロック計画（すなわち、グループとブロックの各水準の組み合わせに対して、yにちょうど1つのオブザベーションがある）の分析に使用できます。
ftableは、「平坦な」分割表を作成します。  通常の分割表と同様、これらは、関係する変数（因子）のレベルの各組み合わせのカウントを含みます。  そして、この情報は、行と列が（それぞれrow.varsとcol.varsで指定された）行変数と列変数のレベルの組み合わせに対応する行列として再整理されます。  組み合わせは、変数を逆順に（左端の変数のレベルが最も遅く変化するように）ループすることによって作成される。  この平坦な行列形式（print.ftable、クラス "ftable "のオブジェクトのprintメソッド）で分割表を表示することは、高次元の配列として表示するよりも好ましい場合が多い。
familyは、クラス "glm "と "lm"（後者はgaussian()を返す）のメソッドを持つ汎用関数です。
familyは、クラス "glm "と "lm "のメソッドを持つ汎用関数です（後者はgaussian()を返します）。
何が起こるかは、オブジェクトformulaのクラスと属性に依存します。  これが "lm "のようなfitted-modelクラスのオブジェクトである場合、このメソッドは、モデルのフィット時に使用された保存されたモデルフレームを返すか（もしあれば、多くの場合、引数model = TRUEで選択されます）、フィット時に使用された呼び出しをdefaultメソッドに渡します。  defaultメソッド自体は、他の引数が与えられない場合、MASSパッケージの "lqs "クラスのような標準的なモデルオブジェクトに対応することができます。
NA
NA
典型的な予測変数はresponse ~ termsの形式を持ち、responseは（数値）応答ベクトル、 termsはresponseの線形予測変数を指定する項の系列です。  二項および準二項族では，responseは因子として（最初の水準が失敗を表し，それ以外は成功を表すとき），または列が成功と失敗の数を与える2列の行列として指定することもできる．  first + secondの形の項指定は、重複を取り除いたfirstのすべての項とsecondのすべての項を示す。
glmのcontrol引数は、デフォルトではglm.fitのcontrol引数に渡され、glm.fitはその要素をglm.controlの引数として使用します。
典型的な予測変数はresponse ~ termsの形式を持ち、responseは（数値）応答ベクトル、 termsはresponseの線形予測変数を指定する項の系列です。  二項および準二項族では，responseは因子として（最初の水準が失敗を表し，それ以外は成功を表す場合），または列が成功と失敗の数を与える2列の行列として指定することもできる．  first + secondの形のterms指定は、firstのすべてのtermsとsecondのすべてのtermsの重複を取り除いたものである。
tsp属性は、時間単位での開始時刻、終了時刻、および頻度（月次系列では12など、時間単位あたりのオブザベーション数）を示す。
主な高レベル関数は、influence.measuresで、各モデル変数のDFBETAS、DFFITS、共分散比、クックの距離、ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します。  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされます。
主な高レベル関数は，influence.measuresで，各モデル変数のDFBETAS，DFFITS，共分散比，クックの距離，ハット行列の対角要素を示すクラス "infl" オブジェクトの表形式表示を作成します．  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされる。
この関数は，クラスタ化される n 個のオブジェクトの非類似度の集合を用いて，階層的クラスタ分析を実行する．  最初は、各オブジェクトはそれ自身のクラスタに割り当てられ、その後、アルゴリズムは反復的に進行し、各段階で最も類似した2つのクラスタを結合し、単一のクラスタだけになるまで継続する。各段階でクラスタ間の距離は、使用される特定のクラスタリング手法に従って、Lance-Williams 非類似度更新式によって再計算される。
RowvまたはColvのいずれかがデンドログラムの場合、それらは尊重される（そして、並べ替えられない）。  そうでない場合，デンドログラムは次のように計算されます：dd <- as.dendrogram(hclustfun(distfun(X))) X は x または t(x).
加法Holt-Winters予測関数（期間長pの時系列）は
また、参照に列挙されているinfluence.measures()および他の関数は、さまざまな回帰診断を計算する、よりユーザー指向の方法を提供します。  これらはすべてlm.influenceをベースにしています。  GLM（同一性リンクを持つGaussian族以外）では、これらは1ステップ近似に基づいていることに注意してください。
主な高レベル関数は、influence.measuresで、各モデル変数のDFBETAS、DFFITS、共分散比、Cookの距離、ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します。  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされる。
...以降の引数は，正確に一致しなければならないことに注意．
デフォルトでは，x.factor の水準は，指定された順序で x 軸上にプロットされ，凡例（指定された場合）のために右側に余分なスペースが残される．x.factorが順序付き因子でレベルが数値の場合、これらの数値がx軸に使用されます。
familyは "glm "と "lm "クラスのメソッドを持つ汎用関数です（後者はgaussian()を返します）。
つまり、IQR(x) = quantile(x, 3/4) - quantile(x, 1/4) である。
NA
デンドログラムは，各成分が木の枝に対応する入れ子リストとして直接表現される．  したがって，木zの最初の枝はz[[1]]であり，対応する部分木の2番目の枝はz[[1]][[2]]，またはより短いz[[c(1,2)]]などである．  木の各ノードは、効率的なプロットや切断に必要な情報を属性として持ち、そのうちメンバ、高さ、葉の葉だけが必須である：
ts関数は，時系列オブジェクトを作成するために使用される．  これらは、"ts "のクラス（および追加の属性）を持つベクトルまたは行列であり、時間的に等しい間隔でサンプリングされたデータを表します。  行列の場合、行列データの各列は1つの（単変量の）時系列を含むと仮定されます。時系列は少なくとも1つの観測値を持つ必要があり、数値である必要はありませんが、数値以外の時系列のサポートは非常に限られています。
NA
ts関数は、時系列オブジェクトを作成するために使用される。  これは、"ts "のクラス（および追加属性）を持つベクトルまたは行列であり、時間的に等しい間隔でサンプリングされたデータを表す。  行列の場合、行列データの各列は1つの（単変量の）時系列を含むと仮定されます。時系列は少なくとも1つのオブザベーションを持つ必要があり、数値である必要はありませんが、非数値系列のサポートは非常に限られています。
カーネルは、一般的なカーネルまたは指定されたカーネルを構築するために使用される。  修正Daniellカーネルは端係数を半分にする（S-PLUSで使用）。
このアルゴリズムは, 累積データ(すなわち, cumsum(y))の凸の小関数m(x)を決定し, その結果はm'(x)であり, 凸m(x)が累積データの多角形に接し, 傾きが変化する位置でレベル変化を持つステップ関数である.as.stepfun()は, より簡略化できるstepfunオブジェクトを返す.
これらの関数は、状態ベクトルa、遷移a <- T a + R e,e ~ N(0, kappa Q)、観測方程式y = Z'a + eta,eta ~ N(0, kappa h)を持つ一般的な一変量状態空間モデルで動作します。
これらの関数は、状態ベクトルa、遷移a <- T a + R e,e ~ N(0, kappa Q)、観測方程式y = Z'a + eta,eta ~ N(0, kappa h)を持つ一般的な一変量状態空間モデルで動作します。
これらの関数は、状態ベクトルa、遷移a <- T a + R e,e ~ N(0, kappa Q)、観測方程式y = Z'a + eta,eta ~ N(0, kappa h)を持つ一般的な一変量状態空間モデルで動作します。
これらの関数は、状態ベクトルa、遷移a <- T a + R e,e ~ N(0, kappa Q)、観測方程式y = Z'a + eta,eta ~ N(0, kappa h)を持つ一般的な一変量状態空間モデルで動作する。
NA
カーネルは、一般的なカーネルまたは指定されたカーネルを構築するために使用される。  修正Daniellカーネルは端係数を半分にする（S-PLUSで使用）。
これは、点から割り当てられたクラスタ中心までの二乗和が最小になるように、点をk個のグループに分割することを目的とする。最小では、すべてのクラスタ中心は、そのボロノイセット（クラスタ中心に最も近いデータ点の集合）の平均にある。
NA
kruskal.test は、xの分布の位置パラメータが各グループ（標本）で同じであることのクルスカル・ワリス順位和検定を行う。  もう1つの検定は、少なくとも1つ異なるというものである。
yが数値の場合、xとyが同じ連続分布から抽出されたという帰無仮説の2標本の検定が実行される。
NA
ベクトルまたは行列の引数 x には、hasTsp という tsp 属性が与えられます。
プロットが1つだけ作成される場合、これは従来のプロットです。  複数のプロットが作成される場合、par(mfrow)と他のいくつかのグラフィックパラメータが設定されるので、このようなラグプロットを同じページ上の他のプロットと混在させることは（簡単には）できません。
欠損値のあるケースは省略される。
lmのモデルは記号的に指定される。  典型的なモデルは，response ~ termsの形式を持ち，ここでresponseは（数値）応答ベクトルであり，termsは応答の線形予測変数を指定する一連の項である．  first + secondの形の項指定は，重複を除去したfirstのすべての項とsecondのすべての項を一緒に示す．  first:secondの形の指定は，firstのすべての項とsecondのすべての項の相互作用をとることによって得られる項の集合を示す．  first*second の指定は、first と second の交差を示す。  これは first + second + first:second と同じである。
NA
また参照 "にリストされているinfluence.measures()およびその他の関数は、さまざまな回帰診断を計算する、よりユーザー指向の方法を提供します。  これらはすべてlm.influenceをベースにしています。  GLM（同一性リンクを持つGaussianファミリー以外）では、これらは1ステップ近似に基づいていることに注意してください。
NA
負荷量」は因子分析の用語ですが、社会科学の文献では因子分析と主成分分析（PCA）がoftenconflatedであるため、SPSSではPCAに使用され、したがってSPSSユーザーを支援するためにS-PLUSではprincompで使用されます。
フィットは局所的に行われる。  つまり、点xでのフィットでは、xからの距離で重み付けされたx近傍の点を使用してフィットが行われます（距離を計算する際には、「パラメトリック」変数の違いは無視されます）。  近傍領域のサイズはα（span orenp.targetで設定）で制御される。  α < 1の場合、近傍領域には点の割合αが含まれ、これらの点には3次加重（(1 - (dist/maxdist)^3)^3に比例）が行われる。  α > 1の場合，すべての点が使用され，「最大距離」は，p 個の説明変数の実際の最大距離のα^(1/p)倍であると仮定される．
NA
loess.smoothは、xの範囲をカバーする等間隔の点でloess smoothを評価する補助関数です。
logLikは、最尤法で適合されたモデルに対して最も一般的に使用され、AICなどいくつかの使用法では、これを仮定しています。  他の適合基準、例えばREML（"lme "のデフォルト）が使用されている場合は注意が必要です。
モデルの適合には、Haberman (1972)に提示されている反復比例適合アルゴリズムが使用される。  最大反復が実行され、観測されたマージンとフィットされたマージンとの間の最大偏差がepsより小さくなったときに収束とみなされる。  すべての内部計算は倍精度で行われ、モデルの因子数（表の次元）に制限はない。
lowessは複雑なアルゴリズムで定義されており、Ratforのオリジナル（W. S. Clevelandによる）はRのソースのsrc/library/stats/src/lowess.doc'にあります。  通常、局所線形多項式フィットが使われますが、状況によっては（ファイルを参照）局所定数フィットが使われることもあります。  ローカル」とは、floor(f*n)番目の最近傍までの距離で定義され、近傍領域内にあるxに対して3次加重が使用されます。
NA
NA
重みが指定された場合、重み付き最小2乗法が実行され、wt の j 番目の項目で指定された j 番目のケースに重みが与えられる。
実際に計算される値は constant * cMedian(abs(x - center))であり, centerのデフォルト値は median(x)であり, cMedianは通常の'low'または'high'中央値である。
NA
NA
これらの関数は、状態ベクトルa、遷移a <- T a + R e,e ~ N(0, kappa Q)、観測方程式 y = Z'a + eta,eta ~ N(0, kappa h)を持つ一般的な一変量状態空間モデルで動作します。
これは、poly、bs、nsのメソッドを持つ汎用関数です：デフォルトのメソッドはスケールを扱います。  model.frame.defaultは、モデルフレームを作成する際にこのような項に遭遇した場合、与えられた項のpredvars属性を修正し、新しいデータを予測するのに有効な項に置き換えます。  例えば、makepredictcall.nsはノットと切片の引数を追加します。
クラス "manova "はクラス "aov "とは異なる要約方法を選択する点で異なります。  関数manovaはaovを呼び出し、各層の結果オブジェクトにクラス "manova "を追加する。
x が配列の場合、各次元は少なくとも2でなければならず、エントリは非負の整数でなければならない。  NAは許されない。  それ以外の場合、x, y, z は同じ長さでなければならない。  NAを含むトリプルは削除される。  すべての変数は少なくとも2つの異なる値を取らなければならない。
Mauchlyの検定 共分散行列が与えられた行列に比例すると仮定できるかどうかを検定する。
ヌルは，セル[i,j]と[j,i]に分類される確率が同じであるということである．
これはメソッドを書くことができる一般的な関数である。  しかし、デフォルトのメソッドでは、パッケージ base の is.na、sort、mean が使用されており、これらは汎用的なものです。
これはメソッドを書くことができる汎用関数です。  しかし、デフォルトのメソッドでは、パッケージbaseのis.na、sort、meanが使用されており、これらは汎用的なものです。
フィットされるモデルは加法的（定数＋行＋列）です。このアルゴリズムは、行と列の中央値を交互に削除することで動作し、絶対残差の合計の比例減少がεより小さくなるまで、または最大回数を反復するまで続けられます。trace.iterがTRUEである場合、絶対残差の合計がフィッティングプロセスの各反復で表示されます。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されています。  また、aglm fit の etastart や mustart 成分を抽出するのにも便利です。
何が起こるかは、オブジェクト式のクラスと属性に依存する。  これが "lm "のようなfitted-modelクラスのオブジェクトの場合、このメソッドは、モデルのフィットの際に使用された保存されたモデルフレームを返すか（もしあれば、多くの場合、引数model = TRUEで選択されます）、フィットの際に使用されたコールをdefaultメソッドに渡します。  defaultメソッド自体は、他の引数が与えられない場合、MASSパッケージの "lqs "クラスのような標準的なモデルオブジェクトに対応することができます。
何が起こるかは、オブジェクトのクラスと属性に依存します。  これが "lm "のようなfitted-modelクラスのオブジェクトである場合、このメソッドは、モデルのフィットの際に使用された保存されたモデルフレームを返すか（もしあれば、多くの場合、引数model = TRUEによって選択されます）、フィットの際に使用された呼び出しをdefaultメソッドに渡します。  defaultメソッド自体は、他の引数が与えられない場合、MASSパッケージのクラス "lqs "のような標準的なモデルオブジェクトに対応することができます。
model.matrixは、model.frame(object)を呼び出すか、より正確にはattr(terms(object), "variables")を評価することによって作成されるのと同じ名前の変数を与えなければならないdataのデータを使用して、terms(object)で与えられた説明から設計行列を作成します。  データがデータフレームの場合、他の列があってもよく、列の順番は重要ではありません。  文字変数はすべて因子に強制されます。  強制後は、式の右辺で使用されるすべての変数は、論理、整数、数値、または因子でなければなりません。
model.matrixは、model.frame(object)を呼び出すか、より正確にはattr(terms(object), "variables")を評価することによって作成されるのと同じ名前の変数を与えなければならないdataのデータを使用して、terms(object)で与えられた説明からデザイン行列を作成します。  データがデータフレームの場合、他の列があってもよく、列の順番は重要ではありません。  文字変数はすべて因子に強制されます。  強制後は、式の右辺で使用されるすべての変数は、論理、整数、数値、または因子でなければなりません。
model.matrixは、model.frame(object)を呼び出すか、より正確にはattr(terms(object), "variables")を評価することによって作成されるのと同じ名前の変数を与えなければならないdataのデータを使用して、terms(object)で与えられた説明からデザイン行列を作成します。  データがデータフレームの場合、他の列があってもよく、列の順番は重要ではありません。  文字変数はすべて因子に強制されます。  強制された後、式の右辺で使用されるすべての変数は、論理、整数、数値、または因子でなければなりません。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されています。  aglmフィットのetastart成分やmustart成分などを抽出するのにも便利です。
model.extractはSとの互換性のために提供されている。  また、aglm fitのetastart成分とmustart成分を抽出するのにも便利である。
type = "effects "の場合は、各項の係数の表が得られ、オプションで標準誤差も得られる。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されています。  aglmフィットのetastart成分やmustart成分などを抽出するのにも便利です。
これらの関数は時系列から部分系列を抽出し、それらを1つのフレームにプロットします。  tsメソッド、stlメソッド、StructTSメソッドは、内部に記録された周波数と開始時刻と終了時刻を使用して、スケールと季節を設定します。  デフォルトのメソッドでは、オブザベーションは12個のグループであると仮定します（ただし、これは変更可能です）。
基礎となるモデルは、2つのサンプルがそれぞれf(x-l)とf((x-l)/s)/sから引き出されるというもので、lは共通の位置パラメータ、sはスケールパラメータである。
NA
na.actionは汎用関数であり、na.action.defaultはそのデフォルトメソッドである。  後者はリストの "na.action "コンポーネントがあればそれを、なければ "na.action "属性を抽出する。
NA
現在のところ、これらはベクトル、行列、およびベクトルと行列からなるデータフレーム（のみ）を扱います。
現時点では、これらはベクトル、行列、およびベクトルと行列からなるデータ・フレーム（のみ）を扱います。
現在のところ、これらはベクトル、行列、およびベクトルと行列（のみ）からなるデータ・フレームを扱います。
現在のところ、これらはベクトル、行列、およびベクトルと行列（のみ）からなるデータフレームを扱います。
これらは、モデリング関数のpredict、fitted、residualsメソッドで、フィッティングプロセスにおけるNAの除去を補正するために使用されるユーティリティ関数です。  デフォルトの "lm"、"glm"、"nls "メソッドや、MASS、rpart、survivalパッケージのメソッドで使用されます。  また、factanal、prcomp、 princompが返すスコアにも使用される。
naprint.omitは省略された行数を報告し、naprint.defaultは空文字列を報告します。
これらは、モデリング関数のpredict、fitted、residualsメソッドが、フィッティングプロセスにおけるNAの除去を補正するために使用されるユーティリティ関数です。  デフォルト、"lm"、"glm"、"nls "メソッド、およびMASS、rpart、survivalパッケージのメソッドで使用されます。  また、factanal、prcomp、 princompが返すスコアにも使用される。
NA
...以降の引数は正確に一致しなければならないことに注意。
startの名前はすべてobjectiveに渡され、gradientとhessianにも渡される。  パラメータvectorはdoubleに強制される。
nlsオブジェクトはフィットモデルオブジェクトの一種です。  汎用関数anova、coef、confint、deviance、df.residual、fitted、formula、logLik、predict、print、profile、residuals、summary、vcov、weightsのメソッドを持っています。
NA
NA
NA
NA
NA
このパッケージには、"lm"、"glm"、"nls"、"logLik "クラスのオブジェクト用のメソッドと、デフォルトのメソッド（重みと残差成分を探すときにuse.fallback = TRUEでない限りエラーを投げる - 注意して使ってください！）があります。
これはC関数のnumeric_derivのフロントエンドであり、Writing R Extensionsで説明されている。
1つのモデル式に複数のオフセットを指定することができますが、オフセット項に対して-はサポートされていません（+と等価です）。
式の右辺に複数の項が含まれる場合、それらの相互作用がグループ化を形成する。
...の後の引数は正確にマッチしなければならないことに注意。
の後の引数は正確にマッチしなければならないことに注意。
の後の引数は正確にマッチしなければならないことに注意。
の後の引数は正確にマッチしなければならないことに注意。
左から右の順に、葉のインデックスまたはラベルが検索される。
調整法には、p値に比較数を乗じるボンフェローニ補正("bonferroni")がある。  より保守的な補正は、Holm (1979) ("holm")、Hochberg (1988) ("hochberg")、Hommel (1988) ("hommel")、Benjamini &Hochberg (1995) ("BH "またはその別名 "fdr")、Benjamini &Yekutieli (2001) ("BY")にもそれぞれ含まれている。メソッドのセットはp.adjust.methods vectorに含まれ，オプションとしてメソッドを持ち，p.adjustに渡す必要があるメソッドのために役立つ．
調整メソッドには、p値に比較の数を乗じるBonferroni補正("bonferroni")が含まれます。  より保守的な補正は、Holm (1979) ("holm")、Hochberg (1988) ("hochberg")、Hommel (1988) ("hommel")、Benjamini &Hochberg (1995) ("BH "またはその別名 "fdr")、Benjamini &Yekutieli (2001) ("BY")にもそれぞれ含まれている。メソッドのセットはp.adjust.methodsベクトルに含まれ，メソッドをオプションとして持ち，p.adjustに渡す必要があるメソッドのために役立ちます．
type="correlation "および "covariance "の場合、推定は標本の共分散に基づいて行われます。(ラグ0の自己相関は慣例により1に固定される)。
NA
NA
 pool.sdスイッチは、すべてのグループに共通のSDを計算し、すべての比較にそれを使用する（これはいくつかのグループが小さい場合に便利である）。このメソッドは実際にはt.testを呼び出さないので、余分な引数は無視されます。プーリングは対応のある検定には一般化されないので、pool.sdとpairedの両方をTRUEにすることはできません。
多群比較を行う関数は、別々のcompare.levels関数（iとjで対称であると仮定）を作成し、それらをこの関数に渡します。
wilcox.testに渡される余分な引数は、この文脈では意味がある場合とない場合がある。特に、可能な比較の行列の下三角形だけが計算されるので、alternativeを "two.sided "以外に設定すると、gの水準が分別のある順序になる必要がある。
パラメータshape1 = a とshape2 = bを持つベータ分布は密度を持つ。
大きさ＝n，確率＝pの二項分布は密度を持つ
誕生日のパラドックスとは、23人という非常に少ない人数で、2人以上が同じ誕生日である確率が50/50になるというものである。  この関数は、0.5以外の確率、2以外の一致イベントの数、365以外のクラスの数に対して計算を一般化する。
位置とスケールが指定されない場合、それぞれデフォルト値の0と1と仮定される。
自由度 df= n ≥ 0 のカイ2乗分布は，密度
rateが指定されない場合は，デフォルト値1が仮定される．
df1 = n1 および df2 =n2 の自由度を持つF分布の密度
scale が省略された場合は，デフォルト値1となる．
prob = pの幾何分布が密度を持つ
超幾何分布は，置換なしのサンプリングに使用される．  この分布の密度は，パラメータm，n，k（以下の文献ではそれぞれNp，N-Np，nと命名されている。
chisq()関数はオプションで非心引数を取るようになったので、*nchisq()関数は必要なくなりました。
対数正規分布は密度
location および scale が省略された場合は、それぞれデフォルトの値 0 および 1 となります。
e.c.d.f.(経験的累積分布関数)Fnは、観測値でジャンプi/nを持つステップ関数で、iはその値で結ばれた観測値の数です。  欠損値は無視される。
NA
NA
NA
yが欠損している場合、この関数は、plot.typeによって2種類のうちの1つの多変量系列の時系列プロットを作成する。
size = n、prob = pの負の2項分布は、密度を持つ。
meanまたはsdが指定されない場合、それぞれデフォルト値の0および1となる。
familyは "glm "と "lm "クラスのメソッドを持つ汎用関数です（後者はgaussian()を返します）。
信頼区間は、1標本の場合はbinom.test、2標本の場合はbinom.testと同様に計算されます。
正式には次数は（次のように...）命名されるべきであるが、長さ1の無名の第2引数は次数として解釈され、poly(x, 3)が計算式に使えるようになる。
正式には次数に名前を付けるべきであるが(次のように...)、長さ1の無名の第2引数は次数として解釈される。
lambda が正でない場合はゼロとみなされ、loglink が得られる。  デフォルトのlambda = 1はidentitylinkを与える。
groups, n, between.var, power, within.var, sig.levelのパラメータのうち1つだけをNULLとして渡す必要があり、そのパラメータは他のパラメータから決定される。sig.levelのデフォルトはNULLではないので、計算したい場合は明示的にNULLを渡さなければならない。
パラメータn、p1、p2、power、sig.levelのうち正確に1つをNULLとして渡す必要があり、そのパラメータは他のパラメータから決定される。  sig.levelのデフォルトはNULLではないので、計算したい場合は明示的にNULLを渡さなければならない。
n、delta、power、sd、sig.levelのパラメータのうち1つだけがNULLとして渡されなければならず、そのパラメータは他のパラメータから決定される。  最後の2つはデフォルトではNULLではないので、計算したい場合は明示的にNULLを渡さなければならないことに注意してください。
定数と線形トレンドを組み込んだ一般的な回帰式が使用され、1次の自己回帰係数が1に等しい場合の補正されたt統計量が計算されます。  igma^2を推定するために、Newey-West推定量が使用される。  lshortがTRUEの場合、切り捨てラグパラメータはtrunc(4*(n/100)^0.25)に設定され、そうでない場合はtrunc(12*(n/100)^0.25)が使用される。  p値はBanerjee et al(1993)の103ページの表4.2から補間したものである。
0 < a < 1の場合、結果の値は(0,1)(境界を除く)の中にある。いずれにせよ、結果のシーケンスは[0,1]で対称であり、すなわち、p + rev(p) == 1である。
ポアソン分布は密度
基本的な方法はFriedman(1984)によるもので、基本的にはS-PLUSのppregで使われているコードと同じです。  このコードは使用するコンパイラに非常に敏感である。
計算は共分散行列の固有値ではなく、データ行列の特異値分解によって行われます。  これは一般的に数値的な正確さのために好ましい方法です。  これらのオブジェクトのprint メソッドは結果をきれいな形式で表示し、plot メソッドはscree プロットを作成します。
線形モデルに類似したほとんどの予測メソッドには、予測に使用する説明変数を探す最初の場所を指定する引数 newdata があります。  newdataの列をフィッティングに使用される列と一致させるために、かなりの試みがなされます。たとえば、それらが比較可能なタイプであること、任意の因子が同じ順序で同じ水準セットを持つこと（またはそうなるように変換できること）などです。
新しいデータが省略された場合，予測は適合に使用されたデータに基づく．  その場合、元のフィットで欠損値を持つケースがどうなるかは、そのfitのna.action引数によって決定される。  na.action=na.omitの場合、省略されたケースは残差に現れないが、na.action=na.excludeの場合は、残差値NAで（予測値と標準誤差に）現れる。  napredictも参照。
predict.lm は、フレーム newdata (デフォルトはmodel.frame(object))で回帰関数を評価することによって得られる予測値を生成します。  論理se.fitがTRUEの場合、予測値の標準誤差が計算されます。  数値引数scaleが設定されている場合（オプションのdf付き）、標準誤差の計算で残差標準偏差として使用され、そうでない場合はモデル適合から抽出されます。区間を設定すると、指定された水準での信頼区間または予測（許容）区間の計算が指定されます。
現在のところ、基本Rでは一般的な関数のみが提供されていますが、いくつかのアドオンパッケージにはメソッドがあります。主にSとの互換性のためにここにある。
princompは "formula "と "default "メソッドを持つ汎用関数である。
NA
NA
投影はオブジェクトの各層に与えられるので、Error項を持つaovmodelsの結果は投影のリストになる。
これらは、負荷量行列の構造を明らかにするために、因子 x %*% T の「回転」を求める。  行列T は，varimax の場合は回転（場合によっては反射を伴う）であるが，promax の場合は一般的な線形変換であり，因子の分散は保存される．
成功数と失敗数が有限であるグループのみが使用される。成功数と失敗数は、非負でなければならず、したがって、対応する試行数（正でなければならない）より大きくはならない。  すべての有限回数は整数でなければならない。
NA
この分布は次のようにして得られる。  xを原点に対して対称な連続分布からの大きさnの標本とする。  そしてウィルコクソン符号付き順位統計量は，x[i]が正である絶対値x[i]の順位の和である。  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24である。
df=n自由度を持つt分布の密度は次のようになる。
ng =nrangesが1より大きい場合，Rは，それぞれnmeans観測のng個のグループの最大値である．
minまたはmaxが指定されない場合、それぞれ0と1のデフォルト値となる。
形状パラメータ a とスケール・パラメータ b を持つワイブル分布は，次式で与えられる密度を持つ．
この分布は次のように得られる。  xとyを大きさmとnの2つの無作為な独立標本とすると、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数である。  この統計量は，0 から m * n の間の値をとり，その平均と分散は，それぞれ m * n / 2 と m * n * (m + n + 1) / 12である．
パラメータshape1 = a およびshape2 = bを持つベータ分布は，密度を持つ
size = n andprob = p の二項分布は密度を持つ。
誕生日のパラドックスとは、23人という非常に少ない人数で、2人以上が同じ誕生日である確率が50/50になるというものである。  この関数は、0.5以外の確率、2以外の一致イベントの数、365以外のクラスの数に対して計算を一般化する。
位置とスケールが指定されない場合、それぞれデフォルト値の0と1と仮定される。
自由度 df= n ≥ 0 のカイ2乗分布は，密度
rateが指定されない場合は，デフォルト値1が仮定される．
df1 = n1 および df2 =n2 の自由度を持つF分布の密度
scale が省略された場合は，デフォルト値1となる．
prob = pの幾何分布が密度を持つ
超幾何分布は，置換なしのサンプリングに使用される．  この分布の密度は，パラメータm，n，k（以下の参考文献ではそれぞれNp，N-Np，nと命名されている。
対数正規分布は密度
位置またはスケールが省略された場合，それぞれ0と1のデフォルト値となる．
サイズ = n、確率 = p の負の2項分布は密度を持つ。
mean または sd が指定されない場合、それぞれデフォルト値 0 および 1 となる。
ポアソン分布の密度
NA
NA
NA
この分布は次のように得られる。  x を原点について対称な連続分布からの大きさ n の標本とする。  そしてウィルコクソンの符号付き順位統計量は，x[i]が正である絶対値x[i]の順位の和である。  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24である。
df=n自由度を持つt分布の密度は次のようになる。
ng =nrangesが1より大きい場合，Rは，それぞれnmeans観測のng個のグループの最大値である．
quade.testは、正規性の仮定が違反される可能性のある反復されない完全ブロック計画（すなわち、グループとブロックの各水準の組み合わせについてyにちょうど1つのオブザベーションがある）の分析に使用できる。
names = TRUEの場合，names属性を持つ．
family は、クラス "glm "と "lm"（後者はgaussian()を返す）のメソッドを持つ汎用関数です。
familyは、クラス "glm "および "lm "のメソッドを持つ汎用関数です（後者はgaussian()を返します）。
family は、クラス "glm "と "lm "のメソッドを持つ汎用関数です（後者はgaussian()を返します）。
minまたはmaxが指定されない場合、それぞれデフォルト値の0と1になります。
形状パラメータ a とスケールパラメータ b を持つワイブル分布の密度は次式で与えられる。
この分布は次のようにして得られる。  xとyを大きさmとnの2つの無作為な独立標本とすると、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数である。  この統計量は，0 から m * n の間の値をとり，その平均と分散は，それぞれ m * n / 2 と m * n * (m + n + 1) / 12である．
NA
パラメータshape1 = a およびshape2 = bを持つベータ分布は、密度を持つ
size = n、prob = pの2項分布には密度があります。
locationとscaleが指定されない場合、それぞれデフォルト値の0と1を仮定する。
df= n≥ 自由度0のカイ2乗分布には密度があります。
read.ftableは、ファイルから平坦な分割表を読み込みます。  ファイルがフラットテーブルの記述表現（より正確には、列変数の名前とレベルに関するすべての情報を含むヘッダと、行変数の名前を含む行）を含む場合、それ以上の引数は必要ありません。  同様に、最初の行の唯一の項目である列変数名が1つだけのフラットテーブルも自動的に処理されます。  skipを使用してヘッダー情報をすべてスキップし、row.var.namesとcol.varsをそれぞれ使用して行変数の名前と列変数の名前とレベルを指定することで、他の変種を処理することができます。  以下の例を参照してください。
NA
NA
これは、reorder() として、単に factor(x, levels = levels(x)[......])を呼び出す特殊なケースです。
これは、relevel() として、単純に callfactor(x, levels = levels(x)[......])の特殊なケースです。
formula がデータ・フレームでデータが欠損している場合、formula は数式 ~ .
reshape()は様々な文脈で使用できるが、その動機となるアプリケーションは縦断的研究のデータであり、この関数の引数はその用語で命名され説明される。縦断的研究の特徴は、異なる時点（すべての単位で同じであると仮定される）で、研究される各単位（例えば、個々の人）で、同じ変数（例えば、身長と体重）の測定を繰り返すことである。これらの変数は時変変数と呼ばれる。調査には、各単位について一度だけ測定され、時間によって変化しない他の変数（例えば、性別や人種）を含めることができる；これらは時間一定変数と呼ばれる。
NA
NA
参考文献は、残差のタイプを定義している：Davison & Snell は、それぞれの使用法に関する良いリファレンスです。
汎用アクセッサ関数 coef、effects、fitted、residuals は、lm が返す値の様々な有用な特徴を抽出するために使用できます。
rateが指定されない場合は、デフォルト値の1とみなされます。
df1 = n1、df2 = n2の自由度を持つF分布の密度は1です。
scale が省略された場合、デフォルト値1となる。
prob = pの幾何分布が密度を持つ
超幾何分布は，置換なしのサンプリングに使用される．  この分布の密度は，パラメータm，n，k（以下の参考文献ではそれぞれNp，N-Np，nと命名されている。
対数正規分布は密度
locationまたはscaleが省略された場合、それぞれ0と1のデフォルト値となる。
x が K 成分ベクトルである場合、 dmultinom(x, prob)は確率である。
サイズ = n、prob = p の負の2項分布は、密度
mean と sd が指定されない場合は、それぞれデフォルトの値 0 と 1 となる。
ポアソン分布の密度
この分布は，次のように得られる．  x を原点について対称な連続分布からのサイズ n の標本とする。  そしてウィルコクソンの符号付き順位統計量は，x[i]が正である絶対値x[i]の順位の和である。  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24である。
主な高レベル関数は、influence.measuresで、各モデル変数のDFBETAS、DFFITS、共分散比、クックの距離、ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します。  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされます。
主な高レベル関数は，influence.measuresで，各モデル変数のDFBETAS，DFFITS，共分散比，クックの距離，ハット行列の対角要素を示すクラス "infl" オブジェクトの表形式表示を作成します．  これらの尺度のいずれかに関して影響力のあるケースは、アスタリスクでマークされる。
df = n自由度を持つ t 分布は，密度を持つ
min および max が指定されない場合，それぞれデフォルト値 0 および 1 となる．
終了値を除けば，結果 y = runmed(x, k) は，単に y[j] = median(x[(j-k2):(j+k2)]) (k = 2*k2+1) となり，非常に効率的に計算される．
形状パラメータaとスケールパラメータbを持つワイブル分布は，次式で与えられる密度を持つ．
この分布は次のようにして得られる。  xとyを大きさmとnの2つの無作為な独立標本とする。そして、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数である。  この統計量は，0 から m * n の間の値をとり，その平均と分散は，それぞれ m * n / 2 と m * n * (m + n + 1) / 12である．
R^pのX1,...,Xm,Xiが平均(ベクトル)0、共分散行列Σを持つm個の独立な多変量ガウスの標本である場合、M = X'Xの分布はW_p(Σ, m)となります。
loess.smoothは, xの範囲をカバーする等間隔の点でloess smoothを評価する補助関数です.
NA
varと同様、分母n - 1を使用します。
コントラストは、通常、ある平均が有意に異なるかどうかを検定するために使用されます。係数から直接計算するよりも、se.contrastを使用する方が簡単です。
nls() は、これらの自己開始モデルに対して getInitial と initial 関数を呼び出します。
NA
NA
後者は(漸近的/近似的に)一般化されたガウス("最小二乗法")問題に対して一般的に正しいものです。
これはジェネリック関数です。  この関数の使い方の詳細については、個々のモデリング関数を参照してください。
3は長さ3の中央値を実行するためのTukeyの短い表記法で、3Rは収束するまで3を繰り返す、Sは長さ2または3の水平ストレッチの分割を意味する。
xもyも欠損値や不定値を含むことは許されない。
smoothEndsは，'終点スムージング'，つまり，ウィンドウkの半分よりも始点/終点に近いオブザベーションだけを変更するためだけに使用される．
NA
NA
生のピリオドグラムはスペクトル密度の一貫性のある推定値ではないが、隣接する値は漸近的に独立である。したがって、スペクトル密度が平滑であると仮定して、生のピリオドグラムを平滑化することで、一貫性のある推定値を導き出すことができる。
コサイン・ベル・テーパーは、時系列x[, i]の最初と最後のp[i]オブザベーションに適用される。
spectrumは、メソッドspec.pgramとspec.arを呼び出すラッパー関数です。
method = "fmm "の場合、使用されるスプラインは、Forsythe, Malcolmand Molerのスプライン（データの両端の4点を通して正確な3次がフィットされ、これは終了条件を決定するために使用される）。
method = "fmm "の場合、使用されるスプラインはForsythe, Malcolmand Molerのものである（データのeachendの4点を通して正確な3次がフィットされ、これが終了条件を決定するために使用される）。
method = "fmm "の場合、使用されるスプラインはForsythe, Malcolmand Molerのものである（正確な3次曲線がデータのeachendの4点を通してフィットされ、これが終了条件を決定するために使用される）。
NA
NA
NA
NA
NA
NA
NA
NA
NA
NA
このモデルはSSasympモデルを一般化したもので、pwrが単一であるときにSSasympに還元されます。
月系列1995.5はc(1995, 7)として表現される。頻度fの系列では、timen+i/fはc(n, i+1)と表現される（i = 0, f = 1の場合でも）。
NA
AICがMallowsのCpと等しくなるように加法定数を選択できる場合、これは実行され、表は適切にラベル付けされる。
NA
季節成分は、これらの季節の部分系列（1月のすべての値の系列、...）をLoess平滑化することによって発見される; ifs.window = "periodic" 平滑化は、平均をとることによって効果的に置き換えられる。季節値は除去され、残りはトレンドを見つけるために平滑化される。全体的なレベルは、これらの季節成分から取り除かれ、トレンド成分に加えられる。このプロセスを数回繰り返す。  残りの成分は、季節＋トレンドフィットからの残差である。
構造時系列モデルは、時系列をいくつかの成分に分解することに基づく（一変量）時系列の（線形ガウス）状態空間モデルである。誤差分散の集合によって指定され、そのうちのいくつかはゼロである可能性がある。
NA
print.summary.glmは、係数や標準誤差などの書式を工夫し、さらにsignif.starsがTRUEであれば「有意性の星」を表示します。  この3番目の列は、分散が推定されている場合は t 比、分散が既知（または族によって固定）の場合は z 比と表示される。  4番目の列は，Student t または正規参照分布に基づく t 比または z 比に対応する両側p値を与える．  (分散が既知ではなく，それを推定するための自由度が残されていない可能性がある．  その場合、推定値はNaNとなる)。
print.summary.lmは、係数や標準誤差などの書式をスマートにしようとし、さらにsignif.starsがTRUEであれば'有意性の星'を表示します。
summary.manovaメソッドは、要約表に多変量検定統計量を使用します。  Wilksの統計量が文献上最も一般的ですが、デフォルトのPillai-Bartlett統計量はHand and Taylor (1987)によって推奨されています。
NA
supsmuは、3つのスパンから直線を選択するランニングラインスムーサーです。ランニングラインスムーサーは対称で、予測点の両側にk/2個のデータ点を持ち、kの値は0.5 * n, 0.2 * n, 0.05 * nで、renはデータ点の数です。  spanが指定された場合、span * nを持つ単一のスムーザーが使用されます。
NA
alternative = "greater" は、xがyよりも大きな平均を持つという選択肢です。
モデル・オブジェクトは、statsパッケージのglmやsurvivalパッケージのcoxphやsurvregのように、 type = "terms "を受け付けるpredictメソッドを持っていなければなりません。
クラス "aovlist "と "terms "の "formula"（terms.formulaを参照）のためのメソッドがあります：デフォルトのメソッドは、単にオブジェクトのtermsコンポーネントを抽出するか、失敗すると "terms "属性（model.frameで使用される）を抽出します。
すべてのオプションがSと同じように動作するわけではありませんし、すべてが実装されているわけでもありません。
これらはすべて汎用関数であり、xのtsp属性が存在すればそれを使用します。timeとcycleには、結果をそのクラスに強制するクラスts用のメソッドがあります。
NA
ts関数は、時系列オブジェクトを作成するために使用されます。  これらは、"ts "クラス（および追加属性）を持つベクトルまたは行列であり、時間内の等しい間隔でサンプリングされたデータを表します。  行列の場合、行列データの各列は、1つの（単変量の）時系列を含むと仮定されます。時系列は、少なくとも1つのオブザベーションを持つ必要があり、数値である必要はありませんが、非数値系列のサポートは非常に限られています。
特殊なケースとして、...は、1行の時系列だけでなく、存在する時系列の結合時系列と同じ長さのベクトルまたは行列を含むことができる。
NA
特殊なケースとして，...は，1行のものと同様に，存在する時系列の結合時系列と同じ長さのベクトルまたは行列を含むことができる．
これは汎用的な関数です。通常、残差（多くの場合、標準化されたもの）、残差の自己相関関数、およびgof.lagまでのすべてのラグに対するPortmanteau検定のp値をプロットします。
tsp属性は、時間単位での開始時刻、終了時刻、頻度（月次系列では12など、時間単位あたりのオブザベーション数）を示します。
tsp属性は、時間単位での開始時刻、終了時刻、頻度（時間単位あたりのオブザベーション数、例えば月次系列では12）を与える。
NA
これは汎用関数である：ここでの説明は、クラス "aov "の適合のための手法に適用される。
...以降の引数は正確に一致しなければならないことに注意。
NA
NA
oldとnewのどちらか一方または両方は、as.formulaを介して式に強制することができる長さ1文字のベクトルなどのオブジェクトにすることができます。
covとcorについては、xに行列のordataフレームを与えるか、xとyの両方を与えなければならない。
帰無仮説は、xとyが抽出された母集団の分散の比、または線形モデルxとyが適合されたデータの分散の比がratioと等しいというものである。
NA
これらは，負荷量行列の構造を明らかにするために，因子 x %*% T の「回転」を求める．  行列T は，varimax の場合は回転（場合によっては反射を伴う）であるが，promax の場合は一般的な線形変換であり，因子の分散は保持される．
この関数のメソッドを持つクラスには、lm, mlm, glm, nls, summary.lm, summary.glm, negbin, polr, rlm (MASSパッケージ), multinom (nnetパッケージ) gls, lme (nlmeパッケージ), coxph, survreg (survivalパッケージ)があります。
これは汎用関数であり、最初の引数xに対してメソッドを定義することができる。 デフォルトのメソッド以外に、日付時刻クラス "POSIXct"、"POSIXlt"、"difftime"、"Date "に対するメソッドがある。  デフォルト・メソッドは、[, 乗算, 除算, 和算が適切なメソッドを持つ数値のようなオブジェクト（複素数ベクトルも含む）に対して動作します。
重み付き残差はデビアンス残差に基づくもので、lmフィットの場合は生の残差にwi^0.5を掛けたものです。
NA
この数式インターフェースは、2標本検定にのみ適用できる。
開始時刻と終了時刻はtsと同様に指定できる。新しい開始時刻または終了時刻にオブザベーションがない場合は、直後の（開始）または直前の（終了）オブザベーション時刻が使用されます。
開始時刻と終了時刻はtsと同様に指定できる。新しい開始時刻または終了時刻に観測がない場合は、その直後(開始時刻)または直前(終了時刻)の観測時刻が使用される。
read.ftableは、ファイルから平坦な分割表を読み込む。  ファイルがフラットテーブルの記述された表現（より正確には、列変数の名前とレベルに関するすべての情報を含むヘッダと、行変数の名前を含む行）を含む場合、それ以上の引数は必要ありません。  同様に、最初の行の唯一の項目である列変数名が1つだけのフラットテーブルも自動的に処理されます。  skipを使用してヘッダー情報をすべてスキップし、row.var.namesとcol.varsをそれぞれ使用して行変数の名前と列変数の名前とレベルを指定することで、他の型にも対応できます。  以下の例を参照してください。
tableまたはxtabs(*, sparse = FALSE)によって作成された分割表オブジェクトには、基本的な情報を与え、因子の独立性についてカイ2乗検定を実行する要約メソッドがあります（chisq.test関数は現在2次元表しか扱えないことに注意してください）。
