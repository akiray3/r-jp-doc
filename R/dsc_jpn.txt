x
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
Date "クラスの演算子。
カレンダーの日付と時刻を表すクラス "POSIXlt" と "POSIXct" の説明。
正規シーケンスの生成。
ネームスペース内のエクスポートされた変数と内部変数、つまりRオブジェクト（遅延ロードされたデータセットを含む）へのアクセス。
名前空間内の R オブジェクト（遅延ロードされたデータセットを含む）。
これらの演算子は、生のベクトル、論理ベクトル、数値に似たベクトルに作用する。
整数を16進数形式に変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
整数を8進数形式に変換または印刷します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
原子ベクトルの値の比較を可能にする二項演算子。
開括弧()および開中括弧{は、Rにおける原始関数である。
ベクトル、行列、配列、リストに作用する演算子。
オブジェクトのクラスを変更して、「そのまま」扱うことを示す。
データ・フレームの部分集合の抽出または置換。
カレンダーの日付を表すクラス "Date" の説明。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時差 "を呼び出す。
ベクトル、行列、配列、リストに作用する演算子。
この関数は、Rセッションに現在ロードされているすべてのDLL(seedyn.load)のリストを取得する方法を提供します。
因子の部分集合を抽出または置換します。
整数を16進数形式に変換または表示します。その際、最大値を表示するのに必要な桁数だけ、必要に応じて先頭のゼロを使用します。
ベクトル、行列、配列、リストに対して作用する演算子で、部分の抽出や置換を行う。
文字列を引用符なしで表示します。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルな S3 クラスと、それに関連するメソッド。
8進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数だけ変換または表示します。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
ベクトル、行列、配列、リストに作用する演算子。
table は、交差分類因子を使用して、各因子レベルの組み合わせにおけるカウントの分割表を作成します。
warningsとそのprintメソッドは、変数last.warningを見やすい形で表示します。
ベクトル、行列、配列、リストに作用する演算子。
データ・フレームの部分集合の抽出または置換。
カレンダーの日付を表すクラス "Date" の説明。
因子の部分集合を抽出または置換します。
パッケージ・バージョンを含む数値バージョンを表す単純な S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt" と "POSIXct" の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
ベクトル、行列、配列、リストに作用する演算子。
データ・フレームの部分集合の抽出または置換。
因子の部分集合の抽出または置換。
パッケージ・バージョンを含む数値バージョンを表す単純な S3 クラスと、それに関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
ベクトル、行列、配列、リストに作用する演算子で、部分の抽出や置換を行う。
データ・フレームの部分集合の抽出または置換。
カレンダーの日付を表すクラス "Date" の説明。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時差 "を呼び出します。
因子の部分集合の抽出または置換。
パッケージ・バージョンを含む数値バージョンを表す単純な S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
開括弧()と開中括弧{はRの原始関数である。
形式的(S4)なクラス構造を持つオブジェクトのスロットの内容を抽出または置換する。
形式的な(S4)クラス構造を持つオブジェクトのスロットの内容を抽出または置換します。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらを "時間差 "と呼びます。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル (またはそれらに強制することができるオブジェクト) に対して演算を実行します。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらを "時差 "と呼びます。
これらの演算子は、生のベクトル、論理ベクトル、および数値のようなベクトルに作用します。
整数を16進数形式に変換または印刷します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
8進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数で変換または表示する。
これらの演算子は、生のベクトル、論理ベクトル、および数値に似たベクトルに作用します。
2つの行列が適合する場合、2つの行列を乗算します。  一方の引数がベクトルの場合、行行列または列行列に昇格され、2つの引数を適合させる。  両方が同じ長さのベクトルであれば、（行列としての）内積を返します。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
matchは、その第2引数における第1引数の（最初の）マッチの位置のベクトルを返す。
配列XとYの外積は、c(dim(X), dim(Y))次元の配列Aとなり、ここで elementA[c(arrayindex.x, arrayindex.y)] = FUN(X[arrayindex.x], Y[arrayindex.y], ...) となります。
2つの配列XとYの一般化クロネッカー積を計算する。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
Date "クラスの演算子。
カレンダーの日付と時刻を表すクラス "POSIXlt" と "POSIXct" の説明。
アトミック・ベクトルの値の比較を可能にする二項演算子。
名前に値を代入する
名前に値を代入する。
アトミックベクトル内の値の比較を可能にする二項演算子。
名前に値を代入する。
アトミックベクトル内の値の比較を可能にする二項演算子
原子ベクトル内の値の比較を可能にする二項演算子。
アトミック・ベクター内の値の比較を可能にする二項演算子。
これらの演算子は、生ベクトル、論理ベクトル、および数値ライクベクトルに作用する。
最大値を表示するのに必要な桁数の整数を16進数形式に変換または表示する。
8進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数で変換または表示する。
これらの演算子は、生のベクトル、論理ベクトル、数値に似たベクトルに作用する。
チルダは、モデル式の左辺と右辺を区切るのに使われます。
ベクトル、行列、配列、リストに作用する演算子で、部分の抽出や置換を行います。
この関数は、Rセッションに現在ロードされているすべてのDLL（seedyn.load）のリストを取得する方法を提供します。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルな S3 クラスと、関連するメソッド。
ベクトル、行列、配列、リストに作用する演算子。
データフレームのサブセットを抽出または置換します。
strict=TRUEでない限り，文字列を（一意であったとしても）一意なまま，少なくとも最小の長さの文字に省略する。
abs(x)はxの絶対値を計算し、sqrt(x)はxの(主)平方根、√{x}を計算します。
これらの関数は明らかな三角関数を与えます。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算する。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または「面積余弦」など）を計算します。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
factor関数はベクトルを因子としてエンコードするために使用されます（因子には'category'と'enumerated type'という用語も使用されます）。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数も用意されている。
addTaskCallbackは、トップレベルタスクが完了するたびに呼び出されるR関数を登録する。
一般化レーベンシュタイン編集距離（ある文字列を別の文字列に変換するのに必要な、挿入、削除、置換の最小の加重数）を用いて、文字列x（2番目の引数）の各要素内でパターン（1番目の引数）に近似的にマッチするものを探索する。
一般化レーベンシュタイン編集距離（1つの文字列を別の文字列に変換するのに必要な、挿入、削除、置換の最小可能加重数）を使って、文字列x（2番目の引数）の各要素内でパターン（1番目の引数）に近似的にマッチするものを検索する。
両方の種類のRリストを構築、強制、チェックする関数。
論理ベクトル集合が与えられたとき、すべての値は真か？
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しいか'をテストしながら比較するユーティリティです。  もし両者が異なっていても、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合でも、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合でも、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合でも、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合でも、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合でも、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しい'テストとして比較するユーティリティです。  両者が異なる場合でも、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用します。
式または呼び出しで出現するすべての名前を含む文字ベクトルを返します。
式または呼び出しで出現するすべての名前を含む文字ベクトルを返します。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供する。
論理ベクトル・セットが指定された場合、値の少なくとも 1 つが真か?
duplicated() は、ベクトルまたはデータ・フレームのどの要素が添え字の小さい要素と重複しているかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複してい るかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複してい るかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複してい るかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複して いるかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
NA は、欠落値インジケータを含む長さ 1 の論理定数です。  NA は、raw 以外の任意のベクトル型に強制することができる。  NA_integer_,NA_real_,NA_complex_,NA_character_という定数もあり、これらはすべてR言語の予約語である。
NAは欠損値インジケータを含む長さ1の論理定数である。  NAはraw以外の任意のベクトル型に強制することができる。  NA_integer_,NA_real_,NA_complex_,NA_character_という定数もあり、これらはすべてR言語の予約語です。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連メソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
次元を並べ替えて配列を転置し、オプションでサイズを変更する。
次元の並べ替えによる配列の転置と、サイズ変更。
次元の並べ替えによる配列の転置と、サイズ変更。
ベクトルに要素を追加する。
Vector関数は、配列または行列の余白に関数を適用して得られたベクトルまたは配列、または値のリストを返します。
算術演算子 +、-、*、/、^ に加えて、R で複素数演算をサポートする基本関数。
関数またはプリミティブの引数名と対応するデフォルト値を表示します。
配列の作成または検定
論理オブジェクトの TRUE インデックスを指定します。
配列の作成またはテスト
配列の作成またはテストを行います。
call "モード（または"("、詳細参照）のオブジェクトを作成またはテストする。
character "型のオブジェクトを作成またはテストする。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
文字表現と、カレンダーの日付を表す "Date "クラスのオブジェクトを変換する関数。
character" 型のオブジェクトを作成またはテストします。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
character" 型のオブジェクトの作成またはテスト。
16進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数で変換または表示します。
パッケージ・バージョンを含む数値バージョンを表現するシンプルな S3 クラスと、関連するメソッド。
必要に応じて先行ゼロを使用し、最大値を表示するために必要な桁数の8進数形式で整数を変換または表示します。
文字表現と、「POSIXlt」クラスおよび「POSIXct」クラスの暦日および時刻を表すオブジェクトとの間で変換を行う関数。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（「srcref」）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型 R セッション（options(keep.source = TRUE) の場合）で使用できます。
算術演算子 +, -, *, /, ^ に加え、R の複素数演算をサポートする基本関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
オブジェクトがデータ・フレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
カレンダーの日付を表すクラス "Date "の説明。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする、あるいは可能であればそれを強制する関数
オブジェクトがデータフレームであるかどうかを調べる、または可能であれば強制する関数
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
パッケージ・バージョンと関連するメソッドを含む、数値バージョンを表現するためのシンプルなS3クラス。
オブジェクトがデータ・フレームであるかどうかをチェックする関数と、可能であればそれを強制する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
オブジェクトがデータ・フレームであるかどうかをチェックする関数。
テーブルは、分類横断因子を使用して、各因子レベルの組み合わせにおけるカウントの分割表を構築する。
オブジェクトがデータ・フレームであるかどうかをチェックする関数。
オブジェクトがデータフレームであるかどうかをチェックする、または可能であればそれを強制する関数。
文字表現とカレンダーの日付を表す "Date "クラスのオブジェクトを変換する関数
文字表現と暦日付を表す "Date "クラスのオブジェクトとの間で変換を行う関数。
文字表現と暦日付を表す "Date" クラスのオブジェクトを変換する関数。
文字表現と暦日付を表す "Date" クラスのオブジェクトとの間で変換する関数。
文字表現と暦日付を表す "Date" クラスのオブジェクトとの間で変換する関数。
文字表現と暦日付を表す "Date" クラスのオブジェクトとの間で変換する関数。
文字表現と暦日付を表す "Date "クラスのオブジェクトを変換する関数。
時間間隔の作成、印刷、および一部の演算。  print()メソッドは、これらの "時差 "を呼び出します。
倍精度ベクトルの作成、強制、テスト。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時間差 "を呼び出します。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
Rオブジェクトを環境に強制する汎用関数。  数値または文字列を検索パス上の対応する環境に変換します。
expression "モードのオブジェクトを作成またはテストします。
モード "expression "のオブジェクトを作成またはテストします。
factor 関数は、ベクトルを factor としてエンコードするために使用されます（'category' および 'enumerated type' という用語も factor に対して使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のために、as.functionという関数もある。
as.functionはオブジェクトを関数に変換する汎用関数です。
as.functionはオブジェクトを関数に変換する汎用関数です。
整数を16進数形式に変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
integer" 型のオブジェクトを作成またはテストする。
両方の種類のRリストを作成、共有、チェックする関数。
両方の種類のRリストの構築、共有、チェックを行う関数。
カレンダーの日付を表すクラス "Date "の説明。
両方のRリストの作成、強制、チェックのための関数。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時差 "を呼び出す。
Rリストの作成、共有、チェックに関する関数。
Rリストの作成、共有、チェックに関する関数。
Rリストの作成、共有、チェックを行う関数。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
logical "型のオブジェクトと基本logical定数を作成またはテストする。
logical "型のオブジェクトと基本logical定数の作成またはテスト。
matrix は、指定された値の集合から行列を作成します。
matrix は、指定された値の集合から行列を作成します。
matrixは、指定された値の集合から行列を作成します。
文字列を引用符なしで表示します。
カレンダーの日付と時刻を表すクラス "POSIXlt" と "POSIXct" の説明。
名前」（「シンボル」とも呼ばれる）は、Rオブジェクトを名前で参照する方法である（その名前にバインドされているオブジェクトがあれば、その値ではなく）。
NULLはRのNULLオブジェクトを表し、予約語です。  NULLは、値が未定義の式や関数からよく返されます。
NULLはRのNULLオブジェクトを表し、予約語である。  NULLは、値が未定義の式や関数からよく返されます。
is.numericは、オブジェクトが数値として解釈可能かどうかを判定する、より一般的なテストです。
パッケージ・バージョンと関連するメソッドを含む数値バージョンを表現するためのシンプルなS3クラスです。
8進数形式で整数を変換または表示します。最大値を表示するために必要な桁数で、必要に応じて先頭のゼロを使用します。
factor 関数は、ベクトルを因子としてエンコードするために使用されます（因子には 'category' と 'enumerated type' という用語も使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
両方の種類のRリストを構築、強制、チェックする関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトを操作する関数。
qr ： 行列のQR分解を計算する。
raw "型のオブジェクトの作成またはテスト。
倍精度ベクトルの作成、変換、テスト。
倍精度ベクトルの作成、変換、テスト。
名前」（「シンボル」とも呼ばれる）は、R オブジェクトを（その名前にバインドされているオブジェクトがあれば、その値ではなく）名前で参照する方法である。
テーブルは、分類横断因子を使用して、各因子レベルの組み合わせでのカウントの分割表を構築します。
table は、因子レベルの各組み合わせにおけるカウントの分割表を構築するために、分類横断因子を使用します。
vector は、指定された長さとモードのベクトルを作成します。
vector は、与えられた長さと最頻値のベクトルを生成する。
これらの関数は，明らかな三角関数を与える．  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算します。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または「面積余弦」など）を計算します。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、base名前空間の特別な性質によってのみ見える。
配列または行列を余白で分割します。
オブジェクトが S4 クラスのインスタンスであるかどうかをテストします。
オブジェクトが S4 クラスのインスタンスであるかどうかを調べます。
環境内の名前に値を代入します。
これらの関数は明らかな三角関数を与えます。  これらの関数はそれぞれ、余弦、正弦、正接、円弧余弦、円弧正弦、円弧正接、および 2 つの引数を持つ円弧正接を計算します。
これらの関数は明らかな三角関数を与える。  これらの関数は、コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算します。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または「面積余弦」など）を計算する。
データベースはRの検索パスにアタッチされます。  これは、変数を評価する際にRによってデータベースが検索されることを意味し、データベース内のオブジェクトは名前を指定するだけでアクセスできる。
名前空間のロードとアンロードを行う関数。
オブジェクトの特定の属性を取得または設定する関数。
all.equal(x,y)は、Rオブジェクトxとyを'ほぼ等しいかどうか'をテストしながら比較するユーティリティです。  もし異なっていても、比較はある程度行われ、差分のレポートが返されます。    isTRUE(all.equal(...))を使用するか、適切であればidenticalを使用してください。
オブジェクトの特定の属性を取得または設定します。
これらの関数はオブジェクトの属性にアクセスします。以下の最初の形式はオブジェクトの属性リストを返します。
これらの関数は、オブジェクトの属性にアクセスします。以下の最初のフォームは、オブジェクトの属性リストを返します。代替フォームは、割り当ての右側のリストをオブジェクトの属性として使用します（適切な場合）。
autoloadはpromise-to-evaluate autoloaderを作成し、.AutoloadEnv環境にnameという名前で格納します。Rがnameを評価しようとすると、autoloaderが実行され、パッケージがロードされ、新しいパッケージの環境でnameが再評価されます。  その結果、Rはあたかもパッケージがロードされたかのように振る舞うが、メモリを占有することはない。
autoloadはpromise-to-evaluate autoloaderを作成し、.AutoloadEnv環境にnameという名前で格納します。Rがnameを評価しようとすると、autoloaderが実行され、パッケージがロードされ、nameが新しいパッケージの環境で再評価されます。  その結果、Rはあたかもパッケージがロードされたかのように振る舞うが、メモリは占有しない。
三角連立一次方程式を解く。
環境の取得、設定、テスト、作成。
basenameは、lastpathセパレータ（もしあれば）を含むすべてのパスを削除します。
整数次と分数次のBessel関数、第1種と第2種のJ(ν)とY(ν)、および修正Bessel関数(第1種と第3種の)、I(ν)とK(ν)
第1種および第2種の整数および分数次のBessel関数、J(ν)およびY(ν)、ならびに修正Bessel関数（第1種および第3種）、I(ν)およびK(ν)。
第1種および第2種の整数および分数次のBessel関数、J(ν)およびY(ν)、ならびに修正Bessel関数（第1種および第3種）、I(ν)およびK(ν)。
整数次と分数次のベッセル関数，第1種と第2種のJ(ν)とY(ν)，および修正ベッセル関数（第1種と第3種の）I(ν)とK(ν)．
ベータ関数とガンマ関数に関連する特殊な数学関数。
これらの関数は、環境の調整や環境内のバインディングのためのインターフェイスを表す。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができる。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数を関数にリンクすることができます。
ネイティブ言語サポート(NLS)がRのこのビルドで有効になっている場合(bindtextdomain()の例を参照)、文字ベクトルの翻訳を試みたり、翻訳を見つける場所を設定したりします。
要素をビットの集合と見なした整数ベクトルに対する論理演算。
要素をビットの集合とみなす整数ベクトルに対する論理演算。
要素をビットの集合と見なした整数ベクトルに対する論理演算
要素をビットの集合とみなす整数ベクトルに関する論理演算
要素をビットの集合とみなす整数ベクトルに関する論理演算
要素をビットの集合と見なした整数ベクトルに対する論理演算
関数の本体を取得または設定する。これは基本的に関数定義のすべてであるが、形式引数（formals）については「詳細」を参照のこと。
基本的には関数定義のすべてであるが、形式引数(formals)を含む関数の本体を取得または設定する。
LISPのbackquoteマクロのアナローグです。 bquoteは、()でくくられた項が指定されたwhere環境で評価されることを除いて、 その引数を引用します。splice = TRUEの場合、.()に包まれた用語は評価され、呼び出しにスプライスされる。
これらはR言語の基本的な制御フロー構成要素である。  Algol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
式の実行を中断し、ブラウザが呼び出された環境を検査できるようにする。
ブラウザの呼び出しは、テキスト引数か条件引数を与えることでコンテキストを提供することができる。  これらの関数は、これらの引数のいずれかを取得するために使用することができます。
ブラウザの呼び出しは、text引数またはcondition引数のいずれかを指定することで、コンテキストを提供することができる。  これらの関数は、これらの引数のいずれかを取得するために使用することができます。
ブラウザへの呼び出しは、text引数または条件引数のいずれかを指定することで、コンテキストを提供することができます。  これらの関数は、これらの引数のいずれかを取得するために使用できます。
すべての組み込みオブジェクトの名前を返します。  これらはRインタプリタのシンボルテーブルから直接取得されます。
関数byはデータフレームに適用されるオブジェクト指向ラッパーです。
関数byは、データフレームに適用されるapplyのオブジェクト指向ラッパーです。
関数byは、データフレームに適用されるfortapplyのオブジェクト指向ラッパーです。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
これは、引数を組み合わせる汎用関数です。
カレンダーの日付を表すクラス "Date "の説明。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの「時差」を呼び出します。
factor 関数は、ベクトルを因子としてエンコードするために使用されます（因子には 'category' および 'enumerated type' という用語も使用されます）。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
文字列を引用符なしで表示します。
パッケージ・バージョンを含む数値バージョンを表現するシンプルな S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日時を表すクラス "POSIXlt "と "POSIXct "の説明。
warningsとそのprintメソッドは、変数last.warningを喜ばせる形で表示する。
call "モード（または"("、詳細参照）のオブジェクトの作成またはテスト。
Schemeのcallの下方向のみのバージョンで、現在の継続を持つ。
Rのthisbuildにコンパイルされたオプション機能についての報告。
文字ベクトル中の文字、特に大文字から小文字、またはその逆を変換する。
オブジェクトの表現を連結して出力する。
ベクトル、行列、データフレームの一連の引数をとり、それぞれ列または行で結合する。  これらは、他のRクラス用のメソッドを持つ汎用関数です。
vector、matrix、data-frameの引数列をとり、それぞれ列または行と結合する。  これらは他のRクラスのメソッドを持つ汎用関数です。
ceilingは1つの数値引数xを取り、xの対応する要素より小さくない最小の整数を含む数値ベクトルを返す。
第2引数の要素の中で、第1引数の要素に一意に一致するものを求める。  成功すればこの要素を返し、そうでなければ第3引数で指定されたアクションを実行する。
character "型のオブジェクトを作成またはテストする。
charmatchは、第2引数の要素の中から第1引数の要素にマッチするものを探す。
raw "型のオブジェクトへの変換と操作、ビットまたは "packed "8ビットとして使用。
文字ベクトル内の文字、特に大文字から小文字への変換、またはその逆の変換。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
呼び出し元の...にある余計な引数について警告する。  例えば、形式的な...引数を必要とするが、それを使用しないS3メソッドで使用することができます。  これは、（chkDots()の呼び出し元である）問題の関数を呼び出す際のユーズドエラーをキャッチするのに役立ちます。
実対称正定値正方行列のコレスキー分解を計算します。
実対称正定値正方行列のコレスキー分解を計算します。
対称正定値正方行列をコレスキー分解から反転する。  同様に、XのQR分解の(R部分)から(X'X)^(-1)を計算する。
ベータ関数とガンマ関数に関連する特殊な数学関数。
Rには、オブジェクト指向プログラミングに使用できる簡単な汎用関数メカニズムがある。  メソッドのディスパッチは、ジェネリック関数の第1引数のクラスに基づいて行われます。
Rは、オブジェクト指向スタイルのプログラミングに使用できるシンプルなジェネリック関数メカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数の最初の引数のクラスに基づいて行われます。
テキスト行をコネクションにプッシュバックする関数と、現在プッシュバックされている行数を照会する関数。
コネクションを作成、オープン、クローズする関数。すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」への接続を作成、オープン、クローズする関数。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（「srcref」）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型Rセッション（options(keep.source = TRUE)の場合）で使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（「srcref」）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型 R セッション（options(keep.source = TRUE) の場合）で使用できます。
接続の側面を表示します。
行列のようなオブジェクトの列番号を示す整数の行列、または列ラベルの係数を返します。
数値配列（またはデータフレーム）に対して、行と列の合計と平均を計算します。
行列状オブジェクトの行名または列名の取得または設定
行列のようなオブジェクトの行や列の名前を取得したり設定したりする。
数値配列（またはデータ・フレーム）の行と列の合計と平均を作成する。
このRセッションが起動されたときに指定されたコマンドライン引数のコピーへのアクセスを提供します。
これらの関数は、Rオブジェクトのコメント属性を設定したり問い合わせたりします。  これは通常、data.frameやモデル・フィットに便利です。
これらの関数は、Rオブジェクトのcommentattributeを設定したり問い合わせたりします。  これは通常、data.framesやモデル・フィットに便利です。
算術演算子 +, -, *, /, ^ に加え、R の複素数演算をサポートする基本関数。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理する機構を提供する。
これらの関数は、エラーや警告を含む異常な状態を扱うための機構を提供する。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供する。
ライブラリおよび require アドオン・パッケージのロードとアタッチ。
conflicts は、検索パス上の 2 つ以上の場所に同じ名前で存在するオブジェクトについてレポートします。これは通常、ユーザのワークスペースまたはパッケージ内のオブジェクトが、同じ名前のシステム・オブジェクトをマスクしているためです。  これは、意図しないマスキングを発見するのに役立ちます。
算術演算子 +、-、*、/、^ に加え、R の複素数演算をサポートする基本関数。
RのWho-is-whoは、Rの開発に大きく貢献した人物を説明しています。
これらの関数は明らかな三角関数を与える。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算する。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または「面積余弦」など）を計算します。
これらの関数は、明らかな三角関数を与える。  これらの関数は、コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算します。
行列xとyを引数に与えると、行列のクロス積を返す。  これは形式的には t(x) %*% y (crossprod) または x %*% t(y) (tcrossprod) の呼び出しと等価です(しかし、通常はそれより若干高速です)。
C のスタック・サイズと使用量に関する情報を報告する(利用可能な場合)。
引数の要素の累積和、積、最小値または最大値を要素とするベクトルを返します。
引数の要素の累積和、積、極小値または極大値を要素とするベクトルを返します。
引数の要素の累積和、積、極小値または極大値を要素とするベクトルを返します。
引数の要素の累積和、積、最小値または最大値を要素とするベクトルを返します。
http://、ftp://、https://、 ftps://など、サポートされているプロトコルのURLのヘッダを取得します。 すべてのプラットフォームでサポートされているわけではないオプションの関数です。
cutは、xの範囲を区間に分割し、どの区間に該当するかによってxの値をコード化します。  一番左の区間はレベル1に対応し、次に左の区間はレベル2に対応します。
cut のメソッドを日付時刻オブジェクトに適用。
cut は、x の範囲を区間に分割し、どの区間に該当するかに従って x の値をコード化します。  一番左の区間はレベル1に対応し、次に左の区間はレベル2に対応します。
日付時刻オブジェクトに適用されるカットの方法。
任意のRオブジェクトのクラスを決定する。
data.frame()関数は、データ・フレームを作成します。データ・フレームは、マトリックスやリストの特性の多くを共有する、緊密に結合された変数の集合で、Rのほとんどのモデリング・ソフトウェアで基本的なデータ構造として使用されています。
データフレーム内のすべての変数を数値モードに変換し、それらを行列の列として結合した行列を返します。  因子と順序付き因子は、それらの内部コードに置き換えられます。
現在のシステムの日付と時刻を文字列で返します。
関数のデバッグ・フラグの設定、解除、問い合わせを行います。テキスト引数と条件引数は、ブラウザの呼び出しで与えられるものと同じです。  また、どのブレークポイントが有効化されたかを識別するためのメカニズムも提供します。
関数のデバッグ・フラグの設定、解除、問い合わせを行います。  また、どのブレークポイントが有効化されたかを識別するためのメカニズムも提供します。
関数のデバッグ・フラグの設定、解除、問い合わせを行います。  また、どのブレークポイントが有効化されたかを識別するためのメカニズムも提供します。
data.frame()関数は、データ・フレームを作成します。データ・フレームは、Rのモデリング・ソフトウェアのほとんどで基本的なデータ構造として使用されている行列やリストの特性の多くを共有する、緊密に結合された変数の集合です。
delayedAssignは、その値が要求された場合、与えられた式を評価する約束を作成します。  これは、Rが（解釈される）関数の評価に使用する遅延評価メカニズムへの直接アクセスを提供します。
未評価の式を文字列に変換する
評価されていない式を文字列に変換します。
determinantは、行列式のモジュラス（オプションで対数スケール）と行列式の符号を別々に返す汎用関数です。
データベースを切り離す、つまり、利用可能なRオブジェクトのsearch()パスから削除します。  通常、これはアタッチされているadata.frameかlibraryによってアタッチされているapackageです。
determinantは、行列式のモジュラス（オプションで対数スケール）と行列式の符号を別々に返す汎用関数です。
detは行列の行列式を計算します。 determinantisは行列式のモジュラス（オプションで対数スケール）と行列式の符号を別々に返す汎用関数です。
RオブジェクトのASCIIテキスト表現をファイル、Rconsole、または接続に書き込んだり、オブジェクトの再作成に使用したりします。
行列の対角を抽出または置換したり、対角行列を構築したりします。
行列の対角を抽出または置換、あるいは対角行列を作成します。
適切に遅延および反復された差分を返します。
関数は、適切に遅延および反復された差分を返します。
適切な遅延および反復された差分関数を返します。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時間差 "を呼び出す。
適切に遅延され、反復された差分を返す。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時間差 "を呼び出す。
ベータ関数およびガンマ関数に関連する特殊な数学関数。
オブジェクトの次元の取得または設定。
オブジェクトの寸法の取得または設定
オブジェクトの次元の取得または設定
オブジェクトの dimnames の取得または設定
オブジェクトの dimnames を取得または設定する。
オブジェクトの dimnames を取得または設定する。
オブジェクトのdimnamesの取得または設定
これらの関数は、指定されたディレクトリ内のファイル名やディレクトリ名の文字ベクトルを生成します。
これらの関数は、コンピュータのファイル・システムに対する低レベルのインタフェースを提供します。
これらの関数は、コンピュータのファイル・システムに対する低レベルのインタフェースを提供します。
basenameは、lastpathセパレータ（ある場合）を含む、lastpathまでのすべてのパスを削除します。
do.callは、関数名と関数に渡す引数のリストから関数コールを作成し、実行します。
dontCheck関数はidentityと同じですが、RのCMDチェックコード解析ではxのチェックを抑制するディレクティブとして解釈されます。
倍精度ベクトルの作成、強制、テストを行います。
RオブジェクトのASCIIテキスト表現をファイル、Rconsole、または接続に書き込んだり、オブジェクトの再作成に使用したりします。
適切なシングルまたはダブルの左引用符と右引用符を組み合わせて、テキストをシングルまたはダブル引用符で囲みます。
1つのレベルしか持たない配列の次元を削除します。
関数 droplevels は、因子から、またはより一般的にはデータ・フレーム内の因子から、使用されていないレベルを削除するために使用されます。
関数 droplevels は、afactor や、より一般的にはデータフレーム内の因子から、未使用のレベルを削除するために使用されます。
関数 droplevels は、afactor から、またはより一般的にはデータフレーム内の因子から、未使用のレベルを削除するために使用されます。
この関数は、Rオブジェクトの名前のベクトルを取り、ファイルまたは接続上のオブジェクトのテキスト表現を生成します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素が、より小さい添え字を持つ 要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複してい るかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複してい るかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated() は、ベクトルまたはデータ・フレームのどの要素がより小さい添え字を持つ要素と重複してい るかを判別し、どの要素 (行) が重複しているかを示す論理ベクトルを返します。
duplicated()は、ベクトルまたはデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判別し、どの要素（行）が重複しているかを示す論理ベクトルを返します。
パッケージ・バージョンを含む数値バージョンを表す単純な S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
warningsとそのprintメソッドは、変数last.warningを喜ばしい形で表示します。
DLL（共有オブジェクトとも呼ばれる）をロードまたはアンロードし、C関数またはFortranサブルーチンが使用可能かどうかをテストする。
DLL（共有オブジェクトとしても知られている）をロードまたはアンロードし、C関数またはFortranサブルーチンが利用可能かどうかをテストします。
オブジェクトの名前による検索(get)、またはゼロ個以上のオブジェクトの検索(mget)。
eapplyは、FUNを環境からの名前付き値に適用し、結果をリストとして返します。  ユーザは、名前付きオブジェクトをすべて使用するように要求することができる（通常、ドットで始まる名前は使用されない）。  出力はソートされず、周囲の環境は検索されません。
数値（ダブル、整数、論理）または複素行列の固有値および固有ベクトルを計算します。
環境の取得、設定、テスト、作成。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりします。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりする。
encodeStringは、print.defaultと同じ方法で文字ベクトル内の文字列をエスケープし、オプションでエンコードされた文字列をフィールド幅内に収めます。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりします。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりします。
文字列は共通の長さにリサイクルされます。
substitutionは、(未評価の)式exprの解析木を、envに束縛された変数を代入して返します。
環境の取得、設定、テスト、作成。
環境の取得、設定、テスト、作成。
環境の取得、設定、テスト、作成。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数と関数をリンクすることができます。
環境の取得、設定、テスト、作成。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
指定された環境でR式を評価します。
指定された環境でR式を評価します。
指定された環境でR式を評価する。
指定された名前のRオブジェクトを探し、場合によってはそれを返す。
logは対数を計算し、デフォルトでは自然対数、log10は常用対数（つまり底10）、log2は両用対数（つまり底2）を計算する。一般的な形式log(x, base)は底を底とする対数を計算する。
与えられたベクトルまたは因子のすべての組み合わせからデータフレームを作成する。  この処理の正確な詳細については、戻り値の説明を参照してください。
logは対数を計算し、デフォルトでは自然対数、log10は常用（つまり底10）対数、log2は2進（つまり底2）対数を計算する。
expression "モードのオブジェクトを作成またはテストする。
使用した（外部の）サードパーティ製ソフトウェアのバージョンを報告する。
logical "型のオブジェクト、および基本logical定数を作成またはテストします。
factor 関数は、ベクトルを factor としてエンコードするために使用されます（'category' および 'enumerated type' という用語も、factor に対して使用されます）。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
ベータ関数とガンマ関数に関連する特殊な数学関数。
接続を作成、オープン、クローズする関数。すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」接続を作成、オープン、クローズする機能。
ユーザーのファイルシステム上のファイルに関する情報にアクセスするユーティリティ関数。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
対話的にファイルを選択する。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
これらの関数は、コンピュータのファイルシステムに低レベルのインターフェイスを提供します。
これらの関数は、コンピュータのファイルシステムに低レベルのインターフェイスを提供します。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ関数。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ機能。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ関数。
プラットフォームに依存しない方法でコンポーネントからファイルへのパスを構築します。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
1つまたは複数の(プレーンな)テキストファイルを、プラットフォーム固有の方法で、通常は「ページャー」を介して表示します。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ関数。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインタフェースを提供する。
Filterは、述語（論理）関数が真となるベクトルの要素を抽出します。  FindとPositionはそれぞれ、そのような要素の最初か最後、およびベクトル内の位置を与える。  Map は、与えられたベクトルの対応する要素に関数を適用します。  Negateは、与えられた関数の否定を作成します。
Filterは、述語（論理）関数が真を返すベクトルの要素を抽出します。  FindとPositionはそれぞれ、そのような要素の最初か最後、およびベクトル内の位置を与える。  Map は、与えられたベクトルの対応する要素に関数を適用します。  Negate は、与えられた関数の否定を作成します。
1つ以上のパッケージへのパスを見つける。
vecの減らないブレークポイントのベクトルが与えられた場合、 xの各要素を含む区間を見つける; すなわち、 ifi <- findInterval(x,v), for each index j in xv[i[j]] ≤ x[j] < v[i[j] + 1]where v[0] := - Inf, v[N+1] := + Inf, and N <- length(v).2 つの境界では、オプション引数rightmost.closedとall.insideによって、 返されるインデックスが1だけ異なる場合がある。
基本パッケージの内部オブジェクトのほとんどは、基本名前空間の特別な性質のために、ユーザから見えるだけです。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
ceilingは1つの数値引数xを取り、xの対応する要素より小さくない最小の整数を含む数値ベクトルを返します。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
接続を作成、オープン、クローズする関数、すなわち「一般化されたファイル」。
これらはR言語の基本的な制御フロー構成要素である。  これらは、Algol系言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
関数の引数の評価を強制します。
関数がクロージャである場合、呼び出しの前に強制的に指定された数の先行引数で関数を呼び出します。
関数の形式引数を取得または設定します。
関数の形式引数の取得と設定
プリティ・プリンティング用にRオブジェクトをフォーマットする
プリティ印刷用にRオブジェクトをフォーマットする
プリティ印刷用にRオブジェクトをフォーマットする
文字表現とカレンダーの日付を表す "Date "クラスのオブジェクトを変換する関数
きれいな印刷のためのRオブジェクトのフォーマット
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時差 "を呼び出します。
Rオブジェクトを整形してきれいに印刷する。
整数を16進数形式に変換し、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数で表示します。
format(x,digits,nsmall)がどのようにフォーマットされるかの情報が返されます。
ライブラリにロードし、アドオンパッケージをアタッチする必要があります。
パッケージのバージョンを含む数値のバージョンを表現するためのシンプルなS3クラスと関連するメソッド。
8進数形式で整数を変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
ライブラリーをロードし、アドオンパッケージをアタッチする必要があります。
文字表現と、カレンダー日付と時刻を表すクラス "POSIXlt "および "POSIXct "のオブジェクトとを変換する関数。
format.pvalは、文字表現と、暦日時を表すクラス "POSIXlt "および "POSIXct "のオブジェクトとの間で変換を行う関数である。
format.pvalは、p値の書式設定に使用する。
summaryは、様々なモデル適合関数の結果の要約を作成するために使用される汎用関数です。  この関数は、第1引数のクラスに依存する特定のメソッドを呼び出します。
formatC() は、C スタイルの書式指定を使用して、数値を個別に柔軟に書式設定します。
項目とその説明のベクトルを2列表またはLaTeXスタイルの説明リストとしてフォーマットする。
三角連立一次方程式を解く。
これらの関数は、R言語で新しい関数を定義するための基本的なメカニズムを提供します。
ベータ関数とガンマ関数に関連する特殊な数学関数。
gcを呼び出すと、ガベージ・コレクションが行われる。gcinfoはフラグを設定するので、自動コレクションは無音（verbose = FALSE）か、メモリ使用量の統計（verbose = TRUE）を表示する。
この関数は、GC タイミングが有効になっている間、R セッション内でこれまでにガベージ・コレクションに費やされた時間を報告する。
gcの呼び出しは、ガベージコレクションを実行させる。gcinfoは、自動コレクションがサイレント（verbose = FALSE）またはメモリ使用量の統計（verbose = TRUE）を表示するようにフラグを設定する。
ガベージコレクションは、（ほぼ）すべてのメモリ割り当てに対して行われる。  また、残念ながらRの動作が非常に遅くなります。
ほぼ）すべてのメモリ割り当てに対してガベージコレクションを引き起こす。  また、残念ながらRの動作が非常に遅くなる。
オブジェクトの名前で検索する(get)か、0個以上のオブジェクトを検索する(mget)。
与えられた名前のRオブジェクトを探し、場合によってはそれを返す。
接続の側面を表示する。
これはRのCコードから呼び出される内部関数で、PACKAGE引数を持たない.C/.Call/.Fortran/.External呼び出しの包含名前空間を決定する。呼び出しが名前空間内の関数から行われた場合は、その名前空間に関連付けられている DLL を見つけることができます。  この目的は、このようなネイティブ呼び出しでPACKAGE引数を使用する必要をなくし、パッケージのバージョンをよりよくサポートすることです。
これはRのCコードから呼び出される内部関数で、PACKAGE引数を持たない.C/.Call/.Fortran/.External呼び出しの包含名前空間を決定します。呼び出しが名前空間内の関数から行われた場合は、その名前空間に関連付けられている DLL を見つけることができます。  この目的は、このようなネイティブ呼び出しでPACKAGE引数を使用しなくて済むようにし、パッケージのバージョンをよりよくサポートすることです。
接続の表示。
この関数を使用すると、動的検索、ネイティブ・ルーチン呼び出し時のエラー処理、および将来的なセキュリ ティを強化するために、R に登録されている DLL 内のルーチン・セットを照会できます。この関数は、DLL 内の各登録ルーチンについて、.C、.Call、.Fortran、.External などのさまざまなインタフェースの説明を提供します。
この関数を使用すると、R に登録されている DLL 内のルーチン・セットを照会して、動的検索、ネイティブ・ルーチン呼び出し時のエラー処理、および将来的なセキュリティ機能を強化することができます。
この関数を使用すると、R に登録されている DLL 内のルーチン・セットを照会して、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、および将来的なセキュリティ機能を強化することができます。この関数を使用すると、DLL 内の各登録ルーチンについて、.C、.Call、.Fortran、.External などのさまざまなインターフェイスについて説明することができます。
ベクトル、行列、配列、リストに作用する演算子。
stopは現在の式の実行を停止し、エラー・アクションを実行する。
名前空間オブジェクトに対するリフレクションをサポートする内部関数。
これらの関数を使用すると、パッケージがアタッチ/デタッチされ、ネームスペースが（アン）ロードされる前に実行されるアクションを設定できます。
この関数は、R セッションで現在ロードされているすべての DLL (seedyn.load) のリストを取得する方法を提供します。
名前空間オブジェクトに対するリフレクションをサポートする内部関数。
名前空間オブジェクトへの参照をサポートする内部関数。
名前空間オブジェクトに対するリフレクションをサポートする内部関数。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、base 名前空間の特別な性質のためにのみ見える。
名前空間オブジェクトのリフレクションをサポートする内部関数。
名前空間オブジェクトのリフレクションをサポートする内部関数。
名前空間オブジェクトに対するリフレクションをサポートする内部関数。
これは、1 つ以上の動的にロードされた、または 'エクスポートされた' 組み込みネイティブ・シンボルの説明を見つけて返します。  各シンボル名について、そのシンボルの名前、そのシンボルが配置されているライブラリ、利用可能な場合はそのシンボルが期待する引数の数、およびどのインタフェースで呼び出すか (つまり .Call、.C、.Fortran、または .External) に関する情報を返します。さらに、シンボルのアドレスを返し、これを他のCルーチンに渡すことができます。  具体的には、ダイナミックにロードされた異なるパッケージ・ライブラリ間でシンボルを明示的に共有する方法を提供します。  また、シンボルが解決された場所を問い合わせる方法を提供し、動的解決に関連する奇妙な動作の診断に役立ちます。
Rの計算や結果の表示方法に影響を与えるさまざまなグローバル・オプションを設定し、調べることができます。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、すなわちソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE)の場合、対話型Rセッションで使用できます。
これは、各トップレベル・タスクの終了時に呼び出される、現在登録されているタスク・コールバックの名前（または識別子）を取得する方法を提供します。
ネイティブ言語サポート(NLS)がRのこのビルドで有効になっている場合（bindtextdomain()の例を参照）、文字ベクトルの翻訳を試みるか、翻訳がどこで見つかるかを設定する。
C関数のsprintfのラッパーで、テキストと変数値の組合せをフォーマットした文字ベクトルを返す。
setwd(dir)は、作業ディレクトリをdirに設定するために使用されます。
setwd(dir) は、作業ディレクトリを dir に設定するために使用される。
setwd(dir)は、作業ディレクトリをdirに設定するために使用されます。これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
環境の取得、設定、テスト、作成。
grep、grepl、regexpr、gregexpr、regexec、gregexec は、文字ベクトルの各要素内の引数パターンに一致するものを検索する。
grep、grepl、regexpr、gregexpr、regexec、gregexec は、文字ベクトルの各要素内の引数パターンとのマッチを検索します。
grep、grepl、regexpr、gregexpr、regexec、gregexec は、文字ベクトルの各要素内の引数パターンとのマッチを検索します。
grep、grepl、regexpr、gregexpr、regexec、gregexec は、文字ベクトルの各要素内の引数パターンとのマッチを検索します。
grepRawは、rawベクトルx内の部分文字列パターンとのマッチを検索します。
groupingは、同じ値が隣接するように最初の引数を並べ替えた並べ替えを返します。  属性としてグループ単位の分割とグループの最大サイズが返される。
grep、grepl、regexpr、gregexpr、regexec および gregexec は、文字ベクトルの各要素内の引数パターンにマッチするものを検索する。
gzcon は既存の接続をラップする修正された接続を提供し、 その接続を通して読み込みを伸長したり書き込みを圧縮したりする。  標準的な gzip ヘッダを想定している。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
オブジェクトのクラスを変更して、'as is' で扱うことを示す。
これは、エンコーディング間で文字ベクトルを変換するためにシステム機能を使用します： 'i'は'国際化'を意味します。
i'は'internationalization'を表す。
ICU（Rbuildのオプション部分）による照合方法を制御する。
ICUによる照合順序を制御する（Rbuildのオプション）。
2つのオブジェクトが厳密に等しいかどうかをテストする安全で信頼できる方法。  この場合はTRUEを返し、それ以外の場合はFALSEを返します。
引数を返す些細な同一性関数。
これらはR言語の基本的な制御フローの構成要素である。  これらはAlgol-Likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
ifelseは、testの要素がTRUEかFALSEかによってyesかnodから選択された要素で満たされた、testと同じ形の値を返します。
算術演算子+、-、*、/、^に加えて、Rの複素数演算をサポートする基本関数。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、base名前空間の特別な性質のためにのみ見える。
単一のRオブジェクトをファイルに書き込んだり、復元したりする関数。
Rには、オブジェクト指向プログラミングに使用できるシンプルな汎用関数メカニズムがある。  メソッドのディスパッチは、ジェネリック関数の最初の引数のクラスに基づいて行われます。
integer "型のオブジェクトを作成またはテストします。
interactionは、与えられた因子の相互作用を表す因子を計算します。  interactionの結果は常に順序なしである。
Rが対話的に使用されている場合はTRUEを、そうでない場合はFALSEを返します。
set union, intersection, (asymmetric!) difference, equality, membership を2つのベクトルに対して実行します。
ビットまたは "パックされた "8ビットの両方で使用される "raw "型のオブジェクトへの変換およびオブジェクトからの変換、操作。
UTF-8でエンコードされた文字ベクトルと，UTF-32でエンコードされた整数ベクトルとの変換。
ベクトル内の等しい値のランの長さと値を計算する。
オブジェクトの（一時的な）不可視コピーを返す。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
配列の作成やテストを行います。
is.atomicは、xがアトミック型（またはNULL）であればTRUEを、そうでなければFALSEを返します。
call "モード（または"("、詳細参照）のオブジェクトの作成またはテスト。
character "型のオブジェクトの作成またはテスト。
算術演算子+、-、*、/、^に加えて、Rで複素数演算をサポートする基本関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
倍精度ベクトルの作成、共有、テスト。
2つのベクトルに対して、集合和、交、（非対称！）差、等式、メンバシップを実行する関数。
環境の取得、設定、テスト、作成。
expression "モードのオブジェクトを作成またはテストします。
factor 関数は、ベクトルを factor としてエンコードするために使用されます（'category' および 'enumerated type' という用語も factor に対して使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
is.finiteとis.infiniteはxと同じ長さのベクトルを返し、どの要素が有限か（無限でなく、欠落していないか）無限かを示す。
引数が（プリミティブ）関数であるかどうかをチェックする。
is.finiteとis.infiniteは、xと同じ長さのベクトルを返し、どの要素が有限（無限ではなく、欠落していない）か無限かを示します。
integer "型のオブジェクトを作成またはテストする。
is.languageは、xが変数名、呼び出し、または式の場合にTRUEを返します。
両方の種類のRリストを作成、強制、チェックする関数。
DLL（共有オブジェクトとも呼ばれる）のロードまたはアンロード、C関数またはFortranサブルーチンが使用可能かどうかのテスト。
logical "型のオブジェクト、および基本logical定数の作成またはテスト。
matrix は、与えられた値の集合から行列を作成する。
NAは、欠測インジケータを含む長さ1の論理定数である。  NA は raw 以外の任意のベクトル型に強制することができる。  NA_integer_,NA_real_,NA_complex_,NA_character_は、欠損値をサポートする他の原子ベクトル型の定数です。
NAは欠損値インジケータを含む長さ1の論理定数である。  NAはraw以外の任意のベクトル型に強制することができる。  NA_integer_,NA_real_,NA_complex_,NA_character_という定数もあり、これらはすべてR言語の予約語です。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連メソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
NAは、欠測インジケータを含む長さ1の論理定数です。  NA は raw 以外の任意のベクトル型に強制することができる。  NA_integer_,NA_real_,NA_complex_,NA_character_という定数もあり、これらはすべてR言語の予約語である。
NAは欠損値インジケータを含む長さ1の論理定数である。  NAはraw以外の任意のベクトル型に強制することができる。  NA_integer_,NA_real_,NA_complex_,NA_character_という定数もあり、これらはすべてR言語の予約語である。
factor関数はベクトルを因子としてエンコードするために使用されます（因子には'category'と'enumerated type'という用語も使用されます）。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
パッケージ・バージョンを含む数値バージョンと関連するメソッドを表現するためのシンプルなS3クラスです。
名前'（'シンボル'とも呼ばれる）は、名前によってRオブジェクトを参照する方法です（その名前にバインドされたオブジェクトの値（もしあれば）ではなく）。
is.finiteとis.infiniteはxと同じ長さのベクトルを返し、どの要素が有限（無限でなく、欠落していない）か無限かを示します。
NULLはRのNULLオブジェクトを表し、予約語である。  NULLは、値が未定義の式や関数からよく返されます。
numeric".is.numeric型のオブジェクトを作成または強制します。numericは、オブジェクトが数値として解釈可能かどうかをテストする、より一般的なテストです。
パッケージ・バージョンと関連するメソッドを含む数値バージョンを表現するための単純なS3クラスです。
"numeric".is.numericはオブジェクトが数値として解釈可能かどうかのより一般的なテストです。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時間差 "を呼び出します。
is.numericは、オブジェクトが数値として解釈可能かどうかの、より一般的なテストです。
内部で使用するための関数である。  オブジェクトxにR内部OBJECTビットがセットされていればTRUEを、そうでなければFALSEを返します。  OBJECTビットは "class "属性が追加されたときにセットされ、その属性が削除されたときに削除されます。  (S4オブジェクトは常にそうあるべきです）。
factor関数は、ベクトルをfactorとしてエンコードするために使用されます（'category'と'enumerated type'という用語もfactorとして使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
両方の種類のRリストを構築、強制、チェックする関数。
引数が（プリミティブ）関数であるかどうかをチェックします。
qrは行列のQR分解を行います。
Rで実行されているかどうかをテストする。
raw "型のオブジェクトを作成またはテストする。
is.atomicは、xがatomic型（またはNULL）であればTRUEを返し、そうでなければFALSEを返します。
is.singleはエラーを報告する。  Rには単精度値はありません。
名前」（「シンボル」とも呼ばれる）は、Rのオブジェクトを名前で参照する方法です（その名前にバインドされているオブジェクトの値がある場合は、その値ではありません）。
表は、因子レベルの各組み合わせでのカウントの分割表を構築するために、分類横断因子を使用します。
オブジェクトが（昇順に）ソートされていないかどうかを、ソートのコストをかけずにテストする。
vector は、与えられた長さとモードのベクトルを生成します。
Rには、オブジェクト指向プログラミングに使用できるシンプルな汎用関数メカニズムがある。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
接続の表示
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、ベース・ネームスペースの特別な性質のためにのみ見える。
関数のデバッグ・フラグを設定、解除、または問い合わせる。  また、どのブレークポイントが有効化されたかを識別するためのメカニズムも提供します。
これらの演算子は、生のベクトル、論理ベクトル、数値のようなベクトルに作用する。
接続を作成、オープン、クローズするための関数、つまり、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、ベース名前空間の特別な性質のためにのみ見える。
名前空間のロードとアンロードを行う関数。
数値表現から日時を作成するための便利なラッパー。
数値表現から日時を作成するための便利なラッパー。
コネクション、すなわち圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供します。
オブジェクトがS4クラスのインスタンスであるかどうかのテスト。
接続の位置を変更する関数
オブジェクトが対称かどうかをテストする汎用関数。現在、行列メソッドのみが実装されており、isSymmetric(Z)が真となるためには、複素行列Zが "エルミート "でなければなりません。
現在実装されているのは行列メソッドのみであり、isSymmetric(Z)が真となるためには、複素行列Zが "Hermitian "でなければならない。
これらの演算子は、生のベクトル、論理ベクトル、数値に似たベクトルに作用する。
数値ベクトルに少量のノイズを加える。
曜日、月、四半期、またはユリウス時間（ある原点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付-時刻クラスのメソッドについては、ここに文書化されています。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは汎用的な関数です。内部日付-時刻クラスのメソッドについては、ここに記述されています。
正規（正方）行列の条件数は、行列のノルムとその逆行列（または擬似逆行列）のノルムの積であり、したがって行列ノルムの種類に依存します。
正則（正方）行列の条件数は、行列のノルムとその逆行列（または擬似逆行列）のノルムの積であり、したがって行列ノルムの種類に依存する。
正則（正方）行列の条件数は、行列のノルムとその逆行列（または擬似逆行列）のノルムの積であり、したがって行列ノルムの種類に依存する。
正則（正方）行列の条件数は、行列のノルムとその逆行列（または擬似逆行列）のノルムの積であり、したがって行列のノルムの種類に依存する。
2つの配列 X と Y の一般化されたクロネッカー積を計算する．
ローカライズ情報を報告する。
使用しているLAPACK実装の共有オブジェクトファイル名を報告する。
使用中のLAPACKのバージョンを報告せよ。
矩形行列の特異値分解を計算しなさい。
印刷やプロットなどで使用するために、オブジェクトから適切なラベルのセットを見つける。  汎用関数。
例えば印刷やプロットで使用するために、オブジェクトからラベルの適切なセットを見つける。  汎用関数。
lapplyは、Xの対応する要素にFUNを適用した結果である、Xと同じ長さのリストを返します。
Rオブジェクトのデータベースを遅延ロードする内部関数。
Rオブジェクトのデータベースを遅延ロードする内部関数。
基本パッケージの内部オブジェクト。基本名前空間の特別な性質のため、そのほとんどはユーザが見ることができる。
ベータ関数とガンマ関数に関連する特殊な数学関数。
ベータ関数およびガンマ関数に関連する特殊な数学関数。
ベクトル（リストを含む）と因子、およびメソッドが定義されているその他の R オブジェクトの長さの取得と設定。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
ベクトル（リストを含む）と因数、およびメソッドが定義されているその他の R オブジェクトの長さを取得または設定する。
カレンダーの日付を表す "Date "クラスの説明
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時差 "を呼び出す。
ベクトル（リストを含む）と因子、およびメソッドが定義されているその他の R オブジェクトの長さの取得と設定。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
リストまたはアトミックベクトル（is.atomic）の各要素の長さを、整数または数値ベクトルとして取得する。
Rに組み込まれている定数
Rに組み込まれている定数
levelsは変数のlevels属性へのアクセスを提供します。最初の形式は引数のlevelsの値を返し、2番目の形式はその属性を設定します。
levelsは変数のlevels属性へのアクセスを提供します。最初の形式は引数のlevelsの値を返し、2番目は属性を設定します。
levels は、変数の levels 属性へのアクセスを提供します。
levelsは、変数のlevels属性へのアクセスを提供します。最初の形式は、引数のlevelsの値を返し、2番目は属性を設定します。
ベータ関数とガンマ関数に関連する特殊な数学関数。
ベータ関数とガンマ関数に関連する特殊な数学関数。
使用中の libcurl のバージョンを報告します。
library と require アドオン パッケージをロードしてアタッチします。
指定されたコンパイル コード ファイルがまだロードされていない場合はロードし、ロードされていない場合はアンロードします。
コンパイル済みコードの指定されたファイルがすでにロードされていない場合、それをロードするか、アンロードします。
Rが配布されているライセンス条項。
Rが配布されているライセンス条項。
両方の種類のRリストを作成、強制、チェックする関数。
これらの関数は、指定されたディレクトリ内のファイル名またはディレクトリ名の文字ベクトルを生成します。
これらの関数は、指定されたディレクトリ内のファイル名またはディレクトリ名の文字ベクトルを生成します。
変数リストからデータフレームを作成する。
名前付きリストxから、すべてのリスト構成要素をオブジェクトとして含む環境を作成する。
関数saveで書き込んだデータセットを再ロードする。
名前空間をロードおよびアンロードする関数。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、base名前空間の特別な性質のために見えるだけである。
名前空間をロードおよびアンロードする関数。
指定された環境で R 式を評価する関数。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数を関数にリンクすることができます。
logは対数を計算し、デフォルトでは自然対数、log10は常用（つまり基数10）対数、log2は2進数（つまり基数2）対数を計算します。一般形式のlog(x, base)は基数を持つ対数を計算します。
logは対数を計算し、デフォルトでは自然対数、log10は常用対数（つまり、基数10）、log2はバイナリ（つまり、基数2）対数を計算します。一般的な形式log(x, base)は、基数を持つ対数を計算します。
logは対数を計算し、デフォルトでは自然対数、log10は常用対数（つまり、基数10）、log2はバイナリ（つまり、基数2）対数を計算します。一般的な形式log(x, base)は、基数を持つ対数を計算します。
logは対数を計算し、デフォルトでは自然対数、log10は常用対数（つまり、基数10）、log2はバイナリ（つまり、基数2）対数を計算します。一般的な形式log(x, base)は、基数を持つ対数を計算します。
logは対数を計算し、デフォルトでは自然対数を計算し、log10は常用（すなわち、底10）対数を計算し、log2はバイナリ（すなわち、底2）対数を計算する。
logical "型のオブジェクト、および基本logical定数を作成またはテストする。
下三角形または上三角形に TRUE を指定すると、指定された行列と同じ大きさの論理の行列を返します。
lsとobjectsは、指定された環境のオブジェクトの名前を文字列のベクトルで返します。  トップ・レベルのプロンプトで引数なしで呼び出された場合、 ls は、ユーザが定義したデータ・セットと関数を表示する。  関数内部で引数なしで呼び出された場合、lsはその関数のローカル変数名を返します。
文字ベクトルから構文的に有効な名前を作成します。
重複する文字にシーケンス番号を付加することで、文字ベクトルの要素を一意にします。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
Filterは、述語（論理）関数が真となるベクトルの要素を抽出します。  FindとPositionはそれぞれ、そのような要素の最初か最後、およびベクトル内の位置を与える。  Map は、与えられたベクトルの対応する要素に関数を適用します。  Negateは、与えられた関数の否定を返します。
mapplyは、sapplyの多変量バージョンである。mapplyは、各...引数の最初の要素、2番目の要素、3番目の要素というようにFUNを適用する。
配列形式の分割表に対して、与えられたマージンまたはマージンの集合に対する表エントリーの合計を計算する。
配列形式の分割表に対して、与えられたマージンまたはマージンの集合に対する表入力の合計を計算する。
mat.or.vecは、ncが1より大きい場合、nr x ncのゼロ行列を作成し、ncが1の場合、長さnrのゼロベクトルを作成する。
matchは、第1引数の（最初の）マッチの第2引数の位置のベクトルを返す。
match.argは、argを choicesで指定された候補値のテーブルとマッチさせます。
match.callは、指定されたすべての引数がフルネームで指定された呼び出しを返します。
関数を引数に取る関数の内部で呼び出されると、他の型のオブジェクトとの望ましくないマッチングを避けながら、目的の関数オブジェクトを抽出します。
グループジェネリックメソッドは、Math、Ops、Summary、Complexの4つのあらかじめ指定された関数グループに対して定義することができます(ベースRにはこれらの名前のオブジェクトはありませんが、メソッドパッケージにはあります)。
カレンダーの日付を表す "Date "クラスの説明。
時間間隔の作成、印刷、いくつかの演算。  print()メソッドは、これらの「時差」を呼び出す。
factor 関数は、ベクトルを因子としてエンコードするために使用されます（因子には 'category' および 'enumerated type' という用語も使用されます）。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
matrix は、与えられた値の集合から行列を作成します。
入力値の（正則または並列の）最大値と最小値を返す。
行列の各行の最大位置を求め、同値をランダムに解消します。
(トリムされた)算術平均の汎用関数。
カレンダーの日付を表すクラス "Date "の説明
(トリミングされた)算術平均の汎用関数
時間間隔の作成、印刷、およびいくつかの算術演算。  print()メソッドは、これらの "時差 "を呼び出す。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
現在の R プロセスのベクトル・ヒープの最大サイズとヒープ・ノードの最大数を照会および設定する。
現在の R プロセスのベクトル・ヒープの最大サイズとヒープ・ノードの最大数を照会および設定します。
生のベクトルに対するメモリ内圧縮または展開。
生のベクトルに対するメモリ内圧縮または展開。
SEXPRECタイプ別にconsセルの使用状況をリストアップします。
2つのデータフレームを共通の列名または行名でマージします。
2つのデータフレームを共通の列名または行名でマージします。
2つのデータフレームを共通の列名または行名でマージします。
引数から診断メッセージを生成する。
オブジェクトの名前による検索(get)、または0個以上のオブジェクトの検索(mget)。
入力値の（正規または並列の）最大値と最小値を返します。
missingは、値が関数の引数として指定されたかどうかをテストするために使用することができます。
算術演算子+、-、*、/、^に加えて、Rで複素数演算をサポートする基本関数。
Rオブジェクトの'mode'(一種の'type')、または格納モードを取得または設定する。
Rオブジェクトの'モード'（'型'の一種）、または格納モードを取得または設定する。
Rに組み込まれている定数
R に組み込まれている定数
曜日、月、四半期、ユリウス時間（ある起点からの日数）の抽出。  これらは汎用的な関数です。内部の日付-時刻クラスのメソッドについては、ここに文書化されています。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
これらの関数はオブジェクトの属性にアクセスします。以下の最初の形式はオブジェクトの属性リストを返します。
オブジェクトの名前を取得または設定する関数。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
オブジェクトの名前を取得または設定する関数
カレンダーの日時を表すクラス "POSIXlt "と "POSIXct "の説明。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、ベース名前空間の特別な性質のために見えるだけである。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、ベース名前空間の特別な性質のためにのみ見える。
内部名前空間サポート関数。  直接呼び出すことは意図されておらず、ベース名前空間の特別な性質のためにのみ見える。
内部名前空間サポート関数。  直接呼び出すことは意図されておらず、ベース名前空間の特別な性質のためにのみ見える。
内部名前空間サポート関数。  直接呼び出すことは意図されておらず、ベース名前空間の特別な性質によってのみ見える。
関数本体の内部で使用された場合、nargsはその関数に与えられた引数の数を返します。
ncharは引数として文字ベクトルを取り、その要素にxの対応する要素のサイズを含むベクトルを返します。
NCOLとNROWは、as.matrix()やcbind()と互換性があり、0長ベクトルであってもベクトルを1列の行列として扱うことができます。
NCOL と NROW は、as.matrix() や cbind() と互換性があり、0 長のベクトルであっても、ベクトルを 1 列の行列として扱うのと同じです。
Filterは、述語（論理）関数が真を返すベクトルの要素を抽出します。  FindとPositionはそれぞれ、そのような要素の最初か最後、およびベクトル内の位置を与える。  Map は、与えられたベクトルの対応する要素に関数を適用します。  Negate は、与えられた関数の否定を作成します。
環境の取得、設定、テスト、作成。
これらはR言語の基本的な制御フロー構成要素である。  これらはAlgol-Likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
R言語には、オブジェクト指向プログラミングに使用できるシンプルな汎用関数メカニズムがあります。  メソッドのディスパッチは、ジェネリック関数の最初の引数、またはUseMethodやNextMethodの引数として与えられたオブジェクトのクラスに基づいて行われます。
このビルドのRでネイティブ言語サポート(NLS)が有効になっている場合(bindtextdomain()の例を参照)、文字ベクトルの翻訳を試みたり、翻訳が見つかる場所を設定したりします。
引数が持つレベルの数を返す。
文字列を引用符なしで表示する。
LAPACK を用いて x の行列ノルムを計算する。  ノルムは、1（"O"）ノルム、無限（"I"）ノルム、Frobenius（"F"）ノルム、行列の最大モジュラス（"M"）要素、または "スペクトル "または "2 "ノルムのいずれかであり、typeの値によって決定される。
ユーザが理解できる形で表示し、相対パスと絶対パスを比較できるようにするために、ファイルパスをプラットフォーム用の正規形に変換する。
NCOLとNROWは、as.matrix()やcbind()と互換性があり、0長のベクトルであっても、ベクトルを1列の行列として扱うのと同じことを行います。
NCOLとNROWは、0長ベクトルであっても、as.matrix()または cbind()と互換性があり、ベクトルを1列の行列として扱うのと同じです。
接続の表示。
is.numericは、オブジェクトが数値として解釈可能かどうかの、より一般的なテストです。
パッケージ・バージョンと関連するメソッドを含む、数値バージョンを表現するためのシンプルなS3クラス。
raw "型のオブジェクトへの変換と操作、ビットまたは "packed "8ビットとして使用されます。
raw "型のオブジェクトへの変換と操作。どちらもビットまたは "packed "8ビットとして使用される。
ncharは引数として文字ベクトルを取り、その要素にxの対応する要素のサイズを含むベクトルを返す。
lsとobjectsは、指定された環境内のオブジェクトの名前を文字列のベクトルで返します。  トップ・レベルのプロンプトで引数なしで呼び出された場合、 ls は、ユーザが定義したデータ・セットと関数を表示する。  関数内部で引数なしで呼び出された場合、lsはその関数のローカル変数名を返します。
Rには、オブジェクト指向プログラミングに使用できるシンプルな汎用関数メカニズムがあります。  メソッドのディスパッチは、ジェネリック関数の最初の引数のクラスに基づいて行われます。
Rは、オブジェクト指向スタイルのプログラミングに使用できるシンプルなジェネリック関数メカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数の最初の引数のクラスに基づいて行われます。
Sys.timezoneは、現在のタイムゾーン名を返します。
on.exitは、現在の関数が（自然に、またはエラーの結果として）終了するときに実行される必要があるとして、引数として与えられた式を記録します。  これは、グラフィカル・パラメータのリセットやその他のクリーンアップ・アクションを実行するのに便利です。
接続を作成、オープン、クローズする関数、つまり、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
圧縮ファイル、URL、パイプなど、"一般化されたファイル "接続を作成、オープン、クローズする関数。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（「srcref」）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型Rセッション（options(keep.source = TRUE)の場合）で使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE)の場合、対話型Rセッションで使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE) の場合、対話型 R セッションで使用できます。
グループ・ジェネリック・メソッドは、Math、Ops、Summary、Complexの4つのあらかじめ指定された関数グループに対して定義することができます(ベースRにはこれらの名前のオブジェクトはありませんが、メソッド・パッケージにはあります)。
Date "クラスの演算子。
時間間隔の作成、印刷、いくつかの演算。  print()メソッドは、これらの "時差 "を呼び出します。
factor 関数は、ベクトルを因子としてエンコードするために使用されます (因子には 'category' および 'enumerated type' という用語も使用されます)。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
パッケージ・バージョンを含む数値バージョンと関連するメソッドを表現するためのシンプルなS3クラスです。
factor関数はベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
Rの計算と結果の表示方法に影響を与えるさまざまなグローバル・オプションを設定し、調べることができる。
sort.listは、引数を1つだけ使用して同じことを行います。データ・フレームなどをソートするためにこれらの関数を使用する方法については、例を参照してください。
factor関数はベクトルを因子としてエンコードするために使用されます（因子には'category'と'enumerated type'という用語も使用されます）。  引数orderedがTRUEである場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
配列XとYの外積は次元c(dim(X), dim(Y))の配列Aであり，ここでelementA[c(arrayindex.x, arrayindex.y)] = FUN(X[arrayindex.x], Y[arrayindex.y], ...)である．
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
これらの関数は、パッケージがアタッチ/デタッチされ、名前空間が（アン）ロードされる前に実行されるアクションをユーザーが設定することを可能にします。
内部ネームスペース・サポート関数。  直接呼び出すことは意図されておらず、ベース・ネームスペースの特別な性質のためにのみ表示されます。
1 つ以上のパッケージへのパスを検索します。
引数から診断メッセージを生成する。
raw "型のオブジェクトへの変換、オブジェクトからの変換、オブジェクトの操作。
両方の種類のRリストの構築、強制、チェック関数。
環境の取得、設定、テスト、作成
環境の取得、設定、テスト、作成。
これらの関数は、呼び出しスタックのさらに上の関数に関連する環境（S用語では「フレーム」）へのアクセスを提供する。
parse()は、パースされたが評価されていない式を、呼び出しの「リスト」であるexpressionで返します。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、base 名前空間の特別な性質によってのみ表示されます。
文字に変換した後にベクトルを連結する。
文字に変換した後にベクトルを連結する。
パス名を展開する。例えば、先頭のチルダをユーザーのホームディレクトリ（そのプラットフォームで定義されている場合）で置き換える。
1つ以上のパッケージへのパスを検索する。
このRセッションで使用しているPCREのバージョンの設定オプションの一部を報告する。
Rに組み込まれている定数
接続、すなわち圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
Rオブジェクトをプロットするための汎用関数。
pmatchは、第2引数の要素の中から第1引数の要素にマッチするものを探します。
pmatch関数は、入力値の（正規または並列の）最大値と最小値を返します。
pmatch関数は、入力値の（正規または並列の）極大値と極小値を返します。
入力値の（正則または並列）極大値と極小値を返します。
入力値の（正則または平行な）極大値と極小値を返します。
実数または複素数の多項式の零点を求めます。
検索パスの指定された位置の環境を返します。
Filterは、述語（論理）関数が真を返すベクトルの要素を抽出します。  FindとPositionはそれぞれ、そのような要素の最初か最後、およびベクトル内の位置を与える。  Map は、与えられたベクトルの対応する要素に関数を適用します。  Negateは与えられた関数の否定を表します。
xの値の範囲をカバーするn+1個の等間隔の「丸い」値のシーケンスを計算する。
xの値の範囲をカバーする約n+1個の等間隔の'round'値のシーケンスを計算する。
formatC()は、Cスタイルの書式指定を使用して、数値を個別に柔軟に書式設定する。
printは引数を表示し、それを不可視にして返す（ainvisible(x)）。  これはジェネリック関数であり、新しいクラスに新しい印刷メソッドを簡単に追加できることを意味する。
オブジェクトのクラスを変更することで、そのオブジェクトが「そのまま」扱われることを示します。
関数byは、データフレームに適用されるオブジェクト指向ラッパーです。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
コネクションの作成、オープン、クローズ、すなわち「一般化されたファイル」（圧縮ファイル、URL、パイプなど）を行う関数。
データ・フレームの印刷。
カレンダーの日付を表すクラス "Date "の説明。
print.defaultは、引数を印刷するgenericprint関数のデフォルト・メソッドです。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時差 "を呼び出す。
printは引数を表示し、それを不可視で返す（viaainvisible(x)）。  これは汎用的な関数であり、新しいクラス用に新しい印刷メソッドを簡単に追加できることを意味します。
この関数は、Rセッションに現在ロードされているすべてのDLLのリスト（seedyn.load）を取得する方法を提供します。
この関数は、Rセッションに現在ロードされているすべてのDLL(seedyn.load)のリストを取得する方法を提供します。
この関数を使用すると、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、および将来的なセキュリ ティを強化するために、R に登録されている DLL 内のルーチン・セットを照会することができます。
数値（double、integer、logical）または複素行列の固有値と固有ベクトルを計算します。
printは引数を表示し、それを不可視にして(viaainvisible(x))返します。  これは汎用的な関数であり、新しいクラスのために新しい印刷メソッドを簡単に追加できることを意味します。
printは引数を表示し、それを不可視にして返す（viaainvisible(x)）。  これは汎用的な関数であり、新しいクラスのために新しい印刷メソッドを簡単に追加できることを意味する。
整数を16進数形式に変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
ライブラリとrequireは、アドオン・パッケージをロードしてアタッチします。
printは引数を表示し、それを不可視にして（ainvisible(x)を使って）返す。  これは汎用的な関数であり、新しいクラス用に新しい印刷メソッドを簡単に追加できることを意味します。
この関数を使用すると、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、および将来的なセキュリ ティを強化するために、R に登録されている DLL 内のルーチン・セットを照会できます。
文字列を引用符なしで表示します。
パッケージ・バージョンを含む数値バージョンを表すシンプルな S3 クラスと、関連するメソッド。
必要に応じて先頭のゼロを使用し、最大値を表示するために必要な桁数で、8進数形式の整数を変換または表示します。
ライブラリのロードとアドオン・パッケージのアタッチを要求します。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
POSIXlt "クラスと "POSIXct "クラスの説明。
proc.timeは、現在実行中のRプロセスが既に費やした実時間とCPU時間（秒単位）を決定する。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
ベクトル内の等しい値のランの長さと値を計算する。
printは引数を表示し、それを不可視にして返します（ainvisible(x)）。  これは汎用的な関数であり、新しいクラス用に新しい印刷メソッドを簡単に追加できることを意味します。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE)の場合、対話型Rセッションで使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（「srcref」）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型 R セッション（options(keep.source = TRUE) の場合）で使用できます。
table は、クロス分類因子を使用して、各因子レベルの組み合わせにおけるカウントの分割表を構築します。
warningsとそのprintメソッドは、変数last.warningを見やすい形で表示します。
summaryは、さまざまなモデル適合関数の結果の要約を作成するために使用される汎用関数です。  この関数は、最初の引数のクラスに依存する特定のメソッドを呼び出します。
printは引数を表示し、それを不可視にして（ainvisible(x)を介して）返します。  これは汎用的な関数であり、新しいクラスに対して新しい表示メソッドを簡単に追加できることを意味します。
warningsとそのprintメソッドは、変数last.warningを見やすい形で表示します。
Sとの互換性のために提供された、行列を表示するための以前のメソッド。
proc.timeは、現在実行されているRプロセスにどれだけの実時間とCPU時間（秒単位）がかかっているかを判定します。
prod は、引数に含まれるすべての値の積を返します。
margin関数は、マージン、つまりxのエントリを適切なマージン合計で割った値が与えられたときの条件付き比率を返します。
margins関数は、マージン、つまりxのエントリを適切なマージン合計で割った値が与えられたときの条件付き比率を返します。
オブジェクトのdimnamesを取得または設定します。
ベータ関数とガンマ関数に関連する特殊な数学関数
テキスト行をコネクションにプッシュバックする関数。
テキスト行を接続にプッシュバックする関数と、現在プッシュバックされている行数を問い合わせる関数。
関数quitまたはそのエイリアスqは、現在のRセッションを終了する。
qrは行列のQR分解を行います。
qrは行列のQR分解を計算する。
qrは行列のQR分解を計算する．
qr は行列の QR 分解を計算します。
オブジェクトが構成された元の行列、または分解の成分を返します。
qr は行列の QR 分解を行います。
qr は行列の QR 分解を計算する。
qr は行列の QR 分解を計算する。
qr は行列の QR 分解を行います。
qr は行列の QR 分解を計算する。
オブジェクトが構築された元の行列、または分解の構成要素を返します。
曜日、月、四半期、またはユリウス時間（ある原点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
関数quitまたはその別名qは、現在のRセッションを終了します。
substitutionは、envに束縛された変数を代入して、(未評価の)式exprの解析木を返します。
パッケージ・バージョンを含む数値バージョンを表現するシンプルな S3 クラスと、関連するメソッド。
Rのホームディレクトリ、またはRのインストールコンポーネントへのフルパスを返します。
R.Version()は、実行中のRのバージョンに関する詳細情報を提供します。
R.Version() は、実行中の R のバージョンに関する詳細情報を提供します。
R.Version() は、実行中の R のバージョンに関する詳細情報を提供します。
range は、与えられたすべての引数の最小値と最大値を含むベクトルを返します。
range は、与えられたすべての引数の最小値と最大値を含むベクトルを返します。
range関数は、ベクトル内の値の標本順位を返します。  同値（等しい値）や欠損値は、いくつかの方法で扱うことができます。
rapply は lapply の再帰バージョンで、結果の構造化方法 (how = "..") に柔軟性があります。
raw "型のオブジェクトを作成またはテストする。
入出力 raw 接続。
入出力raw接続。
ビットまたは "パックされた "8ビットとして使用される、"raw "型のオブジェクトへの変換およびオブジェクトからの変換、操作。
ビットまたは "packed "8ビットとして使用される "raw "タイプのオブジェクトとの変換および操作。
ビットまたは "packed "8ビットとして使用される "raw "型のオブジェクトとの変換および操作。
ベクトル、行列、データフレームの一連の引数をとり、それぞれ列または行で結合する。  これらは他のRクラスのメソッドを持つ汎用関数です。
vector、matrix、data-frameの引数列をとり、それぞれ列または行で結合する。  これらは他のRクラスのメソッドを持つ汎用関数です。
正規（正方）行列の条件数は、行列のノルムとその逆行列（または擬似逆行列）のノルムの積であり、したがって行列のノルムの種類に依存する。
算術演算子 +, -, *, /, ^ に加えて、Rで複素数演算をサポートする基本関数。
RオブジェクトをDebian Control Fileformatのファイルから/ファイルへ読み書きする。
接続または raw ベクタからのバイナリデータの読み込み、または接続または raw ベクタへのバイナリデータの書き込み
接続上でヌル終端であると仮定せずに、文字列を接続との間で転送する。
readline は、ターミナルから行を読み込む（対話型使用時）。
接続からテキスト行の一部または全部を読み込む。
単一のRオブジェクトをファイルに書き込んだり、それを復元したりする関数。
.Renviron'または'Renviron.site'のようなファイルを、Startupのヘルプで説明されているフォーマットで読み込み、そのファイルで定義されている環境変数を設定します。
Recallは、呼び出される関数名のプレースホルダーとして使用されます。  これにより、名前を変更しても動作する再帰関数を定義することができます。
Filterは、述語（論理）関数が真を返すベクトルの要素を抽出します。  FindとPositionはそれぞれ、そのような要素の最初か最後、およびベクトル内の位置を与える。  Map は、与えられたベクトルの対応する要素に関数を適用します。  Negateは、与えられた関数の否定を作成します。
オブジェクトのガベージ・コレクション時、または（オプションで）Rセッションの終了時に呼び出されるR関数を登録します。
grep、grepl、regexpr、gregexpr、regexec、gregexec は、文字ベクトルの各要素内の引数パターンとの一致を検索します。
grep、grepl、regexpr、gregexpr、regexec および gregexec は、文字ベクトルの各要素内の引数パターンとのマッチを検索します。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、ベース名前空間の特別な性質のために見えるだけである。
内部名前空間サポート関数。  直接呼び出すことは意図しておらず、ベース名前空間の特別な性質によってのみ見える。
regexpr、gregexpr、regexec または gregexec によって得られたマッチデータから、マッチした部分文字列を抽出または置換する。
regexpr、gregexpr、regexec または gregexec によって得られたマッチデータから、マッチした部分文字列を抽出または置換する。
removeとrmはオブジェクトを削除するのに使われます。  これらは、文字列として、または文字ベクトル・リストとして、あるいはその両方を組み合わせて、連続して指定することができる。  こうして指定されたオブジェクトはすべて削除される。
addTaskCallbackは、トップレベル・タスクが完了するたびに呼び出されるR関数を登録します。
repはxの値を複製します。これは一般的な関数で、（内部的な）デフォルトのメソッドはここに記述されています。
repはxの値を複製する。これは一般的な関数であり、(内部的な)デフォルトメソッドはここに記述されている。
repはxの値を複製する。これはgenericfunctionであり、(内部的な)デフォルトメソッドはここに記述されている。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドはこれらの "時間差 "を呼び出す。
repはxの値を複製する。これはジェネリック関数であり、（内部的な）デフォルト・メソッドはここに記述されている。
repはxの値を複製します。これはgenericfunctionで、(内部的な)デフォルトメソッドはここに記述されています。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連するメソッド。
repはxの値を複製します。これはgenericfunctionで、(内部の)デフォルトメソッドはここに記述されています。
repはxの値を複製します。これはgenericfunctionであり、（内部的な）デフォルト・メソッドはここに記述されています。
これらはR言語の基本的な制御フロー構成要素である。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
replaceは、listで与えられたインデックスを持つxの値をvaluesで与えられた値で置き換える。
lapplyは、Xの対応する要素にFUNを適用した結果の、Xと同じ長さのリストを 返します。
libraryとrequireは、アドオン・パッケージのロードとアタッチを行います。
名前空間をロードおよびアンロードする関数。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
この関数は、内部コードがオブジェクトをコピーするたびにメッセージが出力されるようにオブジェクトをマークします。  Rのメモリ使用量を予測しにくくする主な原因となっています。
これらの関数は、R言語で新しい関数を定義するための基本的なメカニズムを提供します。
traceを呼び出すと、任意の関数の選択された場所にデバッグコード（ブラウザへの呼び出しやrecoveryなど）を挿入することができます。  untraceを呼び出すと、トレースがキャンセルされます。指定したメソッドも同様にトレースすることができ、汎用関数へのすべての呼び出しをトレースする必要はありません。  トレース・コード(tracer)は任意のR式です。  トレースは、tracingStateを呼び出すことによって、一時的にグローバルにオンまたはオフにすることができます。
revはその引数の逆バージョンを提供します。  revはベクトル用のデフォルトメソッドとデンドログラム用のデフォルトメソッドを持つジェネリック関数です。
rev は引数の逆バージョンを提供します。  これはベクトル用のデフォルトメソッドとデンドログラム用のデフォルトメソッドを持つgenericfunctionです。
ベクトル内の等しい値のランの長さと値を計算します。
removeとrmはオブジェクトの削除に使用される。  これらのオブジェクトは、文字列として、または文字ベクトル・リストとして、あるいはその両方を組み合わせて連続して指定することができる。  こうして指定されたオブジェクトはすべて削除される。
.Random.seedは整数ベクトルで、Rの乱数生成のための乱数生成器（RNG）の状態を含みます。
.Random.seedは整数ベクトルで、Rの乱数生成のための乱数生成器（RNG）の状態を含みます。
ceilingは1つの数値引数xをとり、xの対応する要素より小さくない最小の整数を含む数値ベクトルを返す。
日付時刻オブジェクトの丸めまたは切り捨て
日付時刻オブジェクトを丸めたり切り捨てたりします。
amatrix関数は、行列のようなオブジェクトの行番号を示す整数の行列、または行ラベルを示す係数を返します。
すべてのデータフレームは行名と、重複や欠損のない行数を表す長さの文字ベクトルを持つ。
すべてのデータフレームは行名と、重複も欠損もない行の数を表す長さの文字ベクトルを持つ。
すべてのデータフレームは行名と、重複も欠損もない行の数を表す文字ベクトルを持つ。
すべてのデータフレームは行名と、重複も欠損もない行の数を表す文字ベクトルを持つ。
すべてのデータフレームは行名と、重複も欠損もない行の数を表す文字ベクトルを持つ。
すべてのデータフレームは行名を持ち、重複も欠損もない行の数を長さの文字ベクトルで表す。
数値配列（またはデータ・フレーム）の行と列の合計と平均を作成する。
行列のようなオブジェクトの行名または列名を取得または設定する。
行列のようなオブジェクトの行名や列名の取得や設定
rowsum は汎用的なもので、データフレーム用のメソッドと、ベクトルや行列用のデフォルトのメソッドがあります。
rowsum は汎用で、データフレーム用のメソッドとベクトルおよび行列用のデフォルトメソッドがあります。
rowsum は汎用で、データフレーム用のメソッドとベクトルおよび行列用のデフォルトメソッドがあります。
数値配列（またはデータフレーム）の行と列の合計と平均を作成します。
sample は、x の要素から指定されたサイズの標本を、置換ありまたは置換なしで取ります。
sampleは、xの要素から指定されたサイズのサンプルを置換ありまたは置換なしで取ります。
lapplyはXと同じ長さのリストを返し、その各要素はXの対応する要素にFUNを適用した結果である。
save は、Rオブジェクトの外部表現を指定されたファイルに書き込みます。  このオブジェクトは、関数loadまたはattach(場合によってはdata)を使用することで、後日ファイルから読み出すことができます。
saveは、Rオブジェクトの外部表現を指定されたファイルに書き込みます。  このオブジェクトは、load関数やattach関数（場合によってはdata関数）を使って、後日ファイルから読み出すことができる。
1つのRオブジェクトをファイルに書き込んだり、それを復元したりする関数です。
scale は、数値行列の列のセンタリングとスケーリングを行う汎用関数です。
scale は、数値行列の列のセンタリングとスケーリングを行う汎用関数です。
コンソールまたはファイルからデータをベクトルまたはリストに読み込みます。
付属パッケージ(ライブラリを参照)とRオブジェクト(通常はdata.frames)のリストを表示します。
付属パッケージ(ライブラリを参照)のリストとRオブジェクト(通常はdata.frames)を提供する。
接続の位置を変更する関数
接続を再配置する関数。
seq.intはプリミティブで、より高速に処理できますが、いくつかの制限があります。seq_alongとseq_lenは、2つの一般的なケースに対して非常に高速なプリミティブです。
seq.intはプリミティブで、より高速に処理できるが、いくつかの制約がある。seq_alongとseq_lenは、よくある2つのケースに対して非常に高速なプリミティブである。
seq.intはプリミティブで、より高速に処理できるが、いくつかの制約がある。seq_alongとseq_lenは、よくある2つのケースに対して非常に高速なプリミティブである。
seqメソッドは、カレンダーの日付を表す "Date "クラスのオブジェクトを対象とする。
seq.intはより高速なプリミティブだが、いくつかの制約がある。seq_alongとseq_lenは、よくある2つのケースに対して非常に高速なプリミティブである。
seq_alongとseq_lenは、よくある2つのケースに対して非常に高速なプリミティブである。
seqメソッドは日付-時間クラス用。
sequenceのデフォルトメソッドは、並列（およびリサイクル）ベクトルfrom,by,nvecの各要素iに対してsequenceseq(from[i], by = by[i], length.out = nvec[i])を生成します。そして、これらのシーケンスを連結した結果を返します。
sequence のデフォルトメソッドは、並列（およびリサイクル）ベクトル from,by,nvec の要素 i に対して sequenceseq(from[i], by = by[i], length.out = nvec[i]) を生成します。そして、これらのシーケンスを連結した結果を返す。
コネクションにシリアライズするためのシンプルな低レベルインターフェース。
コネクション、すなわち圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
.Random.seedは整数ベクトルで、Rにおける乱数生成のための乱数生成器（RNG）の状態を含む。
論理和、論理積、(非対称！)差分、等式、メンバシップを2つのベクトルに対して行います。
set union, intersection, (asymmetric!) difference, equality and membership を2つのベクトルに対して実行します。
これらの関数を使用すると、パッケージがアタッチ/デタッチされ、ネームスペースが（アン）ロードされる前に実行されるアクションを設定できます。
内部ネームスペース・サポート関数。  直接呼び出されることは意図されておらず、ベース・ネームスペースの特別な性質のためにのみ表示されます。
トップレベルの計算または現在のセッションの CPU および/または経過時間の制限を設定する関数。
トップレベルの計算や現在のセッションのCPU制限や経過時間制限を設定する関数。
getwdは、Rプロセスの現在の作業ディレクトリを表す絶対ファイルパスを返す。
setwd(dir)は、作業ディレクトリをdirに設定するために使用する。
オペレーティング・システムのシェルに渡す文字列を引用する。
signは、xの対応する要素の符号を持つベクトルを返します（実数の符号は、それぞれ正、ゼロ、 負の場合、1、0、または-1です）。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
ceilingは1つの数値引数xを取り、xの対応する要素より小さくない最小の整数を含む数値ベクトルを返す。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
lapplyは、Xの対応する要素にFUNを適用した結果を要素とする、Xと同じ長さのリストを返します。
これらの関数は明らかな三角関数を与える。  これらの関数はそれぞれ、余弦、正弦、正接、円弧余弦、円弧正弦、円弧正接、2引数の円弧正接を計算する。
倍精度ベクトルの作成、強制、テスト。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または'面積余弦'など）を計算します。
sinkは、R出力をコネクションに分岐します（そして、そのような分岐を停止します）。
sinkはRの出力を接続に流用します（そしてそのような流用を止めます）。
これらの関数は明らかな三角関数を与える。  これらはそれぞれ、余弦、正弦、接線、円弧余弦、円弧正弦、円弧接線、および2引数の円弧接線を計算します。
配列中のスライス数を示す整数行列を返す．
接続を作成、オープン、クローズする関数。すなわち、圧縮ファイル、URL、パイプなど、「一般化されたファイル」を作成する関数。
圧縮ファイル、URL、パイプなどの "一般化されたファイル "接続を作成、オープン、クローズする関数。
複数のソケット接続とサーバーソケットのうち、最初のものが利用可能になるのを待つ。
コネクションを作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
この汎用関数は、方程式 a %*% x = b を x に対して解きます。
この汎用関数は方程式 a %*% x = b を x に対して解きます。
qrは行列のQR分解を行います。
ベクトルまたは因子を（部分的に）昇順または降順に並べ替えます。  1つ以上の変数に沿った順序付け、例えばデータフレームのソートについては order を参照。
ベクトルまたは因子を（部分的に）昇順または降順に並べ替える（または並べ替える）。  1つ以上の変数に沿った順序付け、例えばデータ・フレームのソートについては、orderを参照。
ベクトルまたは因子を（部分的に）昇順または降順に並べ替える（または並べ替える）。  1つ以上の変数に沿った順序付け、例えばデータ・フレームのソートについては order を参照。
sort.listは、引数を1つだけ使用して同じことを行います。データフレームなどをソートするためにこれらの関数を使用する方法については、例を参照してください。
ベクトルまたは因子を（部分的に）昇順または降順に並べ替えます。  データ・フレームのソートなど、1つ以上の変数に沿った順序付けについては、orderを参照してください。
source を指定すると、R は指定されたファイルや URL、または接続や式から直接入力を受け付けます。  入力はそのファイルから読み込まれ、ファイルの最後に達するまで解析され、解析された式は選択された環境で順次評価されます。
splitは，ベクトルxのデータをfで定義されたグループに分割します．
split は、ベクトル x のデータを f で定義されるグループに分割します。置換形は、そのような分割に対応する値を置き換えます。
カレンダーの日付を表すクラス "Date" の説明。
split は、ベクトル x のデータを f で定義されるグループに分割します。置換形式は、そのような分割に対応する値を置き換えます。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
split は、ベクトル x のデータを f で定義されるグループに分割します。置換形式は、このような分割に対応する値を置き換えます。
splitはベクトルxのデータをfで定義されたグループに分割します。置換形はそのような分割に対応する値を置き換えます。
splitはベクトルxのデータをfで定義されたグループに分割します。置換形はそのような分割に対応する値を置き換えます。
C関数のsprintfのラッパーであり、テキストと変数値の組合せをフォーマットした文字ベクトルを返す。
abs(x)はxの絶対値を、sqrt(x)はxの（主）平方根を、√{x}はxの（主）平方根を計算する。
適切なシングルクォーテーションとダブルクォーテーションを組み合わせて、テキストをシングルクォーテーションまたはダブルクォーテーションします。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型Rセッション、つまりoptions(keep.source = TRUE)のときに使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE)の場合、対話型Rセッションで使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE)の場合、対話型Rセッションで使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、options(keep.source = TRUE)の場合、対話型Rセッションで使用できます。
standardGeneric関数は、S4メソッドのディスパッチを開始します。  通常、この関数の呼び出しは自動的に生成され、プログラマが明示的に行うことはありません。
文字列が共通の長さにリサイクルされる場合、xのエントリがそれぞれ文字列(のエントリ)のプレフィックスまたはサフィックスで始まるか終わるかを決定します。
接続のアスペクトを表示する。
接続のアスペクトを表示する。
接続の側面を表示する。
stop は、現在の式の実行を停止し、エラー・アクションを実行する。
(in ... または exprs) の式がすべて TRUE でない場合、stop が呼び出され、(すべて) TRUE でなかった最初の式を示すエラー・メッセージが生成される。
Rオブジェクトの'mode'(一種の'型')、または格納モードを取得または設定する。
Rオブジェクトの'mode'（'type'の一種）またはstoragemodeを取得または設定する。
parse() は、パース済みだが未評価の式を、呼び出しの「リスト」である anexpression で返します。
parse()は、expression内のパース済みだが未評価の式を、呼び出しの「リスト」として返す。
文字表現と、カレンダー日付と時刻を表すクラス "POSIXlt "および "POSIXct "のオブジェク トとを変換する関数。
文字表現と、カレンダー日付と時刻を表すクラス "POSIXlt "と "POSIXct "のオブジェクトとの間で変換を行う関数。
文字ベクトル内の文字列を指定された回数繰り返す（すなわち、それぞれの文字列のコピー数を連結する）。
文字ベクトルxの要素を、その中の部分文字列分割のマッチに従って部分文字列に分割する。
C関数 strtol を使って文字列を指定された基数に従って整数に変換するか、Cの規則に従って適切な基数を選ぶ。
文字列を指定された表示幅にトリムする。
構造体は、与えられたオブジェクトにさらにattributesをセットして返す。
入力の各文字列は、まず段落（または空白のみを含む行）に分割されます。  そして、段落は単語の境界で改行されることによって整形される。  行を折り返す対象の列と、段落の最初の行とそれに続くすべての行のインデントは、独立に制御することができる。
grep、grepl、regexpr、gregexpr、regexec および gregexec は、文字ベクトルの各要素内の引数パターンにマッチするものを検索する。
条件を満たすベクトル、行列、データフレームの部分集合を返します。
条件を満たすベクトル、行列、またはデータ・フレームの部分集合を返します。
条件を満たすベクトル、行列、またはデータ・フレームの部分集合を返します。
条件を満たすベクトル、行列、またはデータ・フレームのサブセットを返します。
substitute は、(未評価の) 式 expr の解析ツリーを返します。
文字ベクトル内の部分文字列を抽出または置換します。
文字ベクトル内の部分文字列を抽出または置換します。
文字ベクトル内の部分文字列の抽出または置換
文字ベクトル内の部分文字列を抽出または置換する。
sumは、引数に含まれるすべての値の合計を返します。
summary は、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、最初の引数のクラスに依存する特定のメソッドを呼び出します。
接続を作成、オープン、クローズする関数、つまり、圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成する関数です。
summaryは、様々なモデルフィッティング関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第1引数のクラスに依存する特定のメソッドを呼び出します。
グループジェネリックメソッドは、Math、Ops、Summary、Complexの4つのあらかじめ指定された関数グループに対して定義することができます(ベースRにはこれらの名前のオブジェクトはありませんが、メソッドパッケージにはあります)。
カレンダーの日付を表す "Date "クラスの説明。
カレンダー日付を表すクラス "Date "の説明。
summaryは、様々なモデルフィット関数の結果の要約を作成するために使用される汎用関数です。  この関数は、第1引数のクラスに依存する特定のメソッドを呼び出します。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドは、これらの "時間差 "を呼び出します。
summaryは、様々なモデルフィッティング関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第1引数のクラスに依存する特定のメソッドを呼び出します。
factor 関数は、ベクトルを因子としてエンコードするために使用されます（因子には 'category' および 'enumerated type' という用語も使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
summaryは、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第1引数のクラスに依存する特定のメソッドを呼び出します。
パッケージ・バージョンを含む数値バージョンと関連するメソッドを表現するためのシンプルなS3クラスです。
factor関数は、ベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数orderedがTRUEである場合、factorlevelsは順序付けされていると仮定される。  Sとの互換性のためにordered関数もある。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
暦日時を表すクラス "POSIXlt "と "POSIXct "の説明。
POSIXlt "及び "POSIXct "クラスの説明。
カレンダーの日付と時刻を表すクラス「POSIXlt」と「POSIXct」の説明。
proc.timeは、現在実行されているRプロセスが既に費やした実時間とCPU時間（秒）を決定する。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（"srcref"）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型Rセッション（options(keep.source = TRUE)の場合）で使用できます。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（「srcref」）、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常、対話型 R セッション（options(keep.source = TRUE) の場合）で使用できます。
table は、クロス分類因子を使用して、各因子レベルの組み合わせにおけるカウントの分割表を構築します。
warningsとそのprintメソッドは、変数last.warningを見やすい形で表示します。
引数から診断メッセージを生成する。
引数から診断メッセージを生成します。
引数および（オプションで）その引数が呼び出された式または関数に対応する警告メッセージを生成します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
矩形行列の特異値分解を計算します。
入力配列から要約統計量を掃引して得られた配列を返す。
switchはEXPRを評価し、それに応じてさらに引数の1つを選択する（in ...）。
これらの関数は、呼び出しスタックのさらに上の関数に関連する環境（S用語では「フレーム」）へのアクセスを提供する。
これらの関数は、呼び出しスタックのさらに上にある関数に関連する環境（S用語では「フレーム」）へのアクセスを提供する。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供する。
Sys.timeとSys.Dateは、時刻の有無にかかわらず、システムが考える現在の日付を返します。
これらの関数は、呼び出しスタックのさらに上の関数に関連する環境（S用語で「フレーム」）へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上にある関数に関連付けられた環境（S用語では「フレーム」）へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上にある関数に関連する環境('フレーム')へのアクセスを提供する。
Sys.getenvは環境変数の値を取得します。
Rプロセスのロケールの詳細を取得または設定する。
RセッションのプロセスIDを取得する。  同時に実行される2つのRセッションが異なるIDを持つことはオペレーティング・システムによって保証されているが、異なる時間に実行されるRセッションが同じIDを持つ可能性もある。
ファイルパスのワイルドカード展開（「グロビング」とも呼ばれる）を行う関数。
システムおよびユーザー情報のレポート。
基本パッケージの内部オブジェクト。そのほとんどは、基本名前空間の特別な性質のため、ユーザーからのみ見ることができる。
現在のロケールにおける数値および通貨表現の詳細を取得します。
これらの関数は、呼び出しスタックのさらに上にある関数に関連する環境（S用語では「フレーム」）へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた環境（S用語では「フレーム」）へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上にある関数に関連する環境('フレーム')へのアクセスを提供する。
これらの関数は、呼び出しスタックのさらに上にある関数に関連付けられた環境（S用語では'フレーム'）へのアクセスを提供する。
ファイルパスがシンボリックリンクであるかどうか、またシンボリックリンクである場合はそのリンク先が何であるかを、システムコール readlink を使って調べることができる。
Sys.setenvは、ベース・パッケージの内部オブジェクトを設定する。
Sys.setenvは、環境変数を設定します（Rの内部から呼び出される他のプロセスや、このRプロセスから将来呼び出されるSys.getenvのために）。
システム・コールを使用して、ファイルやディレクトリの時刻を設定する。
R プロセスのロケールの詳細を取得または設定する。
指定された時間間隔の間、R式の実行を一時停止する。
指定されたファイル内の式を解析し、指定された環境でそれらを連続的に評価する。
これらの関数は、呼び出しスタックのさらに上の関数に関連する環境（S用語では「フレーム」）へのアクセスを提供する。
Sys.timeとSys.Dateは、時刻の有無にかかわらず、システムが考える現在の日付を返します。
Sys.timezoneは、現在のタイムゾーン名を返します。
これらの関数は、コンピュータのファイル・システムに対する低レベルのインタフェースを提供する。
Sys.setenvは、環境変数を設定します（R内から呼び出される他のプロセスや、このRプロセスから将来呼び出されるSys.getenvのために）。
これは、systemコマンド、またはWindows上のエミュレーションへのインターフェースです。
systemは、commandで指定されたOSコマンドを呼び出します。
パッケージなどに含まれるファイルの完全なファイル名を検索します。
exprが使用したCPU（およびその他の）時間を返す。
system2はcommandで指定されたOSコマンドを起動します。
行列またはdata.frame x,tを指定すると、xの転置行列を返します。
logical "型のオブジェクト、およびbasiclogical定数を作成またはテストする。
行列またはdata.frame x,tからxの転置行列を返します。
行列またはdata.frame x,tが指定されると、xの転置行列を返します。
table は、因子レベルの各組み合わせにおけるカウントの分割表を構築するために、分類横断因子を使用します。
tabulateは、整数値ベクトルbinを取り、各整数がその中に出現する回数を数えます。
これらの関数は明らかな三角関数を与える。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントをそれぞれ計算します。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または「面積余弦」など）を計算します。
これらの関数は、明らかな三角関数を与える。  これらの関数は、コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2つの引数を持つアーク・タンジェントを計算する。
ラグド配列の各セル、つまり、ある因数のレベルの一意な組み合わせで与えられる値の（空でない）各グループに関数を適用する。
これは、各トップレベル・タスクの終了時に呼び出されるコールバックやアクションを管理するための、完全にR言語的なメカニズムを提供する。  基本的には、このマネージャから1つのR関数を基礎となるネイティブなタスク・コールバック機構に登録し、この関数がマネージャの制御下で他のRコールバックの呼び出しを処理する。マネージャは、ユーザーレベルのコールバックのリストを管理するために共有変数にアクセスする関数のコレクションで構成される。
行列xとyを引数として与え、行列のクロス積を返す。  これは形式的にはt(x) %*% y (crossprod)またはx %*% t(y) (tcrossprod)の呼び出しと等価です（ただし、通常はそれより若干高速です）。
tempfile は、一時ファイルの名前として使用できる文字列のベクトルを返します。
tempfile は、一時ファイルの名前として使用できる文字列のベクトルを返します。
入出力テキスト接続
入出力テキスト接続。
文字ベクトル内の文字、特に大文字から小文字への変換、またはその逆。
environmentenvirとそれを囲む環境からトップレベル環境を見つける。
これは、R オブジェクトを記述する 1 文字の文字列を生成する format 用のヘルパー関数です。
これは、Rオブジェクトを記述する1文字の文字列を生成するformatのヘルパー関数です。
文字ベクトル内の文字、特に大文字から小文字、またはその逆を変換します。
traceを呼び出すと、関数内の選択された場所にデバッグ・コード（ブラウザへの呼び出しやrecoveryなど）を挿入することができます。  untraceの呼び出しは、トレースをキャンセルします。指定されたメソッドは、汎用関数へのすべての呼び出しをトレースすることなく、同じ方法でトレースすることができます。  トレース・コード(tracer)は任意のR式です。  トレースは、tracingStateを呼び出すことで、一時的にグローバルにオンまたはオフにすることができます。
デフォルトでは、traceback() は最後に捕捉されなかったエラーのコールスタック、つまりエラーに至った呼び出しのシーケンスを表示します。  また、現在のスタックや呼び出しの任意のリストを表示するためにも使用できる。
この関数はオブジェクトをマークし、内部コードがそのオブジェクトをコピーするたびにメッセージが表示されるようにします。  この関数は、Rのメモリ使用量を予測しにくくする主な原因となっています。
traceを呼び出すと、デバッグ・コード（例えば、ブラウザやrecoveryへの呼び出し）を任意の関数の選ばれた場所に挿入することができます。  untraceを呼び出すと、トレースがキャンセルされます。指定したメソッドも同じようにトレースすることができ、ジェネリック関数へのすべての呼び出しをトレースする必要はありません。  トレース・コード(tracer)は任意のR式です。  トレースは、tracingStateを呼び出すことによって、一時的にグローバルにオンまたはオフにすることができます。
transform.defaultは、可能であれば最初の引数をデータフレームに変換し、transform.data.frameを呼び出します。
transform.defaultは最初の引数を可能であればデータフレームに変換し、transform.data.frameを呼び出します。
transform.defaultは最初の引数を可能であればデータフレームに変換し、transform.data.frameを呼び出す。
ベータ関数とガンマ関数に関連する特殊な数学関数。
文字列から先頭または末尾の空白を除去する。
ceilingは1つの数値引数xを取り、xの対応する要素より小さくない最小の整数を含む数値ベクトルを返す。
date-time オブジェクトを丸めたり切り捨てたりする。
日付-時刻オブジェクトを丸めたり切り捨てたりします。
接続の位置を変更する関数
接続の位置を変更する関数。
try は、失敗する可能性のある式を実行し、ユーザーのコードでエラー回復を処理できるようにするためのラッパーです。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
typeofはオブジェクトの(R内部の)型や記憶モードを決定します。
Rには、オブジェクト指向プログラミングに使用できるシンプルな汎用関数メカニズムがあります。  メソッドのディスパッチは、ジェネリック関数の最初の引数のクラスに基づいて行われます。
関数のデバッグ・フラグの設定、解除、または問い合わせを行います。テキスト引数と条件引数は、ブラウザの呼び出しで与えられるものと同じです。  また、どのブレークポイントが有効化されたかを識別するためのメカニズムも提供します。
union(和)、intersection(交差)、(非対称！)difference(差)、equality(等号)、membership(メンバーシップ)を2つのベクトルに対して実行します。
unique は、xb のようなベクトル、データフレーム、または配列を返しますが、重複する要素や行は削除されます。
unique関数は、xbのようなベクトル、データフレーム、または配列を返しますが、重複する要素や行は削除されます。
unique関数は、重複する要素や行を取り除いたxbのようなベクトル、データ・フレーム、または配列を返します。
unique関数は、xbのようなベクトル、データ・フレーム、または配列を、重複する要素や行を削除して返します。
uniqueは、xbutのようなベクトル、データフレーム、または配列を返しますが、重複した要素や行は削除されます。
パッケージ・バージョンを含む数値バージョンを表すシンプルな S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス "POSIXlt "と "POSIXct "の説明。
warningsとそのprintメソッドは、変数last.warningを気持ちの良い形で表示します。
時間間隔の作成、印刷、いくつかの演算。  print()メソッドは、これらの "時差 "を呼び出す。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドはこれらの「時間差」を呼び出す。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドはこれらの「時間差」を呼び出す。
時間間隔の作成、印刷、およびいくつかの演算。  print()メソッドはこれらの "時間差 "を呼び出す。
これらの関数は、Rの古いバージョンとの互換性のためだけに提供されており、次のリリースの時点で廃止される可能性がある。
unlinkは、xで指定されたファイルまたはディレクトリを削除する。
リスト構造xが与えられた場合、unlistはそれを単純化し、xに出現するすべての原子成分を含むベクトルを生成する。
名前空間をロードおよびアンロードする関数。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスを表す。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
Rオブジェクトのnamesまたはdimnames属性を削除します。
コネクションにシリアライズするためのシンプルな低レベルインターフェース。
splitはベクトルxのデータをfで定義されたグループに分割します。
traceを呼び出すと、関数内の任意の場所にデバッグ・コード（ブラウザやrecoveryへの呼び出しなど）を挿入することができます。  untraceの呼び出しは、トレースをキャンセルします。指定されたメソッドは、汎用関数へのすべての呼び出しをトレースすることなく、同じ方法でトレースすることができます。  トレース・コード(tracer)は任意のR式です。  トレースは、tracingStateを呼び出すことによって、一時的にグローバルにオンまたはオフにすることができます。
この関数はオブジェクトをマークし、内部コードがそのオブジェクトをコピーするたびにメッセージが出力されるようにします。  この関数は、Rのメモリ使用量を予測しにくくする主な原因となっています。
コネクション、すなわち「一般化されたファイル」（圧縮ファイル、URL、パイプなど）を作成、オープン、クローズする関数。
下三角形または上三角形に TRUE を持つ、与えられた行列と同じ大きさの論理の行列を返す。
接続、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
Rは、オブジェクト指向スタイルのプログラミングに使用できるシンプルなジェネリック関数メカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数の最初の引数、またはUseMethodやNextMethodの引数として与えられたオブジェクトのクラスに基づいて行われます。
UTF-8でエンコードされた文字ベクトルをUTF-32でエンコードされた整数ベクトルに変換します。
文字ベクトルの各要素が、その暗黙のエンコーディングで有効かどうかをチェックします。
文字ベクトルの各要素がその暗黙のエンコーディングで有効かどうかをチェックする。
lapplyは、Xの対応する要素にFUNを適用した結果の、Xと同じ長さのリストを返す。
vector は、与えられた長さとモードのベクトルを生成します。
Vectorizeは、引数FUNの作用をベクトル化する関数のラッパーを作成します。
R.Version()は、実行中のRのバージョンに関する詳細情報を提供します。
R.Warning()は、引数および（オプションで）呼び出された式または関数に対応する警告メッセージを生成します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
warningsとそのprintメソッドは、変数last.warningを楽しい形式で表示します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付時刻クラスのメソッドについては、ここで文書化されています。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、このドキュメントを参照してください。
論理オブジェクトの TRUE インデックスを返します。
数値(または論理)ベクトルの(最初の)最小値または最大値の位置、つまりインデックスを決定します。
数値(または論理)ベクトルの(最初の)最小値または最大値の位置、すなわちインデックスを決定します。
これらはR言語の基本的な制御フローの構成要素である。  これらはAlgol系言語の制御文とほとんど同じように機能します。  これらはすべて予約語である。
データから構築された環境でR式を評価し、場合によっては元のデータを変更（コピー）する。
データから構築された環境でR式を評価する。
source を指定すると、R は指定されたファイルや URL、または接続や式から直接入力を受け付けます。  入力はそのファイルから読み込まれ、ファイルの終端に達するまで解析された後、解析された式が選択された環境で順次評価されます。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
データから構築された環境でR式を評価し、場合によっては元のデータを変更（コピー）する。
データから構築された環境でR式を評価し、場合によっては元のデータを変更（コピー）する。
データから構築された環境でR式を評価し、元のデータを変更（コピー）する。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
この関数は式を評価し、その値と自動的に印刷されるかどうかを示すフラグを含む2要素のリストで返します。
データ（通常は行列）xはファイルfileに書き込まれます。xが2次元行列の場合、内部表現と同じ列をファイルに書き込むために転置する必要があります。
RオブジェクトをDebian Control Fileformatのファイルから/ファイルへ読み書きする。
接続または raw ベクタからのバイナリデータの読み込み、または接続または raw ベクタへのバイナリデータの書き込み。
接続上でヌル終端であると仮定せずに、文字列を接続との間で転送する。
接続にテキスト行を書き込む。
これらの演算子は、生のベクトル、論理ベクトル、および数値ライクなベクトルに対して作用します。
データ・フレームで使用する内部補助関数。
x と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
xと同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
xと同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
xと同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
xと同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
xと同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
xと同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連するメソッド。
xと同じ順序でソートする数値ベクトルを生成する汎用補助関数。
x と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
接続を作成、オープン、クローズする関数。すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
zapsmallは、round(x, digits = dr)を呼び出すためのdigits引数drを決定し、(絶対値の最大値と比較して)0に近い値を「zaps」、つまり0に置き換える。
この関数は、現在のプロットを通る1本以上の直線を追加します。
点のペア間に矢印を引く。
2次元分割表の行と列の独立性からのずれを示すCohen-Friendly連想プロットを作成します。
現在のプロットに軸を追加し、辺、位置、ラベル、およびその他のオプションを指定できるようにする。
現在のプロットに適切な軸を追加する汎用関数。
POSIXlt"、"POSIXct "および "Date "クラスのオブジェクトをプロットする関数。
クラス "POSIXlt"、"POSIXct "および "Date "のオブジェクトをカレンダーの日付と時刻でプロットする関数
Rが内部的に行うのと同じ方法で、きれいな目盛りの位置を計算します。これは、対数座標が有効な場合にのみ、自明ではありません。デフォルトでは、atの値は、axis(side)が使用する値を与えます。
縦棒または横棒の棒グラフを作成します。
垂直または水平のバーを持つ棒グラフを作成します。
この関数は、与えられた色と線種で、現在のプロットの周囲にボックスを描画します。  bty パラメータは、描画されるボックスのタイプを決定します。  詳細は par を参照。
与えられた（グループ化された）値の箱ひげ図プロットを作成します。
与えられた(グループ化された)値の箱ひげプロットを作成します。
行列の列（または行）を異なるグループとして解釈し、それぞれについて箱ひげ図を描画する。
bxp は、与えられた z の要約に基づいて箱ひげ図を描画します。通常は boxplot 内から呼び出されますが、直接呼び出すこともできます。
カテゴリ変数yの条件付き分布が、数値変数xに対してどのように変化するかを記述する条件付き密度を計算し、プロットします。
ユーザー座標でクリッピング領域を設定
split.screenは、現在のデバイスの中に、ある程度、別々のグラフィックデバイスとして扱えるいくつかの領域を定義します。  これは、1つのデバイスで複数のプロットを作成するのに便利です。  画面そのものを分割することができるので、かなり複雑なプロットの配置が可能になる。
この関数は、以下のリファレンスで説明されているコンディショニング・プロットの2つのバリエーションを作成します。
等高線プロットの作成、または既存のプロットに等高線を追加。
等高線プロットを作成、または既存のプロットに等高線を追加。
この関数は、以下のリファレンスで説明されているコンディショニングプロットの2つのバリエーションを作成します。
curveは、変数xname（デフォルトx）の式もプロットできます。
クリーブランドドットプロット
split.screenは、カレントデバイス内にいくつかの領域を定義し、それらをある程度別々のグラフィックデバイスとして扱うことができます。  これは、1つのデバイスで複数のプロットを作成するのに便利です。  画面そのものを分割することができるので、かなり複雑なプロットの配置が可能になる。
この関数は、等高線と等高線の間の領域を実線で塗りつぶした等高線プロットを作成します（Clevelandはこれをレベルプロットと呼んでいます）。  プロットの右側には、色がz値にどのように対応するかを示すキーが表示される。
2×2×k分割表の4重表示を現在のグラフィックス・デバイス上に作成し、1つまたは複数の母集団（層）における2つの2分変数間の関連を視覚的に検査できるようにします。
この関数(frameはplot.newのエイリアス)は、現在のプロット(もしあれば)を終了させ、新しいグラフィックス・フレームに進めます。  これは、すべての高レベルのプロット関数で使用され、また、複数の図領域が使用されているときにプロットをスキップするのにも便利です。
グラフィックス座標系間の変換
グラフィックス座標系間の変換。
grid は，既存のプロットに nx × ny の矩形グリッドを追加します．
汎用関数 hist は，与えられたデータ値のヒストグラムを計算します．  plot = TRUEの場合，"histogram "クラスのオブジェクトがplot.histogramによってプロットされてから返されます．
ジェネリック関数 hist は，与えられた値のヒストグラムを計算します．  plot = TRUEの場合，"histogram "クラスのオブジェクトは，plot.histogramによってプロットされてから返されます．
identify は，（最初の）マウスボタンが押されたときのグラフィックスポインタの位置を読み込みます．  この点がポインタに十分に近ければ，そのインデックスが呼び出し値の一部として返されます．
これは、3次元データまたは空間データ、別名画像を表示するために使用することができます。
zの値に対応する色を持つ色付きまたはグレースケールの矩形のグリッドを作成します。
layoutは、matrix matの数だけデバイスを行と列に分割し、それぞれの引数で列幅と行の高さを指定します。
layout は、それぞれの引数で指定された列幅と行高で、デバイスを行列 mat の数だけ行と列に分割します。
layoutは、それぞれの引数で指定された列幅と行の高さで、matrixの中にあるのと同じ数の行と列にデバイスを分割します。
この関数は、プロットに凡例を追加するために使用することができる。  引数xとyの代わりに関数locator(1)の呼び出しが使えることに注意。
様々な方法で与えられた座標を取り、対応する点を線分で結合する汎用関数。
様々な方法で与えられた座標を取り、対応する点を線分で結合する汎用関数。
(最初の)マウスボタンが押された時のグラフィックカーソルの位置を読み取る。
ある行列の列を別の行列の列に対してプロットする（1列の行列として扱われるベクトルであることが多い）。
ある行列の列を別の行列の列に対してプロットする (多くの場合、1列の行列として扱われる単なるベクトルである)。
ある行列の列を別の行列の列に対してプロットする(whichoftenは単なる1列行列として扱われるベクトルである)。
現在のグラフィックデバイスにモザイクをかける。
テキストは、現在の図形領域の4つの余白のうちの1つ、またはデバイス領域の外側の余白のうちの1つに書き込まれます。
散布図の行列が生成される。
散布図の行列が生成される。
coplotやpairsなどの引数として使用される単純で便利なパネル関数の例。
パラメータは、par の引数として intag = value 形式で指定するか、タグ付き値のリストとして渡すことで設定できます。
perspは汎用関数です。
円グラフを描画します。
アクティブなグラフィックス・ウィンドウで、軸やタイトルなどの装飾を持つ散布図を描画します。
アクティブなグラフィックスウィンドウで、軸やタイトルなどの装飾を含む散布図を描く
1つまたは複数の要因の単変量効果をプロットします。典型的には、aov()によって分析された計画された実験の場合です。
curveは、変数xname（デフォルトx）の式もプロットすることができます。
この関数(frameはplot.newのエイリアス)は、現在のプロット(もしあれば)を終了させ、新しいグラフィックフレームに進めます。  これは、すべての高レベルのプロット関数で使用され、また、複数の図領域が使用されているときにプロットをスキップするのにも便利です。
この関数は、グラフィックスウィンドウのワールド座標系を設定します。  plot.default（plot.newの後）のような上位関数から呼び出されます。
これは点と線の基本的なプロットを行う内部関数です。  通常、より上位の関数を使用し、引数の説明についてはそのヘルプページを参照してください。
pointsは、指定された座標に一連の点を描画する汎用関数です。  指定された文字は、座標を中心として描画される。
pointsは、指定された座標に一連の点を描画する汎用関数です。  指定された文字が座標を中心に描画される。
polygonは、xとyを頂点とする多角形を描画します。
path は、頂点が x と y で指定されたパスを描画します。
rasterImageは、指定された位置とサイズのラスター画像を描画します。
rect は、与えられた座標、塗りつぶし色、境界色で矩形（または矩形のシーケンス）を描画します。
データのラグ表現（1-dプロット）をプロットに追加します。
split.screenは、カレントデバイス内にいくつかの領域を定義し、ある程度、別々のグラフィックデバイスとして扱うことができます。  これは、1つのデバイスで複数のプロットを生成するのに便利です。  画面自体を分割することができるので、かなり複雑なプロットの配置が可能になります。
点のペア間に線分を引く。
smoothScatterは、（2D）カーネル密度推定によって得られる、散布図の平滑化されたカラー密度表現を生成します。
スパインプロットは、モザイクプロットの特殊なケースであり、積み重ね（またはハイライト）棒グラフの一般化と見ることができます。同様に、スピノグラムはヒストグラムの拡張です。
split.screenは、現在のデバイス内にいくつかの領域を定義するもので、ある程度、別々のグラフィック・デバイスとして扱うことができる。  これは、1つのデバイスで複数のプロットを作成するのに便利です。  画面自体も分割できるので、かなり複雑なプロットの配置が可能です。
1つの場所で、「スパイダー」（または「レーダー」）プロットも作成できます。
パラメータ scale は、プロットのスケールを拡大するために使用できます。  scale = 2とすると、プロットの長さはデフォルトの約2倍になります。
これらの関数は、与えられた文字列または数式s[i]の幅または高さを、現在の描画デバイス上で、それぞれユーザ座標インチまたは図幅の分数par("fin")で計算します。
stripchartは、与えられたデータの1次元散布図（または点描図）を作成します。  これらのプロットは、標本サイズが小さい場合に、boxplotsに代わる良い方法です。
これらの関数は、与えられた文字列または数式s[i]の幅または高さを、現在の描画デバイス上で、それぞれユーザ座標、インチ、または図幅の分数par("fin")で計算します。
複数の点は、複数の葉('花びら')を持つ'ひまわり'としてプロットされ、オーバープロットが偶然に起こるのではなく、見えないように視覚化されます。
この関数は、プロット上にシンボルを描画します。  円、正方形、長方形、星形、温度計、箱ひげ図の6つのシンボルのうちの1つを、指定したx座標とy座標にプロットすることができます。  相対的な大きさなど、シンボルの特定の側面は、追加のパラメータによってカスタマイズすることができます。
textは、ベクトルラベルで指定された文字列をxとyで指定された座標に描画します。座標の構築にxy.coords(x, y)が使用されるため、yが不足する場合があります。
xy.coords(x, y)が座標の構築に使用されるため、x.y.yで与えられた座標のベクトルラベルに指定された文字列が欠落している可能性があります。
この関数は、プロットにラベルを追加するために使用することができる。  最初の4つの主要な引数は、ほとんどの高レベルのプロット関数の引数としても使用できます。  これらは文字型か式型でなければならない。後者の場合、下付き文字や上付き文字、ギリシャ文字、分数など、多くの数学的記法が利用できます。
xinchとyinchは、引数として与えられた指定されたインチ数を、グラフィック関数でプロットするための正しい単位に変換します。  通常、これは通常の座標が使用される場合、つまり対数スケールがない場合にのみ意味を持ちます（parのlog引数を参照）。
Xスプラインを描画します。
xinch と yinch は、引数として指定されたインチ数を、graphics 関数で描画するための正しい単位に変換します。  通常、これは通常の座標が使用される場合、つまり対数スケールがない場合にのみ意味を持ちます（parのlog引数を参照）。
xinch と yinch は、引数として与えられた指定されたインチ数を、graphics 関数でプロットするための正しい単位に変換します。  通常、これは通常の座標が使用される場合、つまり対数スケールがない場合にのみ意味を持ちます（parのlog引数を参照）。
行列の乗算に類似した操作として、2つのベクトルや行列を加算するのが便利な場合があります。行列nXmとmYpの場合、nSpのi,j番目の要素の行列和=iXm + mYjのsum(over m)。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、些細な関数ですが、行列の下三角形を四捨五入して表示する便利な関数です。reflectは、因子分析または主成分分析の出力を、1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
信頼性の内部一貫性の尺度は、omega_hierchicalからalpha、omega_totalまであります。  この関数は2つの推定値を報告します：Cronbachの係数αとGuttmanのλ_6。  また、項目-全体相関、項目が省略された場合のアルファ値、項目の平均値と標準偏差も報告されます。
信頼性の内部一貫性の尺度は、omega_hierchical から alpha から omega_total までの範囲です。  この関数は2つの推定値を報告する：Cronbachの係数アルファとGuttmanのλ_6。  また、項目と全体の相関、項目が省略された場合のアルファ値、項目の平均値と標準偏差も報告されます。
データから回帰を行うとき、またはsetCorを使って相関行列から回帰を行うとき、またはlink{mmediate}を使って媒介分析を行うときは、代替モデルを比較するのが便利です。  これらは両方とも回帰モデルなので、適切な検定は分散分析です。  カイ2乗を用いた同様な検定は、因子分析モデルについても行うことができる。
多くの分野では，根底にある現象はたぶん連続的であるにもかかわらず，決定や結果はカテゴリー的である．  例えば、学生が大学院に合格するかしないか、卒業するかしないか。X線検査は、患者が癌であるか否かを診断する。   このような決定の結果は、通常、Valid Positives（有効な陽性）、Valid Negatives（有効な陰性）、False Positives（偽陽性）、False Negatives（偽陰性）とラベル付けされる。仮説検定では、偽陽性はタイプIのエラーとして知られ、偽陰性はタイプIIのエラーである。  これら4つのセルの関係は、決定ルールと結果の相関関係、および決定に必要な証拠のレベル（基準）に依存する。  信号検出理論と決定理論には、性能（accuracy = VP + VN）、感度（VP/(VP + FN)）、特異度（1 - FP）、d プライム（d'）、および応答動作特性曲線下面積（AUC）の多くの関連尺度がある。より一般的には，これらは2値データに基づく相関の例である．  AUCは、これらの質問のいくつかに対応します。  
Von Neumanら(1941)は、平均の漸進的なシフトを考慮に入れた変動性の尺度として、連続差の二乗平均について論じています。これは、弾道学の誤差を研究するときや、情動を研究するときの気分の変動性や安定性を研究するときに適切である。ランダムなデータの場合、これは分散の2倍になりますが、順序が連続し、正の自己相関を持つデータの場合、これはずっと小さくなります。mssdは分散-自己相関の2倍なので、特定のラグの自己相関を見つけることも可能です。
Goldberg (2006)は、「トップ・ダウン」からの階層的な因子構造構成について説明した。  最初のアイデアは、あるレベルから次のレベルへの因子スコア相関によって組織化された1因子からnf因子までの連続した因子分析を行うことでした。  Waller (2007) は，スコアを求めずに成分についてこれを行う簡単な方法について議論した．  因子を階層的に組織化するために（Gorsuchからの）因子相関を使用すると，結果が多くの異なるレベルで組織化されるかもしれない．このアルゴリズムは，主成分（pca）または真の因子分析に適用できる．
Goldberg (2006) は，「トップ・ダウン」からの階層的な因子構造編成を説明した．  最初のアイデアは，あるレベルから次のレベルへの因子スコア相関によって組織化された1因子からnf因子までの連続した因子分析を行うことであった．  Waller (2007) は，スコアを求めずに成分についてこれを行う簡単な方法について議論した．  因子を階層的に組織化するために（Gorsuchからの）因子相関を使用すると，結果が多くの異なるレベルで組織化されるかもしれない．このアルゴリズムは，主成分（pca）または真の因子分析に適用できる．
Holzinger-Swineford (1937) は，一般因子と無相関グループ因子の2因子モデルを導入した．Holzingerのデータ・セットは、Joreskogによって例として使用された9 *9 行列と同様に、彼らの論文からのオリジナルの14 * 14 行列です。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
bestScalesは、特定の基準と最も相関のある項目/尺度から尺度を形成し、次に単位重み付けされた尺度を用いてホールドアウト標本で交差検証を行います。  これは、基本的なブートストラップ集計（バギング）手法またはKフォールド・クロス検証のいずれかを使用して、n.iter回繰り返すことができる。したがって，この手法は，BISCUIT (Best Items Scales that are Cross validated, Unit weighted, Informative, and Transparent) として知られている．  項目内容の辞書が与えられると、bestScalesは、基準の相関によってソートし、項目内容を表示する。バギング（ブートストラップ集計）のオプションも含まれています。単位重み付けの代替は、基準とのゼロ次相関（交差検証）によって項目を重み付けすることである。この重み付きバージョンはBISCWITと呼ばれ、オプションの出力です。
bestScalesは、特定の基準と最も相関のある項目/尺度から尺度を形成し、次に単位重み付けされた尺度を用いてホールドアウト標本でクロス検証を行います。  これは、基本的なブートストラップ集計（バギング）技法またはK-foldクロス検証のいずれかを使用して、n.iter回繰り返すことができる。したがって，この手法は，BISCUIT (Best Items Scales that are Cross validated, Unit weighted, Informative, and Transparent) として知られている．  項目内容の辞書が与えられると、bestScalesは、基準の相関によってソートし、項目内容を表示する。バギング（ブートストラップ集計）のオプションも含まれています。単位重み付けの代替は、基準とのゼロ次相関（交差検証）によって項目を重み付けすることである。この重み付けバージョンはBISCWITと呼ばれ、オプションの出力です。
Synthetic Aperture Personality Assessment (SAPA)ウェブベースの性格評価プロジェクトの一環として、International Personality Item Pool (ipip.ori.org)から採取された25の性格自己報告項目が含まれている。  被験者2800人のデータは、尺度構成、因子分析、項目反応理論分析のための実証セットとしてここに含まれている。  さらに3つの人口統計学的変数（性別、学歴、年齢）も含まれている。このデータセットは非推奨であり、ユーザーはbfiを使うことが推奨される。
Synthetic Aperture Personality Assessment (SAPA)ウェブベースの性格評価プロジェクトの一環として、International Personality Item Pool (ipip.ori.org)から採取した25の性格自己報告項目が含まれている。  被験者2800人のデータは、尺度構成、因子分析、項目反応理論分析のための実証セットとしてここに含まれている。  さらに3つの人口統計学的変数（性別、学歴、年齢）も含まれている。このデータセットは非推奨であり、ユーザーはbfiを使うことが推奨される。
例えば、2つのグループの年齢分布や学歴分布を表示する場合、それらを背中合わせにプロットすると便利です。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、その名前で呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotationへの適切な呼び出しによって実装されます。
bigCor は、変数を（size=size の）サブセットに分割し、すべてのサブセットの相関を求め、得られた行列を 1 つの大きな行列につなぎます。   cor と比較して速度が顕著に向上しています。  
fa, fa.poly, principalの出力にbiplot関数を拡張します。因子スコアと因子負荷量を同じグラフにプロットします。  因子の数が2より多い場合は、因子のすべてのペアがプロットされます。因子得点ヒストグラムは対角線上にプロットされる．入力は，fa, principal, または}code{linkfa.polyにscores=TRUEオプションを付けた結果のオブジェクトである．点は，他の基準に従って色付けすることもできる．
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
四分木相関は、二変量正規性を仮定した2×2表から推定されるピアソン相関です。ポリコレ相関は、これを n x m 表に一般化します。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
N個の条件のすべてに同数のn人の被験者を無作為に割り当てることは、ブロック無作為化によって行うことができ、ブロック・サイズは実験条件の数である。独立変数の数と各IVの水準数が入力として指定される。出力はブロック無作為化計画である。
McDonald(1999)や項目応答理論の他の議論で使用されているデータセットの例では、法科大学院入学共通テスト（LSAT）の10項目（5項目×2セット）のデータ表が使用されています。  このデータセットには、元の表と、第1セット（図分類）と第2セット（討論）に対する1000人の被験者の回答が含まれている。
Rindskopf and Rose (1988) は、このデータ集合を使って確認的2次因子モデルを実証しています。  これは、階層構造と代替因子解を探索するための良い例のデータセットです。このデータセットには流動性知能と結晶性知能の測定値が含まれている。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
John Schmid と John M. Leiman (1957)は、階層的因子構造を二因子構造に変換する方法について論じています。Schmid.leiman は、対角上に共同体性を持つ 12 x 12 の相関行列です。これは減衰補正の効果を示すために使用できます。Chenら(2006)から2つのデータセットを追加しました。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
因子分析と主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとする。  別の構造として，変数が2次元空間の円の外周に一様に配置された円周構造がある．  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
因子分析の回転や主成分分析の解は、一般的に相関行列を単純構造として表現しようとする。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造がある。  このようなデータを作成するのは簡単で、影響やパーソナリティ構造の代替解を探索するのに有用である。
因子分析の回転や主成分分析の解は、一般的に相関行列を単純な構造として表現しようとする。  代替的な構造として魅力的なのは、変数が2次元空間の円の外周に一様に配置された円周構造である。  このようなデータを作成するのは簡単で、影響やパーソナリティ構造の代替解を探索するのに有用である。
因子分析の回転や主成分分析の解は、一般的に相関行列を単純な構造として表現しようとする。  代替的な構造として魅力的なのは、変数が2次元空間の円の外周に一様に配置された円周構造である。  このようなデータの生成は簡単であり、感情や性格の構造に関する代替解を探索するのに有用である。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最も適合する位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最も適合する位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
1s、0s、1sのn x c個のクラスタ定義行列（キー）、およびn x n個の相関行列、またはN x n個のデータ行列が与えられたとき、合成クラスタの相関を求めます。  キー行列は，手入力，クリップボードからのコピー（read.clipboard），または factor2cluster や make.keys 関数からの出力として得ることができます．  scoreItems と同様の機能で、項目ごとのクラスタ相関も得ることができます。
ICLUSTによって発見されたクラスタモデルは、元の相関行列にどの程度フィットするか？  同様のアルゴリズム factor.fit が VSS にある。この関数は ICLUST の内部関数であるが、より一般的な使い方もできる。
n x n の相関行列と、c 個のクラスタ上の n 個の項目に対する-1,0,1 クラスタ重みの n x c 行列が与えられたとき、各項目と各クラスタとの相関を求めます。  項目がクラスタの一部である場合、項目の重複を補正する。  ICLUST関数セットの一部であるが、多くの項目分析問題に有用である。
クラスター分析と因子分析は、より少ない数の（潜在）因子または（観察された）クラスターの観点から項目をグループ化する手順である。  クラスターのグラフィカルな表示は、一般的にツリー構造を示しますが、項目とクラスターの相関で表現することもできます。  
kmeans クラスタリング関数の出力は、クラスタ・メンバーシップのベクトルを生成します。  score.items と cluster.cor 関数はキーの行列を必要とします。
data.frameまたは行列が与えられた場合、グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d 統計量を r 統計量に変換し、Student の t 統計量と関連する p 値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL, OVL2など）が利用可能である．
Cohenのカッパ (Cohen, 1960) および重み付きカッパ (Cohen, 1968) は，名義得点を使用する場合に2人の評定者の一致を見つけるために使用できる．  2人以上の評定者を使用する場合，ライトのカッパは，単に平均コーエン・カッパである．
2つの行列の一致係数は，それぞれの値のクロス積を平方根で割ったものである．列がゼロ中心の場合、これは単なる相関である。列がスケール中立点を中心とする場合、これはコーエンのプロファイル相関である。距離の集合（街区、ユークリッド、ミンコフスキー）は、距離関数によって求めることができる。
医学や臨床心理学では、診断はカテゴリー化される傾向がある（誰かがうつ病かそうでないか、誰かが不安障害かそうでないか）。  これらの症状が併存することを併存性という。   診断カテゴリーによって、他の診断カテゴリーとの併存性の程度は異なる。  相関の観点からは、併存率は4重表の1つのセルにつけられた名前にすぎない。  したがって、別々の診断の確率と合同診断の確率を考慮することで、併存率を分析することが可能である。  これにより、ファイ相関、ユール相関、テトラコリック相関に必要な2×2の表が得られる。
因子分析や主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとする。  別の構造として，変数が2次元空間の円の外周に一様に配置される円周構造がある．  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
古典的テスト理論（CTT）は、すべてのテストが1つの因子と残差誤差で表現できる場合、4つ以上のテストは共属的に等価であると考える。  並列検定は，（通常2つの）検定が等しい因子負荷量を持つ特別なケースである．  タウ等価検定は，等しい因子負荷量を持つが，不均等な誤差を持つことがある．  共属検定は，因子負荷と誤差分散の両方で異なることがある．
2つの行列の一致係数は，それらの平方和の平方根で割ったそれぞれの値の積である．列がゼロ中心の場合，これは単なる相関である．列がスケール中立点を中心とする場合、これはコーエンのプロファイル相関である。距離の集合（街区、ユークリッド、ミンコフスキー）は、距離関数によって求めることができる。
正規理論は相関の信頼区間を提供するが、これは個々の項目がMassively Missing at RandomであるSynthetic Aperality Assessment (SAPA)データでは特に問題となる。  ブートストラップ信頼区間は、Pearson相関、Spearman相関、Kendall相関、tetrachoric相関、polychoric相関、およびそれらの相関から作成された尺度について発見されます。相関行列と標本サイズが与えられると，正規理論による信頼区間が提供される．
相関行列は，構造を強調するために画像関数を用いてグラフィカルに表示することができる．  これは，明確な構造を持つ相関行列の構造を示すのに特に有用なツールである．  部分的には，因子分析や他の多変量解析技法を教えたり議論したりするためのグラフィックの教育的価値を意味する．
相関行列は，構造を強調するために画像関数を用いてグラフィカルに示すことができる．  これは、相関行列の構造を明確に示すのに特に有用なツールである。  部分的には，因子分析や他の多変量解析技法を教えたり議論したりするためのグラフィックの教育的価値を意図している．
因子分析は正定相関行列を必要とする。  残念ながら、欠損データのペアごとの削除や、テトラコリック相関やポリコリック相関を使用する場合、すべての相関行列が正定値とは限りません。 cor.smoothは、固有ベクトル（主成分）の平滑化を行います。  負の固有値は100 * eig.tolで置き換えられ，行列は再現され，cov2corを用いて強制的に相関行列に変換される．
因子分析には，正定値相関行列が必要である．  残念ながら、欠損データのペアごとの削除や、テトラコリック相関やポリコリック相関を使用する場合、すべての相関行列が正定値とは限りません。 cor.smoothは、固有ベクトル（主成分）の平滑化を行います。  負の固有値は 100 * eig.tol で置き換えられ，行列は再生成され， cov2cor を用いて強制的に相関行列に変換される．
RCoreのcov.wt関数はこの処理を行い、共分散行列または相関行列を返します。  cor.wt関数はサンプルサイズまたは標準誤差で重み付けを行い、デフォルトでは相関を返します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つまたは複数の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。 chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。 r2cとcor2covは相関行列を共分散行列に変換します。
相関（-1～1）を距離（0～2）に変換するマイナーなヘルパー関数 d = √{(2(1-r))}.
正規理論は相関の信頼区間を提供するが，これは個々の項目がMassively Missing at RandomであるSynthetic Aperality Assessment (SAPA)データでは特に問題となる．  ブートストラップ信頼区間は、Pearson相関、Spearman相関、Kendall相関、tetrachoric相関、polychoric相関、およびそれらの相関から作られた尺度について見つけられます。相関行列と標本サイズが与えられると，正規理論の信頼区間が提供される．
FIMLの共分散行列/相関行列を求めるために、lavaanパッケージの関数を利用します。  FIMLは、corの通常のペアワイズ削除オプションよりもはるかに遅いかもしれませんが、わずかに正確な推定値を提供します。
相関行列は、構造を強調するために image 関数を使用してグラフィカルに表示することができます。  これは、構造が明確な相関行列の構造を示すのに特に便利なツールです。  部分的には，因子分析や他の多変量解析技法を教えたり議論したりするためのグラフィックの教育的価値を意図している．
相関行列は，構造を強調するために画像関数を用いてグラフィカルに示すことができる．  これは、相関行列の構造を明確に示すのに特に有用なツールである。  部分的には、因子分析や他の多変量解析テクニックを教えたり議論したりするためのグラフィックの教育的価値を意味する。
cor関数は行列の相関を求めますが、確率値は報告しません。cor.testは相関を求めますが、一度に1組の変数の相関しか報告しません。corr.testはcorを使って完全データまたはペアワイズデータの相関を求め、サンプルサイズと確率値も報告します。対称行列の場合、生の確率が対角線の下に、多重比較で調整された相関が対角線の上に報告されます。x と y が異なる場合、デフォルトでは多重検定のために確率が調整される。corr.testとcorr.pの両方は、各相関について未加工の信頼区間と調整済み信頼区間を返す。
cor 関数は行列の相関を求めますが、確率値を報告しません。cor.test は相関を求めますが、一度に1組の変数のみを対象とします。corr.test は、cor を使って完全データまたはペアワイズデータの相関を求め、サンプルサイズと確率値も報告します。対称行列の場合、生の確率が対角線の下に、多重比較で調整された相関が対角線の上に報告されます。x と y が異なる場合、デフォルトでは多重検定のために確率が調整される。corr.testとcorr.pの両方は、各相関について未加工の信頼区間と調整された信頼区間を返す。
生の相関行列と信頼度のベクトルが与えられた場合、対角線上の減衰された相関を報告する。
Steiger (1980)は、相関行列の要素の2乗の合計、またはFisher z scoreに相当するものが、値が0であるという帰無仮説（すなわち、恒等行列の要素）の下ではカイ2乗として分布することを指摘しました。  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970) は，行列間の差の検定も検討した．
Bartlett (1951) は，Rが恒等行列であれば，-ln(det(R)*(N-1 - (2p+5)/6) がカイ2乗として分布することを提案した．  残差相関がすべてゼロであることを検定するのに有用である．Kaiser-Meyer-Olkin 検定とは対照的である．
Steiger (1980) は，相関行列の要素の2乗の合計，またはFisher z スコアに相当するものが，値が0（つまり，恒等行列の要素）であるという帰無仮説のもとで，カイ2乗として分布することを指摘した．  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970) は、行列間の差の検定も検討した。
Steiger (1980) は，相関行列の要素の2乗の合計，またはFisher z スコアに相当するものが，値が0であるという帰無仮説（すなわち，恒等行列の要素）のもとで，カイ2乗として分布することを指摘した．  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970) は、行列間の差の検定も検討した。
Steiger (1980) は，相関行列の要素の2乗の合計，またはFisher z スコアに相当するものが，値が0であるという帰無仮説（すなわち，恒等行列の要素）のもとで，カイ2乗として分布することを指摘した．  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970)は、行列間の差の検定も検討した。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最も適合する位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくとよい。  これは、SAPAタイプの分析を行うときに特に有用である。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられる。
相関行列または生データの行列またはデータフレームが与えられた場合、重回帰を求め、x変数の集合の関数としてy変数の集合を関連づけるパス図を描きます。  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も見つける。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する、些細ですが便利な関数です。reflectは、因子分析または主成分分析の出力を、1つまたは複数の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frameを（同じ長さで）相関させます。
行動の力学（Atkinson and Birch, 1970, Revelle, 1986）のような動的動機づけモデルは、単純な微分（行列）方程式のペアとして再パラメータ化することができます（Revelle, 1986, 2008）。この関数は、CTAの動的側面をシミュレートする。  CTAモデルについては、Revelle and Condon (2015)で詳述されている。
行動の力学（Atkinson and Birch, 1970, Revelle, 1986）のような動的動機づけモデルは、単純な微分（行列）方程式のペアとして再パラメータ化することができる（Revelle, 1986, 2008）。この関数は、CTAの動的側面をシミュレートする。  CTAモデルについては、Revelle and Condon (2015)で詳しく議論されている。
data.frameまたは行列が与えられて、グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d 統計量を r 等価値に変換し，Student の t 統計量と関連する p 値を報告し，グループ化変数の両方の値の統計量を返す．  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
データ集合を表現する多くの方法の中で，1つはグループ変数の各値での密度プロットで，もう1つは複数の変数のバイオリン・プロットである．  密度プロットは、効果量を示すために、異なるグループの密度を示します。バイオリン・プロットは、箱ひげ図に似ていますが、実際の分布を示します。中央値、25パーセンタイル線、75パーセンタイル線が表示に追加されます。グループ化変数が指定されると、violinByは各変数と各グループについてviolin plotを描画します。データポイントも描画されます。
Rには多くの要約統計量がありますが、この関数は古典的な心理測定における尺度構成や項目分析に最も役立つものを提供します。Rangeは、データ集合の最初のパス、コーディングエラーのチェックに最も役立ちます。  
グループ化変数による基本的な要約統計量をレポートする。  グルーピング変数が何らかの実験変数で、データをプロットするために集計する場合に便利です。  byとdescribeのラッパー
グループ化変数による基本的な要約統計量を報告する。  グルーピング変数が何らかの実験変数で、プロットのためにデータが集計される場合に有用。  byとdescribeのラッパー
Rには多くの要約統計量がありますが、この関数は古典的な心理測定における尺度構成や項目分析に最も有用なものを提供します。Rangeは、データセットの最初のパス、コーディングエラーのチェックに最も役立ちます。  
この関数は、古典的な心理測定における尺度構成や項目分析に最も役立つものを提供します。Rangeは、データセットの最初のパスで、コーディングエラーをチェックするために最も有用である。  
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描くためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの機能の一部の代替として使用されます。
McDonaldは、検定の一般的な因子飽和度の推定値として係数ωを提案しています。  ωを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid Leiman変換を行い、ωを求めることです。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらにもう1つの方法は、WallerのSchmid-Leimanを直接行うことである。
2つの行列の合同係数は、それぞれの値の積を平方根で割ったものである。列がゼロ中心であれば、これは単なる相関である。列がスケール中立点を中心とする場合、これはコーエンのプロファイル相関である。距離関数により、距離の集合（街区、ユークリッド、ミンコフスキー）を求めることができる。
2つの正規分布上のxとyのカットポイントに基づいて4つの領域に分割された相関楕円のグラフィック。  これもレイアウト関数の使用例である。テトラコリックがどのように機能するかを示すために、2変量密度プロットを描く。
2つの正規分布上のxとyのカットポイントに基づいて4つの領域に分割された相関楕円のグラフィック。  これはレイアウト関数の使用例でもある。テトラコリックスの働きを示す2変量密度プロットを描く。
n個の異なる値を持つ変数xがあるとすると、各変数の存在(1)または非存在(0)を0/1にコード化したn個の新しいダミー・コード化変数を作成します。  典型的なアプリケーションは、大学の専攻のベクトルからダミー・コード化された大学の専攻を作成することであろう。グループによってカテゴリを組み合わせることもできる。  デフォルトでは、xのNA値はNAとして返される（2017/10/20追記）
Dwyer (1937) は、因子拡張の手法を導入し、Thurstoneからの8つの認知変数を使用しました。  これは彼の論文で使用されたデータ集合の例です。
 eigen.loadingsは、固有値の平方根を掛けた固有ベクトルのより典型的なメトリックに変換します。   これは、princompまたはeigenを使用した場合に、擬似的な因子負荷量を見つけることができます。主成分分析を行うためにprincipalを使用する場合は、このルーチンは必要ない。
相関を教えるには、相関を反映するために平均の周りに楕円を描くのが便利です。  John Foxのcarパッケージの楕円関数のこのバリエーションがそうである。  入力は2つのベクトルか行列かdata.frameです。  後者の場合、変数の数が2以上であれば、楕円はpairs.panel関数で行われます。楕円は既存のプロットに追加することもできる。minkowski 関数は、一般化された楕円として含まれています。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013)が提案するバリミン回転は、GPArotationへの適切な呼び出しによって実装される。
平均と信頼区間をプロットするRの多くの関数の1つ。必要であれば、棒グラフを使用することもできます。  分布を要約するためにboxplotなどの関数と組み合わせることもできる。  平均と標準誤差は describe を用いて生データから計算される。あるいは、平均±1標準偏差のプロットを描くこともできる。
平均と信頼区間をプロットするRの多くの関数の1つ。  主に複数標本からの再現の確率を示すためのデモンストレーションを目的としている。  分布を要約するためにboxplotなどの関数と組み合わせることもできる。  各グループの平均と標準誤差は describeBy を使って計算される。
平均と信頼区間をプロットするRの多くの関数の1つ。必要であれば、棒グラフを使用することもできる。  分布を要約するためにboxplotなどの関数と組み合わせることもできる。  平均と標準誤差は、describeを用いて生データから計算される。あるいは、平均±1標準偏差のプロットを描くこともできる。
データの2つのベクトル（XとY）が与えられたら、平均をプロットし、XとYの両方向の標準誤差を示す。
describe、describeBy、statsBy または bestScales の data を用いて、異なるグループまたは変数のエラーバーを持つドットチャートを見つけることができます。
行列またはデータフレームdataが与えられたら、グループ化変数に基づいて統計量を求め、グループ化変数の各値についてエラーバー付きのxおよびy平均をプロットします。  データがペアの場合（例：男女別）、すべての変数について2つのグループの平均とエラー・バーをプロットします。
構造方程式モデリング(SEM)は、多変量構造を確認するための強力なツールで、lavaan、sem、またはOpenMxパッケージによってよく実行されます。SEMモデルは確認的であるため、特定のモデルを検定します。  一方、探索的構造方程式モデリング（ESEM）は、より探索的なアプローチをとります。  因子拡張を使用することで、ある変数集合（X）の因子を別の変数集合（Y）の変数空間に拡張することができます。この手法を用いて、通常のSEMがそうであるように、潜在変数の2つの集合の間の相関を推定することができます。  探索的因子分析（EFA）に基づいて、このアプローチは、探索的構造方程式モデリングを行うための迅速で簡単なアプローチを提供します。  
構造方程式モデリング（SEM）は、多変量構造を確認するための強力なツールであり、lavaan、sem、またはOpenMxパッケージによってよく実行されます。SEMモデルは確認的であるため、特定のモデルを検定します。  一方、探索的構造方程式モデリング（ESEM）は、より探索的なアプローチをとります。  因子拡張を使用することで、ある変数集合（X）の因子を別の変数集合（Y）の変数空間に拡張することができます。この手法を用いて、通常のSEMがそうであるように、潜在変数の2つの集合の間の相関を推定することができます。  探索的因子分析（EFA）に基づいて、このアプローチは、探索的構造方程式モデリングを行うための迅速で簡単なアプローチを提供します。  
因子分析または主成分分析の結果は、通常、各因子の主要負荷量の観点から解釈されます。  fa.diagramは、様々なダイアグラム関数を使用してダイアグラムを描画します。 fa.rgraphは、Rgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、より良い方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角線上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は，n.iter > 1でfaによって求められます．
2組の因子負荷量が与えられた場合，それらの一致度（ベクトル余弦）を報告する．最初に報告したのはBurt (1937,1 1948)であるが，これは因子一致のTucker 指数としてよく知られている．Cohenのプロファイル類似度も見られることがある。
因子分析または主成分分析の結果は、通常、各因子の主要負荷量の観点から解釈される。  fa.diagramは、さまざまなダイアグラム関数を使用してダイアグラムを描画します。 fa.graphは、外部プロット用のドットコードを生成します。 fa.rgraphは、Rgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。
Dwyer (1937) は、オリジナルの分析に含まれていない変数の因子負荷量を見つける方法を紹介しました。  これは基本的に，因子スコアとの拡張変数の減衰されない相関を見つけることである．  因子信頼性を補正しない代替法が、Gorsuch (1997)によって提案されました。両方のオプションは、新しい変数への拡張を伴う探索的因子分析の応用です。また，因子空間での変数の有効性を見つけるのにも有用である．  
Dwyer (1937) は、オリジナルの分析に含まれていない変数の因子負荷量を見つける方法を紹介しました。  これは基本的に，因子スコアとの拡張変数の減衰されない相関を見つけることである．  因子信頼性を補正しない代替法が、Gorsuch (1997)によって提案されました。両方のオプションは、新しい変数への拡張を伴う探索的因子分析の応用です。また，因子空間での変数の有効性を見つけるのにも有用である．  
因子分析または主成分分析の結果は，通常，各因子の主要負荷量の観点から解釈される．  fa.diagramは、様々なダイアグラム関数を使用してダイアグラムを描画します。fa.rgraphは、Rgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。het.diagramは、異なるレベルの因子/尺度解の「ヘテラーキー」ダイアグラムを描画します。
 合理的、要因的、または経験的な手段によって尺度を構成する場合、互いに最も関連性の高い項目の内容（例えば、一連の項目のfa.lookupの因子負荷量）、または特定の基準のセット（例えば、bestScales）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
因子分析解の中には、相関因子を生成し、それが因数分解されるものもあります。  解が1つの高次を持つ場合，ω関数が最も適切である．  しかし、複数の高次因子がある場合は、faMulti関数が低次因数分解を行い、その結果の相関行列を因数分解します。  マルチレベル因子ダイアグラムも表示されます。
因子分析解の中には、相関因子を生成し、それが因数分解されるものもあります。  解が1つの高次の場合、ω関数が最も適切です。  しかし、複数の高次因子がある場合、faMulti関数は低次因数分解を行い、その結果の相関行列を因数分解します。  複数レベルの因子図も表示されます。
fa.sortは、faまたはprincipal関数の出力を受け取り、各因子の負荷量をソートします。  項目は最大の負荷量の順に配置されます。  fa.organizeは、列または行を再編成することができます。
データ行列または相関行列の因子または成分の数を決定する1つの方法は、連続する固有値の「scree」プロットを調べることです。  プロットの鋭い切れ目が、抽出すべき成分や因子の適切な数を示唆する。  「並列 "分析は、観察されたデータの因子のscreeと、元のデータと同じサイズのランダムなデータ行列の因子のscreeを比較する代替手法である。これは、連続データ、2値データ、多値データについて、ピアソン相関、4値相関、多値相関を用いて行うことができる。
データ行列または相関行列の因子または成分の数を決定する1つの方法は、連続する固有値の "scree "プロットを調べることである。  プロットの鋭い切れ目が、抽出すべき成分や因子の適切な数を示唆する。  「並列 "分析は、観察されたデータの因子のscreeと、元のデータと同じサイズのランダムなデータ行列の因子のscreeを比較する代替手法である。これは、連続データ、2値データ、多値データに対して、ピアソン相関、4値相関、多値相関を用いて行うことができる。
クラスター分析と因子分析は、より少ない数の（潜在）因子または（観察された）クラスターの観点から項目をグループ化する手順である。  クラスターのグラフィカル・プレゼンテーションは、一般にツリー構造を示すが、クラスター相関で表現することもできる。  
6年が経過した今、これらの非推奨関数の使用を止める時が来ました！  これらの古い関数のすべての機能を含むfaをご覧ください。  
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、より良い方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は、n.iter > 1でfaによって求められます。
fa.randomは、profileRパッケージのwprifm関数にインスパイアされたもので、平均値の被験者間差を除去し、ipsatizedデータの正規探索的因子分析を行います。  機能的には、これは因数分解の前にデータの一般因子を除去します。残差データ行列の非正定値性を防ぐために、各変数に非常に少量のランダムノイズが加えられます。これは被験者間効果を除去した後にfaを呼び出すだけです。すべての入力パラメータと出力オブジェクトの詳細な説明については、faのヘルプファイルをお読みください。
因子分析または主成分分析の結果は、通常、各因子の主要負荷量の観点から解釈されます。  fa.diagramは、様々なdiagram関数を使用して図を描画します。fa.rgraphは、Rgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。het.diagramは、異なるレベルの因子/尺度解の「ヘテラーキー」図を描画します。
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、より良い方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は、n.iter > 1でfaによって求められます。
fa.sortは、faまたはprincipal関数からの出力を受け取り、各因子の負荷量をソートします。  項目は最大の負荷量の順に配置されます。  fa.organizeでは、列や行を再編成することができます。
カイ2乗およびその他の適合度統計量は、相関行列に対する因子または成分モデルの適合度に基づいて求められます。  これらの統計量は、通常、最尤解に関連しますが、最小残差解（OLS）、主軸解、主成分解でも求めることができます。  主にこれらの関数内から呼び出されますが、factor.statsは単独で使用することもできます。要因の妥当性と有効性の測定は，Grice, 2001の論文に従う．
探索的因子分析と項目反応理論は、バイナリ・データの非常に異なるモデルのように見えますが、項目の困難さと項目の識別について同等のパラメータ推定を提供することができます。  2値項目または多値項目のデータ集合の4値相関または多値相関は，最小残差または最尤因子分析を用いて因子分析され，その結果の負荷量が項目識別パラメータに変換される．  項目の因子負荷と組み合わされた四分位相関/多分位相関からのタウ・パラメータは、項目の困難性を推定するために使用されるかもしれない。
データを2つのレベル（たとえば、個人といくつかのグループ化変数のセット）で調査する場合、基本的な記述統計量（グループごとの平均、sds、ns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルでの相関の行列を、グループ内の相関とグループ間の相関に分解する能力です。
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、よりよい方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は，n.iter > 1のfaによって求められます．
データ行列または相関に対する2つの因子分析またはpca解が与えられたとき，2つの解の類似性は何か．これは因子相関と因子一致によって見つけられるかもしれない．  因子相関は，因子重みと相関行列の行列積によって求められ，因子スコア相関がどうなるかの推定値である．  因子一致度（別名タッカー係数またはバート係数）は，因子負荷量のベクトルの余弦である．
因子負荷量の2つのセットが与えられたとき，それらの一致度（ベクトルの余弦）を報告する．最初に報告したのはBurt (1937,1 1948)であるが，これは因子一致のTucker 指数としてよく知られている．Cohenのプロファイル類似度も見られるかもしれない。
基本的な因子または主成分モデルは，相関行列または共分散行列が，因子負荷行列とその転置行列との積によって再現されるというものである．F'FまたはP'P。  適合度の1つの簡単な指標は、1-残差の2乗和/元の相関の2乗和です。この適合度指数は、VSSやICLUSTなどで使用されている。
6年経った今、これらの非推奨関数の使用をやめる時が来た！  これらの古い関数のすべての機能を含む fa をご覧ください。  
基本的な因子モデルまたは主成分モデルは、相関行列または共分散行列が、因子負荷行列とその転置行列との積によって再現されるというものです。  この再現行列を求めます。  factor.fit、VSS、ICLUSTなどで使われる。
6年後、これらの非推奨関数の使用を止める時が来ました！  これらの古い関数のすべての機能を含む fa をご覧ください。  
クラスター分析と因子分析は、より少ない数の（潜在）因子または（観測された）クラスターの観点から項目をグループ化するための手続きです。  クラスターのグラフ表示は、一般的にツリー構造を示しますが、クラスター間の項目相関で表現することもできます。  
基本的な因子または主成分モデルは，相関行列または共分散行列が，因子負荷行列とその転置行列との積によって再現されるかもしれないということである．  元の行列から再現行列を引いた残差を求めます。  factor.fit, VSS, ICLUST などで使用。
因子行列や成分行列が与えられたときに、特定の変数の組を任意に回転させることができる。  これは、より強力な回転パッケージ GPArotation を補うもので、通常とは異なる回転を行う特定の要件に対応するものです。
因子分析の基本的な問題は、モデルが構造レベルで定義されているにもかかわらず、データレベルでは不確定であるということです。この因子不確定性の問題は，因子スコアを推定する代替方法につながるが，どれも理想的なものではない．  Grice (2001)に従うと、ここでは4つの異なる方法が利用可能である。
カイ2乗および他の適合度統計量は，相関行列への因子または成分モデルの適合に基づいて求められる．  これらの統計量は、通常、最尤解に関連しますが、最小残差（OLS）、主軸、主成分解でも求めることができます。  主にこれらの関数内から呼び出されますが、factor.statsは単独で使用することもできます。要因の妥当性と有効性の測定は，Grice, 2001の論文に従う．
6年後、これらの非推奨関数の使用をやめる時が来ました！  これらの古い関数のすべての機能を含むfaをご覧ください。  
因子負荷行列または主成分負荷行列が与えられたとき、各項目を、その項目の最大（符号付き）因子負荷に対応するクラスタに割り当てます。  本質的に、これはクラスタ定義への非常に単純な構造のアプローチであり、ほとんどの人が実際に行っていることに対応します：各項目について最大の負荷量を強調し、残りを無視します。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、JennrichとBentler (2011)によって導入された回転を実装しています。promaxは、HendricksonとWhite (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案するバリミン回転は、GPArotation への適切な呼び出しによって実装されます。
因子回転アルゴリズムの汚い小さな秘密は、局所最小の問題である（Nguyen and Waller,2022）。  その論文のアイデアに従って、我々は複数のランダムな再スタートを許容し、そして大域的な最適解を返す。  fa関数の一部として使用されるほか、独立した関数としても利用できます。
r2dは相関を効果量(Cohenのd)に、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
lmなどからの数式入力は、標準的な構文を使って、媒介項、2次項、部分項を含むように拡張することができます。これはsetCorとmediateで使用されます。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
Garcia, Schmitt, Branscombe, and Ellemers (2010) は、認知された性差別が、差別に抗議するイングルー プのメンバーに対する女性の反応の怒りや好感に及ぼす影響について、129人の被験者のデータを報告している。このデータセットは、Hayes (2013 and 2018)による「抗議」データセットとしても使用されている。  これは、回帰における媒介と中庸の有用な例である。また，交互作用のプロットの例としても使用できる．
幾何平均は，非正規分布，すなわち，幾何分布を記述するのに有用である．
検定の信頼性の8つの代替推定には、Guttman (1945)によって議論された6つ、ten Berge and Zergers (1978)によって議論された4つ（μ_0 ... μ_3）、さらにβ（最悪のスプリット・ハーフ、Revelle, 1979）、Bentler and Woodward (1980)によって議論されたglb（最大最小境界）、および ω_h と ω_t (McDonald, 1999; Zinbarg et al., 2005)が含まれる。スプリットハーフの最大値と最小値は、総当りまたはサンプリングによって求められる。
最大下限値は「教育テスト問題」を解決する。すなわち，テストの信頼性はどの程度か，という問題である（この問題についてはguttmanを参照）．テストの信頼性には多くの推定値があるが（Guttman, 1945）、ほとんどはテストの真の信頼性を過小評価している。
テストの信頼性の8つの代替推定値には、Guttman (1945)が議論した6つ、ten Berge and Zergers (1978)が議論した4つ（μ_0 ... μ_3）、さらにβ（最悪のスプリット・ハーフ、Revelle, 1979）、Bentler and Woodward (1980)が議論したglb（最大最小境界）、ω_h と ω_t (McDonald, 1999; Zinbarg et al., 2005)が含まれます。スプリット・ハーフの最大値と最小値は、総当りまたはサンプリングによって求められる。
Gleser, Cronbach and Rajaratnam (1965) は，一般化可能性理論の導入の一部として，分散成分とそれらの比率の推定について議論している．  これは彼らの "完全にマッチしたG研究のための例示データ "の適応である（表3）。  12人の患者が6つの症状について2人の判定者から評価される。  分散成分がANOVAから導出される．
Gorsuch (1997) は，古典的なDwyer (1937) 因子拡張手法の代替を提案します．  このデータ集合は，その論文から取られたものです．  correct=TRUE オプションの有無でlink{fa.extension}を比較するのに便利です。  
検定の信頼性の8つの代替推定は、Guttman (1945)によって議論された6つ、ten Berge and Zergers (1978)によって議論された4つ（μ_0 ... μ_3）、さらにβ（最悪のスプリット・ハーフ、Revelle, 1979）、Bentler and Woodward (1980)によって議論されたglb（最大最小境界）、および ω_h と ω_t (McDonald, 1999; Zinbarg et al., 2005)を含みます。スプリットハーフの最大値と最小値は、総当たりまたはサンプリングによって求められる。
Harman (1967)によって報告された5つの古典的なデータ集合は、Holzingerから取られた9つの心理（認知）変数とBurtから取られた8つの感情変数です。他の2つは、社会経済と政治のデータセットです。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されている。
調和平均は単に逆数の算術平均の逆数である。
data.frame、行列、テキストオブジェクトの最初と最後のn行を表示する簡単な方法。  headとtailまたはViewを呼び出すだけです。
data.frame、行列、テキストオブジェクトの最初と最後のn行を表示する簡単な方法。  head and tailまたはViewを呼び出すだけの簡単な操作
因子分析または主成分分析の結果は、通常、各因子の主要な負荷量の観点から解釈されます。  fa.diagramは、様々なダイアグラム関数を使用してダイアグラムを描画します。fa.rgraphは、Rgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。het.diagramは、異なるレベルの因子/尺度解の「ヘテラーキー」ダイアグラムを描画します。
行列またはdata.frameが与えられた場合、各変数のヒストグラムを「行列」形式で作成します。各プロットの正規適合と密度分布を含む。
Holzinger-Swineford (1937) は、一般因子と無相関グループ因子の2因子モデルを導入した。Holzingerのデータセットは、Joreskogが例として使用した9 * 9行列と同様に、彼らの論文からのオリジナルの14 * 14行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
クラス内相関は、評定者の信頼性を研究する際に、関連性の尺度として使用される。  Shrout and Fleiss (1979) は、特定の実験デザインに依存する6つの異なる推定を概説している。すべてが実施され、信頼限界が与えられる。  lmerは欠損値を許す。
一般的なデータ削減手法は、ケース（被験者）をクラスタ化することである。あまり一般的ではありませんが、心理学研究で特に有用なのは、項目（変数）をクラスタ化することです。これは因子分析の代替と考えられ、より単純なモデルに基づきます。クラスター・モデルは、変数間の相関は、各項目が最大1つのクラスターに負荷することを反映し、それらのクラスターに負荷する項目は、そのクラスターへのそれぞれの負荷量の関数として相関し、異なるクラスターを定義する項目は、それぞれのクラスター負荷量とクラスター間相関の関数として相関するというものである。本質的に、クラスター・モデルは、複雑さ1のVery Simple Structure因子モデルである（VSSを参照）。
一般的なデータ削減手法は、ケース（被験者）をクラスタリングすることです。あまり一般的ではありませんが、心理学研究で特に有用なのは、項目（変数）をクラスタリングすることです。これは、より単純なモデルに基づく因子分析の代替と考えることができる。クラスター・モデルは、変数間の相関は、各項目が最大1つのクラスターに負荷することを反映し、それらのクラスターに負荷する項目は、そのクラスターへのそれぞれの負荷量の関数として相関し、異なるクラスターを定義する項目は、それぞれのクラスター負荷量とクラスター間相関の関数として相関するというものである。本質的に、クラスター・モデルは、複雑度 1 の Very Simple Structure 因子モデルである（VSS を参照）。
ICLUSTアルゴリズムの骨子。  ICLUSTによって呼び出される 説明はICLUSTを参照。
ICLUSTによって決定されたクラスタ構造が与えられた場合、psychパッケージのグラフィック関数を使用してグラフィック構造図を作成する ICLUSTの出力をより正確に記述するためのドットコードを作成するには、ICLUST.graphを使用する。Rgraphvizが正常にインストールされている場合、ICLUST.rgraphを使用する方法もある。
ICLUST によって決定されたクラスター構造が与えられたら、ICLUST 出力を記述するドットコードを作成する。  ドットコードを使用するには、https://www.graphviz.org/ Graphvizまたは市販のビューア（OmniGraffleなど）のいずれかを使用する。  この関数はRgraphvizを使用するICLUST.rgraphと類似している。
ICLUSTによって決定されたクラスター構造が与えられると、Rgraphvizを使用して直接rgraphicを作成する。 ICLUST出力をより正確に記述するドットコードを作成するには、ICLUST.graphを使用する。  オプションとして、ドットコードも生成され、ファイルに保存される。ドットコードを使用するには、https://www.graphviz.org/ Graphviz または市販のビューア（OmniGraffleなど）を使用する。
クラスター分析または因子分析の負荷量行列が与えられたとき、各列の負荷量の（絶対）サイズによって項目をソートする。  ICLUST および SAPA 分析の一部として使用される。列は
クラスター分析または因子分析の負荷量行列が与えられた場合，各列の負荷量の（絶対）サイズによって項目を並べ替える．  ICLUSTおよびSAPA分析の一部として使用される。で列を並べ替える．
構造方程式モデリング（SEM）は、多変量構造を確認するための強力なツールであり、lavaan、sem、またはOpenMxパッケージによってよく実行されます。SEMモデルは確認的であるため、特定のモデルを検定します。  一方、探索的構造方程式モデリング（ESEM）は、より探索的なアプローチをとります。  因子拡張を使用することで、ある変数集合（X）の因子を別の変数集合（Y）の変数空間に拡張することができます。この手法を用いて、通常のSEMがそうであるように、潜在変数の2つの集合の間の相関を推定することができます。  探索的因子分析（EFA）に基づいて、このアプローチは、探索的構造方程式モデリングを行うための迅速で簡単なアプローチを提供します。  
限定された数の回答カテゴリ（たとえば、態度項目）を持つデータでは、各回答カテゴリを幅 w を持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の四分位値を線形補間することが有用です。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
項目反応理論では、個人の能力（θ）と項目の難易度（diff）パラメータを推定することで、項目に対する個人の反応をモデル化する。  これは、このモデル化手順を捉える初期の粗雑な試みです。よりよい手順は、irt.faを使用することです。
項目反応理論は、個人の能力（θ）と項目困難度（diff）パラメータを推定することにより、項目に対する個人の反応をモデル化します。  これは、このモデリング手順を理解するための初期の粗雑な試みです。よりよい手順は、irt.faを使用することです。
項目反応理論は、個人の能力（θ）と項目困難度（diff）パラメータを推定することにより、項目に対する個人の反応をモデル化します。  これは、このモデリング手順を理解するための初期の粗雑な試みです。より良い手順は、irt.faを使用することです。
非常に粗雑で予備的なIRTプログラムへのステップです。これら2つの関数は、項目の難易度と識別パラメータを推定します。  よりよい手順は、irt.faまたはltmパッケージを使用することである。
探索的因子分析と項目反応理論は、バイナリデータの非常に異なるモデルのように見えますが、項目困難度と項目識別の同等のパラメータ推定を提供することができます。  2値項目または多値項目のデータ集合の4値相関または多値相関は、最小残差または最尤因子分析を用いて因子分析され、その結果の負荷量は項目識別パラメータに変換される。  項目の因子負荷と組み合わされた四分位相関/多分位相関からのタウ・パラメータは、項目の困難さを推定するために使用されるかもしれない。
非常に粗雑で予備的なIRTプログラムへのステップ．これらの2つの関数は，項目の困難度と識別パラメータを推定する．  よりよい手順は、irt.fa または ltm パッケージを使用することである。
項目反応理論は、個人の能力(θ)と項目困難度(diff)パラメータを推定することにより、項目に対する個人の反応をモデル化します。  これは、このモデリング手順を取り込むための初期の粗雑な試みです。よりよい手順は、irt.faを使用することである。
能力テストを分析するとき、潜在特性の関数として、注意散漫の選択肢がどのように変化するかを考慮することが重要です。  簡単な図解は、複数の項目から発見された潜在特性の値に対して、回答の支持頻度をプロットすることです。良い項目とは、潜在特性が増加するにつれて、ディストラクターの確率が減少し、キーとなる答えが増加するものです。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論（IRT）パラメータを求めます。scoreIrtは、これらの識別と位置のパラメータ推定値を使用して、回答のIRTベースのスコアを求めます。scoreIrt.2plは尺度のリストをスコア化します。
探索的因子分析と項目反応理論は、バイナリデータの非常に異なるモデルのように見えますが、項目の困難さと項目の識別の同等のパラメータ推定を提供することができます。  2値項目または多値項目のデータ集合の4値相関または多値相関は，最小残差または最尤因子分析を用いて因子分析され，その結果の負荷量が項目識別パラメータに変換される．  項目の因子負荷と組み合わされたテトラコロリック/ポリコロリック相関からのタウパラメータは、項目の困難さを推定するために使用することができる。
irt.faは二項または多項項目の四項相関または多項相関の因子分析を通して項目反応理論(IRT)パラメータを求めます。scoreIrtはこれらの識別と位置のパラメータ推定値を使用して、IRTに基づく回答スコアを求めます。scoreIrt.2plは尺度リストを採点します。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論(IRT)のパラメータを求めます。scoreIrtは、これらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答の得点を求めます。scoreIrt.2plは尺度リストをスコア化します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つまたは複数の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
因子分析や主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
 合理的、要因的、または経験的な手段によって尺度を構成する場合、互いに最も高く関係する項目の内容（例えば、一連の項目のfa.lookupの因子負荷量）、または特定の基準のセット（例えば、bestScales）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
因子分析と主成分分析のソリューションの回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として，変数が2次元空間の円の外周に一様に配置される円周構造がある．  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
尺度の妥当性は、尺度の項目数、平均相互相関、平均妥当性の関数として変化する。任意の特定の基準に対する尺度の有効性の漸近限界は、平均有効性を平均尺度内項目相関の平方根で割ったものに過ぎません。predicted.validityは、（keys.listで定義された）尺度セットに対する予測有効性と、さまざまな基準に対する平均項目有効性を求めます。  
Kaiser (1958) は，因子負荷量を回転させる前に正規化し，回転後に非正規化することを提案した．  GPArotationパッケージは，（デフォルトでは）正規化しないし，fa関数も正規化しない．kaiserは、正規化されていない解の出力を取り、正規化された解を報告します。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高い相関を持つ項目の内容（例えば、一連の項目のfa.lookupの因子負荷量）、または特定の基準の集合（例えば、bestScales）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
 scoreItemsを使用して未加工データから、またはcluster.corを使用して相関行列から複合尺度を形成して項目をスコアリングする場合、以前はキーマトリックスを作成する必要がありました。make.keysは単にキー行列を作成するためのショートカットです。  キー行列は-1,0,1のnvar x nscales行列で、各スケールのメンバーシップを定義します。項目は場所または名前で指定できる。
n個のアイテムが与えられた場合、最も類似したアイテムのペアまたはトリプレットから、n/2またはn/3のミニスケールまたはパーセルを作成します。  これらは、その後の尺度構築や多変量（因子など）分析の基礎として使用できる。
Henry Kaiser (1970) は、因子分析データ行列のサンプリング適正測定法（MSA）を導入した。Kaiser and Rice (1974) はそれを修正した。これは，元の相関の2乗と比較した「イメージ」行列の2乗要素の関数である．  全体のMSAと各項目の推定値が求められる。この指数は、カイザー・マイヤー・オルキン（KMO）指数として知られている。
data.frameまたは行列の各変数の歪度（skew）と尖度（kurtosis）を求めます。  e1071のスキューと尖度とは異なり、これはdata.frame/matrixの各変数または各列について異なるスキューを計算します。
構造方程式モデルのグラフィカルな表現は、半確定因子モデルや確認因子モデルを概念化するのにとても便利な方法です。x (xmodel) と y (ymodel) の測定モデル、および x と y (phi) を接続するパス・モデルが与えられている場合、グラフを描きます。  ymodel が指定されていない場合は，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合，x 変数または y 変数間の相関を示す．
lowerCorは、x変数の相関を求め、それらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する、些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
ロジスティック関数（1/(1+exp(-x)）とロジット関数（log(p/(1-p)）は、項目反応理論の基本です。  単なる1行関数ですが、デモやIRTモデルの描画を容易にするために、ここに含まれています。また、graded responseモデルのlogistic.grmも含まれています。
ロジスティック関数（1/(1+exp(-x)）とロジット関数（log(p/(1-p)）は、項目応答理論の基本です。  単なる1行関数ですが、デモやIRTモデルの描画を簡単にするために、ここに含まれています。また、graded responseモデルのlogistic.grmも含まれています。
ロジスティック関数（1/(1+exp(-x)）とロジット関数（log(p/(1-p)）は、項目応答理論の基本です。  単なる1行関数ですが、デモやIRTモデルの描画を簡単にするために、ここに含まれています。また、graded responseモデルのlogistic.grmも含まれています。
 合理的、要因的、または経験的な手段によって尺度を構成する場合、互いに最も高い相関を持つ項目の内容（例えば、一連の項目のfa.lookupの因子負荷量）、または特定の基準のセット（例えば、bestScales）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高い相関を持つ項目（例えば、一連の項目のfa.lookupの因子負荷量）、または特定の基準セット（例えば、bestScales）の内容を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高い相関を持つ項目（例えば、一連の項目のfa.lookupの因子負荷量）、または特定の基準セット（例えば、bestScales）の内容を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
2つの標本（例えば、男性と女性）の相関行列を報告する場合、1つの行列として表示するのが便利で、対角線より下の項目は一方の行列を表し、対角線より上の項目はもう一方の行列を表します。  また、相関行列を、適合した（因子など）モデルからの残差と比較するのも便利です。  
McDonald(1999)が項目応答理論の他の議論と同様に使用したデータセットの例では、Law School Admissions Test (LSAT)の10項目（5項目の2セット）のデータ表を使用しています。  このデータセットには、元の表と、第1セット（図分類）と第2セット（討論）に対する1000人の被験者の回答が含まれている。
McDonald(1999)が項目応答理論の他の議論と同様に使用したデータセットの例では、法科大学院入学試験(LSAT)の10項目(5項目の2セット)のデータ表を使用しています。  このデータセットには、元の表と、第1セット（図分類）と第2セット（討論）の1000人の被験者の回答が含まれています。
data.frameまたは行列が与えられたら，グループ化変数に依存する各変数の標準化平均差（コーエンのd）と信頼区間を求めよ．  d 統計量を r 等価値に変換し、スチューデントの t 統計量と関連する p 値を報告し、グループ化変数の両方の値の統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりの複数の尺度（たとえば，OVL, OVL2, など）が利用可能である．
古典的検定理論（CTT）は，すべての検定が1つの因子と残差誤差で表現できる場合，4つ以上の検定は共属的に等価であるとみなす．  並列検定は、（通常2つの）検定が等しい因子負荷量を持つ特別なケースである。  タウ等価検定は，等しい因子負荷量を持つが，不均等な誤差を持つことがある．  共属検定は，因子負荷と誤差分散の両方が異なることがある．
因子負荷量と因子相互相関の集合から母集団直交相関行列または階層相関行列を作成する．そして，この母集団からサイズ n の標本を抽出することができる．  標本データ、標本相関、または母集団相関のいずれかを返します。  これは、指導やデモンストレーション用のサンプル・データ・セットを作成するために使用されます。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論（IRT）のパラメータを求めます。scoreIrt.2plは尺度のリストを採点します。
 scoreItemsを使用して生データから、またはcluster.corを使用して相関行列から複合尺度を形成して項目をスコアリングする場合、以前はキー行列を作成する必要がありました。make.keysは単にキー行列を作成するためのショートカットです。  キー行列は-1,0,1のnvar x nscales行列で、各スケールのメンバーシップを定義します。項目は場所または名前で指定できます。
 生データから scoreItems を使用して、または相関行列から cluster.cor を使用して、複合尺度を形成して項目をスコアリングする場合、以前はキー行列を作成する必要がありました。make.keysは単にキー行列を作成するためのショートカットです。  キー行列は-1,0,1のnvar x nscales行列で、各スケールのメンバーシップを定義します。項目は場所または名前で指定できる。
特定の基準との多くの相関の強さを示す便利な方法は、マンハッタン・プロットです。  これは、あるキーとなる変数によって並べられた相関のプロットに過ぎない。  bestScalesで使用される項目の基礎を理解するのに便利です。
data.frameまたは行列の各変数の歪度（skew）と尖度（kurtosis）を求めます。  e1071のskewとkurtosisとは異なり、data.frame/matrixの各変数または各列に対して異なるskewを計算します。
相関行列または生データの行列またはデータフレームが与えられたとき、重回帰を求め、x変数の集合の関数としてy変数の集合を関連付けるパス図を描く。  共変量(z)の集合は、xとyの集合から分割することができる。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も見つける。
相関行列の構造を見るには，類似項目が一緒にグループ化されるように項目を整理することが有用である．そのようなグループ化の手法の1つが因子分析です。 mat.sortは、因子モデル（指定された場合）、またはその他の順序、あるいは第1因子への負荷量（指定されていない場合）によって項目を並べ替えます。
相関行列または生データの行列またはデータフレームが与えられたら、重回帰を求め、x 変数の集合の関数として y 変数の集合を関連付けるパス図を描きます。  共変量（z）の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求める。
相関行列または生データの行列またはデータ・フレームが与えられると，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描く．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も見つける。
相関行列の構造を見るには，類似項目が一緒にグループ化されるように項目を整理することが有用である．そのようなグループ化の手法の1つが因子分析です。 mat.sortは、因子モデル（指定された場合）、またはその他の順序、または第1因子への負荷量（指定されていない場合）によって項目を並べ替えます。
mat.sortは、因子モデル（指定された場合）、または順序、または最初の因子の負荷量（指定されていない場合）によって項目を並べ替えます。間接効果の信頼区間をブートストラップする．  媒介モデルは，モデル中の特定の共変量の効果を明示する拡張回帰モデルにすぎない．モデレーションは、予測変数の乗算によって行われます。   この関数は、いくつかの典型的な問題タイプについて、基本的な媒介/修正分析を提供します。
媒介と修正のパス・モデルでの予測変数の直接効果と間接効果を求めます。間接効果の信頼区間をブートストラップします。  媒介モデルは，モデル中の特定の共変量の効果を明示する拡張回帰モデルにすぎない．モデレーションは、予測変数の乗算によって行われます。   この関数は，いくつかの古典的な問題タイプについて基本的な媒介/修正分析を提供する．
相関を教えるためには，相関を反映するために平均のまわりに楕円を描くことが有用である．  John Foxのcarパッケージの楕円関数のこのバリエーションがそうです。  入力は2つのベクトルか行列かdata.frameである。  後者の場合、変数の数が2以上であれば、楕円はpairs.panel関数で行われます。楕円は既存のプロットに追加することもできる。一般化された楕円としてminkowski関数が含まれます。
mixedCorは、連続変数、多値変数、二値変数を持つデータセットについて、絶対ピアソン相関は、基礎となる潜在相関から下方に偏っている。結果には、完全な相関行列、および多項相関と四項相関の個別の相関行列と難易度が含まれる。
連続変数、多値変数、2値変数を持つデータ集合では、絶対ピアソン相関は、基本的な潜在相関から下方に偏っています。mixedCorは、連続変数のピアソン相関、多値項目のポリコレ、2値項目のテトラコレ、およびさまざまな混合変数の多列相関または双列相関を求めます。結果には、完全な相関行列、多項相関と四項相関の個別の相関行列と難易度が含まれる。
マルチレベル・データの信頼性のさまざまな指標（たとえば、被験者内にネストされた時間にわたる項目）が、一般化可能性理論を用いて見つけられるかもしれません。  分散成分が抽出されたデータに、基本的な3元配置のアノバが適用されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットをロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について、時間オーバーのオブザベーションの複数の格子プロットが作成されます。
マルチレベル・データの信頼性のさまざまな指標（たとえば、被験者内にネストされた経時的項目）が、一般化可能性理論を用いて見つけられるかもしれません。  分散成分が抽出されたデータに、基本的な3元配置のアノバが適用されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットをロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について、時間オーバーのオブザベーションの複数の格子プロットが作成されます。
マルチレベル・データの信頼性のさまざまな指標（たとえば、被験者内にネストされた経時的項目）が、一般化可能性理論を用いて見つけられるかもしれません。  分散成分が抽出されたデータに、基本的な3元配置のアノバが適用されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットをロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について時間オーバーのオブザベーションの複数の格子プロットが作成されます。
媒介および緩和のパス・モデルにおける予測変数の直接効果および間接効果を求めます。間接効果の信頼区間をブートストラップします。  媒介モデルは，モデル中の特定の共変量の効果を明示する拡張回帰モデルにすぎない．モデレーションは、予測変数の乗算によって行われます。   この関数は，いくつかの古典的な問題タイプについて，基本的な媒介/修正分析を提供する．
Von Neuman ら (1941) は，平均の漸進的なシフトを考慮に入れた変動の尺度として，連続差の平均2乗について議論した．これは、弾道学の誤差を研究するときや、情動を研究するときの気分の変動性や安定性を研究するときに適切である。ランダムなデータの場合、これは分散の2倍になりますが、順序が連続し、正の自己相関を持つデータの場合、これはずっと小さくなります。mssdは分散の2倍-自己相関なので、特定のラグの自己相関を見つけることも可能です。
パスモデルは、構造方程式モデルまたはクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描くためのプリミティブを提供します。  Rgraphvizの機能の一部の代替として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
行列またはdata.frameが与えられると、各変数のヒストグラムを「行列」形式で作成します。各プロットには正規適合と密度分布が含まれます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの機能の一部の代替として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
一般化可能性理論（generalizability theory）を用いて、マルチレベルデータの信頼性の様々な指標（例えば、被験者内にネストされた経時的な項目）を見つけることができる。  基本的な3元配置のアノバがデータに適用され、そこから分散成分が抽出されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットをロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について時間オーバーのオブザベーションの複数の格子プロットが作成されます。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、因子分析または主成分分析の出力を、1つまたは複数の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
探索的因子分析で適切な因子の数を決定する方法は複数あります。Very Simple Structure (VSS)基準のルーチンでは、さまざまな複雑さの解を、さまざまな因子数で比較することができます。グラフィック出力は、さまざまな複雑さのレベルについて、「最適な」因子の数を示します。  VelicerのMAP基準も良い選択です。nfactorsは、これらの代替推定をいくつか見つけ、プロットします。
McDonaldは、テストの一般的な因子飽和の推定値として係数ωを提案しています。  ωを求める1つの方法は，元のデータ集合の因子分析を行い，因子を斜めに回転させ，Schmid Leiman 変換を行い，それからωを求めることである．この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらにもう1つの方法は、Wallerの直接Schmid-Leimanを行うことである。
階層的因子構造は，変数間の相関を，それ自体が高次の因子で表現できる相関因子のより小さな集合で表現する．
階層的因子構造は，変数間の相関を，それ自体がより高次の因子で表現できる，より小さい相関因子の集合で表現する．
McDonald は，テストの一般的な因子飽和の推定として係数 ω を提案している．  オメガを求める1つの方法は，元のデータ集合の因子分析を行い，因子を斜めに回転させ，Schmid Leiman 変換を行い，それからオメガを求めることである．この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらに、WallerのSchmid-Leimanを直接実行する方法もある。
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid-Leiman 変換を行い、それからオメガを求めることである。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらに、WallerのSchmid-Leimanを直接実行する方法もある。
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid-Leiman 変換を行い、それからオメガを求めることである。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらに、WallerのSchmid-Leimanを直接実行する方法もある。
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid-Leiman 変換を行い、それからオメガを求めることである。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらにもう1つの方法は、Wallerの直接Schmid-Leimanを行うことである。
マハラノビス距離はD^2 = (x-μ)' Σ^-1 (x-μ)であり、Σはx行列の共分散である。  D2は、分布の異常値を検出する方法として使用することができる。  予想されるカイ2乗値と比較して大きなD2値は，異常な応答パターンを示す．  statsのマハラノビス関数は欠損データを扱いません。
Peter Killeen (2005)が議論している実験的または相関的発見の再現確率は、正確な再現で同じ方向の効果を見つける確率である。  Psychological Science に投稿された論文については、p.rep を報告する必要がある。
ピーター・キリーン（Peter Killeen）（2005）で議論されている実験的または相関的所見の再現確率は、正確な再現で同じ方向の効果を見つける確率である。  Psychological Science に投稿された論文については、p.rep を報告する必要がある。
ピーター・キリーン（Peter Killeen）（2005）で議論されている実験的または相関的所見の再現確率は、正確な再現で同じ方向の効果を見つける確率である。  Psychological Science に投稿された論文については、p.rep を報告する必要がある。
ピーター・キリーン（Peter Killeen）（2005）で議論されている実験的または相関的所見の再現確率は、正確な再現で同じ方向の効果を見つける確率である。  Psychological Science に投稿された論文については、p.rep を報告する必要がある。
   2つの（対または非対）相関の差を検定する。3つの変数 x, y, z が与えられたとき、xy 間の相関は xz 間の相関と異なるか?  y と z が独立であれば、これは z 変換 rs の単純な t 検定である。  しかし、それらが従属であれば、もう少し複雑になります。
pairsのヘルプページから引用したpairs.panelは、行列の散布図（SPLOM）を示し、対角線の下に2変量散布図、対角線上にヒストグラム、対角線の上にピアソン相関を示します。小さなデータセットの記述統計に便利です。  lm=TRUEの場合、y×xとx×yの両方で線形回帰フィットが表示されます。ポイントは、グループ化変数によって異なる色で表示されます。  ロバスト・フィッティングは、lowess または loess 回帰を用いて行われる。要求があれば、lmまたはloessの信頼区間が描画されます。
cor(x, use= "pairwise")を行うとき、各対相関のケース数を知っておくと便利です。  これは、SAPAタイプの分析を行うときに特に便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられる。
n個の項目の集合が与えられた場合、最も類似した項目のペアまたはトリプレットのn/2またはn/3のミニスケールまたはパーセルを形成する。  これらは、その後の尺度構築や多変量（因子など）分析の基礎として使用することができる。
x集合からy集合の変数の効果を除去するための行列代数の簡単な応用．入力は、データ行列または相関行列のいずれかである。  xとyの変数は位置によって指定される。  x と y が指定されていない場合は、すべての変数の影響が他のすべての相関から除算される。  回帰モデルと結果を比較するときにより便利な数式入力を使用してもよい。
固有値分解 固有値分解を行い、指定された成分数の固有値、負荷量、適合度を返す。  基本的には、相関行列または共分散行列のn個の主成分について主成分分析（PCA）を行うだけである。  残差相関も表示できる。2乗相関の削減の質は、残差相関と元の相関を比較することで報告される。princomp とは異なり、これは最良の n因子のサブセットだけを返します。固有ベクトルは，因子分析でより一般的な成分負荷量を生成するために，固有値の平方で再尺度化される．
度数の1 x 4ベクトルまたは2 x 2行列が与えられたとき、相関のファイ係数を求めます。  典型的な使用法は、2値予測変数から2値基準を予測する場合です。
2変量連続データが2分されるとどうなるかのあまりおもしろくないデモです。  基本的には、r、phi、polychorのデモです。  
structure.listはリスト入力をデザイン行列に変換します。phi.listは相関行列に対して同じことを行います。NULL値を持つ因子は0で埋められます。
phi 係数（2つの二項変数で計算されたピアソンr）と限界度数（パーセント）が与えられたとき、それに対応する四項相関の推定値は何ですか？
Yule2tetraとYule2phiに置き換わった非推奨関数のセット。
Φ係数（2つの2値変数で計算されるピアソンr）と限界度数（パーセンテージ）が与えられた時、それに対応する4値相関の推定値は？
フルランク未満の行列が与えられた場合、従来の逆関数は失敗します。  擬似逆行列または一般化逆行列は、特異値分解d行列の正値のみを使用することにより、この問題を解決します。MASSのginv関数とpracmaのpinv関数の応用です。
複数のプロット関数を "psych "クラスのオブジェクト用に1つにまとめたものです。  これは、fa、irt.fa、VSS、ICLUST、omega、factor.pa、principalの結果をプロットするために使用できます。
クラス "psych "のオブジェクトに対して、複数のプロット関数を1つにまとめる。  これは、fa, irt.fa, VSS, ICLUST, omega, factor.pa, principalの結果をプロットするために使用できる。
データ行列または相関行列の因子または成分の数を決定する1つの方法は、連続する固有値の "scree "プロットを調べることである。  プロット内の鋭い切れ目が、抽出すべき成分または因子の適切な数を示唆する。  「並列 "分析は、観察されたデータの因子のscreeと、元のデータと同じサイズのランダムなデータ行列の因子のscreeを比較する代替手法である。これは連続データ、2値データ、多値データに対して、Pearson相関、4値相関、多値相関を用いて行うことができる。
クラス "psych "のオブジェクトに対して、複数のプロット関数を1つにまとめる。  これは、fa, irt.fa, VSS, ICLUST, omega, factor.pa, principalの結果をプロットするのに使用できる。
Revelle and Condon, (2019) は，理論家だけでなく実務家にも役立つことを意図したチュートリアルで，信頼性の問題をレビューした．  単一の尺度の信頼性を推定するための関数（アルファやオメガなど）、スプリットハーフの信頼性を推定するための関数、テスト・リテスト信頼性testRetestやマルチレベル信頼性mlrを求めるための関数など、心理学には多くの関数がありますが、信頼性関数はこれらの関数をいくつか組み合わせて、複数の尺度についてこれらの推奨尺度を報告します。
クラス "psych" のオブジェクトについて、複数のプロット関数を1つにまとめます。  これは、fa, irt.fa, VSS, ICLUST, omega, factor.pa, principalの結果をプロットするために使用できます。
因子分析およびクラスター分析の出力は、通常、項目ごとの因子相関（負荷量）を示します。  因子負荷量の表は、負荷量の大きさによってソートされることが多い。  このプレゼンテーションのスタイルは，他の，2次的な次元での負荷量のパターンに気づきにくくする傾向がある．  極座標に変換することで、二次的な負荷量のパターンが見やすくなります。
四分位相関は、二変量正規性を仮定した2 x 2表から推測されるピアソン相関である。多項相関は，これを n x m 表に一般化する．項目反応理論を行うときや，正規理論を用いた併存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。この後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
四分木相関は、二変量正規性を仮定した2×2の表から推定されるピアソン相関である。ポリコレ相関は、これを n x m 表に一般化したものです。項目反応理論を行うときや，正規理論を用いた併存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。この後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
四分木相関は、二変量正規性を仮定した2×2の表から推定されるピアソン相関である。ポリコレ相関は、これを n x m 表に一般化したものです。項目反応理論を行うときや，正規理論を用いた併存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。この後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
四分木相関は、二変量正規性を仮定した2×2の表から推定されるピアソン相関である。ポリコレ相関は、これを n x m 表に一般化したものです。項目反応理論を行うときや，正規理論を用いた併存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。この後の2つの入力はデータフレームまたは行列である。  mnormt パッケージが必要。
予測因子得点は推定因子得点を求めるために使用される重み行列を使用し，予測成分は負荷量行列を使用する．スコアは，予測標本に関して標準化されるか，オリジナル・データに基づいて標準化される．bestScales モデルからの予測スコアは、元の標本からの統計量に基づきます。
尺度の有効性は、尺度の項目数、平均相互相関、平均有効性の関数として変化する。任意の特定の基準に対する尺度の有効性の漸近限界は、平均有効性を平均尺度内項目相関の平方根で割ったものです。predicted.validityは、（keys.listで定義された）尺度の集合に対する予測有効性と、さまざまな基準に対する平均項目有効性を求めます。  
固有値分解：固有値分解を行い、指定された数の成分について固有値、負荷量、適合度を返します。  基本的には、相関行列または共分散行列のn個の主成分について主成分分析(PCA)を行うだけです。  残差相関も表示できる。2乗相関の削減の質は、残差相関と元の相関を比較することで報告される。princomp とは異なり、これは最良の n因子のサブセットだけを返します。固有ベクトルは，因子分析でより一般的な成分負荷量を生成するために，固有値の平方で再尺度化される．
psychのほとんどの関数について、限定的な出力（print）またはやや詳細な出力（summary）を与える。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、JennrichとBentler (2011)によって導入された回転を実装しています。promaxは、HendricksonとWhite (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。これは、些細なことですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame(同じ長さ)を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案した varimin 回転は、GPArotation への適切な呼び出しによって実装されます。
psychパッケージの概要。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
data.frame、行列、テキストオブジェクトの最初と最後のn行を表示する簡単な方法。  head and tail または View を呼び出すだけです。
r2dは相関を効果量(Cohenのd)に、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiは元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
Steiger検定 単一の相関、2つの独立した相関の差、1つの変数を共有する2つの従属相関の差（Williams検定）、または異なる変数を持つ2つの従属相関の差（Steiger検定）の有意性を検定します。
r2dは相関を効果量(Cohenのd)に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiは元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
data.frameまたは行列が与えられた時、グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値の統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
r2dは相関を効果量（Cohenのd）に変換し，d2rはdをrに変換する．   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
レーダープロットとスパイダープロットは、多変量データを表示する多くの方法のうちの2つに過ぎません。レーダープロットは、相関を0（r=-1に対応）から1（r=1に対応）までの長さのベクトルで表示します。  ベクトルは円の周りに放射状に配置される。スパイダ・プロットは，各ベクトルの端点を結ぶ．プロットは，変数が何らかの意味のある方法で編成されている場合に最も適切である．
応用設定では，予測変数とある基準との間の相関を見つけることが典型的である．  残念ながら，予測変数が被験者を選ぶために使用される場合，予測変数の範囲は著しく減少する．  これは，観察される相関が予測変数の全範囲で観察されるよりも小さいことを制限する．  この問題の補正は，ソーンダイク・ケース2としてよく知られている．
lowerCorは、x変数の相関を求め、そしてそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、因子分析または主成分分析の出力を1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame(同じ長さ)を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
Holzinger-Swineford (1937)は、一般因子と相関のないグループ因子の2因子モデルを導入した。Holzingerのデータセットは、Joreskogが例として使用した9 *9行列と同様に、彼らの論文からのオリジナルの14 * 14行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Revelle and Condon, (2019) は、理論家だけでなく実務家にも役立つことを意図したチュートリアルで、信頼性の問題をレビューしている。  心理学には，単一尺度の信頼性を推定するための関数（アルファやオメガなど），スプリット・ハーフ信頼性splitHalf，テスト・リテスト信頼性testRetestやマルチレベル信頼性mlrを求めるための関数などがあるが，信頼性関数は，これらの関数をいくつか組み合わせて，複数の尺度についてこれらの推奨尺度を報告する．
心理学者は、"IQ" (mean=100, sd=15)、"SAT/GRE" (mean=500, sd=100)、"ACT" (mean=18, sd=6)、"Tスコア" (mean=50, sd=10)、"Stanines" (mean=5, sd=2)のような変換された尺度でデータを報告することがよくあります。再スケール関数は、データを標準スコアに変換し、指定された平均と標準偏差に再スケールします。
さまざまな心理関数の残差が抽出され、"きれいに "印刷されます。
さまざまな心理関数の残差が抽出され、"きれい "に印刷される。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらを得点する方向のリスト（k個のキーを持つkeys.list）が与えられたとき、各人と各尺度の合計得点または平均得点を求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目重複の補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は make.keys を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は求められませんが、項目の統計量は報告されます。(cluster.corと同様の機能) response.frequenciesは、多項式または多肢選択式項目の各回答カテゴリにおける項目の支持頻度を報告します。  大規模なデータセットではより高速。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらを採点する方向のリスト（k個のキーを持つkeys.list）が与えられた場合、各人と各尺度の合計スコアまたは平均スコアを求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目重複の補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は make.keys を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は求められませんが、項目の統計量は報告されます。(cluster.corと同様の機能) response.frequenciesは、多項式または多肢選択式項目の各回答カテゴリにおける項目の支持頻度を報告します。  大規模なデータセットではより高速です。
IRT関数の中には、すべての項目が同じ方向にコード化されている必要があるものがあります。  reverse.codeは、1と-1のキーベクトルに基づいて項目を反転させます。  反転された項目は、項目最大値＋項目最小値から差し引かれる。  これらは指定してもよいし、計算してもよい。
Von Neumanら(1941)は、平均の漸進的なシフトを考慮に入れた変動性の尺度として、連続差の平均二乗について議論した。これは、弾道学の誤差を研究するときや、情動を研究するときの気分の変動性や安定性を研究するときに適切である。ランダムなデータの場合、これは分散の2倍になりますが、順序が連続し、正の自己相関を持つデータの場合、これはずっと小さくなります。mssdは分散-自己相関の2倍に過ぎないので、特定のラグの自己相関を求めることも可能である。
SAT Verbal、SAT Quantitative、ACTの自己申告スコアは、Synthetic Aperture Personality Assessment (SAPA)のウェブベースの性格評価プロジェクトの一環として収集された。  年齢、性別、学歴も報告されている。700人の被験者のデータは、相関と分析のためのデモセットとしてここに含まれている。
選択肢の行列と尺度値のベクトルが与えられたとき、尺度値はどの程度選択肢を捉えているのだろうか？  つまり、モデルで与えられた残差の2乗の大きさと、選択値の2乗の大きさはどのくらい違うのでしょうか？
推定密度を持つXとYのヒストグラムを関連付けたX Y散布図を描きます。  グループごとの密度プロットや、グループごとの分布楕円も描きます。一部はレイアウトの使用のデモンストレーション。また、相関だけでなく、lowessの平滑度や線形モデルの傾きも含まれます。
XとYのヒストグラムと推定密度を伴うXY散布図を描きます。  グループごとの密度プロットや、グループごとの分布楕円も描きます。一部はレイアウトの使用のデモンストレーション。また、相関だけでなく、lowess平滑度や線形モデルの傾きも含まれます。
オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid Leiman変換を行い、それからオメガを求めることです。以下はSchmid Leimanのコードである。  S-L変換は、因子またはPC解を取り、それを斜め解に変換し、斜め解を因数分解して高次の（g ）因子を見つけ、そしてグループ因子からg を残差化します。
John Schmid と John M. Leiman (1957) は，階層因子構造を2因子構造に変換する方法を議論している．Schmid.leiman は，対角上に共同体性を持つ 12 x 12 の相関行列です．これは減衰補正の効果を示すために使用できます。さらに2つのデータセットがChen et al.
John Schmid と John M. Leiman (1957)は、階層的因子構造を2因子構造に変換する方法について議論しています。Schmid.leiman は、対角上に共同体性を持つ 12 x 12 の相関行列です。これは減衰補正の効果を示すために使用できます。さらに2つのデータセットがChen et al.
m個の項目（-1, 0, 1）のk個のキーの行列またはdata.frameと、m個の項目とn人の項目のスコアの行列またはdata.frameが与えられたとき、各人と各尺度の合計スコアまたは平均スコアを求めなさい。  さらに、クロンバックのアルファ、平均r、尺度間相関、および項目と尺度の相関を報告する。  (score.itemsによって置き換えられた)。
irt.faは二項項目または多項項目の四項相関または多項相関を因子分析することにより、項目反応理論(IRT)のパラメータを求めます。scoreIrt.2plは尺度リストを採点します。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論(IRT)のパラメータを求めます。scoreIrtは、これらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答の得点を求めます。scoreIrt.2plは尺度リストを採点します。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論(IRT)のパラメータを求めます。scoreIrtは、これらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答の得点を求めます。scoreIrt.2plは尺度リストをスコア化します。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらをスコアリングする方向のリスト（k個のキーを持つkeys.list）が与えられたとき、各人と各尺度の合計スコアまたは平均スコアを求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目重複の補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は make.keys を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は求められませんが、項目の統計量は報告されます。(cluster.corと同様の機能) response.frequenciesは、多項式または多肢選択式項目の各回答カテゴリにおける項目の支持頻度を報告します。  大規模なデータセットではより高速です。
score.multiple.choiceは、採点キーとデータマトリックス（またはdata.frame）を受け取り、各参加者の合計または平均正解数を求めます。  テストの基本統計量（アルファ値、平均r、項目平均、項目-全体相関）も報告されます。
1s、0s、1sのn x c個のクラスタ定義行列（キー）、およびn x n個の相関行列、またはN x n個のデータ行列が与えられた場合、複合クラスタの相関を求めます。  キー行列は，手入力，クリップボードからのコピー（read.clipboard），または factor2cluster や make.keys 関数からの出力として得ることができます．  scoreItemsと同様の機能で、項目ごとのクラスタ相関も得ることができます。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらをスコアリングする方向のリスト（k個のキーを持つkeys.list）が与えられた場合、各人と各スケールの合計スコアまたは平均スコアを求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は make.keys を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は求められませんが、項目の統計量は報告されます。(cluster.corと同様の機能) response.frequenciesは、多項式または多肢選択式項目の各回答カテゴリにおける項目の支持頻度を報告します。  大規模なデータセットではより高速。
irt.faは二項または多項項目の四項または多項の相関の因子分析を通して項目反応理論(IRT)のパラメータを求めます。scoreIrt.2plは尺度リストを採点します。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論(IRT)のパラメータを求めます。scoreIrtは、これらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答の得点を求めます。scoreIrt.2plは尺度リストを採点します。
irt.faは、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論(IRT)のパラメータを求めます。scoreIrtは、これらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答の得点を求めます。scoreIrt.2plは尺度リストをスコア化します。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらをスコアリングする方向のリスト（k個のキーを持つkeys.list）が与えられたとき、各人と各尺度の合計スコアまたは平均スコアを求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は make.keys を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は求められませんが、項目の統計量は報告されます。(cluster.corと同様の機能) response.frequenciesは、多項式または多肢選択式項目の各回答カテゴリにおける項目の支持頻度を報告します。  大規模なデータセットではより高速。
1s、0s、1sのn x c個のクラスタ定義行列（キー）、およびn x n個の相関行列、またはN x n個のデータ行列が与えられたとき、複合クラスタの相関を求めます。  キー行列は，手入力，クリップボードからのコピー（read.clipboard），または factor2cluster や make.keys 関数からの出力として得ることができます．  scoreItemsと同様の機能で、項目ごとのクラスタ相関も得ることができます。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらをスコアリングする方向のリスト（k個のキーを持つkeys.list）が与えられた場合、各人と各スケールの合計スコアまたは平均スコアを求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は make.keys を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は求められませんが、項目の統計量は報告されます。(cluster.corと同様の機能) response.frequenciesは、多項式または多肢選択式項目の各回答カテゴリにおける項目の支持頻度を報告します。  大規模なデータセットではより高速になります。
bestScalesまたはsetCorの項目重みは、重み付きスケールスコアを求めるために使用されます。scoreItems で使用される単位重みとは対照的に、scoreWtd はデータに一連の重みを乗じて尺度得点を求めます。  これらの重みは、回帰（lm や setCor など）から得られることもあれば、bestScales からの 0 次相関重みであることもあります。
Cattell の scree 検定は、相関行列の成分や因子の数を検定する最も簡単な方法の1つです。ここでは、相関行列の固有値と因子分析の固有値をプロットします。
データ分析の面倒な部分は、NAや他の値に変換する必要があるミスコード・データの問題に対処することです。  scrubは、与えられたdata.frameや行列に対して、fromからto=toまでの列の値のうち、最小値の集合（ベクトル）より小さいもの、または最大値のベクトルより大きいものをすべてNAに設定します。また、すべての値=isvalueからnewvalueへの基本的なデータの再コード化にも使用できます。連続変数をより少ないカテゴリに再コード化することもできます。  Nan、-Inf、InfをNAに変換します。
ベクトル、行列、data.frame の標準偏差を求めます。  後者2つの場合、各列の sd を返す。  sd 関数とは異なり、オブザベーションがない場合はエラーを投げるのではなく NA を返します。
 scoreItemsを使用して生データから、またはcluster.corを使用して相関行列から、複合尺度を形成して項目を採点する場合、以前はキー行列を作成する必要がありました。make.keysは単にキー行列を作成するためのショートカットです。  キー行列は-1,0,1のnvar x nscales行列で、各スケールのメンバーシップを定義します。項目は、場所または名前で指定できます。
構造方程式モデルのグラフィカル・プレゼンテーションは，半確定因子モデルと確認因子モデルを概念化するのにとても便利な方法である．x (xmodel) と y (ymodel) の測定モデル、および x と y を結ぶパス・モデル (phi) がある場合、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定されている場合は，x 変数または y 変数間の相関を示す．
構造方程式モデルのグラフィカル・プレゼンテーションは， sem および確認的因子モデルを概念化するのにとても便利な方法である．x (xmodel) と y (ymodel) の測定モデル、および x と y を結ぶパス・モデル (phi) が与えられている場合、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合，x 変数または y 変数間の相関を示す．
相関行列または生データの行列またはデータフレームが与えられたら，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描画する．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求める。
相関行列または生データの行列またはデータ・フレームが与えられると，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描く．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求める。
相関行列または生データの行列またはデータ・フレームが与えられると，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描く．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合の間の正準相関も求めます。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高く関係する項目の内容（たとえば、項目集合のfa.lookupの因子負荷量）、またはある特定の基準集合（たとえば、bestScales）を調査することが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame(同じ長さ)を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、circumplex構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、主要因子とマイナー因子をシミュレートするsim.minor、オメガの様々な例をテストするsim.omega、因子の数を決定する様々な方法の効率を比較するsim.parallelなどがあります。   sim.rasch はシミュレーションされたraschデータを作成します。sim.irt はsim.npl 1-4パラメータロジスティックIRTまたはsim.npn 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成します。また、sim.poly.ideal.npn 1～4パラメータ多項式正規理論理想点モデルやsim.poly.ideal.npl 1～4パラメータ多項式ロジスティック理想点モデルを呼び出して、理想点や展開モデルに従ったデータを作成するsim.poly.idealもあります。
sim.anovaは、3つの独立変数(IV1, IV2, IV3)の計画行列を、主効果と交互作用について、任意の数の水準と効果量とともに生成します。  IVは連続またはカテゴリーで、線形または2次効果を持つことができます。単一の従属変数または複数の（被験者内の）従属変数のいずれかが、指定されたモデルに従って生成されます。反復測定は，指定された信頼性を持つタウ等価であると仮定される．
因子負荷量と因子相互相関の集合から母集団直交相関行列または階層相関行列を作成する．そして，この母集団からサイズ n の標本を抽出することができる．  標本データ，標本相関，母集団相関のいずれかを返す．  これは、指導やデモンストレーションのためのサンプル・データ・セットを作成するために使用されます。
因子分析と主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造がある。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
古典的テスト理論（CTT）は、すべてのテストが1つの因子と残差誤差で表現できる場合、4つ以上のテストが共属的に等価であると見なします。  並列検定は，（通常2つの）検定が等しい因子負荷量を持つ特別なケースである．  タウ等価検定は，等しい因子負荷量を持つが，不均等な誤差を持つことがある．  共属検定は，因子負荷と誤差分散の両方で異なるかもしれない．
構造方程式モデルは，相関または相関行列を測定（因子）モデルと構造（回帰）モデルに分解する．既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データが生成されます。
因子分析と主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、circumplex構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、主要因子とマイナー因子をシミュレートするsim.minor、オメガの様々な例をテストするsim.omega、因子数を決定する様々な方法の効率を比較するsim.parallelなどがあります。   sim.rasch はシミュレーションされたraschデータを作成します。sim.irt はsim.npl 1-4パラメータロジスティックIRTまたはsim.npn 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成します。また、sim.poly.ideal.npn 1～4パラメータ多項式正規理論理想点モデルまたはsim.poly.npl 1～4パラメータ多項式ロジスティック理想点モデルを呼び出して、理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります。
因子負荷量と因子相互相関のセットから母集団直交相関行列または階層相関行列を作成します。そして、この母集団からサイズnの標本を抽出することができる。  標本データ，標本相関，母集団相関のいずれかを返す．  これは、指導やデモンストレーション用のサンプル・データ・セットを作成するために使用されます。
psychパッケージの多くの関数は、特定の構造を持つシミュレーション・データを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目のシミュレーションのsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、より一般的な項目シミュレーションのsim.itemなどがあります。itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
因子分析や主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円周上に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、circumplex構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、主要因子とマイナー因子をシミュレートするsim.minor、オメガの様々な例をテストするsim.omega、因子数を決定する様々な方法の効率を比較するsim.parallelなどがあります。   sim.rasch はシミュレーションされたraschデータを作成します。sim.irt はsim.npl 1-4パラメータロジスティックIRTまたはsim.npn 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成します。また、sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して、理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります。
多階層データは、オブザベーションがグループ内に入れ子になっている場合に発生します。これは、時に理解しにくい相関構造を生み出すことがあります。これらの2つのシミュレーションは、グループ内の相関が、グループ平均間の相関を意味するものでも、グループ平均間の相関によって暗示されるものでもないことを実証することを可能にします。集計されたデータの相関は「生態学的相関」と呼ばれることがある。グループレベルの相関と個人レベルの相関が独立であることは、このような推論を問題にする。  個人内データは、sim.multiで様々な個人内構造が可能なようにシミュレートされています。  
多階層データは、オブザベーションがグループ内に入れ子になっているときに発生します。これは、時に理解しにくい相関構造を生み出すことがあります。これらの2つのシミュレーションは、グループ内の相関が、グループ平均間の相関を意味するものでも、グループ平均間の相関によって暗示されるものでもないことを示すことができます。集計されたデータの相関は「生態学的相関」と呼ばれることがある。グループレベルの相関と個人レベルの相関が独立であることは、このような推論を問題にする。  個人内データは、sim.multiで様々な個人内構造が可能なようにシミュレートされています。  
sim.multiでは、様々な個人内構造を持つ個人内データがシミュレートされます。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、circumplex構造のsim.circ、1因子共同モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、circumplex構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、主要因子とマイナー因子をシミュレートするsim.minor、omegaの様々な例をテストするsim.omega、因子の数を決定する様々な方法の効率を比較するsim.parallelなどがあります。   sim.rasch はシミュレーションされたraschデータを作成します。sim.irt はsim.npl 1-4パラメータロジスティックIRTまたはsim.npn 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成します。また、sim.poly.ideal.npn 1〜4パラメータ多項式正規理論理想点モデルまたはsim.poly.npl 1〜4パラメータ多項式ロジスティック理想点モデルを呼び出して、理想点または展開モデルに従ったデータを作成するsim.poly.idealがあります。
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、circumplex構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、主要因子とマイナー因子をシミュレートするsim.minor、omegaの様々な例をテストするsim.omega、因子の数を決定する様々な方法の効率を比較するsim.parallelなどがあります。   sim.rasch はシミュレーションされたraschデータを作成します。sim.irt はsim.npl 1-4パラメータロジスティックIRTまたはsim.npn 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成します。また、sim.poly.ideal.npn 1〜4パラメータ多項式正規理論理想点モデルまたはsim.poly.npl 1〜4パラメータ多項式ロジスティック理想点モデルを呼び出して、理想点または展開モデルに従ったデータを作成するsim.poly.idealがあります。
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレクスのim、データシンプレクスのsim.simplex、円周構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.itemはより一般的な項目シミュレーション、sim.minorはメジャー因子とマイナー因子をシミュレート、sim.omegaはomegaの様々な例をテスト、sim.parallelは因子数を決定する様々な方法の効率を比較、sim.raschはシミュレートされたraschデータを作成、sim.irtは、sim.npl 1〜4パラメータロジスティックIRTまたはsim.npn 1〜4パラメータ正規IRTを呼び出して、一般的な1〜4パラメータIRTデータを作成します。sim.polyは、sim.poly.npn 1〜4パラメータ多値正規理論項目またはsim.poly.npl 1〜4パラメータ多値正規理論項目を呼び出して、多値アイデアを作成します。また，sim.poly.ideal.npn 1-4パラメータ多値正規理論理想点モデルまたはsim.poly.ideal.npl 1-4パラメータ多値ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
sim.poly.ideal.npl1-4パラメータ多値ロジスティック理想点モデル psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、因子シンプレックスのim、データシンプレックスのsim.simplex、circumplex構造のsim.circ、1因子共生成モデルのsim.congeneric、2値項目をシミュレートするsim.dichot、階層的因子モデルを作成するsim.hierarchical、より一般的な項目シミュレーションのsim.item、主要因子とマイナー因子をシミュレートするsim.minor、omegaの様々な例をテストするsim.omega、因子の数を決定する様々な方法の効率を比較するsim.parallelなどがあります。   sim.rasch はシミュレーションされたraschデータを作成します。sim.irt はsim.npl 1-4パラメータロジスティックIRTまたはsim.npn 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成します。また，sim.poly.ideal.npn 1～4パラメータ多項式正規理論理想点モデルまたはsim.poly.npl 1～4パラメータ多項式ロジスティック理想点モデルを呼び出して，理想点または展開モデルに従ったデータを作成するsim.poly.idealもあります．
因子分析や主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円周上に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
構造方程式モデルは、相関行列または相関行列を測定（因子）モデルと構造（回帰）モデルに分解します。sim.structuralは、測定と構造の特性が既知のデータセットを作成します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データも生成されます。
構造方程式モデル（Structural Equation Models） 相関行列または相関行列を、測定（因子）モデルと構造（回帰）モデルに分解します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データも生成されます。
シミュレーションは、統計学や心理測定に関する最も有用な手法の1つです。  ここでは、指定された数の因子からなる単純な構造の相関行列をシミュレーションする。  各項目は複雑度1であると仮定します。  別のシミュレーションについては circ.sim と item.sim を参照してください。
構造方程式モデルは、相関行列または相関行列を、測定（因子）モデルと構造（回帰）モデルに分解します。sim.structuralは、測定と構造の特性が既知のデータセットを作成します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データが生成されます。
因子分析と主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造がある。  これらのデータを作成するのは簡単で、影響や性格の構造に関する代替解を探索するのに便利である。
data.frameまたは行列の各変数のskewとkurtosisを求めます。  e1071のskewとkurtosisとは異なり、これはdata.frame/matrixの各変数または各列に対して異なるskewを計算します。
ある変数と行列内の残りの変数の2乗重相関は、変数の共同性の初期推定値として使用されることがある。
レーダー・プロットとスパイダー・プロットは，多変量データを表示する多くの方法のうちの2つに過ぎない．レーダー・プロットは，0（r=-1に対応）から1（r=1に対応）までの長さのベクトルとして相関をプロットする．  ベクトルは円の周りに放射状に配置される。スパイダ・プロットは，各ベクトルの端点を結ぶ．プロットは，変数が何らかの意味のある方法で編成されている場合に最も適切である．
テストの信頼性の8つの代替推定は，Guttman (1945)によって議論された6つ，ten Berge and Zergers (1978)によって議論された4つ（μ_0 ... μ_3），さらにβ（最悪のスプリット・ハーフ，Revelle, 1979），Bentler and Woodward (1980)によって議論されたglb（最大最小境界），および ω_h と ω_t (McDonald, 1999; Zinbarg et al., 2005)を含む．スプリットハーフの最大値と最小値は、総当たりまたはサンプリングによって見つけられます。
2つのレベル（たとえば、個人といくつかのグループ化変数の集合）でデータを調査する場合、基本的な記述統計量（平均、sds、グループごとのns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルの相関の行列を、グループ内の相関とグループ間の相関に分解する機能です。
2つのレベル（例えば、個人といくつかのグループ化変数のセット）でデータを調査する場合、基本的な記述統計量（平均、sds、グループごとのns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルの相関の行列を、グループ内の相関とグループ間の相関に分解する機能です。
2つのレベル（例えば、個人といくつかのグループ化変数のセット）でデータを調査する場合、基本的な記述統計量（平均、sds、グループごとのns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルの相関の行列を、グループ内の相関とグループ間の相関に分解する機能です。
構造方程式モデルのグラフィカル・プレゼンテーションは，半確定因子モデルと確証因子モデルを概念化するのに非常に有用な方法である．x (xmodel) と y (ymodel) の測定モデル、および x と y (phi) を接続するパス・モデルが与えられている場合、グラフを描きます。  ymodel が指定されていない場合は，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定されている場合は，x 変数または y 変数間の相関を示す．
構造方程式モデルのグラフィカル・プレゼンテーションは， sem および確認的因子モデルを概念化するのにとても便利な方法である．x (xmodel) と y (ymodel) の測定モデル、および x と y を結ぶパス・モデル (phi) が与えられている場合、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定されている場合は，x 変数または y 変数間の相関を示す．
構造ダイアグラムや構造モデルを作成するとき、構造行列のすべてのゼロ負荷量を指定する必要がないのは便利です。structure.list は、リスト入力をデザイン行列に変換します。NULL値を持つ因子は0で埋められます。
構造方程式モデルのグラフィック表示は、半確定因子モデルと確証因子モデルを概念化するのに非常に便利な方法です。x (xmodel)とy (ymodel)の測定モデル、およびxとyをつなぐパスモデル(phi)が与えられたら、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合、x 変数または y 変数間の相関を表示する。
psych のほとんどの関数について，限定的な出力（print）またはやや詳細な出力（summary）を与える．
行列 nXm と jYk が与えられたとき，超対角線に沿った要素 x と y を持つ次元 (n+j) と (m+k) の超行列を形成する．構造方程式を考慮するときに便利である．  測定モデル x と y は，すべての変数のより大きな測定モデルに結合できる．  もし x か y のどちらかが行列のリストであれば，それらのすべての要素から再帰的にスーパー行列を形成します．superCor は，2つの行列と2つの要素の相互相関から行列を形成します．
行列 nXm, jYk が与えられたとき, (n+j), (m+k) 次元の超行列を 形成する.構造方程式を考慮するときに便利である．  測定モデル x と y は，すべての変数のより大きな測定モデルに結合できる．  もし x か y のどちらかが行列のリストであれば，それらのすべての要素から再帰的にスーパー行列を形成します．superCor は，2つの行列とその要素の相互相関から行列を形成します．
行列 nXm, jYk が与えられたとき, (n+j), (m+k) 次元の超行列を 形成する.構造方程式を考慮するときに便利である．  測定モデル x と y は，すべての変数のより大きな測定モデルに結合できる．  superCor は、2つの行列とその要素の相互相関から行列を作成します。
data.frameまたは行列が与えられた時、グループ変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d 統計量を r 等価値に変換し、スチューデントの t 統計量と関連する p 値を報告し、グループ化変数の両方の値の統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
r2dは相関を効果量（Cohenのd）に変換し，d2rはdをrに変換する．   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ2乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
過去のセットの中には、限られたビン数のカウントの要約表として報告されているものもある。  これらの表を元の値を表すdata.frameに変換することは、教育的な目的に役立ちます。  (例えば、回帰を実証するために、身長 x 立方体の元のガルトンの表を変換する)。列名と行名は数値に変換できなければならない。
過去のセットの中には、限られた数のビンにおけるカウントの要約表として報告されているものもある。  これらの表を元の値を表すdata.frameに変換することは、教育的な目的に役立ちます。  (例えば、回帰を実証するために、身長 x 立方体の元のガルトンの表を変換する)。列名と行名は数値に変換できなければならない。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。これは些細な関数ですが、行列の下三角形を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame(同じ長さ)を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
Nurit Tal-Or, Jonanathan Cohen, Yariv Tasfati, and Albert Gunther (2010) は、メディアが他者に及ぼす推定効果と態度の変化を調査しました。  このデータセットは研究2のもので、メディアの推定される影響がその後の行動に及ぼす影響を調べたものである。  これは、Hayes（2013）による媒介の例として、また媒介関数に使用されている。
Nurit Tal-Or, Jonanathan Cohen, Yariv Tasfati, and Albert Gunther (2010)は、他者に対するメディアの推定影響と態度の変化を調査した。  このデータセットは研究2のもので、メディアの推定される影響がその後の行動に及ぼす影響を調べたものである。  これは、Hayes (2013)による媒介の例として、またmediate関数に使用されています。
bifactor回転は、GPArotationパッケージのGPForthを呼び出して、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013)が提案したバリミン回転は、GPArotationへの適切な呼び出しによって実装されます。
テストの信頼性の8つの代替推定値には、Guttman (1945)によって議論された6つ、ten Berge and Zergers (1978)によって議論された4つ（μ_0 ... μ_3）、さらにβ（最悪のスプリット・ハーフ、Revelle, 1979）、Bentler and Woodward (1980)によって議論されたglb（最大最小境界）、および ω_h と ω_t (McDonald, 1999; Zinbarg et al., 2005)が含まれます。スプリットハーフの最大値と最小値は、総当りまたはサンプリングによって求められる。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... 呼び出しルーチン(例えば、test.allはパッケージ内のすべての例をテストします。best.itemsは因子行列を絶対値でソートし、展開された項目名を表示します。cor2は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframe列を数値に変換します。
 項目反応理論（Item Response Theory）は、潜在スコアを推定するための多くの代替方法を提供します。  ここでは、回答パターンに関連する潜在変数を推定する6つの異なる方法を比較します。もともとはscoreIrtのテストとして開発されたものであるが、おそらくデモンストレーションの目的にも有用であろう。  項目はsim.irtを使用してシミュレートされ、次にirt.fa、1PLと2PL、2PNの単純加重モデルを使用して得られた統計量を使用して、factor.scoresから因子スコアを使用して採点されます。結果は、2値の場合はMIRTとltmの推定値と、多値の場合はMIRTとほぼ完全に一致する。  (ldmの結果は多値の場合不安定で、scoreIrtやMIRTと一致することもあれば、かなり悪いこともある)。  
心理関数が基本的なテストデータセットで動作することを確認するテスト
テストの2つのプレゼンテーションが与えられた場合、項目間の信頼性と人の安定性と同様に、テスト・リテスト信頼性を求めるのは簡単です。  データの多階層構造を用いて、人、項目、時間、人 x 時間、人 x 項目、項目 x 時間の分散成分や残差分散を見つけるために、分散分解を行うことも可能です。これは、さまざまな一般化係数につながります。
四分位相関は、二変量正規性を仮定した2 x 2表から推測されるピアソン相関です。多項相関は、これを n x m 表に一般化します。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
サーストンケースVスケーリングは、他のオブジェクトと比較したオブジェクトのスケーリングを可能にする。サーストンが考慮したケースの1つとして、ケースVは等分散と無相関分布を仮定している。
Holzinger-Swineford (1937) は、一般因子と無相関グループ因子の2因子モデルを導入した。Holzingerのデータセットは、Joreskogが例として使用した9 *9 行列と同様に、彼らの論文からのオリジナルの14 * 14 行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
data.frame、行列、テキスト・オブジェクトの最初と最後のn行を表示する簡単な方法。  headとtailまたはViewをきれいに呼び出すだけです。
正方行列のトレースは対角要素の和である。
Tucker and Lewis (1973) は、ML因子分析に信頼性係数を導入しました。  彼らのデータ・セットは、Tucker (1958) によって以前に報告され、Thurstone and Thurstone (1941)から取られたものです。  この相関行列は710人の被験者に対する9×9の行列で、2つの能力の相関因子がある：単語の流暢さ」と「言語能力」である。
項目の集合が1つの潜在特性を測定しているかどうかを評価する方法はいろいろある。  もしデータに1因子モデルが成り立つなら、因子分析分解Fは、FF'が対角線に沿った共分散性を持つ相関を再現することを意味します。この場合、適合度FF'は相関行列から一意性を除いたものと同じになるはずである。  これが高ければ高いほど，一次元性の証拠となる．多くの代替統計量が推定される．
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案する varimin 回転は、GPArotation への適切な呼び出しによって実装される。
データ集合を記述する多くの方法の中で、1つはグループ化変数の各値の密度プロットであり、もう1つは複数変数のバイオリン・プロットです。  密度プロットは、効果量を示すために異なるグループの密度を示します。バイオリン・プロットは、箱ひげ図に似ていますが、実際の分布を示します。中央値、25パーセンタイル線、75パーセンタイル線が表示に追加されます。グループ化変数が指定されると、violinByは各変数と各グループについてviolin plotを描画します。データポイントも描画されます。
データ集合を表現する多くの方法の中で、1つはグループ化変数の各値の密度プロットであり、もう1つは複数の変数のバイオリン・プロットです。  密度プロットは、効果量を示すために、異なるグループの密度を示します。バイオリン・プロットは、箱ひげ図に似ていますが、実際の分布を示します。中央値、25パーセンタイル線、75パーセンタイル線が表示に追加されます。グループ化変数が指定されると、violinByは各変数と各グループについてviolin plotを描画します。データポイントも描画されるかもしれません。
探索的因子分析で適切な因子の数を決定する方法は複数あります。非常に単純な構造(VSS)基準のルーチンは、さまざまな複雑さの解と異なる因子数の解を比較することを可能にします。グラフィック出力は、さまざまな複雑さのレベルについて、「最適な」因子の数を示します。  VelicerのMAP基準も良い選択です。nfactorsは、これらの代替推定をいくつか見つけ、プロットします。
探索的因子分析で適切な因子数を決定する方法は複数あります。Very Simple Structure (VSS)基準のルーチンは、さまざまな複雑さの解と異なる因子数の解を比較することを可能にします。グラフィック出力は、さまざまな複雑さのレベルについて、「最適な」因子の数を示します。  nfactors は、これらの代替推定をいくつか見つけ、プロットします。
因子数のもう1つの有用なテストは、ランダム行列の固有値が実行列の固有値より大きい場合です。ここでは、ランダムデータに対するVSS解を示します。よりよい検定はおそらく fa.parallelであろう。
最適な因子数を推定するための Very Simple Structure 基準 ( VSS ) が、複雑さの増大と因子数の増加の関数としてプロットされている。  
Cattellの scree 検定は、相関行列の成分または因子の数を検定する最も簡単な方法の1つです。ここでは、相関行列の固有値と因子分析の固有値をプロットします。
シミュレーションは、統計学や心理測定学で最も有用な手法の1つである。  ここでは、指定された数の因子からなる単純な構造の相関行列をシミュレートします。  各項目は複雑度1であると仮定します。  別のシミュレーションについては circ.sim と item.sim を参照してください。
シミュレーションは統計学や心理測定学で最も有用な手法の1つです。  ここでは、指定された数の因子からなる単純な構造の相関行列をシミュレーションします。  各項目は複雑度1であると仮定します。  別のシミュレーションについては circ.sim と item.sim を参照してください。
John Schmid と John M. Leiman (1957) は、階層的な因子構造を2因子構造に変換する方法を議論しています。Schmidには、12 x 12の相関行列の例があります。schmid.leimanは、対角上に共分散を持つ12 x 12の相関行列です。これは減衰補正の効果を示すために使用できます。さらに2つのデータセットがChen et al.
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は、Winsorizedスコアを求める。   上下のトリム値は、トリム分位点と1-トリム分位点の値が与えられる。  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
相関がグループ内相関とグループ間相関に分解され、これら2つの相関が独立であることを示す。  グループ間相関は生態学的相関と呼ばれることもあり、グループ内相関とグループ間相関への分解はマルチレベル・モデリングの基本概念である。  このデータ集合は、9つの変数間の合成相関を示し、4つのグループで16のケースを表現している。    
Cohen's kappa (Cohen, 1960)および重み付きκ (Cohen, 1968)は、名義得点を使用する場合、2人の評定者の一致を見つけるために使用できます。  2人以上の評定者を使用する場合，ライトのカッパは，単に平均コーエン・カッパである．
関連性の多くの尺度の1つがユール係数である．  カウントの2 x 2表が与えられる
多くの関連性の尺度の1つがユール係数である。  カウントの2 x 2表が与えられたとき
多くの関連性の尺度の1つがユール係数である。  2×2の個数表
Yule2tetraとYule2phiに置き換わった非推奨関数のセット。
多くの関連性の尺度の1つがYule係数である。  2×2の数表が与えられた場合
Yule2tetraとYule2phiで置き換えられた非推奨関数の集合。
多くの関連性の尺度の1つがYule係数である。  2×2の個数表が与えられた時
多くの関連性の尺度の1つにYule係数がある。  カウントの2 x 2 表が与えられた時
多くの関連性の尺度の1つがユール係数である。  カウントの2 x 2 表が与えられたとき
関数 acf は、自己共分散または自己相関関数の推定値を計算する（デフォルトではプロットする）。  関数pacfは偏自己相関に使われる関数である。  関数ccfは、2つの2変量系列の相互相関または相互共分散を計算する。
自己相関関数に正確にフィットするAR過程を計算する。
add.scopeおよびdrop.scopeは、項の階層性を尊重しながら、モデルに個別に追加または削除できる項を計算します。
scope引数でモデルへの追加、モデルからの削除が可能な単項をすべて計算し、それらのモデルをフィッティングし、フィットの変化量を計算する。
与えられた表について、マージンを計算するために、どの分類因子を1つ以上の水準で拡張するかを指定することができる。  例えば、1番目の次元の合計と平均、2番目の次元の中央値を計算することができる。  結果として得られる表は、1番目の次元に対して2つの追加レベル、2番目の次元に対して1つの追加レベルを持つことになる。  デフォルトは、表のマージン全体の合計である。  他の可能性は、マージンが計算される順序に依存する結果を与えるかもしれない。  このフラグは、関数から出力される印刷物に表示されます。
データを部分集合に分割し、それぞれについて要約統計量を計算し、その結果を便利な形式で返します。
データを部分集合に分割し、それぞれについて要約統計量を計算し、その結果を便利な形式で返します。
データを部分集合に分割し、それぞれについて要約統計量を計算し、その結果を簡便な形式で返す。
一般的な関数は、対数尤度値が得られる1つまたは複数の適合モデルオブジェクトについて、式-2*log-尤度 + k*nparに従って赤池の「情報量基準」を計算します。nparは適合モデルのパラメータ数を表し、通常のAICではk = 2、いわゆるBICまたはSBC（Schwarzのベイズ基準）ではk = log(n)（nはオブザベーション数）です。
式で指定された線形モデルのエイリアス（線形従属項）を見つける。
1つまたは複数の適合モデルオブジェクトについて，分散分析（または偏差）表を計算する
スケールパラメータの差に関するAnsari-Bradleyの2標本検定を実行します
各層についてlmを呼び出して分散分析モデルをフィットする。
与えられたデータ点を線形補間する点のリスト、または線形（または定数）補間を行う関数を返す。
与えられたデータ点を線形補間する点のリスト、または線形（または定数）補間を行う関数を返す。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータにフィットする。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータにフィットする。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータにフィットさせる。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルを普通の最小2乗法でデータにフィットする。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータに当てはめる。
ARIMAモデルを一変量時系列にあてはめる。
ARIMAモデルからシミュレーションを行う
ARIMAモデルを一変量時系列にあてはめ、あてはめたモデルから予測する。
ここに列挙されている関数や変数は、（もう）必要とされていないため、Rの一部ではなくなりました。
ARMA過程の理論的自己相関関数または偏自己相関関数を計算する。
ARMA過程を無限MA過程に変換する。
クラス "dendrogram" は、木のような構造を扱うための一般的な関数を提供します。  これは、階層的クラスタリングや分類/回帰ツリーにおける同様の関数の置き換えを意図したものであり、これらのすべてがツリーのプロットや切断に同じエンジンを使用できるようにするものである。
この関数は，データ行列の行間の距離を計算するために指定された距離尺度を使用して計算された距離行列を計算し，返します．
ジェネリック関数 formula とその特定のメソッドは、他のオブジェクトに含まれている式を抽出する機能を提供します。
他の階層クラスタリング関数のオブジェクトを "hclust" クラスに変換します．
ベクトル(x[1], ..., x[n])と(y[0], y[1], ..., y[n])(1つ多い!)が与えられた場合， stepfun(x, y, ...)は，補間'ステップ'関数，例えば fn を返します．fn(t) = c[i] (定数) for t in ( x[i], x[i+1]) and at the abscissa values, if (by default)right = FALSE, fn(x[i]) = y[i] and forright = TRUE, fn(x[i]) = y[i-1], fori=1, ..., n.
関数tsは、時系列オブジェクトを作成するために使用される。
名前、式、数値、文字列は片側式に変換される。オブジェクトが数式である場合、それは片側でなければならず、その場合、それは変更されずに返される。
x[]のサブセットは平均化され、各サブセットは同じ因子レベルを持つ観測から構成される。
tskernel "クラスは、離散非対称正規化平滑化カーネルを表現するために設計されています。  これらのカーネルは、ベクトル、行列、または時系列オブジェクトを平滑化するために使用できる。
各グループ（標本）の分散が同じであるという帰無値のバートレット検定を実行します。
対数尤度値が得られる1つまたは複数の適合モデルオブジェクトについて、2*対数尤度 + k*nparの式に従って赤池の「情報量基準」を計算する汎用関数。nparは適合モデルのパラメータ数を表し、通常のAICの場合はk = 2、いわゆるBICまたはSBC（Schwarzのベイズ基準）の場合はk = log(n)（nはオブザベーション数）。
ベルヌーイ実験における成功確率に関する単純な帰無仮説の厳密検定を実行します。
ファミリーオブジェクトは、glmのような関数が使用するモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、glmのドキュメントを参照してください。
現在のグラフィックデバイスにバイプロットを描画します。
与えられたデータ点に対して3次（またはエルミート）スプライン補間を行い、補間によって得られた点のリスト、または補間を実行する関数を返します。
密度におけるガウスカーネルの帯域幅セレクタ
密度におけるガウスカーネルの帯域幅セレクタ
密度におけるガウスカーネルの帯域幅セレクタ.
密度におけるガウスカーネルの帯域幅セレクタ
密度のガウシアンカーネルの帯域幅セレクタ。
因子の "contrasts "属性を設定します。
2つのデータ行列間の正準相関を計算します。
大文字小文字を区別しない）大文字と小文字を区別しない）変数名を返す単純なユーティリティ．
関数 acf は，自己共分散または自己相関関数の推定値を計算する（デフォルトではプロットする）．  関数pacfは部分自己相関に使用される関数である。  関数ccfは、2つの2変量系列の相互相関または相互共分散を計算する。
chisq.testは、カイ2乗分割表検定と適合度検定を行う。
主座標分析（Gower, 1966）としても知られている。
coef は、モデリング関数が返すオブジェクトからモデル係数を抽出する汎用関数です。
coef は、モデリング関数が返すオブジェクトからモデル係数を抽出する汎用関数です。
どのケースが完全であるか、つまり欠損値がないかを示す論理ベクトルを返します。
信頼区間(confidence intervals): フィットしたモデルの1つまたは複数のパラメータの信頼区間を計算します。  クラス "lm "を継承するオブジェクトには、デフォルトとメソッドがあります。
適合モデル中の1つ以上のパラメータの信頼区間を計算する。  クラス "lm "を継承するオブジェクトには、デフォルトとメソッドがあります。
適合モデル中の1つまたは複数のパラメータの信頼区間を計算する。  クラス "lm "を継承するオブジェクトには、デフォルトとメソッドがあります。
適応バリアアルゴリズムを用いて、線形不等式制約に従う関数を最小化します。
対照の行列を返します。
対比の行列を返します。
対比の行列を返します。
対比の行列を返せ
対比の行列を返します。
因子に関連する対比の設定と表示
因子に関連するコントラストを設定し、表示する。
高速フーリエ変換を使用して、2つのシーケンスのいくつかの種類の共進を計算する。
この一連の関数は、Belsley, Kuh and Welsch (1980)、Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができる。
階層的クラスタリングの cophenetic distances を計算します。
var, cov, cor は，x と y がベクトルである場合，x の分散と x と y の共分散または相関を計算します．   xとyが行列の場合は、xの列とyの列の間の共分散（または相関）が計算されます。
Pearsonの積モーメント相関係数、Kendallのタウ、Spearmanのrhoのいずれかを用いて、対の標本間の関連を検定する。
var、cov および cor は、x の分散と x と y の共分散または相関を計算します。   x と y が行列の場合は、x の列と y の列の間の共分散（または相関）が計算されます。
重み付き共分散行列とデータの平均の推定値、および（重み付き）相関行列の推定値を含むリストを返します。
var、cov および cor は、x の分散、および x と y の共分散または相関を計算します。   xとyが行列の場合は、xの列とyの列の間の共分散（または相関）が計算されます。
この一連の関数は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
累積ピリオドグラムのプロット
hclust の結果のようなツリーを、必要なグループ数やカットハイトを指定することで、いくつかのグループに分割します。
time 時系列がサンプリングされた時刻のベクトルを作成します。
簡単な式の導関数を，記号的およびアルゴリズム的に計算する。
shape1およびshape2（およびオプションの非心パラメータncp）をパラメータとするベータ分布の密度，分布関数，分位関数，ランダム生成
二項分布（パラメータ size および prob）の密度，分布関数，分位関数，ランダム生成
Cauchy分布の密度，分布関数，分位関数，ランダム生成（位置パラメータlocation，スケールパラメータscaleを指定）．
カイ2乗（chi^2）分布の密度、分布関数、分位関数、およびランダム生成。
移動平均を使って時系列を季節成分，トレンド成分，不規則成分に分解する  加法的または乗法的な季節成分を扱います。
delete.responseは、同じモデルのtermsオブジェクトを返しますが、応答変数はありません。
time関数は、時系列がサンプリングされた時刻のベクトルを作成します。
関数FUNをデンドログラムの各ノードに再帰的に適用する。  y <- dendrapply(x, fn)の時、yはxと同じグラフ構造のデンドログラムであり、各ノードに対して,y.node[j] <- FUN( x.node[j], ...) (ここでy.node[j]はyのj番目のノードの(無効な!)表記法である)。
(S3)汎用関数densityはカーネル密度推定を行います。  そのデフォルトのメソッドは、一変量オブザベーションに対して、与えられたカーネルとバンド幅でこれを行います。
(S3) generic function density は，カーネル密度推定を計算する．  そのデフォルトのメソッドは，与えられたカーネルと一変量オブザベーションのバンド幅でこれを行います．
単純な式の導関数を，記号的およびアルゴリズム的に計算します．
単純な式の導関数を，記号的およびアルゴリズム的に計算します．
deviance関数は，適合モデルオブジェクトのdevianceを返します．
密度，分布関数，分位関数，および率rate（つまり平均1/rate）を持つ指数分布のランダム生成
df1 と df2 の自由度（およびオプションの非心パラメータ ncp）を持つ F 分布の密度、分布関数、分位関数、ランダム生成。
tskernel "クラスは，離散非対称な正規化平滑化カーネルを表現するように設計されている．  これらのカーネルは、ベクトル、行列、または時系列オブジェクトを平滑化するために使用できます。
残差自由度関数は、フィットされたモデルオブジェクトから抽出された残差自由度を返します。
汎用関数 formula とそのメソッドは、他のオブジェクトに含まれている式を抽出する機能を提供します。
この一連の関数は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するのに使用できます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するのに使用できます。
shapeとscaleをパラメータとするガンマ分布の密度、分布関数、分位関数、ランダム生成。
パラメータprobを持つ幾何分布の密度、分布関数、分位関数、ランダム生成
超幾何分布の密度，分布関数，分位関数，ランダム生成
遅延差分関数diffの逆関数を計算します。
この関数は，データ行列の行間の距離を計算するために指定された距離尺度を使用して計算された距離行列を計算し，返します．
対数正規分布の密度，分布関数，分位点関数，ランダム生成（その対数の平均は meanlog に等しく，標準偏差は sdlog に等しい）．
パラメータの位置とスケールを持つロジスティック分布の密度、分布関数、分位関数、ランダム生成
多項分布乱数ベクトルを生成し、多項確率を計算する。
負の二項分布の密度，分布関数，分位関数，ランダム生成（パラメータはサイズと確率）．
平均をmean、標準偏差をsdとする正規分布の密度、分布関数、分位関数、乱数生成
パラメータλを持つポアソン分布の密度、分布関数、分位関数、ランダム生成
add.scopeおよびdrop.scopeは、項の階層構造を尊重しながら、モデルに対して個別に追加または削除できる項を計算します。
delete.responseは、同じモデルの項オブジェクトを返しますが、応答変数はありません。
スコープ引数でモデルに追加またはモデルから削除できるすべての単項を計算し、それらのモデルを適合させ、適合度の変化を計算します。
サイズnの標本から得られるWilcoxon Signed Rank統計量の分布の密度、分布関数、分位関数、ランダム生成。
自由度df（およびオプションの非心パラメータncp）を持つt分布の密度、分布関数、分位関数、ランダム生成。
コード化された変数ではなく、係数の元の水準で係数を抽出します。
これは、コード化された変数ではなく、係数の元の水準から係数を抽出します。
dunifは密度、punifは分布関数、qunifは分位関数、runifはランダム偏差を生成します。
パラメータshapeとscaleを持つワイブル分布の密度、分布関数、分位関数、ランダム生成。
ウィルコクソン順位和統計量の分布の密度、分布関数、分位関数、ランダム生成。
経験的累積分布関数を計算し，そのような "ecdf "オブジェクトをプロット，印刷，計算するためのいくつかの方法を提供します．
複数の層を持つ分散分析モデルにおける固定効果項の効率を計算します。
適合したモデル（通常は線形モデル）から（直交）効果を返す。これは汎用的な関数ですが、現在のところクラス "lm "と "glm "を継承したオブジェクトに対するメソッドしか持っていません。
時系列xを低次元のユークリッド空間に埋め込む。
最初と最後の観測が行われた時刻を抽出し、符号化する。Sバージョン2との互換性のためにのみ提供。
残差平方和と積の行列，または多変量線形モデルの推定分散行列を計算する関数．
新しい変数を、指定されたモデルの式の一部であったかのように評価します。  これは、同じna.actionとsubset引数が適用されることを保証し、例えば、予測変数としてsin(x)を使用するモデルに対してxtを回復することを可能にします。
適合したパラメトリック・モデルの（一般化された）赤池情報量規準を計算します。
共分散行列の順序行列に対して最尤因子分析を実行します。
add.scopeおよび drop.scopeは、項の階層性を尊重しながら、モデルに対して個別に追加または削除できる項を計算します。
ファミリーオブジェクトは、glmなどの関数が使用するモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合の詳細については、glmのドキュメントを参照してください。
配列の離散フーリエ変換(DFT)を高速アルゴリズム "高速フーリエ変換"(FFT)で計算する。
一変量時系列または多変量時系列の各系列に線形フィルタリングを適用する
Fisherの正確検定：固定マージンを持つ分割表の行と列の独立性の帰無を検定するフィッシャーの正確検定を実行する。
fittedは、モデリング関数が返すオブジェクトからフィット値を抽出する汎用関数です。
fitted は、モデリング関数が返す対象からフィット値を抽出する汎用関数です。
Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum)：入力データに対するTukeyの5つの数値要約（最小値、下ヒン ジ値、中央値、上ヒンジ値、最大値）を返す。
Fligner-Killeen（中央値）検定：各グループ（サンプル）の分散が同じであるというヌル検定。
ジェネリック関数 formula とその特定のメソッドは、他のオブジェクトに含まれている式を抽出する機能を提供します。
time は、時系列がサンプリングされた時刻のベクトルを作成します。
Friedman rank sum test (フリードマン順位和検定): 複製されていないブロックデータでフリードマン順位和検定を実行します。
フラットな」分割表を作成します。
Family オブジェクトは、glm などの関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、glmのドキュメントを参照してください。
ファミリーオブジェクトは、glmのような関数で使われるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合の詳細については、glmのドキュメントを参照してください。
model.frame（汎用関数）とそのメソッドは、formulaを使用するために必要な変数と任意の...引数を持つadata.frameを返します。
updateはモデルを更新し、（デフォルトでは）再フィットします。  これは、オブジェクトに格納されている呼び出しを抽出し、呼び出しを更新し、（デフォルトでは）その呼び出しを評価することによって行われます。  データフレームが修正された場合など、1つの引数のみでupdateを呼び出すと便利なことがあります。
この関数は、非線形回帰モデルの初期パラメータ推定値を評価します。  そうでない場合は、そのオブジェクトが、initial属性を評価できるaselfStartオブジェクトへの呼び出しを含んでいるかどうかを調べます。
glmは、線形予測変数の記号的記述と誤差分布の記述によって指定される一般化線形モデルの適合に使用されます。
通常、glm.fitによって内部的にのみ使用されますが、どちらかの関数の制御引数を構成するために使用されるかもしれません。
glmは、線形予測変数の記号的記述と誤差分布の記述によって指定される一般化線形モデルをフィットするために使用されます。
tspは、tsp属性（またはNULL）を返します。tsp<は、tsp属性を設定します。hasTspは、必要に応じて追加することで、xがatsp属性を持つことを保証します。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
非類似度の集合に関する階層クラスター分析とその分析手法。
ヒートマップは，左側と上側にデンドログラムを追加した擬似カラー画像（基本的にはimage(t(x))）である．  通常，デンドログラムが課す制約の範囲内で，ある値（行または列の平均）の集合に従って行と列の並べ替えが行われる．
未知のパラメータは、予測誤差の2乗を最小化することによって決定されます。
この関数は、回帰フィットの品質をチェックするためのさまざまな診断に使用される基本量を提供する。
この一連の関数は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するのに使うことができる。
有限または無限区間上の1変数の関数の適応求積法
因子の2元配置の組み合わせに対する応答の平均（または他の要約）をプロットし、可能な交互作用を説明する。
ファミリーオブジェクトは、glmのような関数が使用するモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、glmのドキュメントを参照してください。
はx値の四分位範囲を計算します。
Rの数式表記法では、切片がなく予測変数がないモデルを使うことができます。is.empty.model()は、オブジェクトがemptyymodelを記述しているかどうかをチェックします。
クラス "dendrogram "は、木のような構造を扱うための一般的な関数を提供します。  これは、階層的クラスタリングや分類/回帰ツリーにおける同様の関数の置き換えを意図したものであり、これらのすべてがツリーのプロットや切断に同じエンジンを使用できるようになっています。
ts関数は、時系列オブジェクトを作成するために使用されます。
ベクトル(x[1], ..., x[n])と(y[0], y[1], ..., y[n])(さらに1つの値!)が与えられると、stepfun(x, y, ...)は補間'ステップ'関数、例えばfnを返す、fn(t) = c[i] (定数) for t in ( x[i], x[i+1]) and at the abscissa values, if (by default)right = FALSE, fn(x[i]) = y[i] and forright = TRUE, fn(x[i]) = y[i-1], fori=1, ..., n.
ts関数は、時系列オブジェクトを作成するために使用されます。
tskernel "クラスは、離散非対称正規化平滑化カーネルを表現するために設計されている。  これらのカーネルは、ベクトル、行列、または時系列オブジェクトを平滑化するために使用できます。
区分的に定数である等張（単調増加ノンパラメトリック）最小2乗回帰を計算する．
カルマンフィルタリングを使用して，（ガウス）対数尤度を求めたり，予測や平滑化を行ったりします．
(ガウス)対数尤度を求めるために、または予測や平滑化のためにカルマンフィルタリングを使用します。
カルマンフィルタリングを使って、(ガウス)対数尤度を求める、または、予測や平滑化を行う。
カルマンフィルタリングを使って、(ガウス)対数尤度を求めたり、予測や平滑化を行う。
kernapply は、入力シーケンスと特定のカーネルとの間の畳み込みを計算します。
tskernel "クラスは、離散非対称な正規化平滑化カーネルを表現するように設計されています。  これらのカーネルは，ベクトル，行列，または時系列オブジェクトを平滑化するために使用できる．
データ行列に対して k-means クラスタリングを実行する．
ベクトル(x[1], ..., x[n])と(y[0], y[1], ..., y[n])(さらに1つの値!)が与えられた場合、 stepfun(x, y, ...)は補間「ステップ」関数、例えば fn を返します、fn(t) = c[i] (定数) for t in ( x[i], x[i+1]) and at the abscissa values, if (by default)right = FALSE, fn(x[i]) = y[i] and forright = TRUE, fn(x[i]) = y[i-1], fori=1, ..., n.
クラスカル・ワリス順位和検定を行う。
1標本または2標本のコルモゴロフ・スミルノフ検定を実行する。
Nadaraya-Watsonカーネル回帰推定を実行する。
時系列のラグ付きバージョンを計算し、時間ベースバックを指定されたオブザベーション数だけシフトします。
時系列をそれ自身のラグ付きバージョンに対してプロットする。自己相関がなくなっても、「自己依存性」を可視化するのに役立つ。
探索的データ分析で推奨されているように、ロバストに直線をフィットする。
lmは線形モデルの適合に使用されます。回帰分析、単一層分散分析、共分散分析を実行するために使用できます（aovはこれらのより便利なインターフェイスを提供するかもしれませんが）。
これらは、線形モデルの適合に使用されるlmによって呼び出される基本的な計算エンジンです。  これらは通常、経験豊富なユーザでない限り、直接使用すべきではありません。  .lm.fit()は、最も内側のQRベースのCコードへの骨組みとなるラッパーです。
この関数は、回帰フィットの品質をチェックするためのさまざまな診断に使われる基本量を提供する。
これらは線形モデルの適合に使われるlmによって呼び出される基本的な計算エンジンである。  これらは、経験豊富なユーザーでない限り、通常は直接使用すべきではありません。  .lm.fit()は、最も内側のQRベースのCコードへの素のラッパーであり、その上にglm.fitとlsfitがある。
因子分析(または主成分分析)における負荷量の抽出または印刷。
1つまたは複数の数値予測変数によって決定される多項式曲面を，局所フィットを使ってフィットする
レスフィットの制御パラメータの設定
散布図に、loessによって計算された滑らかな曲線をプロットし、追加します。
この関数は汎用的であり、メソッド関数は特定のクラスのオブジェクトを扱うために記述することができます。  この関数のメソッドを持つクラスは以下の通り：「glm"、"lm"、"nls"、"Arima"。  パッケージMASSの "fitdistr"、"negbin"、"polr"、パッケージnnetの "multinom"、 packagenlmeの "gls"、"gnls"、"lme "など。
loglin は、反復比例フィッティングによって多次元分割表に対数線形モデルをフィットするために使用される。
この関数は、局所重み付け多項式回帰を使用するLOWESSスムーザーの計算を行う（参考文献を参照）。
回帰係数の標準誤差、t値、p値を含む基本統計量を計算します。
回帰係数の標準誤差、t値、p値を含む基本統計量を計算し、print.itがTRUEであればそれらを表示します。
モデルにおける b の最小2乗推定値
絶対偏差の中央値、すなわち中央値からの絶対偏差の(lo-/hi)中央値を計算し、(デフォルトでは)漸近正規整合性のために係数で調整する。
これは(ベクトルxに対して)次のように定義されます。
この関数は、ファミリー関数 inglm() と共に使用されます。リンクの名前を指定すると、リンク関数、逆リンク関数、微分 dmu/deta および領域チェックのための関数を返します。
(ガウス)対数尤度を求めたり、予測や平滑化のためにカルマンフィルタリングを使用します。
model.frame.defaultが、(一変量)polyやnsのような項を持つモデルから予測するときに、正しい行列を作成するのを助けるユーティリティ。
多変量分散分析のためのクラス。
3元交互作用がないと仮定して、2つの名義変数が各層で条件付き独立であるという帰無値のコクラン・マンテル・ヘーンツェル・カイ2乗検定を実行します。
Wishart分布の共分散行列（またはその変換行列）が、与えられた行列に比例するかどうかを検定します。
McNemarのカイ2乗検定を実行し、2次元分割表における行と列の対称性を検定します。
標本の中央値を計算する
標本の中央値を計算します
Tukeyのメディアン法による加法モデル（2元分解）の適合
model.frame関数は，model.frameのオプション引数として渡されたモデルフレームの応答，オフセット，サブセット，重み，その他の特別な成分を返します．
model.frame（汎用関数）とそのメソッドは、式を使用するために必要な変数と、任意の...引数を持つadata.frameを返します。
model.frame（汎用関数）とそのメソッドは、adata.frameに、formulaを使用するために必要な変数と、任意の...引数を返します。
model.matrixは、デザイン（またはモデル）行列を作成します。例えば、因子をダミー変数の集合に展開し（コントラストに依存）、交互作用も同様に展開します。
model.matrixは，デザイン（またはモデル）行列を作成します．例えば，因子をダミー変数の集合に展開し（コントラストに依存），交互作用を同様に展開します．
model.matrix は，デザイン（またはモデル）行列を作成します．例えば，因子をダミー変数の集合に展開し（contrast に依存），交互作用を同様に展開します．
response,offset,subset,weightsまたはmodel.frameのオプション引数として渡されたモデルフレームのその他の特別なコンポーネントを返します。
tomodel.frameのオプション引数として渡されたモデルフレームのresponse、offset、subset、weights、その他の特別な成分を返します。
モデルフィット、特に複雑なaovfitsの要約表を計算します。
tomodel.frameのオプション引数として渡されたモデルフレームの応答、オフセット、サブセット、重み、その他の特別な成分を返します。
これらの関数は、時系列の季節（またはその他の）部分系列をプロットします。
スケールパラメータの差に関するMoodの2標本検定を実行します。
配列の離散フーリエ変換(DFT)を高速アルゴリズムである「高速フーリエ変換」(FFT)で計算する。
オブジェクトの作成に使用されたNAアクションに関する情報を抽出します。
時系列オブジェクトの中で、欠落していない値の最も長い連続したストレッチを見つける。  (同値の場合は、最初のストレッチ)。
na.omitは不完全なケースを取り除いたオブジェクトを返す。na.passはオブジェクトを変更せずに返す。
na.omitは不完全なケースを取り除いたオブジェクトを返します。na.passはオブジェクトを変更せずに返します。
na.omitは不完全なケースを取り除いたオブジェクトを返します。na.passはオブジェクトを変更せずに返します。
na.omitは不完全なケースを取り除いたオブジェクトを返します。na.passはオブジェクトを変更せずに返します。
欠損値情報を使用して残差と予測値を調整する。
na.actionの効果を報告するために欠損値情報を使用する。
欠損値情報を使用して、残差と予測値を調整します。
nextn は、factors に含まれる値の累乗の積として得られる n 以上の最小の整数を返します。
この関数は、ニュートン型アルゴリズムと融合して関数の最小化を行います。  詳細は参考文献を参照のこと。
PORT ルーチンを使用した非制約およびボックス制約付き最適化。
非線形モデルのパラメータの非線形（重み付き）最小二乗推定値を求める。
nlsnonlinear 最小二乗法アルゴリズムの特性を設定することができます。
b0+b1*(1-exp(-exp(lrc) * x))の形の漸近回帰モデルをxyデータに当てはめます。これは、より複雑なモデルの開始推定値を決定する際のビルディングブロックとして使用することができます。
逆線形補間を使用して、xy で表される関数が yval と等しくなる x 値を近似します。
xyオブジェクトからy対xのグラフの左側（つまりxの小さな値）の水平漸近線の初期推定を行います。  主に自己開始型非線形回帰モデルの初期関数内で使用される。
xyオブジェクトからのy対xのグラフの右側（すなわち、xの大きな値）の水平漸近線の初期推測を提供する。  主に自己開始型非線形回帰モデルの初期関数内で使用される。
モデルフィットから「オブザベーション」の数を抽出します。  これは主にBIC（AICを参照）を計算するために使用されます。
numericDeriv 式の勾配を数値的に評価します。
オフセットは、一般化線形モデルのような線形予測変数に追加される項であり、推定係数ではなく既知の係数1を持つ。
正規分布からの2つ以上の標本が同じ平均を持つかどうかを検定する．  分散は必ずしも等しいとは仮定されない。
Nelder-Mead、準ニュートン、共役勾配アルゴリズムに基づく汎用最適化。ボックス制約付き最適化とシミュレーテッドアニーリングのオプションもあります。
Nelder-Mead、準ニュートン、共役勾配アルゴリズムに基づく汎用最適化。ボックス制約付き最適化およびシミュレーテッドアニーリングのオプションが含まれます。
関数optimizeは、最初の引数に対する関数fの最小値または最大値について、下限から上限までの区間を探索する。
関数optimizeは、その最初の引数に関して、関数fの最小値または最大値の区間をlowerからupperまで探索する。
これらの関数は、付加プログラムの葉の順序（インデックス）または "label "属性を返す。  これらのインデックスは、追加データの適切なコンポーネントにアクセスするために使用することができます。
p-値の集合が指定されると、いくつかの手法のいずれかを使用して調整されたp-値を返します。
p値の集合を指定すると、いくつかの手法のいずれかを用いて調整したp値を返します。
関数acfは、自己共分散または自己相関関数の推定値を計算（デフォルトではプロット）します。  関数pacfは偏自己相関に使用される関数である。  関数ccfは、2つの2変量系列の相互相関または相互共分散を計算する。
2つのベクトルを "Pair "クラスのオブジェクトに結合する。
多重検定の補正を伴う割合の組間の一対比較を計算する。
多重検定の補正を伴うグループ・レベル間の一対比較を計算する
多重検定の補正を伴う一対比較のp値の表を作成します。
多重検定の補正を伴う群間の一対比較の計算
密度、分布関数、分位関数、ベータ分布のランダム生成。パラメータはshape1とshape2（およびオプションの非心パラメータncp）。
二項分布（パラメータ size および prob）の密度，分布関数，分位関数，ランダム生成
pbirthdayは一致の確率を計算し，qbirthdayは少なくとも指定された一致の確率を持つために必要な観測の最小数を計算します．
密度、分布関数、分位関数、および、位置パラメータlocationとスケールパラメータscaleを持つCauchy分布のランダム生成。
自由度fとオプションの非心パラメータerncpを持つカイ2乗(chi^2)分布の密度、分布関数、分位関数、ランダム生成。
率rate(すなわち，平均1/rate)を持つ指数分布の密度，分布関数，分位関数，ランダム生成
自由度 df1 および df2 の F 分布（およびオプションの非心パラメータ ncp）の密度，分布関数，分位点関数，およびランダム生成．
ガンマ分布（パラメータshapeおよびscale）の密度，分布関数，分位関数，ランダム生成
パラメータprobを持つ幾何分布の密度，分布関数，分位関数，ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成。
ここに列挙されている関数や変数は、（もう）必要ないためRの一部ではなくなりました。
対数正規分布の密度、分布関数、分位関数、およびランダム生成。
パラメータの位置とスケールを持つロジスティック分布の密度、分布関数、分位関数、ランダム生成
経験的累積分布関数の計算。このような "ecdf "オブジェクトを使ったプロット、印刷、計算のためのいくつかのメソッド。
spec "クラスのオブジェクトに対するプロットメソッド。  多波長時系列に対して、系列のマージナルスペクトル、またはクロススペクトルのコヒーレンシーと位相のペアプロットをプロットする。
spec "クラスのオブジェクトのプロット法。  マルチバリアット時系列に対して、系列のマージナルスペクトル、またはクロススペクトルのコヒーレンシーと位相のペアプロットをプロットする。
ステップファンオブジェクトの汎用プロットメソッドおよび区分定数関数のプロット用ユーティリティ。
クラス "ts "を継承するオブジェクトのプロットメソッド
負の二項分布の密度、分布関数、分位関数、ランダム生成（パラメータsize、prob付き
平均を mean、標準偏差を sd とする正規分布の密度、分布関数、分位関数、ランダム生成
ファミリーオブジェクトは、glmのような関数が使用するモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、 glmのドキュメントを参照してください。
ポアソン分布の率パラメータに関する単純な帰無仮説の検定、または2つの率パラメータ間の比の検定を行います。
直交多項式: 指定された点xの集合に対する次数1から次数の直交多項式を返すか評価します: これらは次数0の定数多項式にすべて直交します。
指定された点xの集合に対して次数1から次数の直交多項式を返すか評価します: これらは次数0の定数多項式に対して直交します。
リンク関数η = μ ^ λに基づいてリンクオブジェクトを作成します。
検定の検出力を計算するか、目標の検出力を得るためのパラメータを決定します。
割合の2標本検定の検出力を計算するか、または目標とする検出力を得るためにパラメータを決定します。
1標本または2標本のt 検定の検出力を計算するか、または目標とする検出力を得るためのパラメータを決定する。
xが単位根を持つという帰無仮説に対するPhillips-Perron 検定を定常対立仮説に対して計算します。
(1:m-a)/(m+(1-a)-a)の確率点の列を生成します。ここでmは、length(n)==1の場合はn、length(n)の場合はlength(n)です。
パラメータλを持つポアソン分布の密度、分布関数、分位関数、ランダム生成。
射影追跡回帰モデルをフィットします。
prcompは，与えられたデータ行列に対して主成分分析を行い，その結果をprcompクラスのオブジェクトとして返します．
predict は、さまざまなモデル適合関数の結果から予測を行う汎用関数です。  この関数は、第1引数のクラスに依存する特定のメソッドを呼び出します。
フィットされた一般化線形モデルオブジェクトから予測値を取得し、オプションでそれらの予測値の標準誤差を推定します。
線形モデル・オブジェクトに基づく予測値。
与えられたモデル・オブジェクトに関連するプロットに使用されるオブジェクトを計算します。
princomp は、与えられた数値データ行列に対して主成分分析を実行し、その結果を classprincomp オブジェクトとして返します。
summary.lm、summary.glm、anovaのような高レベルのprintメソッドで使用されるユーティリティ関数。  目標は、多くの場合xだけを指定すればよいようなスマートなデフォルトを持つ柔軟なインターフェースを提供することである。
fittedで表される解の近傍での目的関数の振る舞いを調べる。
projは、線形モデルの項へのデータの射影を与える行列または行列のリストを返します。  aovモデルに最も頻繁に使用される。
これらの関数は、因子分析におけるローディング行列を「回転」させます。
prop.testは、複数のグループにおける割合（成功確率）が同じである、あるいはある与えられた値と等しいという帰無値を検定するために使用できます。
割合の傾向に関するカイ2乗検定、すなわち対数オッズがスコアに比例して変化する局所的な選択肢に対して漸近的に最適な検定を実行します。  デフォルトでは、スコアがグループ番号として選択されます。
サイズnの標本から得られるWilcoxon Signed Rank統計量の分布の密度、分布関数、分位関数、ランダム生成。
自由度df（およびオプションの非心パラメータncp）を持つt分布の密度、分布関数、分位関数、ランダム生成
Rは標準正規標本の範囲、df*s^2は自由度dfのカイ2乗として独立に分布する。
dunifは密度を、punifは分布関数を、qunifは分位関数を、runifは乱数偏差を生成する。
パラメータshapeとscaleを持つワイブル分布の密度、分布関数、分位関数、ランダム生成。
ウィルコクソン順位和統計量の分布の密度、分布関数、分位関数、ランダム生成。
ベータ分布の密度、分布関数、分位関数、およびランダム生成。パラメータはshape1とshape2（およびオプションの非心パラメータncp）。
二項分布の密度，分布関数，分位関数，およびランダム生成．
pbirthdayは一致の確率を計算し，qbirthdayは少なくとも指定された一致の確率を持つために必要な観測の最小数を計算します．
密度、分布関数、分位関数、および、位置パラメータlocationとスケールパラメータscaleを持つCauchy分布のランダム生成。
自由度fとオプションの非心パラメータerncpを持つカイ2乗(chi^2)分布の密度、分布関数、分位関数、ランダム生成
率rate(すなわち，平均1/rate)を持つ指数分布の密度，分布関数，分位関数，ランダム生成
自由度 df1 および df2 の F 分布（およびオプションの非心パラメータ ncp）の密度，分布関数，分位点関数，およびランダム生成．
ガンマ分布（パラメータshapeおよびscale）の密度，分布関数，分位関数，ランダム生成
パラメータprobを持つ幾何分布の密度，分布関数，分位関数，ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成
対数が平均logに等しく標準偏差がsdlogに等しい対数正規分布の密度、分布関数、分位関数、ランダム生成
ロジスティック分布の密度、分布関数、分位点関数、ランダム生成（パラメータの位置とスケールが指定可能
負の二項分布の密度、分布関数、分位関数、ランダム生成（パラメータはサイズと確率
平均をmean、標準偏差をsdとする正規分布の密度・分布関数・分位点関数・ランダム生成
パラメータλを持つポアソン分布の密度、分布関数、分位関数、ランダム生成。
qqnorm は汎用の関数で、デフォルトでは y の値の正規 QQ プロットを生成します。qqline は、「理論的な」、デフォルトでは正規分布、分位数-分位数プロットに線を追加します。
qqnorm はジェネリック関数で、デフォルトでは y の値の正規 QQ プロットを作成します。 qqline は、"理論的な"、デフォルトでは正規の、分位数-分位数プロットに線を追加します。
qqnorm はジェネリック関数で、デフォルトのメソッドは y の値の正規 QQ プロットを生成します。qqline は、"理論的な"、デフォルトでは正規分布、デフォルトでは第1四分位数と第3四分位数を通る分位数-分位数プロットに線を追加します。
サイズnの標本から得られるWilcoxon Signed Rank統計量の分布の密度，分布関数，分位関数，ランダム生成
自由度df（およびオプションの非心パラメータncp）を持つt分布の密度、分布関数、分位関数、ランダム生成
Rは標準正規標本の範囲、df*s^2は自由度dfのカイ2乗として独立に分布する。
再現性のないブロックデータでQuade検定を行う。
最小のオブザベーションは0、最大のオブザベーションは1の確率に対応します。
ファミリーオブジェクトは、glmなどの関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、glmのドキュメントを参照してください。
ファミリーオブジェクトは、glmのような関数で使われるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、 glmのドキュメントを参照してください。
ファミリーオブジェクトは、glmのような関数で使われるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合の詳細については、glmのドキュメントを参照してください。
dunifは密度を、punifは分布関数を、qunifは分位関数を、runifはランダム偏 差を生成します。
パラメータshapeとscaleを持つワイブル分布の密度、分布関数、分位関数、ランダム生成。
サイズmとnの標本から得られるウィルコクソン順位和統計量の分布の密度，分布関数，分位関数，ランダム生成
Patefieldのアルゴリズムを使って、与えられたマージンを持つランダムな2元表を生成する。
ベータ分布の密度，分布関数，分位関数，およびランダム生成（パラメータshape1およびshape2（およびオプションの非心パラメータncp））．
二項分布の密度，分布関数，分位関数，ランダム生成.
Cauchy 分布の密度，分布関数，分位関数，およびランダム生成．
カイ2乗（chi^2）分布の密度、分布関数、分位関数、ランダム生成（自由度f、オプションで非心パラメータerncpを含む）。
ftablesと呼ばれる'平坦な'（分割）表の読み込み、書き込み、強制。
デンドログラムの枝の周囲に矩形を描き、対応するクラスタを強調する。まずデンドログラムをあるレベルで切断し、次に選択された枝の周囲に矩形を描画します。
delete.responseは、同じモデルの項オブジェクトを返しますが、応答変数はありません。
因子の水準は、refで指定された水準が最初になり、他の水準が下に移動するように並べ替えられます。これは、最初のレベルを参照とするcontr.treatment対照に便利です。
reorder は汎用関数です。  default "メソッドは、最初の引数をカテゴリ変数として扱い、2 番目の変数（通常は数値）の値に基づいてレベルを並べ替えます。
式の各項の複製数をベクトルまたはリストで返します。
この関数は、データフレームを'wide'フォーマット（同じ行の別々の列に繰り返し測定がある）と'long'フォーマット（別々の行に繰り返し測定がある）の間で整形します。
residualsは、モデリング関数が返すオブジェクトからモデル残差を抽出する汎用関数です。
residualsは、モデリング関数が返すオブジェクトからモデル残差を抽出する汎用関数です。
これらの関数はすべてglmクラスまたはsummary.glmオブジェクトのメソッドです。
これらの関数はすべてクラス "lm "オブジェクトのメソッドです。
密度、分布関数、分位関数、および率rate（すなわち平均1/rate）を持つ指数分布のランダム生成。
df1 と df2 の自由度（およびオプションの非心パラメータ ncp）を持つ F 分布の密度、分布関数、分位関数、ランダム生成。
ガンマ分布（パラメータshapeおよびscale）の密度，分布関数，分位関数，ランダム生成
パラメータprobを持つ幾何分布の密度，分布関数，分位関数，ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成
対数が平均logに等しく標準偏差がsdlogに等しい対数正規分布の密度、分布関数、分位関数、ランダム生成
パラメータの位置とスケールを持つロジスティック分布の密度、分布関数、分位関数、ランダム生成
多項分布乱数ベクトルを生成し、多項確率を計算する。
負の二項分布の密度，分布関数，分位関数，ランダム生成（パラメータはサイズと確率）．
平均をmean、標準偏差をsdとする正規分布の密度、分布関数、分位関数、乱数生成
パラメータλを持つポアソン分布の密度、分布関数、分位関数、ランダム生成
サイズnの標本から得られるWilcoxon Signed Rank統計量の分布の密度、分布関数、分位関数およびランダム生成。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルに対する回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
自由度df（およびオプションの非心パラメータncp）を持つt分布の密度、分布関数、分位関数、ランダム生成。
dunifは密度、punifは分布関数、qunifは分位関数、runifはランダム偏差を生成します。
奇数スパンの実行中央値を計算する。  これは、可能な限り「最も頑健な」散布図の平滑化である。  効率性（と歴史的な理由）のために、同じ結果を与える2つの異なるアルゴリズムのいずれかを使用することができます。
密度、分布関数、分位関数、およびパラメータshapeとscaleを持つワイブル分布のランダム生成。
それぞれサイズmとnの標本から得られるウィルコクソン順位和統計量の分布の密度、分布関数、分位関数、ランダム生成。
SigmaとdfをパラメータとするWishart分布に従って分布するn個のランダム行列W_p(Sigma, df)を生成します。
loess によって計算された平滑曲線を散布図にプロットし、追加します。
screeplot.default 主成分の数に対する分散をプロットします。これは、"princomp" および "prcomp" クラスのプロット手法でもあります。
この関数は、x の値の標準偏差を計算します。na.rm が TRUE の場合、計算を進める前に欠損値が除去されます。
aov オブジェクト内の1つまたは複数の対比の標準誤差を返します。
lsなどで使用される自己開始非線形モデルを構築します。  データから近似的なパラメータ値を計算する初期関数を経由して、そのようなモデルは「自己開始」、すなわち、例えば、nls()で開始引数を必要としません。
これは、オブジェクトに名前を設定し、そのオブジェクトを返す便利な関数です。  この関数は、返すオブジェクトを作成する関数の定義の最後に使用すると便利です。
シャピロ・ウィルク正規性検定を実行します。
誤差の推定標準偏差、"残差標準偏差"（"残差標準誤差 "という誤った名前もある、例えばinsummary.lm()の出力、適合モデルから）を抽出します。
適合したモデルオブジェクトに対応する分布から、1つまたは複数の応答をシミュレートします。
Tukey's smoothers, 3RS3R, 3RSS, 3Rなど。
与えられたデータに3次平滑化スプラインをフィットします。
ベクトルyの端点を平滑化します。(奇数スパン）、
これは sortedXyDataobjects クラスのコンストラクタ関数です。  これらのオブジェクトは、ほとんどの場合、 selfStartクラスの自己開始非線形回帰モデルの初期関数で使用されます。
spec.pgramは、ARモデルをxにフィットし（または既存のフィットを使用し）、フィットされたモデルのスペクトル密度を計算（デフォルトではプロット）します。
spec.pgramは、高速フーリエ変換を使用してピリオドグラムを計算し、オプションで、一連の修正Daniellスムーサー（終了値に半分の重みを与える移動平均）を使用して結果を平滑化します。
時系列にコサイン・ベル・テーパーを適用する。
スペクトル関数は、時系列のスペクトル密度を推定します。
与えられたデータ点に対して3次（またはエルミート）スプライン補間を実行し、補間によって得られた点のリストまたは補間を実行する関数を返す。
与えられたデータ点に対して三次（またはエルミート）スプライン補間を行い、補間により得られた点のリストか補間を行う関数を返します。
与えられたデータ点に対して三次（またはエルミート）スプライン補間を行い， 補間によって得られた点のリストか，補間を行う関数を返します．
この selfStart モデルは、漸近回帰関数とその勾配を評価します。  これは、与えられたデータ集合に対するパラメータ Asym, R0, lrc の初期推定値を評価する initial 属性を持ちます。
このselfStartモデルは、漸近回帰関数の代替パラメータ化と、それらのパラメータに関する勾配を評価します。これは、パラメータAsym、lrc、c0の初期推定値を作成するinitial属性を持ちます。
このselfStartモデルは、原点とその勾配を通して漸近回帰関数を評価します。  これは、与えられたデータ集合についてパラメータ Asym と lrc の初期推定値を評価するinitial 属性を持ちます。
この selfStart モデルは、二指数モデル関数とその勾配を評価します。  パラメータA1、lrc1、A2、lrc2の初期推定値を作成するinitial属性があります。
残差平方和と積の行列、または多変量線形モデルの推定分散行列を計算する関数。
この selfStart モデルは、一次コンパートメント関数とその勾配を評価します。  パラメータlKe、lKa、lClの初期推定値を作成するinitial属性があります。
このselfStartモデルは、4パラメータのロジスティック関数とその勾配を評価します。  このモデルには、与えられたデータ集合のパラメータA、B、xmid、scalの初期推定値を計算する初期属性があります。
この自己開始モデルは、ゴンペルツ成長モデルとその勾配を評価します。  これは、パラメータAsym,b2,b3の初期推定値を作成するinitial属性を持っています。
この自己開始モデルは、ロジスティック関数とその勾配を評価します。  これは、パラメータAsym,xmid,scalの初期推定値を作成するinitial属性を持っています。   R 3.4.2およびそれ以前では、min(input)がちょうどゼロの場合、このinit関数は失敗しました。
このselfStartモデルはMichaelis-Mentenモデルとその勾配を評価します。  パラメータVmとKの初期推定値を評価するinitial属性を持っています。
このselfStartモデルは、成長曲線データのWeibullモデルとその勾配を評価します。  これは、与えられたデータ集合について、パラメータAsym、Drop、lrc、pwrの初期推定値を評価するinitial属性を持ちます。
最初と最後のオブザベーションが行われた時刻を抽出し、エンコードします。Sバージョン2との互換性のためにのみ提供されています。
これはユーティリティ関数で、anova(..., test != NULL)のlmメソッドとglmメソッドで使用され、一般ユーザは使用しないでください。
AICによる数式ベースのモデルの選択
ベクトル(x[1], ..., x[n])と(y[0], y[1], ..., y[n])(もう1つ値がある!)が与えられたとき、 stepfun(x, y, ...)は、補間'ステップ'関数、fnを返す、fn(t) = c[i] (定数) for t in ( x[i], x[i+1]) and at the abscissa values, if (by default)right = FALSE, fn(x[i]) = y[i] and forright = TRUE, fn(x[i]) = y[i-1], fori=1, ..., n.
時系列を季節成分、トレンド成分、不規則成分に分解する。
最尤法を使って時系列の構造モデルをフィットする
分散分析モデルを要約する。
これらの関数は、すべてglmクラスまたはsummary.glmオブジェクトのメソッドです。
クラス "lm "の要約メソッド。
クラス "manova" の要約メソッド。
ベクトル(x[1], ..., x[n])と(y[0], y[1], ..., y[n])(1つ多い!)が与えられたとき、 stepfun(x, y, ...)は、補間'ステップ'関数、例えば fn を返します、fn(t) = c[i](定数) for t in ( x[i], x[i+1])、横軸の値で、(デフォルトで)right = FALSEなら、fn(x[i]) = y[i]、forright = TRUEなら、fn(x[i]) = y[i-1]、fori=1, ..., n。
フリードマンの「スーパースムーサー」によって(x, y)の値を平滑化する。
与えられた数値または論理ベクトルまたは配列を記号化します。相関行列、疎行列、論理行列など、構造化行列の可視化に特に役立ちます。
データのベクトルに対して1標本および2標本のt検定を行う。
回帰項を予測変数に対してプロットし、オプションで標準誤差と部分残差を追加します。
terms関数は、さまざまな種類のRデータ・オブジェクトから項オブジェクトを抽出するために使用できる汎用関数です。
この関数は、数式といくつかのオプション引数を取り、項オブジェクトを構築します。termsオブジェクトは、モデル.matrixを構築するために使用することができます。
timeは、時系列がサンプリングされた時刻のベクトルを作成します。
timeは、時系列がサンプリングされた時刻のベクトルを作成します。
ts関数は、時系列オブジェクトを作成するために使用されます。
ts.unionは、全時系列がカバーする時間にNAを入れ、ts.intersectは、全時系列がカバーする時間に制限をかけます。
複数の時系列を共通のプロット上にプロットします。plot.tsとは異なり、系列は異なる時間ベースを持つことができますが、同じ頻度を持つ必要があります。
ts.unionは、全時系列がカバーする時間にNAを入れ、ts.intersectは、全時系列がカバーする時間に制限をかけます。
時系列診断をプロットする汎用関数。
tspはtsp属性(またはNULL)を返します。tsp<-tsp属性を設定します。hasTspはxがatsp属性を持っていることを確認し、必要であれば追加します。
tspはtsp属性(またはNULL)を返します.これはSバージョン2との互換性のために含まれています.tsp<-tsp属性を設定します.hasTspは必要に応じて1つを追加することによって,xがatsp属性を持つことを保証します.
astate-spaceモデルによる一変量時系列の固定区間平滑化を行います。  固定区間平滑化は、観測された系列全体に基づいて、各時点での状態の最良の推定を行います。
指定されたfamily-wis-eprobability of coverageを持つ因子のレベルのthemeans間の差に関する信頼区間の集合を作成する。  区間は，Studentizedrange 統計量，Tukeyの'Honest Significant Difference' 法に基づく．
関数 uniroot は，最初の引数に対する関数 f の根（つまり，ゼロ）を，lower から upper の区間で探索する．
updateは、モデルを更新し、（デフォルトでは）再フィットします。  updateは、オブジェクトに格納されている呼び出しを抽出し、呼び出しを更新し、（デフォルトでは）その呼び出しを評価します。  データフレームが修正された場合など、1つの引数のみでupdateを呼び出すと便利なことがあります。
updateはモデルを更新し、（デフォルトでは）再フィットします。  これは、オブジェクトに格納されている呼び出しを抽出し、呼び出しを更新し、（デフォルトでは）その呼び出しを評価することで行われます。  データフレームが修正された場合など、1つの引数のみでupdateを呼び出すと便利なことがあります。
update.formulaは、モデル式を更新するために使用されます。これは通常、項の追加や削除を伴いますが、更新はより一般的なものになります。
var、cov、corは、xとyがベクトルの場合、xの分散とxとyの共分散または相関を計算します。   xとyが行列の場合は、xの列とyの列の間の共分散（または相関）が計算されます。
正規母集団からの2つの標本の分散を比較するF検定を実行する。
シンプルなユーティリティは、(欠損していない)ケース名と(欠損していない)変数名を返します。
これらの関数は、因子分析におけるローディング行列を「回転」させます。
mainパラメータ分散共分散行列関数は、適合したモデルオブジェクトの主要パラメータの分散共分散行列を返します。  モデルの「主要」パラメータは coef が返すパラメータに対応し、通常、厄介なスケールパラメータ (sigma) を含みません。
重み付き平均の計算
線形モデルのフィットから重み付き残差を計算。
weights は、モデリング関数が返すオブジェクトからフィットの重みを抽出する汎用関数です。
Wilcoxon検定は、データのベクトルに対して1標本および2標本の検定を行います。
windowは、開始時刻と終了時刻の間に観測されたオブジェクトxのサブセットを抽出する汎用関数です。頻度が指定された場合、系列は新しい頻度で再サンプリングされます。
window は、開始時刻と終了時刻の間に観測されたオブジェクト xobserved の部分集合を抽出する汎用関数です。周波数が指定された場合、系列は新しい周波数で再サンプリングされる。
ftablesと呼ばれる'フラットな'（分割）表の読み書きと強制。
通常データフレームに含まれる分類横断因子から、式インターフェースを使用して分割表（オプションでスパース行列）を作成します。
