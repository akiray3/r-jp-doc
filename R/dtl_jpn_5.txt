x
NA
kruskal.testは、xの分布の位置パラメータが各グループ（標本）で同じであることのKruskal-Wallis順位和検定を行う。  xがリストの場合、その要素は比較されるサンプルとみなされるので、数値データ・ベクトルでなければならない。  この場合、gは無視され、単純にkruskal.test(x)を使って検定を行うことができます。  サンプルがまだリストに含まれていない場合は、kruskal.test(list(x, ...))を使用します。それ以外の場合は、xは数値データ・ベクトルでなければならず、gはxの対応する要素のグループを与えるxと同じ長さのベクトルまたは因子オブジェクトでなければなりません。
yが数値の場合、xとyが同じ連続分布から引き出されたという帰無仮説の2標本検定が実行される。あるいは、yは連続（累積）分布関数またはそのような関数を示す文字列であってもよい。  この場合、xを生成した分布関数が...で指定されたパラメータを持つ分布yであるという帰無仮説の1標本検定が行われる。連続分布は同値を生成しないので、同値が存在すると常に警告が発生する。  alternativeの "two.sided"、"less"、"greater "は、それぞれxの真の分布関数が仮説の分布関数（1標本の場合）またはyの分布関数（2標本の場合）と等しい、等しくない、または大きくないという帰無仮説を指定します。  これは累積分布関数の比較であり、検定統計量は値の差の最大値であり、「より大きい」選択肢の統計量はD^+ = max[F_x(u) - F_y(u)]である。したがって、2標本の場合のalternative = "greater" は、t.testやwilcox.testとは対照的に、xがyより確率的に小さい（xのCDFがyのCDFより上にあり、したがってyのCDFより左にある）分布を含みます。  exact = NULL（デフォルト）の場合、1標本の場合は標本サイズが100未満で同値がない場合、2標本の場合は標本サイズの積が10000未満の場合に正確なp値が計算されます。  1標本両側ケースでは，Marsaglia, Tsang & Wang(2003)に記述されているように正確なp値が得られる（ただし，右尾のオプション近似は使用しないので，小さなp値では時間がかかる）．  1標本の片側検定の場合はBirnbaum &Tingey (1951)の公式が使用されます。1標本の検定が使用される場合、...で指定されるパラメータは、データから推定されたものではなく、事前に指定されたものでなければなりません。推定されたパラメータを持つKS検定については、より洗練された分布理論がありますが（Durbin, 1973を参照）、ks.testには実装されていません。
NA
ベクトルまたは行列の引数xにtsp属性hasTspを与える。
プロットが1つだけ生成される場合, これは通常のプロットである.  複数のプロットが生成される場合、par(mfrow)と他のいくつかのグラフィックパラメータが設定されます。
欠損値を持つケースは省略されます。n とn %% 3に依存して対称なサイズで3つの（ほぼ）等しいサイズのグループにデータを分割し、各グループ内の中央値を計算する参考文献とは逆に、line()コードは、x[.ここで、q1, q2 は、確率 p = 1/3 と p = 2/3 の（一種の）分位数で、 j1 = floor(p*(n-1)) と j2 = ceiling(p(n-1))、 n = length(x)の形である。
lmのモデルは記号的に指定されます。  典型的なモデルは，response ~ termsの形式を持ち，ここでresponseは（数値）応答ベクトルであり， termsは応答の線形予測変数を指定する一連の項である．  first + secondの形の項指定は，重複を除去したfirstのすべての項とsecondのすべての項を一緒に示す．  first:secondの形の指定は，firstのすべての項とsecondのすべての項の相互作用をとることによって得られる項の集合を示す．  first*second の指定は、first と second の交差を示す。  これは first + second + first:second と同じである。式にオフセットが含まれている場合、これは評価され、response から差し引かれる。response が行列の場合、線形モデルは行列の各列に対して別々に最小2乗法でフィットされる。  式中の項は、主効果が最初に来て、交互作用、すべての2次、すべての3次、そしてすぐに来るように並べ替えられます。これを避けるには、式としてtermsオブジェクトを渡します（例としてaovとdemo(glm.vr)を参照）。  これを除去するには、 ~ x - 1 または y ~ 0 + x のいずれかを使用します。NULLでない重みは，異なるオブザベーションが異なる分散を持つことを示すために使用できる（重みの値は分散に反比例する）；あるいは，重みの要素が正の整数 w_i であるとき，各回答 y_i が w_i 個の単位重みのオブザベーションの平均であることを示す（y_i に等しい w_i 個のオブザベーションがあり，データが要約されている場合を含む）．ただし，後者の場合，グループ内変動は使用されないことに注意．  したがって，シグマ推定と残差の自由度は，最適ではないかもしれない．したがって、標準誤差と分散表分析は注意して扱う必要があります。lmは、実際の数値計算のために、後述の低レベル関数lm.fitなどを呼び出します。  重み、サブセット、オフセットはすべて、計算式の変数と同じように評価されます。つまり、まずデータで評価され、次に計算式の環境で評価されます。
NA
influence.measures()および "参照 "に列挙されている他の関数は、さまざまな回帰診断を計算する、よりユーザー指向の方法を提供します。  これらはすべてlm.influenceをベースにしています。  GLM(identityリンクを持つGaussianファミリー以外)の場合、これらは1ステップ近似に基づいていることに注意してください。おそらく1であろう計算されたハット値は1として扱われ、対応する行のinsigmaと係数はNaNであることを保証するように試みられています。  (このようなケースを削除すると、通常、変数が削除されるので、単純なドロップ・ワン診断はできない。)naresidは結果に適用されるので、フィットがna.action = na.excludeであった場合、NAで埋められる。
NA
負荷量」は因子分析の用語ですが、社会科学の文献では、因子分析と主成分分析（PCA）がoftenconflatedであるため、SPSSでPCAに使用され、したがってSPSSユーザーを支援するためにS-PLUSでprincompによって使用されました。factanal "クラスのprintメソッドは、負荷量を表示するために "loadings "メソッドを呼び出すので、cutoffやsortなどの引数を渡します。負荷量ベクトルの符号は、因子分析とPCAの両方で任意です。
フィットは局所的に行われる。  つまり、点xでのフィットは、xからの距離で重み付けされたx近傍の点を用いて行われます（距離の計算の際には、「パラメトリック」変数の違いは無視されます）。  近傍領域のサイズはα（span orenp.targetで設定）で制御される。  α < 1の場合、近傍領域には点の割合αが含まれ、これらの点には3次加重（(1 - (dist/maxdist)^3)^3に比例）が行われる。  α > 1の場合，すべての点が使用され，「最大距離」は，p個の説明変数の実際の最大距離のα^(1/p)倍であると仮定される．  family="symmetric "の場合、Tukeyのbiweightを用いたM推定を数回繰り返す。  初期値は最小2乗フィットなので、これはあまり抵抗のないフィットである必要はないことに注意してください。  詳細はloess.controlを参照。
NA
loess.smoothは、xの範囲をカバーする等間隔の点でloess smoothを評価する補助関数です。
logLikは最尤法で適合したモデルに最もよく使われ、AICなどではこれを仮定しています。  glm "適合の場合、ファミリは対数尤度の計算方法を指定する必要がないので、これはAICを計算するためにファミリのaic()関数を使用することに基づきます。  gaussian、Gamma およびinverse.gaussian ファミリーでは、GLMの分散が推定され、AIC値のパラメータとしてカウントされていると仮定し、他のすべてのファミリーでは、分散が既知であると仮定します。  lm "フィットでは、スケールが（最尤法またはREMLによって）推定され、対数尤度のすべての定数が含まれていると仮定される。  この方法は、単一反応フィットにのみ適用できる。
モデルの適合には，Haberman (1972)で提示されている反復比例適合アルゴリズムが使用される．  最大反復が実行され、観測されたマージンとフィットされたマージンとの間の最大偏差がepsより小さくなったときに収束とみなされる。  構造的なゼロがないと仮定すると、尤度比検定とPearson検定統計量はともに自由度dfの漸近カイ2乗分布を持つ。  MASSパッケージにはloglmが含まれています。loglmはloglinのフロントエンドであり、lmやglmのような他の適合関数と同様に、式に基づいた方法で対数線形モデルを指定し、適合させることができます。
lowessは複雑なアルゴリズムで定義されており、Ratforのオリジナル(W. S. Clevelandによる)はRのソースのsrc/library/stats/src/lowess.docにあります。  通常、局所線形多項式フィットが使われますが、状況によっては（ファイルを参照）局所定数フィットが使われることもあります。  ローカル」とは、floor(f*n)番目の最近傍までの距離で定義され、近傍に入るxに対して三次加重が使用されます。  iter > 0の場合、x値の近傍性から得られる重みと、前の反復の残差から得られるケース重みの積を用いて、さらに重み付きフィットが行われる。  具体的には，Tukeyのbi-weightで，カットオフは残差のMADの6倍である．  (現在のRの実装は、MADが実質的にゼロの場合、アルゴリズムが非常に不安定になるため、反復を停止する点でオリジナルと異なる)デルタは、計算を高速化するために使用される: 各データポイントで局所多項式フィットを計算する代わりに、最後に計算されたポイントからデルタ以内のポイントでは計算されず、スキップされたポイントのフィット値を埋めるために線形補間が使用される。
NA
NA
重みが指定された場合、重み付き最小2乗法が実行され、wtのj番目のtryで指定されたj番目のケースに重みが与えられます。もしオブザベーションのフィールドに欠損値がある場合、そのオブザベーションは分析が実行される前に取り除かれます。
実際に計算される値は constant * cMedian(abs(x - center))であり、centerのデフォルト値はmedian(x)であり、cMedianは通常の'low'または'high'中央値である。デフォルトの定数 = 1.4826 (approximately1/ Φ^(-1)(3/4) = 1/qnorm(3/4)) は整合性を保証します、E[mad(X_1,...,X_n)]=σ(X_iがN(μ, σ^2)として分布し、nが大きい場合) na.rmがTRUEの場合、計算が行われる前にxからNA値が取り除かれます。
NA
NA
これらの関数は、状態ベクトルa、遷移a <- T a + R e,e ~ N(0, kappa Q)、観測方程式y = Z'a + eta,eta ~ N(0, kappa h)を持つ一般的な一変量状態空間モデルで動作します。モデルは、遷移行列、観測係数、観測分散RQR'、現在の状態推定値、状態不確定性行列Qの現在の推定値、状態不確定性行列Qの時刻t-1での推定値（KalmanForecastでは更新されない）を少なくとも含むリストとして指定されます。KalmanSmoothはtsSmoothの主力関数である.makeARIMAはARIMAモデルの状態空間モデルを構築する.arimaも参照.状態空間の初期化はGardnerらの方法(SSinit = "Gardner1980")を長年唯一の方法として使用してきた.  しかし、この方法は非定常性に近い場合、時々欠陥に悩まされる。このため、将来的にはデフォルトとして置き換えられ、再現性のためだけに維持されるかもしれない。  Rossignol2011 "メソッドは、2011-09-20にグルノーブル大学のRaphael Rossignolによって提案され、部分的に文書化されています（以下のPR#14682を参照）。これは(X_{t-1},...,X_{t-p},Z_t,...,Z_{t-q})の共分散行列を差分方程式法(Brockwell and Davisの93ページ)で計算するもので、Gardnerらのレフェリーから提案されたものらしい(彼らの論文の314ページ参照)参照）。
これはpoly、bs、nsのメソッドを持つ汎用関数で、デフォルトのメソッドはスケールを扱う。  model.frame.defaultは、モデルフレームを作成する際にこのような項に遭遇すると、与えられた項のpredvars属性を変更し、新しいデータの予測に有効な項に置き換える。  これを利用するには、モデル・フィット関数がモデル・フレームのterms属性を返すようにするか、モデル・フレームのterms属性のpredvars属性をtermsオブジェクトにコピーしてください。
クラス "manova "はクラス "aov "と異なり、異なる要約法を選択します。  関数manovaはaovを呼び出し、各層の結果オブジェクトにクラス "manova "を追加する。
x が配列の場合、各次元は少なくとも2でなければならず、エントリは非負の整数でなければならない。  NAは許されない。  それ以外の場合、x, y, z は同じ長さでなければならない。  NAを含むトリプルは削除される。  すべての変数は少なくとも2つの異なる値を取らなければならない。
Mauchlyの検定は、共分散行列が与えられた行列に比例すると仮定できるかどうかの検定です。これは、クラス "mlm "と "SSD "用のメソッドを持つ汎用関数です。基本的なメソッドは、クラスSSDのオブジェクト用のメソッドで、mlmオブジェクト用のメソッドは、SSD行列を抽出し、同じオプションと引数で対応するメソッドを呼び出します。これは通常、ブロック内差への変換を伴いますが、より複雑なブロック内デザインに対応することができ、より精巧な変換が必要になります。この検定の一般的な使用法は，反復測定デザインで，X = ~1.デフォルトでは、SSD行列の次元として内部的に計算されるpと、stats名前空間にあるいくつかの隠れた関数、すなわち、設計行列またはモデル式から射影行列を計算するprojと、行のランクが完全になるまで行列から線形従属行を削除するThin.rowが含まれていることに注意してください。
ヌルは，セル[i,j]と[j,i]に分類される確率が同じであることである．xが行列の場合，それは2次元分割表とみなされるので，そのエントリは非負整数でなければならない．  不完全なケースは除去され、ベクトルは因子に強制され、分割表はこれらから計算される。連続性補正は、correctがTRUEである場合にのみ2-by-2のケースで使用される。
これはメソッドを書くことができる汎用関数である。  しかし、デフォルトのメソッドでは、パッケージbaseのis.na、sort、meanが使用されており、これらは汎用的なものです。
これはメソッドを書くことができる汎用関数です。  しかし、デフォルトのメソッドでは、パッケージbaseのis.na、sort、meanが使用されており、これらは汎用的なものです。
フィットされるモデルは加法的（定数＋行＋列）です。このアルゴリズムは、行と列の中央値を交互に削除することで動作し、絶対残差の総和の比例減少がεより小さくなるまで、または最大回数を反復するまで続けられます。絶対残差の総和は、trace.iterがTRUEであれば、フィットプロセスの各反復で表示されます。medpolishはmedpolishクラス（下記参照）のオブジェクトを返します。このクラスには印刷とプロットのメソッドがあり、これらはジェネリックスのprintとplotによって呼び出されます。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されています。  model.offsetは、式の中でoffset項によって指定された項、またはモデルフレームを生成する呼び出しの中でoffset引数によって指定された項を合計します。
何が起こるかは、オブジェクトformulaのクラスと属性に依存します。  これが "lm "のようなfitted-modelクラスのオブジェクトである場合、このメソッドは、モデルのフィット時に使用された保存されたモデルフレームを返すか（もしあれば、多くの場合、引数model = TRUEで選択されます）、フィット時に使用された呼び出しをdefaultメソッドに渡します。  defaultメソッド自体は、他の引数が与えられない場合、MASSパッケージの "lqs "クラスのような標準的なモデルオブジェクトに対応することができます。  formulaがtermsオブジェクトでない限り、as.formulaの後にtermsが呼び出されます。  (terms.formulaのkeep.order引数を使用したい場合は、formulaではなくtermsオブジェクトを渡します。)モデルフレームの行名は、引数dataがある場合はそこから取得され、formulaがある場合は、formulaの応答名(行列の場合はrownames)から取得されます。formula、subset、...のすべての変数は、まずdataで検索され、次にformulaの環境で検索され(詳細はformula()のヘルプを参照)、データフレームに収集されます。  次に、サブセット式が評価され、データ・フレームの行インデックスとして使用されます。  その後、na.action 関数がデータフレームに適用されます（属性が追加されることもあります）。  na.action=NULLでない限り、時系列属性は検出された変数から取り除かれます（NAが取り除かれると間違ってしまうため）。get_all_varsは、式で使用された変数と...で指定された変数を含むdata.frameを返します。get_all_varsは、model.frame.defaultとは異なり、入力変数を返し、式の関数呼び出しの結果は返しません。
何が起こるかは、formula オブジェクトのクラスと属性に依存します。  これが "lm "のようなfitted-modelクラスのオブジェクトである場合、このメソッドは、モデルのフィットの際に使用された保存されたモデルフレームを返すか（もしあれば、多くの場合、引数model = TRUEで選択されます）、フィットの際に使用された呼び出しをdefaultメソッドに渡します。  defaultメソッド自体は、他の引数が与えられない場合、MASSパッケージの "lqs "クラスのような標準的なモデルオブジェクトに対応することができます。  formulaがtermsオブジェクトでない限り、as.formulaの後にtermsが呼び出されます。  (terms.formulaのkeep.order引数を使用したい場合は、formulaではなくtermsオブジェクトを渡します。)モデルフレームの行名は、引数dataがある場合はそこから取得され、formulaがある場合は、formulaの応答名(行列の場合はrownames)から取得されます。formula、subset、...のすべての変数は、まずdataで検索され、次にformulaの環境で検索され(詳細はformula()のヘルプを参照)、データフレームに収集されます。  次に、サブセット式が評価され、データ・フレームの行インデックスとして使用されます。  その後、na.action 関数がデータフレームに適用されます（属性が追加されることもあります）。  na.action=NULLでない限り、時系列属性は検出された変数から取り除かれます（NAが取り除かれると間違ってしまうため）。get_all_varsは、式で使用された変数と...で指定された変数を含むdata.frameを返します。get_all_varsは、model.frame.defaultとは異なり、入力変数を返し、式の関数呼び出しの結果は返しません。
model.matrixは、model.frame(object)を呼び出すか、より正確にはattr(terms(object), "variables")を評価することによって作成されるのと同じ名前の変数を与えなければならないdataのデータを使用して、terms(object)で与えられた説明からデザイン行列を作成します。  データがデータフレームの場合、他の列があってもよく、列の順序は重要ではありません。  文字変数はすべて因子に強制されます。  contrasts.argが因子に指定されると、その変数のデフォルトの因子コーディングと、Cまたはcontrastsで設定された "contrasts "属性が上書きされます。6.0.交互作用項では、水準が最も速く変化する変数は、（項ではなく）式に最初に現れる変数である。
model.matrixは、model.frame(object)を呼び出すか、より正確にはattr(terms(object), "variables")を評価することによって作成されるのと同じ名前の変数を与えなければならないdataのデータを使用して、terms(object)で与えられた説明からデザイン行列を作成します。  データがデータフレームの場合、他の列があってもよく、列の順序は重要ではありません。  文字変数はすべて因子に強制されます。  contrasts.argが因子に指定されると、その変数のデフォルトの因子コーディングと、Cまたはcontrastsで設定された "contrasts "属性が上書きされます。6.0.交互作用項では、水準が最も速く変化する変数は、（項ではなく）式に最初に現れる変数である。
model.matrixは、model.frame(object)を呼び出すか、より正確にはattr(terms(object), "variables")を評価することによって作成されるのと同じ名前の変数を与えなければならないdataのデータを使用して、terms(object)で与えられた説明からデザイン行列を作成します。  データがデータフレームの場合、他の列があってもよく、列の順序は重要ではありません。  文字変数はすべて因子に強制されます。  contrasts.argが因子に指定されると、その変数のデフォルトの因子コーディングと、Cまたはcontrastsで設定された "contrasts "属性が上書きされます。6.0.交互作用項では、水準が最も速く変化する変数は、（項ではなく）式に最初に現れる変数である。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されています。  model.offsetは、式の中でoffset項によって指定された項、またはモデルフレームを生成する呼び出しの中でoffset引数によって指定された項を合計します：offsetが数値であることをチェックします。model.weightsは、返すベクトルに名前をつけないという点で、model.extract(, "weights")とは少し異なります。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されています。  model.offsetは、式の中でoffset項によって指定された項、またはモデルフレームを生成する呼び出しの中でoffset引数によって指定された項を合計します：offsetが数値であることをチェックします。model.weightsは、返すベクトルに名前をつけないという点で、model.extract(, "weights")とは少し異なります。
type = "effects "の場合は、各項の係数の表（オプションで標準誤差付き）を与える。type = "means "の場合は、各項の因子のレベルの組み合わせの平均応答の表を与える。"aov "メソッドは、"aovlist "適合の成分には適用できない。
model.extractは、より特殊な関数を持たないSとの互換性のために提供されている。  model.offsetは、式の中でoffset項によって指定された項、またはモデルフレームを生成する呼び出しの中でoffset引数によって指定された項を合計します：offsetが数値であることをチェックします。model.weightsは、返すベクトルに名前をつけないという点で、model.extract(, "weights")とは少し異なります。
これらの関数は、時系列から部分系列を抽出し、それらを1つのフレームにプロットします。  tsメソッド、stlメソッド、StructTSメソッドは、内部に記録された頻度と開始時刻と終了時刻を使用して、スケールと季節を設定します。  デフォルトのメソッドでは、オブザベーションは12個のグループになっていると仮定しています（ただし、これは変更可能です）。ラベルが与えられておらず、位相が与えられている場合、ラベルのデフォルトは位相の固有値になります。  両方が与えられている場合、位相値はlabels配列のインデックスであると仮定されます。
基礎となるモデルは、2つのサンプルがそれぞれf(x-l)とf((x-l)/s)/sから引き出されるというもので、lは共通の位置パラメータ、sはスケールパラメータである。
NA
na.actionは一般的な関数で、na.action.defaultはデフォルトの手法である。  後者はリストの "na.action "コンポーネントがあればそれを抽出し、なければ "na.action "属性を抽出する。model.frameが呼び出されると、NA処理に関するあらゆる情報を "na.action "属性に記録する。  ほとんどのモデル適合関数は、結果のコンポーネントとしてこれを返します。
NA
na.excludeがna.omitと異なるのは、結果の "na.action "属性のクラスが "exclude "であることだけです。  na.excludeが使用されると、na.excludeで省略されたケースにNAを挿入することで、残差と予測値が正しい長さにパディングされます。
na.excludeはna.omitと異なり、結果の "na.action "属性のクラスが "exclude "であるだけです。  na.excludeが使用されると、na.excludeで省略されたケースにNAを挿入することで、残差と予測値が正しい長さにパディングされます。
na.excludeはna.omitと異なり、結果の "na.action "属性のクラスが "exclude "であるだけです。  na.excludeが使用されると、na.excludeで省略されたケースにNAを挿入することで、残差と予測値が正しい長さにパディングされます。
na.excludeはna.omitと異なり、結果の "na.action "属性のクラスが "exclude "であるだけです。  na.excludeが使用されると、na.excludeによって省略されたケースのNAを挿入することによって、残差と予測値が正しい長さにパディングされます。
これらは、モデリング関数のpredict、fitted、residualsメソッドがフィッティングプロセスにおけるNAの除去を補正するために使用されるユーティリティ関数です。  デフォルト、"lm"、"glm"、"nls "メソッド、およびMASS、rpart、survivalパッケージのメソッドで使用されます。  デフォルトのメソッドは何もしません。  na.excludeアクションのデフォルトのメソッドは、元のデータフレームと同じ行数になるように、適切な位置にNAでオブジェクトを埋めることです。現在、naresidとnapredictは同一ですが、将来のメソッドは同一である必要はありません。
naprint.omitは省略された行の数を報告し、naprint.defaultは空の文字列を報告します。
これらは、モデリング関数のpredict、fitted、residualsメソッドが、フィッティングプロセスにおけるNAの除去を補正するために使用されるユーティリティ関数です。  デフォルト、"lm"、"glm"、"nls "メソッドや、MASS、rpart、survivalパッケージのメソッドで使用されます。  デフォルトのメソッドは何もしません。  na.excludeアクションのデフォルトメソッドは、元のデータフレームと同じ行数になるように、適切な位置にNAでオブジェクトを埋めることです。現在、naresidとnapredictは同一ですが、将来のメソッドは同一である必要はありません。
NA
gradientまたはhessianが提供されたが、間違ったモードまたは長さに評価された場合、警告とともにcheck.analyticals = TRUE（デフォルト）では無視されます。  gradientが存在し、サニティチェックをパスしない限り、ヘシアンはチェックされません。"摂動 "コレスキーcholdc()のCコードには、3.4.1以前のすべてのRバージョンでバグがありました。元のソースで利用可能な3つのメソッドから、我々は常に行探索であるメソッド "1 "を使用します。
startの名前はすべてobjectiveに渡され、該当する場合はgradientとhessianに渡されます。  関数のいずれかがNAまたはNaNを返した場合、これは勾配とヘシアンのエラーとなり、関数評価のためのそのような値は警告とともに+Infに置き換えられます。
nls オブジェクトはフィットモデルオブジェクトの一種です。  このオブジェクトは、汎用関数anova、coef、confint、deviance、df.residual、fitted、formula、logLik、predict、print、profile、residuals、summary、vcov、weightsのメソッドを持っています。formulaの変数（および欠落していない場合は重み）は、まずデータで検索され、次にformulaの環境で検索され、最後に検索パスに沿って検索されます。  引数subsetとna.actionは、データから取り出した式の変数がすべて同じ長さの場合のみサポートされます。
NA
NA
NA
NA
NA
このパッケージには、クラス "lm"、"glm"、"nls"、"logLik "のオブジェクト用のメソッドと、デフォルトのメソッド（重みと残差成分を探すときにuse.fallback = TRUEでない限りエラーを投げる - 注意して使用すること！）があります。主な使用法は、BICのための適切なペナルティを決定することですが、nobsは、異なる適合が同じデータ集合に適合されたことを簡単にチェックするために、ステップワイズ適合手法step、 add1、 drop1でも使用されます（新しい予測変数にNAがあるために、さらに行が削除されたなどではありません）。
これは、Writing R Extensionsで説明されているC関数 numeric_derivのフロントエンドです。
モデル式には複数のオフセットを指定できますが、オフセット項では - はサポートされていません（+ と同じです）。
式の右辺に複数の項が含まれる場合、それらの相互作用がグループ化を形成する。
デフォルトではoptimは最小化を行うが、control$fnscaleが負の場合は最大化を行う。optimHessは、hessian = TRUEを忘れた場合に、後の段階でヘシアンを計算するための補助関数である。デフォルトの方法は、Nelder and Mead(1965)の実装であり、関数値のみを使用し、ロバストであるが比較的遅い。  メソッド "BFGS "は準ニュートン法（可変計量アルゴリズムとしても知られている）であり、特に1970年にBroyden, Fletcher, Goldfarb and Shannoによって同時に発表されたものである。  CG "法は、Fletcher and Reeves (1964)に基づく共役勾配法である（ただし、Polak-RibiereまたはBeale-Sorenson更新のオプション付き）。  共役勾配法は、一般にBFGS法よりも壊れやすいが、行列を保存しないので、はるかに大きな最適化問題で成功する可能性がある。"L-BFGS-B "法は、Byrdら(1995)のもので、ボックス制約、つまり、各変数に下界と上界を与えることができる。初期値は制約を満たさなければならない。これはBFGS準ニュートン法のリミテッド・メモリ・モディフィケーションを用いる。  NocedalとWright(1999)は、前の3つの方法に関する包括的な参考文献である。シミュレーテッド・アニーリングは、確率的大域最適化法のクラスに属する。関数値のみを使用しますが、比較的時間がかかります。また、微分不可能な関数に対しても有効である。この実装では、受け入れ確率にメトロポリス関数を使用します。デフォルトでは、次の候補点は、実際の温度に比例したスケールを持つガウスマルコフカーネルから生成されます。新しい候補点を生成する関数が与えられている場合、"SANN "法は組み合わせ最適化問題を解くためにも使用できる。具体的には、温度はtemp / log(((t-1) %/% tmax)*tmax + exp(1))に設定され、tは現在の反復ステップであり、tempとtmaxは制御によって指定可能である。  SANN "法は制御パラメータの設定に決定的に依存することに注意してください。Brent "メソッドは、optimize()を使用する1次元問題専用である。  optimize()は、stats4パッケージのmleのように、methodしか指定できない他の関数の中でoptimize()が使われる場合に便利です。関数fnは、与えられた値で評価できない場合、NAまたはInfを返すことができますが、初期値はfnの計算可能な有限値でなければなりません(値が常に有限でなければならないメソッド "L-BFGS-B "を除く)。  control引数はリストで、以下の構成要素のいずれかを与えることができる。正数の場合、最適化の進行状況に関するトレース情報が生成されます。値が大きいほど、より多くのトレース情報が生成されます。"L-BFGS-B "メソッドでは、6段階のトレースがあります。  (これらの機能を正確に理解するには、ソースコードを参照してください。)最適化中にfnとgrの値に適用される全体的なスケーリング。負の場合、問題は最大化問題に変わります。最適化はpar/parscaleで実行され、任意の要素の単位変化でスケーリングされた値がほぼ単位変化するという意味で、これらは比較可能でなければなりません。  method = "Brent "の場合は使用されません（必要でもありません）.勾配に対する有限差分近似のステップサイズのベクトルで、パー/パースケールで指定します。デフォルトは1e-3.最大反復回数。SANN "の場合、maxitは関数評価の総数を与え、他の停止基準はありません。デフォルトは10000。絶対収束許容誤差。非負関数の場合のみ有用で、ゼロに到達するまでの許容範囲となる。  1ステップでreltol * (abs(val) + reltol)のファクターだけ値を減らすことができない場合、アルゴリズムは停止します。  デフォルトはsqrt(.Machine$double.eps)、通常は約1e-8.Nelder-Mead法のスケーリングパラメータ。alphaは反射係数(デフォルト1.0)、betaは収縮係数(0.5)、gammaは膨張係数(2.0).control$traceが正の場合の "BFGS"、"L-BFGS-B"、"SANN "法のレポート頻度。デフォルトは、"BFGS "および "L-BFGS-B "の場合は10反復毎、"SANN "の場合は100温度毎である。"Nelder-Mean "法（デフォルト）を1次元最小化に使用する場合に警告を発するべきかどうかを示す論理。  この警告は不適切な場合があるので、共役勾配法ではこのオプションをfalseに設定することで警告を抑制することができる。  L-BFGS-B "法で保持されるBFGS更新の回数を与える整数で、デフォルトは5です。収束は、目的値の減少がマシン許容差のこのファクター以内になったときに起こります。L-BFGS-B "法の収束をコントロールするのに役立ちます。これはカレントサーチ方向の投影勾配に対する公差です。SANN "法を制御します。冷却スケジュールの開始温度。デフォルトは10。"SANN "法の各温度における関数評価数。parに与えられた名前はすべて、fnとgrに渡されるベクトルにコピーされます。
デフォルトではoptimは最小化を実行しますが、control$fnscaleが負の場合は最大化を実行します。optimHessは、hessian = TRUEを忘れた場合に、後の段階でヘシアンを計算するための補助関数です。デフォルトの方法は、Nelder and Mead(1965)の実装で、関数値のみを使用し、ロバストですが比較的遅いです。  メソッド "BFGS "は準ニュートン法（可変計量アルゴリズムとしても知られている）で、特に1970年にBroyden, Fletcher, Goldfarb and Shannoによって同時に発表されたものである。  CG "法は、Fletcher and Reeves (1964)に基づく共役勾配法である（ただし、Polak-RibiereまたはBeale-Sorenson更新のオプション付き）。  共役勾配法は、一般にBFGS法よりも壊れやすいが、行列を保存しないので、より大きな最適化問題で成功する可能性がある。"L-BFGS-B "法は、Byrdら(1995)のもので、ボックス制約、つまり、各変数に下界と上界を与えることができる。初期値は制約を満たさなければならない。これはBFGS準ニュートン法のリミテッド・メモリ・モディフィケーションを用いる。  NocedalとWright(1999)は、前の3つの方法に関する包括的な参考文献である。シミュレーテッド・アニーリングは、確率的大域最適化法のクラスに属する。関数値のみを使用しますが、比較的時間がかかります。また、微分不可能な関数に対しても有効である。この実装では、受け入れ確率にメトロポリス関数を使用します。デフォルトでは、次の候補点は、実際の温度に比例したスケールを持つガウスマルコフカーネルから生成されます。新しい候補点を生成する関数が与えられている場合、"SANN "法は組み合わせ最適化問題を解くためにも使用できる。具体的には、温度はtemp / log(((t-1) %/% tmax)*tmax + exp(1))に設定され、tは現在の反復ステップであり、tempとtmaxは制御によって指定可能である。  SANN "法は制御パラメータの設定に決定的に依存することに注意してください。Brent "メソッドは、optimize()を使用する一次元問題専用である。  optimize()は、stats4パッケージのmleのように、methodしか指定できない他の関数の中でoptimize()が使われる場合に便利です。関数fnは、与えられた値で評価できない場合、NAまたはInfを返すことができますが、初期値はfnの計算可能な有限値でなければなりません(値が常に有限でなければならないメソッド "L-BFGS-B "を除く)。  control引数はリストで、以下の構成要素のいずれかを与えることができる。正数の場合、最適化の進行状況に関するトレース情報が生成されます。値が大きいほど、より多くのトレース情報が生成されます。"L-BFGS-B "メソッドでは、6段階のトレースがあります。  (これらの機能を正確に理解するには、ソースコードを参照してください。)最適化中にfnとgrの値に適用される全体的なスケーリング。負の場合、問題は最大化問題に変わります。最適化はpar/parscaleで実行され、任意の要素の単位変化でスケーリングされた値がほぼ単位変化するという意味で、これらは比較可能でなければなりません。  method = "Brent "の場合は使用されません（必要でもありません）.勾配に対する有限差分近似のステップサイズのベクトルで、パー/パースケールで指定します。デフォルトは1e-3.最大反復回数。SANN "の場合、maxitは関数評価の総数を与え、他の停止基準はありません。デフォルトは10000。絶対収束許容誤差。非負関数の場合のみ有用で、ゼロに到達するまでの許容範囲となる。  1ステップでreltol * (abs(val) + reltol)のファクターだけ値を減らすことができない場合、アルゴリズムは停止します。  デフォルトはsqrt(.Machine$double.eps)、通常は約1e-8.Nelder-Mead法のスケーリングパラメータ。alphaは反射係数(デフォルト1.0)、betaは収縮係数(0.5)、gammaは膨張係数(2.0).control$traceが正の場合の "BFGS"、"L-BFGS-B"、"SANN "法のレポート頻度。デフォルトは、"BFGS "および "L-BFGS-B "の場合は10反復毎、"SANN "の場合は100温度毎である。"Nelder-Mean "法（デフォルト）を1次元最小化に使用する場合に、警告を発するべきかどうかを示す論理。  この警告は不適切な場合があるので、共役勾配法ではこのオプションをfalseに設定することで警告を抑制することができる。  L-BFGS-B "法で保持されるBFGS更新の回数を与える整数で、デフォルトは5です。収束は、目的値の減少がマシン許容差のこのファクター以内になったときに起こります。L-BFGS-B "法の収束をコントロールするのに役立ちます。これはカレントサーチ方向の投影勾配に対する公差です。SANN "法を制御します。冷却スケジュールの開始温度。デフォルトは10。"SANN "法の各温度における関数評価数。parに与えられた名前はすべて、fnとgrに渡されるベクトルにコピーされます。
使用されている方法は、黄金分割探索とsuccessive放物線補間を組み合わせたもので、連続関数で使用するために設計されています。  収束は、フィボナッチ探索の場合よりもはるかに遅くなることはありません。  関数fは、eps * |x_0| + (tol/3)より近い2点で評価されることはありません。epsは約sqrt(.Machine$double.eps)、x_0は約sqrt(.Machine$double.eps)です。fが単峰関数であり、fareの計算値が少なくともeps * |x| + (tol/3)離れたときに常に単峰である場合、x_0は区間lower,upper上のfのグローバル最小値の横軸をeps * |x_0|+ tolより小さい誤差で近似する。fの最初の評価は常にx_1 = a + (1-φ)(b-a) (a,b) = (lower, upper)であり、phi = (sqrt(5) - 1)/2 = 0.61803...は黄金分割比である。ほとんど常に, 2回目の評価は atx_2 = a + phi(b-a) です.fがその中で定数であっても[x_1,x_2]内の局所最小値が解として見つかることに注意してください, 最後の例を参照してください.fは数値xに対してf(x, ...)として呼び出されます.fに渡される引数は特別なセマンティクスを持ち, 呼び出しの間で共有されます.  関数はこれをコピーしてはならない。
使用されている方法は、黄金分割探索とsuccessive放物線補間を組み合わせたもので、連続関数で使用するために設計されています。  収束は、フィボナッチ探索の場合よりもはるかに遅くなることはありません。  関数fは、eps * |x_0| + (tol/3)より近い2点で評価されることはありません。epsは約sqrt(.Machine$double.eps)、x_0は約sqrt(.Machine$double.eps)です。fが単峰関数であり、fareの計算値が少なくともeps * |x| + (tol/3)離れたときに常に単峰である場合、x_0は区間lower,upper上のfのグローバル最小値の横軸をeps * |x_0|+ tolより小さい誤差で近似する。fの最初の評価は常にx_1 = a + (1-φ)(b-a) (a,b) = (lower, upper)であり、phi = (sqrt(5) - 1)/2 = 0.61803...は黄金分割比である。ほとんど常に, 2回目の評価は atx_2 = a + phi(b-a) です.fがそこで定数であっても[x_1,x_2]内の局所最小値が解として見つかることに注意してください, 最後の例を参照してください.fは数値xに対してf(x, ...)として呼び出されます.fに渡される引数は特別なセマンティクスを持っており, 呼び出しの間で共有されるために使用されます.  関数はこれをコピーしてはならない。
左から右の順序で、葉のインデックスまたはラベルが取得される。
調整法には、p値に比較数を乗じるボンフェローニ補正("bonferroni")がある。  より保守的でない補正は、Holm (1979) ("holm")、Hochberg (1988) ("hochberg")、Hommel (1988) ("hommel")、Benjamini &Hochberg (1995) ("BH "またはその別名 "fdr")、Benjamini &Yekutieli (2001) ("BY")によるものも含まれる。最初の4つのメソッドは、ファミリーごとのエラー率を強く制御するように設計されています。  Hochbergの方法とHommelの方法は、仮説検定が独立であるか、またはそれらが非負に関連している場合に有効である(Sarkar,1998; Sarkar and Chang, 1997)。  Benjamini、Hochberg、Yekutieliの "BH"（別名 "fdr"）法と "BY "法は、偽発見率（棄却された仮説の中の偽発見の期待される割合）をコントロールする。  nをlength(p)よりも大きく設定できることに注意してください。これは、"bonferroni "法と "holm "法では、未観測のp値がすべての観測されたpよりも大きいと仮定され、他の方法では1に等しいことを意味します。
調整法には、p値に比較の数を乗じるBonferroni補正("bonferroni")が含まれる。  より保守的でない補正は、Holm (1979) ("holm"), Hochberg (1988) ("hochberg"), Hommel (1988) ("hommel"), Benjamini &Hochberg (1995) ("BH" またはその別名 "fdr"), Benjamini &Yekutieli (2001) ("BY") によるものも含まれる。最初の4つのメソッドは、ファミリーごとのエラー率を強く制御するように設計されています。  Hochbergの方法とHommelの方法は、仮説検定が独立であるか、またはそれらが非負に関連している場合に有効である(Sarkar,1998; Sarkar and Chang, 1997)。  Benjamini、Hochberg、Yekutieliの "BH"（別名 "fdr"）法と "BY "法は、偽発見率（棄却された仮説の中の偽発見の期待される割合）をコントロールする。  nをlength(p)よりも大きく設定できることに注意。これは、"bonferroni "法と "holm "法では、未観測のp値がすべての観測されたpよりも大きいと仮定され、他の方法では1に等しいことを意味する。
タイプ="相関 "および "共分散 "の場合，推定は標本の共分散に基づく．(デフォルトでは、欠損値は許されない。  (na.passのように)na.action関数が欠損値を通過する場合、共分散は完全なケースから計算されます。  これは、計算された推定値が有効な自己相関列ではない可能性があり、欠損値を含む可能性があることを意味します。  偏相関係数は、lag.maxまでの高次の自己回帰モデルに適合させることによって推定される。ジェネリック関数plotには、クラス "acf "のオブジェクト用のメソッドがある。
NA
NA
 pool.sdスイッチは、すべてのグループに共通のSDを計算し、すべての比較にそれを使用します（これは、いくつかのグループが小さい場合に便利です）。このメソッドは実際にはt.testを呼び出さないので、余分な引数は無視される。プーリングは対応のある検定には一般化されないので、pool.sdとpairedの両方をTRUEにすることはできません。可能な比較の行列の下三角形のみが計算されるので、alternativeを "two.sided "以外に設定すると、gの水準が適切に順序付けされる必要があります。
複数のグループ比較を行う関数は、別々のcompare.levels関数（iとjで対称であると仮定される）を作成し、それらをこの関数に渡す。
wilcox.testに渡される余分な引数は、この文脈では賢明な場合もそうでない場合もある。特に、可能な比較の行列の下三角形だけが計算されるので、alternativeを "two.sided "以外に設定すると、gの水準が分別のある順序になる必要がある。
パラメータshape1 = a とshape2 = bを持つベータ分布は密度Γ(a+b)/(Γ(a)Γ(b))x^(a-1)(1-x)^(b-1)を持ち、a > 0, b > 0, 0 ≤ x ≤ 1で、x=0 または x=1での境界値は連続性(極限)で定義されます。平均は a/(a+b) で、分散は ab/((a+b)^2 (a+b+1)) である。これらのモーメントとすべての分布特性は、abがゼロまたは無限大のとき、極限として定義することができ（0、1/2、または1の点質量につながる）、対応する[dpqr]beta()関数がそれに応じて定義される。  6.6.1B_x(a,b) = integral_0^x t^(a-1) (1-t)^(b-1) dt, 6.6.2 I_x(a,b) = B_x(a,b) / B(a,b)ここでB(a,b) = B_1(a,b)はベータ関数(beta)である。I_x(a,b)はpbeta(x, a, b)である。非心ベータ分布(ncp = λ)はX/(X+Y)の分布として定義され(Johnson et al, 1995, pp. 502)、ここでX ~ chi^2_2a(λ)，Y ~ chi^2_2bである。
size = n, prob = pの二項分布は、x = 0, ..., nに対して密度p(x) = choose(n, x) p^x (1-p)^(n-x) を持つ。p(x)はLoaderのアルゴリズムを使って計算される。ここでFは分布関数である。
誕生日のパラドックスとは、23人という非常に少ない人数で、2人以上が同じ誕生日である確率が50/50になるというものである。  この関数は、0.5以外の確率、2以外の一致イベントの数、365以外のクラスの数に対して計算を一般化する。  使用される式は、coincident > 2の場合の近似である。この近似は、確率が中程度の値では非常に良いが、非常に小さい確率ではあまり良くない。
位置またはスケールが指定されていない場合、それぞれデフォルト値の0と1を仮定する。位置l、スケールsのコーシー分布は、すべてのxに対して密度f(x) = 1 / (π s (1 + ((x-l)/s)^2))を持つ。
自由度 df= n ≥ 0 のカイ2乗分布は x > 0 のとき密度 f_n(x) = 1 / (2^(n/2) Γ(n/2)) x^(n/2-1) e^(-x/2)ここで f_0(x) := \lim_{n Γ to 0} f_n(x) = δ_0(x)はゼロの点質量で、密度関数ではなく「δ分布」です。平均と分散はnと2nである。自由度df= n度、非心パラメータncp= λの非心カイ2乗分布は、x≧0の時、密度f(x) = exp(-λ/2) SUM_{r=0}^∞ ((λ/2)^r / r!) dchisq(x, df + 2r)を持つ。  整数nの場合、これは分散1、λは正規平均の平方和を持つn個の正規分布の平方和の分布であり、E(X) = n + λ、Var(X) = 2(n + 2*λ) 、E((X - E(X))^3) = 8(n + 3*λ) となる。自由度 df= n, は整数であり、非中心性λ > 0に関係するn = 0でもあることに注意。この（非心、ゼロdf）の場合、分布はx = 0の点質量（サイズpchisq(0, df=0, ncp=ncp)）と連続部分の混合であり、dchisq()はその混合尺度に関する密度ではなく、むしろdf -> 0の場合の密度の極限です。
率λを持つ指数分布は、x≥0に対して密度f(x) = λ {e}^{- λ x}を持ちます。
自由度 df1 = n1 と df2 =n2 の F 分布は、密度 f(x) = Γ((n1 + n2)/2) を持ちます。/ n1 と n2 の独立した標準正規分布の平均2乗の比の分布であり、2つの独立したカイ2乗変量の比を自由度で割った分布です。  正規分布とm個の独立した正規分布の平方根の比はスチューデントのt_m分布を持つので、t_m変量の2乗は自由度1とmでF分布を持つ。非心F分布は、やはり単位分散の独立した正規分布の2乗平均の比であるが、分子のものは0でない平均を持つことが許され、ncpは平均の2乗和である。  非心分布の詳細については二乗を参照のこと。
パラメータshape = a、scale = sのガンマ分布は、密度f(x)=1/(s^a Gamma(a)) x^(a-1) e^-(x/s)で、x≥0、a > 0、s > 0である(ここでGamma(a)はRのgamma()で実装され、ヘルプで定義されている関数である)。  平均と分散は、E(X) = a*s とVar(X) = a*s^2です。累積ハザードH(t) = - log(1 - F(t))は、shape(およびmoderatecale)の小さな値の場合、ガンマ分布の質量の大部分は、コンピュータの演算でゼロとして表現されるほどゼロに近いxの値であることに注意してください。  だからrgammaはゼロとして表現される値を返すかもしれない。  (実際の生成はscale = 1で行われるため、これは非常に大きなscaleの値でも起こります)。
確率=pの幾何分布は、密度p(x) = p (1-p)^x for x = 0, 1, 2, ..., 0 < p ≤ 1.を持つ。xの要素が整数でない場合、dgeomの結果は警告とともにゼロとなる。分位数は、F(x) ≥ pとなる最小の値xとして定義される。
超幾何分布は，置換なしのサンプリングに使用される．  パラメータm, n, k (以下の文献ではそれぞれNp, N-Np, nと命名。N := m+n は他の文献でも使われている)を持つこの分布の密度は，x = 0, ..., kに対して byp(x) = choose(m, x) choose(n, k-x) / choose(m+n, k)で与えられる．p(x)が0でないのは，max(0, k-n) <= x <= min(k, m)のときだけであることに注意．p := m/(m+n) (従ってNp = N ⅹtimes p in thereference's notation)とすると、最初の2つのモーメントは平均E[X] = μ = k p と分散Var(X) = k p (1 - p) * (m+n-k)/(m+n-1) であり、これはBinomial(k,p)（k = 1でない限り超幾何の方が分散が小さい）に近いことを示している。rhyper()では、m,n,kのいずれかが.Machine$integer.maxを超える場合、qhyper(runif(nn), m,n,k)と同等のものが使用されます。
chisq()関数はオプションで非中心性引数を取るようになったので、*nchisq()関数は不要になりました。実験的だったreshape*はreshapeに置き換えられました。  arima0.diagはtsdiagに置き換えられました。arima0.plot.mtsは削除され、plot.tsが同じ機能を持つようになりました。lm.fit.nullとlm.wfit.nullは、lm.fitとlm.wfit.nullに取って代わられました。同様に、glm.fit.nullは、glm.fitに取って代わられました。mauchley.testは、Mauchlyの名前のスペルミスでしたが、mauchly.testの導入により修正されました。clearNamesは、unnameとほぼ同時に導入されましたが、より一般的ではなく、ほとんど使われていません。plclustは、デンドログラム（"cluster - trees"）を描画していましたが、"dendrogram "クラスのplot()メソッドに取って代わられました。
対数正規分布は密度f(x) = 1/(√(2 π) σ x) e^-((log x - μ)^2 / (2 σ^2))を持ち、μとσは対数の平均と標準偏差です。平均はE(X) = exp(μ + 1/2 σ^2)、中央値はmed(X) = exp(μ)、分散はVar(X) = exp(2*μ + σ^2)*(exp(σ^2)-1)、したがって変動係数はsqrt(exp(σ^2)-1)となり、これが小さいとき(例えば、σ < 1/2).
location = m andscale = sのロジスティック分布は、分布関数F(x) = 1 / (1 + exp(-(x-m)/s))、密度f(x) = 1/s exp((x-m)/s) (1 + exp((x-m)/s))^-2 を持ち、平均m、分散π^2 /3 s^2のロングテール分布である。
e.c.d.f.（経験的累積分布関数）Fn は、iがその値での同値オブザベーションの数であるオブザベーション値でi/nのジャンプを持つステップ関数である。  欠測値は無視されます。オブザベーションx= (x1,x2, ... xn)に対して、Fnはt以下のオブザベーションの割合、つまり、Fn(t) = #{xi <= t}/n = 1/n sum(i=1,n) Indicator(xi <= t).ecdfオブジェクトのプロットメソッドを実装する関数plot.ecdfは、plot.stepfunの呼び出しによって実装されています。
NA
NA
NA
yが存在しない場合、この関数は時系列プロットを作成し、plot.typeに応じて2種類のうちの1つの多変量系列を作成します。yが存在する場合、xとyの両方が一変量でなければならず、散布図y ~ xが描かれます。xy.labelsがTRUEまたは文字である場合はテキストを、xy.linesがTRUEである場合は線を用いて強調されます。
サイズ = n、prob = p の負の二項分布は密度 Γ(x+n)/(Γ(n) x!) p^n (1-p)^xx for x = 0, 1, 2, ..., n > 0, 0 < p ≤ 1.これは成功の目標数に達する前に一連のベルヌーイ試行で起こる失敗の数を表します。負の2項分布は、スケールパラメータ(1 - prob)/プロバンド形状パラメータsizeを持つガンマ分布(pgammaを参照)として分布する平均を持つポアソン分布の混合として生じることもある。  (この定義では，サイズの非整数値を許す)別のパラメタリゼーション(生態学でよく使われる)は，テーマmu (上記参照)と分散パラメタsizeで，prob = size/(size+mu)である。  このパラメトリゼーションでは、分散はmu + mu^2/sizeとなります。xの要素が整数でない場合、dnbinomの結果は0となり、警告が表示されます。size == 0の場合は、0に集中した分布となります。これは、probではなくmuが一定であっても、sizeが0に近づいた場合の限界分布です。  ただし、極限分布の平均は、muの値が何であれ0であることに注意してください。分位は、F(x) ≥ pとなる最小の値xとして定義されます。
正規分布は密度f(x) = 1/(√(2 π) σ) e^-((x - μ)^2/(2 σ^2))を持ち、μは分布の平均、σは標準偏差である。
familyは "glm "と "lm"（後者はgaussian()を返す）クラスのメソッドを持つ汎用関数である。二項族と準二項族の場合、応答は3つのうち1つの方法で指定できる：因子として： 'success'は、第1水準を持たない（したがって、通常は第2水準を持つ）因子として解釈される。0と1の間の値を持つ数値ベクトルとして：成功ケースの比率として解釈される（ケースの総数は重みで与えられる）．準2項族および準ポアソン族は、分散パラメータが1に固定されていない点でのみ2項族およびポアソン族と異なり、過分散をモデルすることができる。  二項の場合は、McCullagh and Nelder(1989, pp.124-8)を参照。  彼らは、(いくつかの制限のもとで)準2項モデルのように平均に比例する分散を持つモデルが存在することを示しているが、glmがそのモデルにおいて最尤推定値を計算しないことに注意してほしい。  Sの振る舞いは準変数に近い。
信頼区間は、1標本の場合はbinom.test、2標本の場合はbinom.testと同様に計算されます。
直交多項式は係数で要約され、Kennedy& Gentle (1980, pp.343-4)に示された3項再帰で評価することができます。  逆に、...でpolymが引数1つで呼び出された場合、それはpolyのラッパーである。
直交多項式は係数によって要約され、Kennedy& Gentle (1980, pp.343-4)に示された3項再帰によってそれを評価するために使用することができ、コードの予測部分で使用されます。  逆に、...でpolymが引数1つで呼ばれた場合、それはpolyのラッパーとなる。
lambdaが正でない場合、0とみなされ、loglinkが得られる。  デフォルトのlambda = 1は同一性リンクを与える。
groups, n, between.var, power, within.var, sig.levelのパラメータのうち1つだけをNULLとして渡す必要があり、そのパラメータは他のパラメータから決定される。sig.levelのデフォルトはNULLではないので、計算したい場合は明示的にNULLを渡さなければならない。
パラメータn、p1、p2、power、sig.levelのうち正確に1つをNULLとして渡す必要があり、そのパラメータは他のパラメータから決定される。  strict=TRUEを使用した場合、検出力には真の効果の反対方向（両側）の棄却確率が含まれます。  例えば、(p1,p2)=(0.9,1)の場合に必要な検出力を得るには、少なくともn = 74のサンプルサイズが必要です。このような不可能な条件に対しては、現在、警告(warning)が発せられますが、将来的にはエラー(stop)になるかもしれません。
パラメータn, delta, power, sd, sig.levelのうちちょうど1つがNULLとして渡されなければならず、そのパラメータは他のパラメータから決定される。  最後の2つはデフォルトではNULLではないので、計算したい場合は明示的にNULLを渡さなければならないことに注意してください。strict = TRUEが使用された場合、検出力には、両側効果の場合、真の効果の反対方向の棄却確率が含まれます。  これがないと、検出力は、真の差がゼロの場合の有意水準の半分になる。
定数と線形トレンドを組み込んだ一般回帰式が使用され、1次の自己回帰係数が1に等しい場合の補正されたt統計量が計算される。  igma^2を推定するために、Newey-West推定量が使用される。  lshortがTRUEの場合、切り捨てラグパラメータはtrunc(4*(n/100)^0.25)に設定され、そうでない場合はtrunc(12*(n/100)^0.25)が使用される。  p値はBanerjee et al(1993)の103ページの表4.2から補間したもので、欠損値は扱わない。
0 < a < 1の場合、結果の値は(0,1)(境界を除く)の中にある。いずれにせよ、結果のシーケンスは[0,1]で対称である、ppoints()は、qqplotとqqnormで、逆分布を評価する確率の集合を生成するために使用されます。aの選択は、Becker et al (1988)の同名の関数のドキュメントに従ったもので、Blom (1958)の期待正規次統計量（quantileも参照）の近似の結果に動機づけられているようです。連続標本の分位数タイプ5から9（分位数参照）の確率点は，それぞれaを1/2，0，1，1/3，3/8とすることで得られる．
ポアソン分布は密度p(x) = λ^x exp(-λ)/x！ x = 0, 1, 2, ... .平均と分散はE(X) = Var(X) = λ.λ=0は本当に極限の場合（0^0 = 1とする）であり、0に点塊が生じることに注意してください。p(x)はLoaderのアルゴリズムを使って計算されます。indbinomを参照してください。分位は右連続です：qpois(p, lambda)は、P(X ≤ x) ≥ p.lower.tail=FALSEを設定すると、デフォルトのlower.tail=TRUEが1を返す場合、より正確な結果を得ることができます。
基本的な方法はFriedman (1984)によるもので、基本的にはS-PLUSのppregで使われているコードと同じものです。  このコードは、使用するコンパイラに非常に敏感である。このアルゴリズムは、まず、最大max.termのリッジ項を一度に1つずつ追加する。  最適化のレベル(引数optlevel)は、この過程でモデルをどの程度徹底的に再フィットするかで異なる。  レベル1では、射影方向は再フィットされないが、リッジ関数と回帰係数は再フィットされる。レベル2と3は、すべての項を再フィットし、1つのレスポンスに対して等価である。レベル3は、各ステップで各帰還因子からの寄与を再バランスするためにより注意深く、2乗和基準の鞍点に収束する可能性が少し低くなる。
計算は、共分散行列の固有値を使用するのではなく、（中心化され、場合によってはスケーリングされた）データ行列の特異値分解によって行われる。  これは一般的に数値的な正確さのために好まれる方法である。  これらのオブジェクトのprint メソッドは結果をきれいな形式で表示し、plot メソッドはscree プロットを作成します。princomp とは異なり、分散は通常の除数N - 1で計算されます。
線形モデルに類似したほとんどの予測メソッドには、予測に使用する説明変数を探す最初の場所を指定する引数 newdata があります。  statsパッケージの時系列予測メソッドには、予測する時間ステップ数を指定する引数n.aheadがあります。多くのメソッドには、標準誤差を返すかどうかを示す論理引数se.fitがあります。
newdata が省略された場合、予測はフィットに使用されたデータに基づきます。  その場合、元のフィットで欠損値を持つケースがどのようになるかは、そのフィットのna.action引数によって決定される。  na.action=na.omitの場合、省略されたケースは残差に現れないが、na.action=na.excludeの場合は、残差値NAで（予測値と標準誤差に）現れる。  napredictも参照。
predict.lm は、フレーム newdata (デフォルトはmodel.frame(object))で回帰関数を評価することによって得られる予測値を生成します。  論理se.fitがTRUEの場合、予測値の標準誤差が計算されます。  区間を設定すると、指定された水準での信頼区間または予測（許容）区間の計算が指定されます。  このようなフィットからの予測は、新しいデータが元のデータと同じ部分空間に含まれる場合にのみ意味をなす。  新しいデータが省略された場合、予測は適合に使われたデータに基づいて行われます。  この場合、元のフィットで欠損値を持つケースがどのように扱われるかは、そのfitのna.action引数によって決定されます。  na.action=na.omitの場合、省略されたケースは予測値に現れないが、na.action=na.excludeの場合、それらは（予測値、標準誤差または区間限界に）現れ、値はNAとなる。  napredictも参照してください。予測区間は、新しいデータ（またはデフォルトではフィットに使用されたデータ）の各ケースでの1つのオブザベーションに対するもので、誤差分散は pred.var.です。  これは、σ^2の推定値であるres.varの倍数とすることができます：デフォルトでは、将来のオブザベーションがフィットに使用されたものと同じ誤差分散を持つと仮定します。  weightsが与えられると、この逆数がスケールファクターとして使用される。  重み付きフィットの場合、予測値が元のデータフレームに対するものであれば、weightsはデフォルトでモデルフィットに使用された重みになり、意図した結果でない可能性があるので警告が表示されます。  フィットが重み付けされ、新しいデータが与えられた場合、デフォルトは一定の予測分散と仮定され、警告が表示されます。
現在のところ、基本Rではジェネリック関数のみが提供されていますが、いくつかのアドオンパッケージにはメソッドがあります。主にSとの互換性のためにここにある。
princompは、"formula "と "default "メソッドを持つ汎用関数です。計算は、相関行列または共分散行列の固有値を使用して行われます。  これはS-PLUSの結果と互換性を持たせるためです。  デフォルトの計算では、共分散行列に除数Nが使用されていることに注意してください。これらのオブジェクトのprintメソッドは、きれいなフォーマットで結果を表示し、plotメソッドは、screeプロット（screeplot）を生成します。  princompは、いわゆるRモードPCA、つまり変数の特徴抽出のみを扱います。  データ行列が（場合によっては式を介して）提供される場合、少なくとも変数と同じ数のユニットが存在することが要求される。  QモードPCAにはprcompを使用する。
NA
NA
投影はオブジェクトの各層に対して与えられるので、誤差項を持つaovmodelsの場合、結果は投影のリストになる。
これらは，負荷量行列の構造を明らかにするために，因子 x %*% T の「回転」を求める．  行列T は，varimax の場合は回転（場合によっては反射を伴う）であるが，promax の場合は一般的な線形変換であり，因子の分散は保存される．
成功数と失敗数が有限であるグループのみが使用される。成功数と失敗数は、非負でなければならず、したがって、対応する試行数（正でなければならない）よりも大きくてはならない。  pがNULLで複数のグループがある場合、各グループの割合が同じであることがNULL検定される。  2つのグループが存在する場合、alternativeで指定されたように、最初のグループの成功確率が2番目のグループの成功確率より小さい、等しくない、または大きいことが選択肢となる。  conf.levelで指定された信頼水準で[-1,1]に切り取られた割合の差の信頼区間が返される。  連続性補正は、絶対値で標本割合の差を超えない場合にのみ使用される。  それ以外の場合、2つ以上のグループがある場合、alternativeは常に "two.sided "となり、返される信頼区間はNULLとなり、continuity correctionは使用されない。  alternativeは、成功確率がpまたは0.5より小さい、等しくない、または大きいというもので、それぞれalternativeで指定される。  conf.levelで指定された信頼水準で、[0,1]に切り取られた、基礎となる割合の信頼区間が返される。  連続補正は、絶対値でサンプル割合とヌル割合の差を超えない場合にのみ使用される。信頼区間はスコア検定を反転して計算される。最後に、pが与えられ、2つ以上のグループがある場合、テストされる正は、成功の基礎となる確率がpで与えられるものであることである。
NA
この分布は次のようにして得られる。  x を原点に対して対称な連続分布からの大きさ n の標本とする。  そしてウィルコクソンの符号付き順位統計量は，x[i]が正である絶対値x[i]の順位の和である。  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24である。最初の2つの引数のどちらかがベクトルである場合、長い方のベクトルの長さまでの2つのすべての組み合わせについて計算を行うためにリサイクル則が使用される。
df=n自由度を持つt分布は密度f(x) = Γ((n+1)/2)/ 平均 0 (n > 1) と分散 n/(n-2) (n > 2) を持ちます。パラメータ(df, Del) = (df, ncp)を持つ一般的な非心2次分布は，T(df, Del) := (U + Del) / √(V/df) の分布として定義され，ここでUとVは独立な確率変数，U ~ N(0,1)，V ~ χ^2(df)である(Chisquareを参照)．T=(mX-m0)/(S/sqrt(n))ここでmXは平均、SはX_1, X_2, ..., X_nの標本標準偏差(sd)であり、i.i.d. N(μ,σ^2)である。Tは非心t撤回f= n - 1degreeの自由度、非心パラメータerncp = (μ - m0) * sqrt(n)/σ として分布する。
ng =nrangesが1より大きい場合, Rは, nmeans観測のng個のグループの最大値である.
一様分布は密度f(x) = 1/(max-min)for min ≤ x ≤ maxを持つ。u := min == maxの場合、X == uの極限の場合が仮定されるが、この場合密度は存在せず、dunifはNaN（エラー条件）を返す。runifは、max = minまたはmax-minがminに比べて小さくない限り、特にデフォルトの引数では極値のどちらも生成しない。
形状パラメータa、スケールパラメータbを持つワイブル分布は、x > 0に対してf(x) = (a/b) (x/b)^(a-1) exp(-(x/b)^a)で与えられる密度を持つ。累積分布関数は x > 0 で F(x) = 1 - exp(- (x/b)^a)，themean は E(X) = b Γ(1 + 1/a)，Var(X) = b^2 * (Γ(1 + 2/a) - (Γ(1 + 1/a))^2)である．
この分布は次のように得られる。  x と y を大きさ m と n の2つの無作為独立標本とすると、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数です。  この統計量は0からm * nの間の値をとり、その平均と分散はそれぞれm * n / 2とm * n * (m + n + 1) / 12である。最初の3つの引数のいずれかがベクトルである場合、最長ベクトルの長さまでの3つのすべての組み合わせについて計算を行うためにリサイクルルールが使用される。
パラメータ shape1 = a andshape2 = b のベータ分布は密度Γ(a+b)/(Γ(a)Γ(b))x^(a-1)(1-x)^(b-1)を a > 0, b > 0, 0 ≤ x ≤ 1 で持ち、x=0 または x=1 の境界値は連続性(極限)で定義されます。平均は a/(a+b) で、分散は ab/((a+b)^2 (a+b+1)) である。これらのモーメントとすべての分布特性は、abがゼロまたは無限大のとき、極限として定義することができ（0、1/2、または1の点質量につながる）、対応する[dpqr]beta()関数がそれに応じて定義される。  6.6.1B_x(a,b) = integral_0^x t^(a-1) (1-t)^(b-1) dt, 6.6.2 I_x(a,b) = B_x(a,b) / B(a,b)ここでB(a,b) = B_1(a,b)はベータ関数(beta)である。I_x(a,b)はpbeta(x, a, b)である。非心ベータ分布(ncp = λ)はX/(X+Y)の分布として定義され(Johnson et al, 1995, pp. 502)、ここでX ~ chi^2_2a(λ)，Y ~ chi^2_2bである。
size = n, prob = pの二項分布は、x = 0, ..., nに対して密度p(x) = choose(n, x) p^x (1-p)^(n-x) を持つ。p(x)はLoaderのアルゴリズムを使って計算される。ここでFは分布関数である。
誕生日のパラドックスとは、23人という非常に少ない人数で、2人以上が同じ誕生日である確率が50/50になるというものである。  この関数は、0.5以外の確率、2以外の一致イベントの数、365以外のクラスの数に対して計算を一般化する。  使用される式は、coincident > 2の場合の近似である。この近似は、確率が中程度の値では非常に良いが、非常に小さい確率ではあまり良くない。
位置またはスケールが指定されていない場合、それぞれデフォルト値の0と1を仮定する。位置l、スケールsのコーシー分布は、すべてのxに対して密度f(x) = 1 / (π s (1 + ((x-l)/s)^2))を持つ。
自由度 df= n ≥ 0 のカイ2乗分布は x > 0 のとき密度 f_n(x) = 1 / (2^(n/2) Γ(n/2)) x^(n/2-1) e^(-x/2)ここで f_0(x) := \lim_{n Γ to 0} f_n(x) = δ_0(x)はゼロの点質量で、密度関数ではなく「δ分布」です。平均と分散はnと2nである。自由度df= n度、非心パラメータncp= λの非心カイ2乗分布は、x≧0の時、密度f(x) = exp(-λ/2) SUM_{r=0}^∞ ((λ/2)^r / r!) dchisq(x, df + 2r)を持つ。  整数nの場合、これは分散1、λは正規平均の平方和を持つn個の正規分布の平方和の分布であり、E(X) = n + λ、Var(X) = 2(n + 2*λ) 、E((X - E(X))^3) = 8(n + 3*λ) となる。自由度 df= n, は整数であり、非中心性λ > 0に関係するn = 0でもあることに注意。この（非心、ゼロdf）の場合、分布はx = 0の点質量（サイズpchisq(0, df=0, ncp=ncp)）と連続部分の混合であり、dchisq()はその混合尺度に関する密度ではなく、むしろdf -> 0の場合の密度の極限です。
率λを持つ指数分布は、x≥0に対して密度f(x) = λ {e}^{- λ x}を持ちます。
自由度 df1 = n1 と df2 =n2 の F 分布は、密度 f(x) = Γ((n1 + n2)/2) を持ちます。/ n1 と n2 の独立した標準正規分布の平均2乗の比の分布であり、2つの独立したカイ2乗変量の比を自由度で割った分布です。  正規分布とm個の独立した正規分布の平方根の比はスチューデントのt_m分布を持つので、t_m変量の2乗は自由度1とmでF分布を持つ。非心F分布は、やはり単位分散の独立した正規分布の2乗平均の比であるが、分子のものは0でない平均を持つことが許され、ncpは平均の2乗和である。  非心分布の詳細については二乗を参照のこと。
パラメータshape = a、scale = sのガンマ分布は、密度f(x)=1/(s^a Gamma(a)) x^(a-1) e^-(x/s)で、x≥0、a > 0、s > 0である(ここでGamma(a)はRのgamma()で実装され、ヘルプで定義されている関数である)。  平均と分散は、E(X) = a*s とVar(X) = a*s^2です。累積ハザードH(t) = - log(1 - F(t))は、形状の小さな値（と中程度のスケール）では、ガンマ分布の質量の大部分は、コンピュータの演算でゼロとして表現されるほどゼロに近いxの値であることに注意してください。  だからrgammaはゼロとして表現される値を返すかもしれない。  (実際の生成はscale = 1で行われるため、これは非常に大きなscaleの値でも起こります)。
確率=pの幾何分布は、密度p(x) = p (1-p)^x for x = 0, 1, 2, ..., 0 < p ≤ 1.を持つ。xの要素が整数でない場合、dgeomの結果は警告とともにゼロとなる。分位数は、F(x) ≥ pとなる最小の値xとして定義される。
超幾何分布は，置換なしのサンプリングに使用される．  パラメータm, n, k (以下の文献ではそれぞれNp, N-Np, nと命名。N := m+n は他の文献でも使われている)を持つこの分布の密度は，x = 0, ..., kに対して byp(x) = choose(m, x) choose(n, k-x) / choose(m+n, k)で与えられる．p(x)が0でないのは，max(0, k-n) <= x <= min(k, m)のときだけであることに注意．p := m/(m+n) (従ってNp = N ⅹtimes p in thereference's notation)とすると、最初の2つのモーメントは平均E[X] = μ = k p と分散Var(X) = k p (1 - p) * (m+n-k)/(m+n-1) であり、これは二項(k,p)に近いことを示している(k = 1でなければ超幾何の方が分散が小さい)。rhyper()では、m,n,kのいずれかが.Machine$integer.maxを超える場合、現在はqhyper(runif(nn), m,n,k)と等価なものが使用されるが、これは比較的に遅い。
対数正規分布は密度f(x) = 1/(√(2 π) σ x) e^-((log x - μ)^2 / (2 σ^2))を持ち、μとσは対数の平均と標準偏差である。平均はE(X) = exp(μ + 1/2 σ^2)、中央値はmed(X) = exp(μ)、分散はVar(X) = exp(2*μ + σ^2)*(exp(σ^2)-1)、したがって変動係数はsqrt(exp(σ^2)-1)となり、これが小さいとき(例えば、σ < 1/2).
locationまたはscaleが省略された場合、それらはそれぞれ0と1のデフォルト値となる。location = m andscale = sのロジスティック分布は、分布関数F(x) = 1 / (1 + exp(-(x-m)/s)) と密度f(x) = 1/s exp((x-m)/s) (1 + exp((x-m)/s))^-2 を持ち、平均mと分散π^2 /3 s^2のロングテール分布である。
サイズ = n、prob = pの負の二項分布は、密度Γ(x+n)/(Γ(n) x!) p^n (1-p)^xfor x = 0, 1, 2, ..., n > 0, 0 < p ≤ 1.これは、成功の目標数に達する前に、一連のベルヌーイ試行で発生する失敗の数を表します。負の2項分布は、スケールパラメータ(1 - prob)/プロバンド形状パラメータsizeを持つガンマ分布(pgammaを参照)として分布する平均を持つポアソン分布の混合として生じることもある。  (この定義では，サイズの非整数値を許す)別のパラメタリゼーション(生態学でよく使われる)は，テーマmu (上記参照)と分散パラメタsizeで，prob = size/(size+mu)である。  このパラメトリゼーションでは、分散はmu + mu^2/sizeとなります。xの要素が整数でない場合、dnbinomの結果は0となり、警告が表示されます。size == 0の場合は、0に集中した分布となります。これは、probではなくmuが一定であっても、sizeが0に近づいた場合の限界分布です。  ただし、muの値がどうであれ、極限分布の平均は0であることに注意してください。分位は、F(x) ≥ pとなる最小の値xとして定義されます。
正規分布は密度f(x) = 1/(√(2 π) σ) e^-((x - μ)^2/(2 σ^2))を持ち、ここでμは分布の平均、σは標準偏差である。
ポアソン分布は密度p(x) = λ^x exp(-λ)/x!for x = 0, 1, 2, ... .平均と分散はE(X) = Var(X) = λ.λ=0は極限ケース(0^0 = 1とする)であることに注意。p(x)はLoaderのアルゴリズムを使って計算されます。indbinomを参照してください。分位は右連続です：qpois(p, lambda)は、P(X ≤ x) ≥ p.lower.tail=FALSEを設定することで、デフォルトのlower.tail=TRUEが1を返す場合に、より正確な結果を得ることができます。
NA
NA
NA
この分布は次のようにして得られる。  xを原点に対して対称な連続分布からのサイズnの標本とする。  そしてウィルコクソンの符号付き順位統計量は，x[i]が正である絶対値x[i]の順位の和である。  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24である。最初の2つの引数のどちらかがベクトルである場合、長い方のベクトルの長さまでの2つのすべての組み合わせについて計算を行うためにリサイクル則が使用される。
df=n自由度を持つt分布は密度f(x) = Γ((n+1)/2)/ 平均 0 (n > 1) と分散 n/(n-2) (n > 2) を持ちます。パラメータ(df, Del) = (df, ncp)を持つ一般的な非心2次分布は，T(df, Del) := (U + Del) / √(V/df) の分布として定義される．ここでUとVは独立な確率変数で，U ~ N(0,1)，V ~ χ^2(df)である(Chisquareを参照)．T=(mX-m0)/(S/sqrt(n))ここでmXは平均、SはX_1, X_2, ..., X_nの標本標準偏差(sd)であり、i.i.d. N(μ,σ^2)である。Tは非心t撤回f= n - 1degreeの自由度と非心パラメータerncp = (μ - m0) * sqrt(n)/σ として分布する。
ng =nrangesが1より大きい場合、Rはそれぞれnmeans観測のng個のグループの最大値である。
quade.検定は、正規性の仮定が破られる可能性のある、再現性のない完全ブロックデザイン（すなわち、グループとブロックの各水準の組み合わせについてyにちょうど1つのオブザベーションがある）の分析に使用できる。帰無仮説は、ブロックの効果を除けば、yの位置パラメータは各グループで同じであるというものである。  yが行列の場合、グループとブロックはそれぞれ列と行の添字から求められる。グループやブロックにNAは許されない。
names=TRUEの場合、names属性を持ちます。probsのNAとNaNの値は結果に伝搬されます。デフォルトのメソッドは、ソートと（タイプ1と3では不要な）要素の加算と数値の乗算が正しく動作する数値ベクトルに十分に似ているクラス化されたオブジェクトで動作します。  また、'正しく'のチェックがないことにも注意。例えば、quantileは複素数ベクトルにも適用でき、(同値であることを除けば)実部の順序になる。  1型と3型は，クラス "Date "と順序付き因子に使用できる．
family は、クラス "glm "と "lm"（後者はgaussian()を返す）用のメソッドを持つ汎用関数である：因子として： 'success'は、第1水準を持たない（したがって、通常は第2水準を持つ）因子として解釈される。0と1の間の値を持つ数値ベクトルとして：成功ケースの比率として解釈される（ケースの総数は重みで与えられる）．準2項族および準ポアソン族は、分散パラメータが1に固定されていない点でのみ2項族およびポアソン族と異なり、過分散をモデルすることができる。  二項の場合は、McCullagh and Nelder(1989, pp.124-8)を参照。  彼らは、(いくつかの制限のもとで)準2項モデルのように平均に比例する分散を持つモデルが存在することを示しているが、glmがそのモデルにおいて最尤推定値を計算しないことに注意してほしい。  Sの振る舞いは準2項モデルに近い。
family は、"glm "と "lm"（後者はgaussian()を返す）クラスのメソッドを持つ汎用関数です。二項および準二項モデルでは、応答は3つの方法のいずれかで指定できます：因子として： 'success'は、第1水準を持たない（したがって、通常は第2水準を持つ）因子として解釈される。0と1の間の値を持つ数値ベクトルとして：成功ケースの比率として解釈される（ケースの総数は重みで与えられる）．準2項族および準ポアソン族は、分散パラメータが1に固定されていない点でのみ2項族およびポアソン族と異なり、過分散をモデルすることができる。  二項の場合は、McCullagh and Nelder(1989, pp.124-8)を参照。  彼らは、(いくつかの制限のもとで)準2項モデルのように平均に比例する分散を持つモデルが存在することを示しているが、glmがそのモデルにおいて最尤推定値を計算しないことに注意してほしい。  Sの振る舞いは準2項モデルに近い。
family は、"glm "と "lm"（後者はgaussian()を返す）クラスのメソッドを持つ汎用関数です。二項および準二項モデルでは、応答は3つの方法のいずれかで指定できます：因子として： 'success'は、第1水準を持たない（したがって、通常は第2水準を持つ）因子として解釈される。0と1の間の値を持つ数値ベクトルとして：成功ケースの比率として解釈される（ケースの総数は重みで与えられる）．準2項族および準ポアソン族は、分散パラメータが1に固定されていない点でのみ2項族およびポアソン族と異なり、過分散をモデルすることができる。  二項の場合は、McCullagh and Nelder(1989, pp.124-8)を参照。  彼らは、(いくつかの制限のもとで)準2項モデルのように平均に比例する分散を持つモデルが存在することを示しているが、glmがそのモデルにおいて最尤推定値を計算しないことに注意してほしい。  Sの振る舞いは準変数に近い。
一様分布は、min ≤ x ≤ maxの場合、密度f(x) = 1/(max-min) を持つ。u := min == maxの場合、X == uの極限の場合が想定されるが、この場合密度はなく、dunifはNaN（エラー条件）を返す。runifは、max = minまたはmax-minがminに比べて小さくない限り、極値のどちらも生成せず、特にデフォルトの引数の場合は生成しない。
形状パラメータa、スケールパラメータbを持つワイブル分布は、x > 0に対してf(x) = (a/b) (x/b)^(a-1) exp(-(x/b)^a)で与えられる密度を持つ。累積分布関数は x > 0 で F(x) = 1 - exp(- (x/b)^a)，themean は E(X) = b Γ(1 + 1/a)，Var(X) = b^2 * (Γ(1 + 2/a) - (Γ(1 + 1/a))^2)である．
この分布は次のように得られる。  x と y を大きさ m と n の2つの無作為独立標本とすると、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数です。  この統計量は0からm * nの間の値をとり、その平均と分散はそれぞれm * n / 2とm * n * (m + n + 1) / 12である。最初の3つの引数のいずれかがベクトルである場合、最長ベクトルの長さまでの3つのすべての組み合わせの計算を行うためにリサイクルルールが使用される。
NA
パラメータ shape1 = a andshape2 = b のベータ分布は密度Γ(a+b)/(Γ(a)Γ(b))x^(a-1)(1-x)^(b-1)を a > 0, b > 0, 0 ≤ x ≤ 1 で持ち、x=0 または x=1 での境界値は連続(極限)で定義されます。平均は a/(a+b) で、分散は ab/((a+b)^2 (a+b+1)) である。これらのモーメントとすべての分布特性は、abがゼロまたは無限大のとき、極限として定義することができ（0、1/2、または1の点質量につながる）、対応する[dpqr]beta()関数がそれに応じて定義される。  6.6.1B_x(a,b) = integral_0^x t^(a-1) (1-t)^(b-1) dt, 6.6.2 I_x(a,b) = B_x(a,b) / B(a,b)ここでB(a,b) = B_1(a,b)はベータ関数(beta)である。I_x(a,b)はpbeta(x, a, b)である。非心ベータ分布(ncp = λ)はX/(X+Y)の分布として定義され(Johnson et al, 1995, pp. 502)、ここでX ~ chi^2_2a(λ)，Y ~ chi^2_2bである。
size = n, prob = pの二項分布は、x = 0, ..., nに対して密度p(x) = choose(n, x) p^x (1-p)^(n-x) を持つ。p(x)はLoaderのアルゴリズムを用いて計算される。分位数は、F(x)≧pとなる最小の値xとして定義される。
位置lとスケールsを持つコーシー分布は，すべてのxに対して密度f(x) = 1 / (π s (1 + ((x-l)/s)^2)) を持つ．
自由度 df= n ≥ 0 のカイ2乗分布は x > 0 のとき密度 f_n(x) = 1 / (2^(n/2) Γ(n/2)) x^(n/2-1) e^(-x/2)ここで f_0(x) := \lim_{n Γ to 0} f_n(x) = δ_0(x)はゼロの点質量で、密度関数ではなく「δ分布」です。平均と分散はnと2nである。自由度df= n度、非心パラメータncp= λの非心カイ2乗分布は、x≧0の時、密度f(x) = exp(-λ/2) SUM_{r=0}^∞ ((λ/2)^r / r!) dchisq(x, df + 2r)を持つ。  整数nの場合、これは分散1、λは正規平均の平方和を持つn個の正規分布の平方和の分布であり、E(X) = n + λ、Var(X) = 2(n + 2*λ) 、E((X - E(X))^3) = 8(n + 3*λ) となる。自由度 df= n, は整数であり、非中心性 λ > 0に関係する n = 0 でもあることに注意。この場合(非心、df=0)、分布はx=0における点質量(サイズpchisq(0, df=0, ncp=ncp))と連続部分の混合となり、dchisq()はその混合測度に関する密度ではなく、むしろdf -> 0における密度の極限となります。ncpの値が約1e5より大きい(さらに小さい)場合、pchisqとqchisqに対して多くの警告が表示され、不正確な結果を与える可能性があることに注意してください。
read.ftableは、ファイルから平坦な分割表を読み込む。  ファイルがフラットテーブルの記述された表現（より正確には、列変数の名前とレベルに関するすべての情報を含むヘッダと、行変数の名前を含む行）を含んでいる場合、それ以上の引数は必要ありません。  同様に、最初の行の唯一の項目である列変数名が1つだけのフラットテーブルも自動的に処理されます。  skipを使用してすべてのヘッダー情報をスキップし、row.var.namesとcol.varsをそれぞれ使用して行変数の名前と列変数の名前とレベルを指定することで、他の変種を処理することができます。  以下の例を参照してください。フラット・テーブルは、行（そしておそらく列も）ラベルが「ぼろぼろ」に表示されることが特徴であることに注意してください。  行変数のレベルの完全なグリッドが与えられている場合は、代わりにread.tableを使用してデータを読み込み、xtabs.write.ftableを使用してこのデータから分割表を作成する必要があります。xtabs.write.ftableは、分割表の「きれいな」ASCII表現を生成するのに便利なフラットテーブルをファイルに書き込みます。  method引数で異なるバージョンが利用でき、例えばLaTeXの表を作成するのに便利である。
NA
NA
これはreorder()と同様、単にfactor(x, levels = levels(x)[......])を呼び出した特別なケースである。
これは、relevel() として、単にfactor(x, levels = levels(x)[......])を呼び出すことの特別な場合である。
formula がデータ・フレームでデータが欠損している場合、formula は、式 ~ ..を持つデータに対して使用されます。式中の任意の文字ベクトルは、因子に強制されます。
reshape()は様々な文脈で使用できるが、その動機となるアプリケーションは縦断的研究のデータであり、この関数の引数はその用語で命名され、説明される。縦断的研究の特徴は、異なる時点（すべての単位で同じであると仮定される）で、研究される各単位（例えば、個々の人）で、同じ変数（例えば、身長と体重）の測定を繰り返すことである。これらの変数は時変変数と呼ばれる。縦断的データセットの「ワイド」形式の表現では、各単位に1レコード（行）があり、通常、1列を占める時定数変数と、複数列（各時点に1列）を占める時変変数がある。  同じデータセットを「long」形式で表現すると、個体ごとに複数のレコード（行）があり、時定数変数はこれらのレコード間で一定で、時変変数はレコード間で変化する。  long'フォーマットのデータセットには、2つの変数が追加される。各レコードがどの時点のものかを示す'time'変数と、どのレコードが同じユニットを参照しているかを示す'id'変数である。変換のタイプ（longからwide、またはwideからlong）は、direction引数によって決定される。  direction = "wide "でのlongからwideへの変換は、より単純な操作であり、データがしばしばワイドフォーマットの行列として期待される多変量解析の文脈で主に有用である。この場合、時間変数timevarとid変数idvarを指定しなければならない。時変変数がv.names引数で明示的に指定されない限り、他のすべての変数は時変であると仮定されます。  時変変数が実際に定数でない場合は警告が発せられます。各時変変数は、wide フォーマットの複数の変数に展開されます。  これらの展開された変数の名前は、v varying 引数で時変変数ごとに1つの要素（または行）を持つリスト（または行列）の形式で指定されない限り、自動的に生成されます。vallingがnamesのベクトルである場合、各時刻変化変数に対して1行を持つ行列に暗黙的に変換される。このオプションは、時変変数が複数ある場合に注意して使用してください。明示的なリストまたは行列形式が曖昧でないのに対して、（行列コンストラクタのデフォルトである列による）順序付けが直感的でない場合があります。direction = "long "によるwideからlongへの変換は、ほとんどの（単変量）統計モデリング関数がlong形式のデータを想定しているため、より一般的な操作です。時変変数が1つしかないような単純なケースでは、ワイドフォーマット入力の対応する列をvol varying引数として指定することができ、これは列名のベクトルでも対応する列インデックスでもよい。これらの列を組み合わせたロングフォーマット出力の対応する変数名は、オプションでv.names引数として指定することができ、時間変数の名前はtimevar引数として指定することができる。ワイドフォーマットの各列に対応する時間値として使用する値は、times 引数として指定することができる。  v.namesが指定されていない場合、関数はv.namesとtimesを変化させて推測しようとする（この場合、明示的に指定されたtimes引数は使用されない）。  デフォルトでは、x.1, x.2のような変数名を想定しており、sep = ". "は、ドットで分割して名前から削除するように指定します。  複数の時間変化変数を指定するには、上記のように原子ベクトルとして変化させる方法と、リスト（または行列）として変化させる方法の2通りがある。最初の形式は、前述の自動変数名分割を使用する場合に便利です（そして必須です）。この場合、すべての時変変数の名前を同じ方法で適切にフォーマットし、v.namesを指定しない必要があります。v varyingがリスト（各時刻変化変数に1つの要素を持つ）または行列（各時刻変化変数に1つの行を持つ）である場合、変数名の分割は試みられず、v.nameとtimesは一般的に指定される必要があるが、それぞれ各集合の最初の変数名と連続したtimesがデフォルトとなる。この場合、時変変数の数はv.namesの長さとみなされ、v varyingは暗黙的に行列に変換され、各時変変数に1行が割り当てられる。longからwidへの変換の場合と同様に、行列は列ごとに埋められていくので、変数名（またはインデックス）の順番に注意する必要がある。  split$regexpコンポーネントは、strsplitまたはregexprのいずれかに渡される。後者は、split$includeがTRUEの場合に使用され、この場合、マッチした文字列の最初の文字の後に分割が行われる。  strsplitの場合、セパレータは結果に含まれず、split$fixedを使って固定文字列マッチングを指定することができる。
NA
NA
参考文献は、残差のタイプを定義している：もしna.action = na.omitであれば、省略されたケースは残差に現れず、na.action = na.excludeであれば、残差値NAで現われる。  naresid も参照してください。y = FALSEでのフィットでは、応答値は他の成分から計算されます。
汎用アクセッサ関数coef、effects、fitted、residualsは、lmが返す値の様々な有用な特徴を抽出するために使用することができます。  デビアンス残差とパールソン残差は重み付き残差で、フィッティングで使用した重みの平方根でスケーリングされます。  部分残差は、各列がモデルから項を省略した行列です。  residualsが元のフィットで欠損値を持つケースをどのように扱うかは、そのフィットのna.action引数によって決まります。na.action = na.omitの場合、省略されたケースは残差に現れませんが、na.action = na.excludeの場合、それらは残差値NAで現れます。  一般的なラベルの "lm "メソッドは、推定可能な項のラベル、つまり少なくとも1つの推定可能な係数を持つ項の名前を返す。
率λを持つ指数分布は、x≥0に対して密度f(x) = λ {e}^{- λ x}を持つ。
自由度 df1 = n1 と df2 =n2 の F 分布は、密度 f(x) = Γ((n1 + n2)/2) を持ちます。/ n1 と n2 の独立した標準正規分布の平均2乗の比の分布であり、2つの独立したカイ2乗変量の比を自由度で割った分布です。  正規分布とm個の独立した正規分布の平方根の比はスチューデントのt_m分布を持つので、t_m変量の2乗は自由度1とmでF分布を持つ。非心F分布は、やはり単位分散の独立した正規分布の2乗平均の比であるが、分子のものは0でない平均を持つことが許され、ncpは平均の2乗和である。  非心分布の詳細については二乗を参照のこと。
パラメータshape = a、scale = sのガンマ分布は、密度f(x)=1/(s^a Gamma(a)) x^(a-1) e^-(x/s)で、x≥0、a > 0、s > 0である(ここでGamma(a)はRのgamma()で実装され、ヘルプで定義されている関数である)。  平均と分散は、E(X) = a*s とVar(X) = a*s^2です。累積ハザードH(t) = - log(1 - F(t))は、形状の小さな値（と中程度のスケール）では、ガンマ分布の質量の大部分は、コンピュータの演算でゼロとして表現されるほどゼロに近いxの値であることに注意してください。  だからrgammaはゼロとして表現される値を返すかもしれない。  (実際の生成はscale = 1で行われるため、これは非常に大きなscaleの値でも起こります)。
確率=pの幾何分布は、密度p(x) = p (1-p)^x for x = 0, 1, 2, ..., 0 < p ≤ 1.を持つ。xの要素が整数でない場合、dgeomの結果は警告付きでゼロとなる。分位数は、F(x) ≥ pとなるような最小の値xとして定義される。
超幾何分布は，置換なしのサンプリングに使用される．  パラメータm, n, k (以下の文献ではそれぞれNp, N-Np, nと命名。N := m+n は他の文献でも使われている)を持つこの分布の密度は，x = 0, ..., kに対して byp(x) = choose(m, x) choose(n, k-x) / choose(m+n, k)で与えられる．p(x)が0でないのは，max(0, k-n) <= x <= min(k, m)のときだけであることに注意．p := m/(m+n) (従ってNp = N ⅹtimes p in thereference's notation)とすると、最初の2つのモーメントは平均E[X] = μ = k p と分散Var(X) = k p (1 - p) * (m+n-k)/(m+n-1) であり、これは二項(k,p)に近いことを示している(k = 1でなければ超幾何の方が分散が小さい)。rhyper()では、m,n,kのいずれかが.Machine$integer.maxを超える場合、現在はqhyper(runif(nn), m,n,k)と等価なものが使用されるが、これは比較的に遅い。
対数正規分布は密度f(x) = 1/(√(2 π) σ x) e^-((log x - μ)^2 / (2 σ^2))を持ち、μとσは対数の平均と標準偏差である。平均はE(X) = exp(μ + 1/2 σ^2)、中央値はmed(X) = exp(μ)、分散はVar(X) = exp(2*μ + σ^2)*(exp(σ^2)-1)、したがって変動係数はsqrt(exp(σ^2)-1)となり、これが小さいとき(例えば、σ < 1/2).
location = m andscale = s のロジスティック分布は、分布関数F(x) = 1 / (1 + exp(-(x-m)/s))、密度f(x) = 1/s exp((x-m)/s) (1 + exp((x-m)/s))^-2 を持ち、平均m、分散π^2 /3 s^2のロングテール分布である。
xがK成分のベクトルであれば、dmultinom(x, prob)は確率P(X[1]=x[1], ... , X[K]=x[k]) = C * prod(j=1 , ..., K) p[j]^x[j]であり、Cは「多項係数」C = Nである！/ (x[1]!*・・・* x[K]!)そして N = sum(j=1, ..., K) x[j].定義により, 各成分X[j]は, j = 1, ..., Kに対してBin(size, prob[j])として2項分布する.rmultinom() アルゴリズムは、Bin(n[j], P[j])から2項X[j]を順次に引く：= P[1] = p[1] (pは確率を和1にスケーリング), そして, j ≥ 2, recursively, n[j] = N - sum(k=1, ..., j-1) X[k]andP[j] = p[j] / (1 - sum(p[1:(j-1)]).
サイズ＝n、prob＝pの負の2項分布は密度Γ(x+n)/(Γ(n) x!) p^n (1-p)^xx for x = 0, 1, 2, ..., n > 0, 0 < p ≤ 1.これは成功の目標数に達する前に一連のベルヌーイ試行で発生する失敗の数を表します。負の2項分布は、スケールパラメータ(1 - prob)/プロバンド形状パラメータsizeを持つガンマ分布(pgammaを参照)として分布する平均を持つポアソン分布の混合として生じることもある。  (この定義では，サイズの非整数値を許す)別のパラメタリゼーション(生態学でよく使われる)は，テーマmu (上記参照)と分散パラメタsizeで，prob = size/(size+mu)である。  このパラメトリゼーションでは、分散はmu + mu^2/sizeとなります。xの要素が整数でない場合、dnbinomの結果は0となり、警告が表示されます。size == 0の場合は、0に集中した分布となります。これは、probではなくmuが一定であっても、sizeが0に近づいた場合の限界分布です。  ただし、極限分布の平均は、muの値が何であれ0であることに注意してください。分位は、F(x) ≥ pとなる最小の値xとして定義されます。
正規分布は密度f(x) = 1/(√(2 π) σ) e^-((x - μ)^2/(2 σ^2))を持ち、ここでμは分布の平均、σは標準偏差である。
ポアソン分布は密度p(x) = λ^x exp(-λ)/x!for x = 0, 1, 2, ... .平均と分散はE(X) = Var(X) = λ.λ=0は極限ケース(0^0 = 1とする)であることに注意。p(x)はLoaderのアルゴリズムを使って計算されます。indbinomのリファレンスを参照してください。分位は右連続です：qpois(p, lambda)は、P(X ≤ x) ≥ p.lower.tail=FALSEを設定すると、デフォルトのlower.tail=TRUEが1を返す場合に、より正確な結果を得ることができます。
この分布は次のようにして得られる。  xを原点に対して対称な連続分布からのサイズnの標本とする。  そしてウィルコクソンの符号付き順位統計量は、x[i]が正である絶対値x[i]の順位の合計である。  この統計量は0からn(n+1)/2の間の値をとり、その平均と分散はそれぞれn(n+1)/4とn(n+1)(2n+1)/24です。最初の2つの引数のどちらかがベクトルである場合、長い方のベクトルの長さまでの2つのすべての組み合わせについて計算を行うためにリサイクルルールが使用されます。
主な高レベル関数は、influence.measuresで、各モデル変数のDFBETAS、DFFITS、共分散比、クックの距離、ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します。  dfbetas、dffits、covratio、cooks.distance関数は、対応する診断量への直接アクセスを提供します。  関数rstandardとrstudentは、それぞれ標準化残差とスチューデント化残差を与える。(一般化線形モデルの値は、Williams (1987)で説明されているように近似値です（ただし、Cooks.distanceはカイ2乗値ではなくFとしてスケーリングされます）。  オプションのinfl、res、sd引数は、例えば、以下のような状況で、これらの直接アクセス関数の使用を奨励するためにある、重み==0のケースは、これらの関数すべてから除外されますが、na.action = na.excludeで線形モデルがフィットされた場合、フィット中に除外されたケースに対して適切な値が入力されることに注意してください。線形モデルの場合、rstandard(*, type = "predictive")は、1つ置きのクロスバリデーション残差を提供し、モデル・モデルの "PRESS "統計量（PREdictive Sum of Squares、CVスコアと同じ）を提供します。 関数hat()は、主にS（バージョン2）との互換性のために存在します。
主要な高レベル関数は，influence.measures で，これは，各モデル変数のDFBETAS，DFFITS，共分散比，クックの距離，ハット行列の対角要素を示すクラス "infl "オブジェクトの表形式表示を生成します．  dfbetas、dffits、covratio、cooks.distance関数は、対応する診断量への直接アクセスを提供します。  関数rstandardとrstudentは、それぞれ標準化残差とスチューデント化残差を与える。(一般化線形モデルの値は、Williams (1987)で説明されているように近似値です（ただし、Cooks.distanceはカイ2乗値ではなくFとしてスケーリングされます）。  オプションのinfl、res、sd引数は、例えば、以下のような状況で、これらの直接アクセス関数の使用を奨励するためにある、重み==0のケースは、これらの関数すべてから除外されますが、na.action = na.excludeで線形モデルがフィットされた場合、フィット中に除外されたケースに対して適切な値が入力されることに注意してください。線形モデルの場合、rstandard(*, type = "predictive")は、1つ置きのクロスバリデーション残差を提供し、モデルの "PRESS "統計量（PREdictive Sum of Squares、CVスコアと同じ）を提供します。
df = n自由度を持つt分布は、密度f(x) = Γ((n+1)/2)/ 平均 0 (n > 1) と分散 n/(n-2) (n > 2) を持ちます。パラメータ(df, Del) = (df, ncp)を持つ一般的な非心2次分布は，T(df, Del) := (U + Del) / √(V/df) の分布として定義される．ここでUとVは独立な確率変数で，U ~ N(0,1)，V ~ χ^2(df)である(Chisquareを参照)．T=(mX-m0)/(S/sqrt(n))ここでmXは平均、Sはi.i.d. N(μ,σ^2)であるX_1,X_2,・・・,X_nの標本標準偏差(sd)である。Tは非心t撤回f= n - 1degreeの自由度と非心パラメータerncp = (μ - m0) * sqrt(n)/σ として分布する。
一様分布は密度f(x) = 1/(max-min)for min ≤ x ≤ maxを持つ。u := min == maxの場合、X == uの極限の場合が想定されるが、この場合密度は存在せず、dunifはNaN（エラー条件）を返す。runifは、max = minまたはmax-minがminに比べて小さくない限り、極端値のどちらも生成せず、特にデフォルトの引数の場合は生成しない。
2つのアルゴリズムは、内部的には全く異なるものである：Berwin Turlachによって実装されたHärdle-Steigeralgorithm（文献参照）である。ツリーアルゴリズムが使用され、O(n * log(k))の性能を保証します。ここで、n = length(x)は漸近的に最適です。  これは漸近的に遅いO(n * k)として実行されますが, 小さいkまたはnではかなり高速です.両アルゴリズム(およびsmoothEnds()ユーティリティ)は, xが非有限項目(+/-Inf, NaN, andNA)を含む場合にも "動作 "することに注意してください:.......現在のところ、非フィニット数に対して基礎となる数学ライブラリ('libm')の演算を適用することで単純に動作します。
形状パラメータaおよびスケールパラメータbを持つワイブル分布は、x > 0に対してf(x) = (a/b) (x/b)^(a-1) exp(-(x/b)^a)で与えられる密度を持つ。累積分布関数は x > 0 で F(x) = 1 - exp(- (x/b)^a)，themean は E(X) = b Γ(1 + 1/a)，Var(X) = b^2 * (Γ(1 + 2/a) - (Γ(1 + 1/a))^2)である．
この分布は次のように得られる。  x と y を大きさ m と n の2つの無作為独立標本とすると、ウィルコクソン順位和統計量は、y[j]がx[i]より大きくないすべての組(x[i], y[j])の数です。  この統計量は0からm * nの間の値をとり、その平均と分散はそれぞれm * n / 2とm * n * (m + n + 1) / 12である。最初の3つの引数のいずれかがベクトルである場合、最長ベクトルの長さまでの3つのすべての組み合わせについて計算を行うためにリサイクルルールが使用される。
R^pのX1,...,Xm,Xiが平均(ベクトル)0、共分散行列Σを持つm個の独立な多変量ガウスの標本である場合、M = X'Xの分布はW_p(Σ, m)である。さらに、シグマがスカラー(p = 1)の場合、Wishart 分布は、自由度 df のスケーリングされたカイ2乗(chi^2)分布であり、 W_1(sigma^2, m) = sigma^2 chi[m]^2.成分ごとの分散は、 Var(M[i,j]) = m*(S[i,j]^2 + S[i,i] * S[j,j])であり、ここで S=シグマである。
loess.smoothは、xの範囲をカバーする等間隔の点でloess smoothを評価する補助関数です。
NA
長さ1または長さ0のベクトルの標準偏差はNAです。
この場合、標準誤差は最も小さい層で計算され、効率と層間の比較のために調整される。(直交対照の使用については、ヘルプのノートのコメントを参照)。  coefで使用するのに適した行列は、contrastsを呼び出し、列に因数でインデックスを付けることで見つけることができます。
nls()は、getInitialとこれらの自己開始モデル用のinitial関数を呼び出します。この関数は汎用的であり、メソッド関数はオブジェクトの特定のクラスを処理するために記述することができます。
NA
NA
後者は、NN <- nobs(object, use.fallback = use.fallback)およびPP <- sum(!is.na(coef(object))) - 以前のRバージョンでは、これはlength(coef(object))として定義されていました。
これは汎用関数です。  statsパッケージには、lmおよびglmフィットに使用される "lm "オブジェクト用のメソッドがあります。  lmまたはglm(family = "gaussian")によってフィットされる線形モデルのメソッドは、与えられた重みが誤差分散に反比例することを仮定します。  二項およびポアソンGLMでは，分散は1に固定される．  整数の事前重み w_i は、観測値i が w_i 個の観測値の平均であることを意味すると解釈できます。これは、割合として指定された2項では自然ですが、事前重みが警告とともに無視されるポアソンではそうではありません。ガンマGLMでは、形状パラメータが最尤法（パッケージMASSの関数 gamma.shapeを使用）によって推定されます。  分散は形状に反比例するので、重みの解釈は、基本的な形状パラメータに対する乗数である。逆ガウスGLMの場合、仮定されるモデルはIG(μ_i, λ w_i) (参照https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution)ここで、λはフィットに対する分散推定値の逆数によって推定される。  分散はμ_i^3/(λ w_i)であり、事前重みに反比例する。  シミュレーションは、SuppDistsパッケージのrinvGauss関数で行われます。
3は、長さ3の中央値を実行するためのTukeyの短い表記法であり、3Rは、収束するまで繰り返される3、Sは、長さ2または3の水平ストレッチの分割を意味する。したがって、3RS3Rは、3R、Sand 3R、3RSSの連結であり、3RSRは、最初に3R、次に（Sと3）収束するまで繰り返されることを意味する。
xベクトルには少なくとも4つの異なる値が含まれていなければならない。ここでいう「異なる」はtolによって制御される：同じとみなされる値は、それらの値の最初の値で置き換えられ、対応するyとwはそれに応じてプールされる。spar の代わりに lambda が指定されない限り、使用される計算λは（spar} の関数として）λ = r * 256^(3*spar - 1)であり、r = tr(X' W X) / tr(Σ)、ΣはΣ[i、j] = Integral B''[i](t) B''[j](t) dt,Xは X[i,j] = B[j](x[i]),W は重みの対角行列（そのトレースが元のオブザベーションの数である nになるようにスケーリングされる）,B[k](.これらの定義では， f_i = f(x_i)であり，B-スプライン基底表現 f = X c（すなわち．cはスプライン係数のベクトルである)，ペナルティ付き対数尤度は，L = (y - f)' W (y - f) + λ c' Σ cであり，したがってcは，(リッジ回帰)(X' W X + λ Σ) c = X' W yの解である．spar と lambdaが欠損しているかNULLの場合，dfの値がスムージングの程度を決定するために使用される．  上記の関係から、sparはspar = s0 + 0.0601 * log(λ)となり、S-PLUSのsmooth.splineの実装（sparはλに比例する）とは意図的に異なっていることに注意。  Rの(logλ)スケールでは、sparを線形に変化させる方が理にかなっています。しかし、現在のところ、sparの値が-1または-2より小さい場合、結果が非常に信頼できなくなる可能性があることに注意してください。  同様に、sparの代わりにlambdaを指定するのは微妙で、特にlambdaの「安全な」値の範囲はスケール不変ではなく、したがって完全にデータに依存するからです。一般化された」クロスバリデーション手法GCVは、xに重複点がある場合に正しく動作します。しかし、重複点がある場合に1つだけ残すクロスバリデーションが何を意味するのかは曖昧であり、内部コードでは重複点のグループを除外する近似を使用しています。
smoothEnds は，'終点スムージング'だけを行うために使用される．つまり，ウィンドウkの半分よりも始点/終点に近いオブザベーションだけを変更する．sm[1]=median(y[1], sm[2], 3*sm[2] - 2*sm[3], na.rm=TRUE).R バージョン3.6.0およびそれ以前では、yの欠損値(NA)は通常エラーにつながるが、現在はmedian(*, na.rm=TRUE)に相当するものが使用される。
NA
NA
生のピリオドグラムはスペクトル密度の一貫性のある推定量ではありませんが、隣接する値は漸近的に独立です。したがって、スペクトル密度が平滑であると仮定して、生のピリオドグラムを平滑化することによって、一貫性のある推定値を得ることができます。高速フーリエ変換を助けるために、系列の長さが高度に合成された数になるまで、系列は自動的にゼロでパディングされます。これはpad引数ではなくfast引数によって制御されます。ゼロのピリオドグラムは、系列の平均が取り除かれるため、理論的にはゼロになります（しかし、これはテーパリングによって影響を受ける可能性があります）：それは、平滑化中に隣接する値の補間によって置き換えられ、その周波数については値が返されません。
コサイン・ベル・テーパは、時系列x[, i]の最初と最後のp[i]オブザベーションに適用されます。
spectrumは、メソッドspec.pgramとspec.arを呼び出すラッパー関数です。ここでのスペクトルは、S-PLUSに従って、スケーリング1/frequency(x)で定義されます。  これはスペクトル密度を範囲(-frequency(x)/2, +frequency(x)/2]の密度にするものである。(例えば、Bloomfield)または1と範囲(-pi, pi])である。もし利用可能であれば、信頼区間がplot.specによってプロットされる: これは非対称であり、中心マークの幅は等価な帯域幅を示す。
method = "fmm "の場合、使用されるスプラインはForsythe, Malcolmand Molerのものである（データの両端の4点を通して正確な3次がフィットされ、これが終了条件を決定するために使用される）。monoH.FC "メソッドは、FritschとCarlsonの方法に従って、単調エルミートスプラインを計算します。  method "hyman "は、厳密に単調な入力に対して、method = "fmm "フィットのHymanフィルタリングを用いて単調な3次スプラインを計算します。これらの補間スプラインは，外挿，つまりxの範囲外の点での予測にも使うことができる．外挿は， method = "fmm" ではほとんど意味をなさない．
method = "fmm "の場合、使用されるスプラインはForsythe, Malcolmand Molerのものです（正確な3次曲線がデータの両端の4点を通ってフィットされ、これが終了条件を決定するために使用されます）。monoH.FC "メソッドは、FritschとCarlsonの方法に従って、単調エルミートスプラインを計算します。  method "hyman "は、厳密に単調な入力に対して、method = "fmm "フィットのHymanフィルタリングを用いて単調な3次スプラインを計算します。これらの補間スプラインは，外挿，つまりxの範囲外の点での予測にも使うことができる．外挿は， method = "fmm" ではほとんど意味をなさない．
method = "fmm "の場合、使用されるスプラインはForsythe, Malcolmand Molerのものです（正確な3次曲線がデータの両端の4点を通ってフィットされ、これが終了条件を決定するために使用されます）。monoH.FC "メソッドは、FritschとCarlsonの方法に従って、単調エルミートスプラインを計算します。  method "hyman "は、厳密に単調な入力に対して、method = "fmm "フィットのHymanフィルタリングを用いて単調な3次スプラインを計算します。これらの補間スプラインは、外挿、つまりxの範囲外の点での予測にも使うことができる。外挿は method = "fmm" ではほとんど意味をなさないが、自然スプラインでは、最も近いデータ点での補間曲線の傾きを使って線形になる。
NA
NA
NA
NA
NA
NA
NA
NA
NA
NA
このモデルはSSasympモデルを一般化したもので、pwrが単一であるときにSSasympに還元されます。
月系列1995.5はc(1995, 7)として表現される。頻度fの系列では、timen+i/fはc(n, i+1)と表現される（i = 0, f = 1の場合でも）。
NA
AICがMallowsのCpと等しくなるように加法定数を選択できる場合、これは実行され、表は適切にラベル付けされる。検索されるモデルの集合は、scope引数によって決定される。  scopeが1つの式の場合、その式は上位コンポーネントを指定し、下位モデルは空である。  スコープがない場合は、初期モデルが上位モデルとして使用されます。スコープで指定されたモデルは、update.formulaで使用されるupdateobjectのテンプレートにすることができます。  したがって、スコープ式で.を使用することは、「すでに存在するもの」を意味し、.^2は既存の項のすべての相互作用を示します。変数スケールでglmフィットを使用する場合、潜在的な問題があります。  関数extractAICの "glm "メソッドは、ガウス族に対しては適切な調整を行うが、他の場合にはビームを追加する必要があるかもしれない。  (二項族とポアソン族はデフォルトで固定スケールであり、可変スケールに対する特定の最尤問題には対応しない)。
NA
もし、s.window = "periodic "であれば、スムージングは、平均を取ることによって効果的に置き換えられます。季節値は除去され、残りはトレンドを見つけるために平滑化される。全体的なレベルは、これらの季節成分から取り除かれ、トレンド成分に加えられる。このプロセスを数回繰り返す。  残りの成分は、季節＋トレンドのフィットからの残差である。結果のクラス "stl "オブジェクトに対するいくつかのメソッドは、plot.stlを参照。
構造時系列モデルとは、（1変量）時系列をいくつかの成分に分解した（線形ガウス）状態空間モデルです。最も単純なモデルは、type = "level "で指定されるローカル・レベル・モデルである。  これは、m[t+1] = m[t] + xi[t], xi[t] ~ N(0, σ^2_ξ)によって展開する基礎レベルm[t]を持つ。オブザベーションは、x[t] = m[t] + eps[t], eps[t] ~ N(0, σ^2_eps)2つのパラメータ、σ^2_ξとσ^2_epsがある。  これはARIMA(0,1,1)モデルですが、パラメータセットに制限があります。局所線形トレンドモデル（タイプ="トレンド"）は、測定方程式を持ちますが、m[t+1] = m[t] + n[t] + xi[t], xi[t] ~ N(0, σ^2_ξ)n[t+1]=n[t] + ζ[t], ζ[t] ~ N(0,σ^2_ζ)で与えられるダイナミクス形式[t]の時間変動スロープを持ち、3つの分散パラメータを持ちます。  σ^2_ζ=0（これはローカルレベルモデルに帰着する）やσ^2_ξ=0（これは滑らかなトレンドを保証する）を見つけることは珍しいことではない。  これは制限付きARIMA(0,2,2)モデルである。基本構造モデル、タイプ = "BSM "は、季節成分を追加した局所トレンドモデルである。したがって、測定方程式は、x[t] = m[t] + s[t] + eps[t], eps[t] ~ N(0,σ^2_eps)となり、s[t]は、ダイナミクスs[t+1] = -s[t] - ...を持つ季節成分である。- s[t - s + 2] + w[t], w[t] ~ N(0, σ^2_w)境界ケースσ^2_w = 0は、決定論的な（しかし任意の）季節パターンに対応する。  (これはBSMの「ダミー変数」バージョンとして知られることもある）。
NA
print.summary.glmは、係数や標準誤差などの書式をスマートにしようとし、さらにsignif.starsがTRUEであれば'有意性の星'を表示します。結果の係数の要素は、推定係数とその推定標準誤差、そしてそれらの比率を表示します。  この3番目の列は、分散が推定されている場合は t 比、分散が既知（または族によって固定）の場合は z 比と表示される。  4番目の列は，Student t または正規参照分布に基づく t 比または z 比に対応する両側p値を与える．  (分散が既知ではなく，それを推定するための自由度が残されていない可能性がある．  相関は小数点以下2桁まで(または記号的に)表示されます: 実際の相関を見るには summary(object)$correlationdirectly を表示します。GLMの分散はフィットプロセスでは使用されませんが、標準誤差を求めるために必要です。summaryは、summary.lmでは扱われない、既知の誤差分散を持つ線形回帰のケースを扱うために、ガウスglmフィットで使用することができます。
print.summary.lmは、係数や標準誤差などの書式を工夫し、さらにsignif.starsがTRUEであれば「有意性の星印」を与えます。
summary.manovaメソッドは、要約表に多変量検定統計量を使用します。  Wilksの統計量が文献では最もポピュラーですが、デフォルトのPillai-Bartlett統計量は、Hand and Taylor (1987)によって推奨されています。  使用される近似は、S-PLUSとSAS（後者はHotelling-Lawley統計量のいくつかのケースを除いて）に従うが、他の多くの分布の近似が存在する：さらなる参照は、Anderson (1984)とKrzanowskiとMarriott(1994)を参照。  4つの近似F統計量は，検定される項の自由度が1である場合はすべて同じであるが，それ以外の場合は，Roy統計量のそれが上限となる．公差tolは，残差相関行列のQR分解に適用される（ある応答が本質的にゼロ残差を持つ場合を除き，それがスケールされていない場合）．  したがって、デフォルト値は、非常に高い相関を持つ応答から保護するものである。
NA
supsmuは、3つのスパンからラインを選択するランニングラインスムーサーです。ランニングラインスムーサーは対称で、予測点の両側にk/2個のデータ点を持ち、kの値は0.5 * n, 0.2 * n, 0.05 * nで、renはデータ点の数です。  spanが指定された場合、span * nを持つ1つのスムーザーが使用される。3つのスムーザーのうち最良のものが、各予測に対してクロスバリデーションによって選択される。FORTRANコードによると、"小さな標本(n < 40)、またはx値に近いオブザベーション間に実質的な系列相関がある場合は、あらかじめ指定された固定スパンのスムーザー(span > 0)を使用すべきである。  妥当なスパン値は0.2から0.4である "x, y または wtの値が有限でないケースは、警告とともに削除される。
NA
alternative="greater "は、xの平均がyより大きいという選択肢である。  欠損値は(pairedがTRUEの場合はペアで)静かに取り除かれる。  var.equalがTRUEの場合、分散のプール推定値が使用されます。  デフォルトでは、var.equalがFALSEの場合、分散は両方のグループで別々に推定され、自由度に対するWelch修正が使用されます。入力データが（2つの平均のうち大きい方と比較して）実質的に一定の場合、エラーが生成されます。
partial.resid=TRUEオプションの場合、モデルはtype = "partial "を受け付けるasidualsメソッドを持たなければなりません。data引数はほとんど必要ないと思われますが、場合によってはtermplotが元のデータフレームを再構築できないことがあります。na.action=na.excludeを使用すると、このような問題は起こりにくくなります。交互作用項については、何も意味がなく、エラーの原因となる可能性があります。plot = FALSEオプションは、2つの異なるモデルの結果を重ね合わせたり、信頼帯をプロットするなど、特別な操作が必要な場合に便利です。
クラス "aovlist "および "terms "の "formula"（terms.formulaを参照）用のメソッドがあります：デフォルトのメソッドは、単にオブジェクトのtermsコンポーネントを抽出するだけです。
すべてのオプションがSと同じように動作するわけではありませんし、すべてが実装されているわけでもありません。
これらはすべてジェネリック関数であり、xのtsp属性が存在すればそれを使用する。timeとcycleには、結果をそのクラスに強制するクラスts用のメソッドがある。
NA
ts関数は、時系列オブジェクトを作成するために使用されます。  これらは、"ts "クラス（および追加属性）を持つベクトルまたは行列であり、時間内の等しい間隔でサンプリングされたデータを表します。  行列の場合、行列データの各列は、1つの（単変量の）時系列を含むと仮定されます。時系列は、少なくとも1つのオブザベーションを持つ必要があり、数値である必要はありませんが、非数値系列のサポートは非常に限られています。  特に、算術演算は時間軸の整列を試み、系列の部分集合を抽出するための部分集合が使用できる（例えば、EuStockMarkets[, "DAX"]）。  ただし、最初の (または唯一の) 次元のサブセットは、行列のサブセットと同様、行列またはベクトルを返します。  tのメソッドには、系列を行列（ベクトルの場合は1列の行列）として転置するメソッドがあり、クラス "ts "を継承しない結果を返します。引数frequencyは時系列のサンプリング頻度を示し、デフォルト値1は単位時間間隔ごとに1回のサンプリングを示します。  例えば、データが毎日サンプリングされ、自然な期間が1週間である場合、frequencyに7を使用することができ、データが毎月サンプリングされ、自然な期間が1年である場合、frequencyに12を使用することができます。  4と12の値は、それぞれ四半期系列と月系列を意味する（例えば）印刷法では仮定される。  R 4.0.0からは、frequencyは整数である必要はない。  例えば、frequency = 0.2は、5つの時間単位ごとに1回サンプリングすることを意味します。  デフォルトのメソッドは、オブジェクトにtsp属性があればそれを使って開始時刻と終了時刻を設定し、frequency.is.tsはオブジェクトが時系列かどうかをテストします。  オブジェクトの特定のクラスを処理するメソッドを書くことができます。
特殊なケースとして、...は、1行のものだけでなく、存在する時系列の結合時系列と同じ長さのベクトルまたは行列を含むことができます。
NA
特殊なケースとして，...は，1行のものと同様に，存在する時系列の結合時系列と同じ長さのベクトルまたは行列を含むことができる．
これは汎用的な関数です。arimaとStructTSオブジェクトのメソッドは、（個々の）分散の推定値でスケーリングされた残差をプロットし、ポルトマンテオ検定のLjung-Boxバージョンを使用します。
tsp属性は、時間単位での開始時間、終了時間、頻度（時間単位あたりのオブザベーション数、例えば月次系列では12）を与えます。
NULLを割り当てると、tsp属性とxの "ts"（または "mts"）クラスが削除されます。
NA
分散分析で因子のレベルの平均を比較する場合、t検定を使って単純に比較すると、実際には有意差がないのに有意差があると宣言する確率が高くなります。  これは，区間が各区間について与えられた包含確率で計算されるが，包含率の解釈は通常，区間ファミリー全体に関するものであるためである．  この関数によって返される区間は，このStudentized rangestatistics に基づく．この方法で構築された区間は，因子の各水準で行われたオブザベーションの数が同じであるバランス・デザインにのみ正確に適用される．  この関数は、軽度のアンバランスデザインに対して賢明な区間を生成する標本サイズの調整を組み込んでいます。非因子の項を指定した場合、これらは警告とともに削除されます：項が残っていない場合、これはエラーです。
...の後の引数は正確に一致しなければならないことに注意してください。区間または下限と上限の両方が指定されなければなりません: 上限の端点は下限の端点よりも厳密に大きくなければなりません.デフォルトのextendInt="no "の場合、端点の関数値は反対の符号(またはゼロ)でなければなりません。  そうでない場合，extendInt="yes "であれば，符号の変化を探索するために，つまり，探索区間[l,u]がf(l) * f(u) <= 0を満たすまで，区間が両側で拡張される．fがルートx0においてどのように符号を変えるかがわかっている場合，つまり，関数がそこで増加または減少する場合，extendIntは，それぞれ "upX"（"upward crossing "の場合）または "downX "として指定することができる（そして，通常はそうすべきである）．  同様に、S:= +/- 1と定義して、解のところでS = sign(f(x0 + eps))を要求する。  この場合, 探索区間[l,u]は, S * f(l) <= 0 かつ S * f(u) >= 0 となるように拡張される可能性がある.  収束は、f(x) == 0か、アルゴリズムの1ステップにおけるxの変化がtol (xの表現誤差の許容値を加えた値)より小さい場合に宣言される。fに渡される引数は特別なセマンティクスを持ち、呼び出し間で共有されます。  関数はこれをコピーしてはならない。
NA
NA
この関数は、まず古い数式の左辺と右辺を特定します。次に新しい数式を調べ、古い数式の左辺を新しい数式の左辺にある'.'に代入し、古い数式の右辺を新しい数式の右辺にある'.'に代入します。  その結果は、terms.formula(simplify = TRUE)によって簡略化される。
入力は（is.numericによって決定されるように）数値でなければなりません："kendall "および "spearman "メソッドは、順序付けられた入力に対して意味を持ちますが、xtfrmは数値への適切な事前変換を見つけるために使用することができます。varはcovへの単なるインターフェイスであり、rena.rmはそれが指定されていない場合に使用するデフォルトを決定するために使用されます。  na.rmがTRUEであれば、完全な観測（行）が分散の計算に使用されます（use = "na.or.complete"）。  useが "everything "の場合、NAは概念的に伝播する。つまり、寄与するオブザベーションの1つがNAの場合、結果の値はNAになる。useが "all.obs "の場合、欠損オブザベーションがあるとエラーになる。  useが "complete.obs "であれば、欠損値はケースワイズド削除で処理される（そして、完全なケースがない場合はエラーになる）。"na.or.complete "は、完全なケースがない限り同じで、NAになる。この結果、共分散行列または相関行列が正半定値にならないことがあり、またその変数の組に完全な組がない場合は、NAのエントリが得られます。   covとvarの場合、"pairwise.complete.obs "は "pearson "法でのみ動作します。(等価な) var(double(0), use = *) は、use = "everything "と "na.or.complete "の場合はNAを与え、その他の場合はエラーを与えることに注意してください。cor()では、methodが "kendall "または "spearman "の場合、KendallのtauまたはSpearmanのrho統計量を使用して、順位ベースの関連尺度を推定します。  これらはより頑健であり、データが必ずしも二変量正規分布に由来しない場合に推奨されている。  spearman" は、基本的に cor(R(x), R(y)) (または cov(., .)) を計算することに注意してください。欠損値の場合，完全なオブザベーションに基づくか，各ペアの順位付けを伴うペアごとの完全性に基づくか，使用値によって順位が計算される．同値の場合，Kendall (1945)によって提案されたKendallの tau_bが計算される．共分散行列を相関行列にスケーリングする方法は多数あり，数学的には，左右の対角行列との乗算，またはweep(., FUN = "/") を2回使用することでより効率的に行うことができる．  cov2cor関数はさらに効率的で、主に教育的な理由から提供されている。
帰無仮説は、xとyが抽出された母集団の分散の比、または線形モデルxとyがフィットされたデータの分散の比がratioと等しいというものである。
NA
これらは，負荷量行列の構造を明らかにするために，因子 x %*% T の「回転」を求める．  行列T は，varimax の場合は回転（場合によっては反射を伴う）であるが，promax の場合は一般的な線形変換であり，因子の分散は保持される．
vcov()は汎用関数であり、vcov.で始まる名前の関数はこの関数のメソッドになります。この関数のメソッドを持つクラスには、lm, mlm, glm, nls, summary.lm, summary.glm, negbin, polr, rlm (MASSパッケージ), multinom (nnetパッケージ) gls, lme (nlmeパッケージ), coxph, survreg (survivalパッケージ)があります。(サマリーオブジェクトのvcov()メソッドは、summary(mod)とvcov(mod)の両方が必要な場合に、より効率的でカプセル化されたアクセスを可能にします。).vcov.aliased()は、NA係数を用いてエンコードされた特異モデルフィットを扱わなければならないvcovメソッドの実装に有用な補助関数です：この関数は、vcov-matrixvcを必要に応じてNAの行と列で補強します。つまり、aliasedのいくつかのエントリが真で、vcの次元がlength(aliased)よりも小さい場合です。
これは汎用関数であり、最初の引数xに対してメソッドを定義することができる。デフォルトのメソッド以外に、日付時刻クラス "POSIXct"、"POSIXlt"、"difftime"、"Date "に対するメソッドがある。  デフォルトのメソッドは、[, 乗算, 除算, 和が適切なメソッドを持つ数値ライクなオブジェクト(複素数ベクトルも含む)に対して動作します。wが欠損している場合、xのすべての要素に同じ重みが与えられ、そうでない場合はas.numericによって重みが数値に強制され、和が1になるように正規化されます(可能であれば: 和がゼロまたは無限の場合、値はNaNになる可能性が高い)。  しかし、重みゼロは特別に扱われ、対応するx値は合計から省略される。
重み付き残差はデビアンス残差に基づくもので、lmフィットの場合は生の残差にwi^0.5を掛けたものである。
NA
xのみが与えられた場合、またはxとyの両方が与えられ、pairedがTRUEである場合、x（1標本の場合）またはx - y（対になった2標本の場合）の分布がmuについて対称であるというWilcoxon 符号順位検定が実行されます。  この場合、帰無仮説はxとyの分布がmuの位置ずれで異なることであり、対立仮説は他の位置ずれで異なることである（そして、片側対立仮説の "より大きい "は、xがyの右にずれていることである）。デフォルトでは（正確が指定されていない場合）、標本が50未満の有限の値を含み、同値がない場合、正確なp値が計算される。  安定性の理由から、同値の判定が非常に小さな数値の差に依存しないように、丸められたデータを使用するか、digits.rank = 7に設定することが望ましいかもしれません（例を参照してください）。オプションとして（引数conf.intがtrueの場合）、ノンパラメトリック信頼区間と擬メディアン（1標本の場合）または位置パラメータx-yの差の推定値が計算されます。  (分布Fのpseudomedianは、(u+v)/2の分布の中央値であり、uとvはそれぞれ独立で、分布Fを持つ。  Hollander & Wolfe(1973)の34ページを参照)。  2標本の場合，位置パラメータの差の推定量は，中央値の差を推定するのではなく（よくある誤解），xからの標本とyからの標本の差の中央値を推定することに注意すること．  そうでない場合、返される信頼区間と点推定値は正規近似に基づく。  小さな標本では，非常に高い信頼区間カバー率を達成できないことがある．この場合、警告が表示され、より低いカバレッジを持つ区間が代用されます。x (および該当する場合はy)が有効な場合、conf.int = TRUEの場合にも信頼区間が計算できず、区間境界と推定値にNaNが含まれることがあります。
開始時刻と終了時刻はtsと同様に指定できる。新しい開始時刻または終了時刻にオブザベーションがない場合、直後の（開始）または直前の（終了）オブザベーション時刻が使用されます。置換関数はtsオブジェクト用のメソッドを持っており、（警告付きで）系列を拡張することができます。  デフォルトメソッドはありません。
開始時刻と終了時刻はtsと同様に指定できる。新しい開始時刻または終了時刻にオブザベーションがない場合、直後の（開始）または直前の（終了）オブザベーション時刻が使用されます。  デフォルトメソッドはない。
read.ftableは、ファイルから平坦な分割表を読み込みます。  ファイルがフラットテーブルの記述された表現（より正確には、列変数の名前とレベルに関するすべての情報を含むヘッダと、行変数の名前を含む行）を含む場合、それ以上の引数は必要ありません。  同様に、最初の行の唯一の項目である列変数名が1つだけのフラットテーブルも自動的に処理されます。  skipを使用してすべてのヘッダー情報をスキップし、row.var.namesとcol.varsをそれぞれ使用して行変数の名前と列変数の名前とレベルを指定することで、他の変種を処理することができます。  フラット・テーブルは、行（そしておそらく列も）ラベルが「ぼろぼろ」に表示されるのが特徴であることに注意してください。  行変数のレベルの完全なグリッドが与えられている場合は、代わりにread.tableを使用してデータを読み込み、xtabs.write.ftableを使用してこのデータから分割表を作成する必要があります。xtabs.write.ftableは、分割表の「きれいな」ASCII表現を生成するのに便利なフラットテーブルをファイルに書き込みます。  method引数で異なるバージョンが利用でき、例えばLaTeXの表を作成するのに便利である。
tableまたはxtabs(*, sparse = FALSE)によって作成された分割表オブジェクトには、基本的な情報を与え、因子の独立性についてカイ2乗検定を実行する要約メソッドがあります（chisq.test関数は現在2次元表しか扱えないことに注意してください）。式中に左辺が与えられている場合、その項目は右辺に対応するセルに単純に合計されます。これは、lhsがカウントを与えていない場合にも機能します。式中の変数が因子である場合、excludesを明示的に指定する必要があります、デフォルトのaddNAがfalseで、na.actionが指定されていない（またはNULLに設定されている）場合は、実質的にna.action = getOption("na.action", default=na.omit)が使用されることに注意してください。
