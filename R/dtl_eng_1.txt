x
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
x does not need to be integer if specified as a numeric vector,but see the comments about fractional days in the help forDates.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
The binary operator : has two meanings: for factors a:b isequivalent to interaction(a, b) (but the levels areordered and labelled differently).For other arguments from:to is equivalent to seq(from, to),and generates a sequence from from to to in steps of 1or -1.  Value to will be included if it differs fromfrom by an integer up to a numeric fuzz of about 1e-7.Non-numeric arguments are coerced internally (hence withoutdispatching methods) to numeric—complex values will have theirimaginary parts discarded with a warning.
For a package pkg, pkg::name returns the value of theexported variable name in namespace pkg, whereaspkg:::name returns the value of the internal variablename.  The package namespace will be loaded if it was notloaded before the call, but the package will not be attached to thesearch path.Specifying a variable or package that does not exist is an error.Note that pkg::name does not access the objects in theenvironment package:pkg (which does not exist until thepackage's namespace is attached): the latter may contain objects notexported from the namespace.  It can access datasets made available bylazy-loading.
For a package pkg, pkg::name returns the value of theexported variable name in namespace pkg, whereaspkg:::name returns the value of the internal variablename.  The package namespace will be loaded if it was notloaded before the call, but the package will not be attached to thesearch path.Specifying a variable or package that does not exist is an error.Note that pkg::name does not access the objects in theenvironment package:pkg (which does not exist until thepackage's namespace is attached): the latter may contain objects notexported from the namespace.  It can access datasets made available bylazy-loading.
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
The binary comparison operators are generic functions: methods can bewritten for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)Comparison of strings in character vectors is lexicographic within thestrings using the collating sequence of the locale in use: seelocales.  The collating sequence of locales such asen_US is normally different from C (which should useASCII) and can be surprising.  Beware of making any assumptionsabout the collation order: e.g. in Estonian Z comes betweenS and T, and collation is not necessarilycharacter-by-character – in Danish aa sorts as a singleletter, after z.  In Welsh ng may or may not be a singlesorting unit: if it is it follows g.  Some platforms maynot respect the locale and always sort in numerical order of the bytesin an 8-bit locale, or in Unicode code-point order for a UTF-8 locale (andmay not sort in the same order for the same language in differentcharacter sets).  Collation of non-letters (spaces, punctuation signs,hyphens, fractions and so on) is even more problematic.Character strings can be compared  with different marked encodings(see Encoding): they are translated to UTF-8 beforecomparison.Raw vectors should not really be considered to have an order, but thenumeric order of the byte representation is used.At least one of x and y must be an atomic vector, but ifthe other is a list R attempts to coerce it to the type of the atomicvector: this will succeed if the list is made up of elements of lengthone that can be coerced to the correct type.If the two arguments are atomic vectors of different types, one iscoerced to the type of the other, the (decreasing) order of precedencebeing character, complex, numeric, integer, logical and raw.Missing values (NA) and NaN values areregarded as non-comparable even to themselves, so comparisonsinvolving them will always result in NA.  Missing values canalso result when character strings are compared and one is not validin the current collation locale.Language objects such as symbols and calls are deparsed tocharacter strings before comparison.
NA
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
Function I has two main uses. In function data.frame.  Protecting an object byenclosing it in I() in a call to data.frame inhibits theconversion of character vectors to factors and the dropping ofnames, and ensures that matrices are inserted as single columns.I can also be used to protect objects which are to beadded to a data frame, or converted to a data frame viaas.data.frame.It achieves this by prepending the class "AsIs" to the object'sclasses.  Class "AsIs" has a few of its own methods, includingfor [, as.data.frame, print and format. In function formula.  There it is used toinhibit the interpretation of  operators such as "+","-", "*" and "^" as formula operators, so theyare used as arithmetical operators.  This is interpreted as a symbolby terms.formula.
Data frames can be indexed in several modes.  When [ and[[ are used with a single vector index (x[i] orx[[i]]), they index the data frame as if it were a list.  Inthis usage a drop argument is ignored, with a warning.There is no data.frame method for $, so x$nameuses the default method which treats x as a list (with partialmatching of column names if the match is unique, seeExtract).  The replacement method (for $) checksvalue for the correct number of rows, and replicates it if necessary.When [ and [[ are used with two indices (x[i, j]and x[[i, j]]) they act like indexing a matrix:  [[ canonly be used to select one element.  Note that for each selectedcolumn, xj say, typically (if it is not matrix-like), theresulting column will be xj[i], and hence rely on thecorresponding [ method, see the examples section.If [ returns a data frame it will have unique (and non-missing)row names, if necessary transforming the row names usingmake.unique.  Similarly, if columns are selected columnnames will be transformed to be unique if necessary (e.g., if columnsare selected more than once, or if more than one column of a givenname is selected if the data frame has duplicate column names).When drop = TRUE, this is applied to the subsetting of anymatrices contained in the data frame as well as to the data frame itself.The replacement methods can be used to add whole column(s) by specifyingnon-existent column(s), in which case the column(s) are added at theright-hand edge of the data frame and numerical indices must becontiguous to existing indices.  On the other hand, rows can be addedat any row after the current last row, and the columns will bein-filled with missing values.  Missing values in the indices are notallowed for replacement.For [ the replacement value can be a list: each element of thelist is used to replace (part of) one column, recycling the list asnecessary.  If columns specified by number are created, the names(if any) of the corresponding list elements are used to name thecolumns.  If the replacement is not selecting rows, list values cancontain NULL elements which will cause the correspondingcolumns to be deleted.  (See the Examples.)Matrix indexing (x[i] with a logical or a 2-column integermatrix i) using [ is not recommended.  For extraction,x is first coerced to a matrix. For replacement, logicalmatrix indices must be of the same dimension as x.Replacements are done one column at a time, with multiple typecoercions possibly taking place.Both [ and [[ extraction methods partially match rownames.  By default neither partially match column names, but [[will if exact = FALSE (and with a warning if exact =  NA).  If you want to exact matching on row names usematch, as in the examples.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
This queries the internal table that manages the DLLs.
When unused levels are dropped the ordering of the remaining levels ispreserved.If value is not in levels(x), a missing value isassigned with a warning.Any contrasts assigned to the factor are preservedunless drop = TRUE.The [[ method supports argument exact.
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
noquote returns its argument as an object of class"noquote".  There is a method for c() and subscriptmethod ("[.noquote") which ensures that the class is not lostby subsetting.  The print method (print.noquote) printscharacter strings without quotes ("...." is printed as ....).If right is specified in a call print(x, right=*), ittakes precedence over a possible right setting of x,e.g., created by x <- noquote(*, right=TRUE).These functions exist both as utilities and as an example of using (S3)class and object orientation.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
If the argument dnn is not supplied, the internal functionlist.names is called to compute the ‘dimname names’.  If thearguments in ... are named, those names are used.  For theremaining arguments, deparse.level = 0 gives an empty name,deparse.level = 1 uses the supplied argument if it is a symbol,and deparse.level = 2 will deparse the argument.Only when exclude is specified (i.e., not by default) andnon-empty, will table potentially drop levels of factorarguments.useNA controls if the table includes counts of NAvalues: the allowed values correspond to never ("no"), only if the count ispositive ("ifany") and even for zero counts ("always").Note the somewhat “pathological” case of two different kinds ofNAs which are treated differently, depending on bothuseNA and exclude, see d.patho in the‘Examples:’ below.Both exclude and useNA operate on an “all or none”basis.  If you want to control the dimensions of a multiway tableseparately, modify each argument using factor oraddNA.Non-factor arguments a are coerced via factor(a,    exclude=exclude).  Since R 3.4.0, care is taken not tocount the excluded values (where they were included in the NAcount, previously).The summary method for class "table" (used for objectscreated by table or xtabs) which gives basicinformation and performs a chi-squared test for independence offactors (note that the function chisq.test currentlyonly handles 2-d tables).
See the description of options("warn") for thecircumstances under which there is a last.warning object andwarnings() is used.  In essence this is if options(warn =    0) and warning has been called at least once.Note that the length(last.warning) is maximallygetOption("nwarnings") (at the time the warnings aregenerated) which is 50 by default.  To increase, use somethinglike It is possible that last.warning refers to the last recordedwarning and not to the last warning, for example if options(warn) hasbeen changed or if a catastrophic error occurred.
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
Data frames can be indexed in several modes.  When [ and[[ are used with a single vector index (x[i] orx[[i]]), they index the data frame as if it were a list.  Inthis usage a drop argument is ignored, with a warning.There is no data.frame method for $, so x$nameuses the default method which treats x as a list (with partialmatching of column names if the match is unique, seeExtract).  The replacement method (for $) checksvalue for the correct number of rows, and replicates it if necessary.When [ and [[ are used with two indices (x[i, j]and x[[i, j]]) they act like indexing a matrix:  [[ canonly be used to select one element.  Note that for each selectedcolumn, xj say, typically (if it is not matrix-like), theresulting column will be xj[i], and hence rely on thecorresponding [ method, see the examples section.If [ returns a data frame it will have unique (and non-missing)row names, if necessary transforming the row names usingmake.unique.  Similarly, if columns are selected columnnames will be transformed to be unique if necessary (e.g., if columnsare selected more than once, or if more than one column of a givenname is selected if the data frame has duplicate column names).When drop = TRUE, this is applied to the subsetting of anymatrices contained in the data frame as well as to the data frame itself.The replacement methods can be used to add whole column(s) by specifyingnon-existent column(s), in which case the column(s) are added at theright-hand edge of the data frame and numerical indices must becontiguous to existing indices.  On the other hand, rows can be addedat any row after the current last row, and the columns will bein-filled with missing values.  Missing values in the indices are notallowed for replacement.For [ the replacement value can be a list: each element of thelist is used to replace (part of) one column, recycling the list asnecessary.  If columns specified by number are created, the names(if any) of the corresponding list elements are used to name thecolumns.  If the replacement is not selecting rows, list values cancontain NULL elements which will cause the correspondingcolumns to be deleted.  (See the Examples.)Matrix indexing (x[i] with a logical or a 2-column integermatrix i) using [ is not recommended.  For extraction,x is first coerced to a matrix. For replacement, logicalmatrix indices must be of the same dimension as x.Replacements are done one column at a time, with multiple typecoercions possibly taking place.Both [ and [[ extraction methods partially match rownames.  By default neither partially match column names, but [[will if exact = FALSE (and with a warning if exact =  NA).  If you want to exact matching on row names usematch, as in the examples.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
When unused levels are dropped the ordering of the remaining levels ispreserved.If value is not in levels(x), a missing value isassigned with a warning.Any contrasts assigned to the factor are preservedunless drop = TRUE.The [[ method supports argument exact.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
Data frames can be indexed in several modes.  When [ and[[ are used with a single vector index (x[i] orx[[i]]), they index the data frame as if it were a list.  Inthis usage a drop argument is ignored, with a warning.There is no data.frame method for $, so x$nameuses the default method which treats x as a list (with partialmatching of column names if the match is unique, seeExtract).  The replacement method (for $) checksvalue for the correct number of rows, and replicates it if necessary.When [ and [[ are used with two indices (x[i, j]and x[[i, j]]) they act like indexing a matrix:  [[ canonly be used to select one element.  Note that for each selectedcolumn, xj say, typically (if it is not matrix-like), theresulting column will be xj[i], and hence rely on thecorresponding [ method, see the examples section.If [ returns a data frame it will have unique (and non-missing)row names, if necessary transforming the row names usingmake.unique.  Similarly, if columns are selected columnnames will be transformed to be unique if necessary (e.g., if columnsare selected more than once, or if more than one column of a givenname is selected if the data frame has duplicate column names).When drop = TRUE, this is applied to the subsetting of anymatrices contained in the data frame as well as to the data frame itself.The replacement methods can be used to add whole column(s) by specifyingnon-existent column(s), in which case the column(s) are added at theright-hand edge of the data frame and numerical indices must becontiguous to existing indices.  On the other hand, rows can be addedat any row after the current last row, and the columns will bein-filled with missing values.  Missing values in the indices are notallowed for replacement.For [ the replacement value can be a list: each element of thelist is used to replace (part of) one column, recycling the list asnecessary.  If columns specified by number are created, the names(if any) of the corresponding list elements are used to name thecolumns.  If the replacement is not selecting rows, list values cancontain NULL elements which will cause the correspondingcolumns to be deleted.  (See the Examples.)Matrix indexing (x[i] with a logical or a 2-column integermatrix i) using [ is not recommended.  For extraction,x is first coerced to a matrix. For replacement, logicalmatrix indices must be of the same dimension as x.Replacements are done one column at a time, with multiple typecoercions possibly taking place.Both [ and [[ extraction methods partially match rownames.  By default neither partially match column names, but [[will if exact = FALSE (and with a warning if exact =  NA).  If you want to exact matching on row names usematch, as in the examples.
When unused levels are dropped the ordering of the remaining levels ispreserved.If value is not in levels(x), a missing value isassigned with a warning.Any contrasts assigned to the factor are preservedunless drop = TRUE.The [[ method supports argument exact.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
Data frames can be indexed in several modes.  When [ and[[ are used with a single vector index (x[i] orx[[i]]), they index the data frame as if it were a list.  Inthis usage a drop argument is ignored, with a warning.There is no data.frame method for $, so x$nameuses the default method which treats x as a list (with partialmatching of column names if the match is unique, seeExtract).  The replacement method (for $) checksvalue for the correct number of rows, and replicates it if necessary.When [ and [[ are used with two indices (x[i, j]and x[[i, j]]) they act like indexing a matrix:  [[ canonly be used to select one element.  Note that for each selectedcolumn, xj say, typically (if it is not matrix-like), theresulting column will be xj[i], and hence rely on thecorresponding [ method, see the examples section.If [ returns a data frame it will have unique (and non-missing)row names, if necessary transforming the row names usingmake.unique.  Similarly, if columns are selected columnnames will be transformed to be unique if necessary (e.g., if columnsare selected more than once, or if more than one column of a givenname is selected if the data frame has duplicate column names).When drop = TRUE, this is applied to the subsetting of anymatrices contained in the data frame as well as to the data frame itself.The replacement methods can be used to add whole column(s) by specifyingnon-existent column(s), in which case the column(s) are added at theright-hand edge of the data frame and numerical indices must becontiguous to existing indices.  On the other hand, rows can be addedat any row after the current last row, and the columns will bein-filled with missing values.  Missing values in the indices are notallowed for replacement.For [ the replacement value can be a list: each element of thelist is used to replace (part of) one column, recycling the list asnecessary.  If columns specified by number are created, the names(if any) of the corresponding list elements are used to name thecolumns.  If the replacement is not selecting rows, list values cancontain NULL elements which will cause the correspondingcolumns to be deleted.  (See the Examples.)Matrix indexing (x[i] with a logical or a 2-column integermatrix i) using [ is not recommended.  For extraction,x is first coerced to a matrix. For replacement, logicalmatrix indices must be of the same dimension as x.Replacements are done one column at a time, with multiple typecoercions possibly taking place.Both [ and [[ extraction methods partially match rownames.  By default neither partially match column names, but [[will if exact = FALSE (and with a warning if exact =  NA).  If you want to exact matching on row names usematch, as in the examples.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
When unused levels are dropped the ordering of the remaining levels ispreserved.If value is not in levels(x), a missing value isassigned with a warning.Any contrasts assigned to the factor are preservedunless drop = TRUE.The [[ method supports argument exact.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
NA
These operators support the formal classes of package methods,and are enabled only when package methods is loaded (as perdefault).  See slot for further details, in particularfor the differences between slot() and the @ operator.It is checked that object is an S4 object (seeisS4), and it is an error to attempt to use @ onany other object.  (There is an exception for name .Data forinternal use only.)  The replacement operator checks that the slotalready exists on the object (which it should if the object is reallyfrom the class it claims to be).These are internal generic operators: see InternalMethods.
These operators support the formal classes of package methods,and are enabled only when package methods is loaded (as perdefault).  See slot for further details, in particularfor the differences between slot() and the @ operator.It is checked that object is an S4 object (seeisS4), and it is an error to attempt to use @ onany other object.  (There is an exception for name .Data forinternal use only.)  The replacement operator checks that the slotalready exists on the object (which it should if the object is reallyfrom the class it claims to be).These are internal generic operators: see InternalMethods.
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
When a vector is promoted to a matrix, its names are notpromoted to row or column names, unlike as.matrix.Promotion of a vector to a 1-row or 1-column matrix happens when oneof the two choices allows x and y to get conformabledimensions.This operator is S4 generic but not S3 generic.  S4 methods need to bewritten for a function of two arguments named x and y.
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
%in% is currently defined as "%in%" <- function(x, table) match(x, table, nomatch = 0) > 0Factors, raw vectors and lists are converted to character vectors, andthen x and table are coerced to a common type (the laterof the two types in R's ordering, logical < integer < numeric <complex < character) before matching.  If incomparables haspositive length it is coerced to the common type.Matching for lists is potentially very slow and best avoided except insimple cases.Exactly what matches what is to some extent a matter of definition.For all types, NA matches NA and no other value.For real and complex values, NaN values are regardedas matching any other NaN value, but not matching NA,where for complex x, real and imaginary parts must match both(unless containing at least one NA).Character strings will be compared as byte sequences if any input ismarked as "bytes", and otherwise are regarded as equal if they arein different encodings but would agree when translated to UTF-8 (seeEncoding).That %in% never returns NA makes it particularlyuseful in if conditions.
X and Y must be suitable arguments for FUN.  Eachwill be extended by rep to length the products of thelengths of X and Y before FUN is called.FUN is called with these two extended vectors as arguments(plus any arguments in ...).  It must be a vectorizedfunction (or the name of one) expecting at least two arguments andreturning a value with the same length as the first (and the second).Where they exist, the [dim]names of X and Y will becopied to the answer, and a dimension assigned which is theconcatenation of the dimensions of X and Y (or lengthsif dimensions do not exist).FUN = "*" is handled as a special case viaas.vector(X) %*% t(as.vector(Y)), and is intended only fornumeric vectors and arrays.%o% is binary operator providing a wrapper forouter(x, y, "*").
If X and Y do not have the same number ofdimensions, the smaller array is padded with dimensions of sizeone.  The returned array comprises submatrices constructed bytaking X one term at a time and expanding that term asFUN(x, Y, ...).%x% is an alias for kronecker (whereFUN is hardwired to "*").
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
The unary and binary arithmetic operators are generic functions:methods can be written for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)If applied to arrays the result will be an array if this is sensible(for example it will not if the recycling rule has been invoked).Logical vectors will be coerced to integer or numeric vectors,FALSE having value zero and TRUE having value one.1 ^ y and y ^ 0 are 1, always.x ^ y should also give the proper limit result wheneither (numeric) argument is infinite (one of Inf or-Inf).Objects such as arrays or time-series can be operated on thisway provided they are conformable.For double arguments, %% can be subject to catastrophic loss ofaccuracy if x is much larger than y, and a warning isgiven if this is detected.%% and x %/% y can be used for non-integer y,e.g. 1 %/% 0.2, but the results are subject to representationerror and so may be platform-dependent.  Because the IEC 60559representation of 0.2 is a binary fraction slightly larger than0.2, the answer to 1 %/% 0.2 should be 4 butmost platforms give 5.Users are sometimes surprised by the value returned, for example why(-8)^(1/3) is NaN.  For double inputs, R makesuse of IEC 60559 arithmetic on all platforms, together with the Csystem function pow for the ^ operator.  The relevantstandards define the result in many corner cases.  In particular, theresult in the example above is mandated by the C99 standard.  On manyUnix-alike systems the command man pow gives details of thevalues in a large number of corner cases.Arithmetic on type double in R is supposed to be done in‘round to nearest, ties to even’ mode, but this does depend onthe compiler and FPU being set up correctly.
x does not need to be integer if specified as a numeric vector,but see the comments about fractional days in the help forDates.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
The binary comparison operators are generic functions: methods can bewritten for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)Comparison of strings in character vectors is lexicographic within thestrings using the collating sequence of the locale in use: seelocales.  The collating sequence of locales such asen_US is normally different from C (which should useASCII) and can be surprising.  Beware of making any assumptionsabout the collation order: e.g. in Estonian Z comes betweenS and T, and collation is not necessarilycharacter-by-character – in Danish aa sorts as a singleletter, after z.  In Welsh ng may or may not be a singlesorting unit: if it is it follows g.  Some platforms maynot respect the locale and always sort in numerical order of the bytesin an 8-bit locale, or in Unicode code-point order for a UTF-8 locale (andmay not sort in the same order for the same language in differentcharacter sets).  Collation of non-letters (spaces, punctuation signs,hyphens, fractions and so on) is even more problematic.Character strings can be compared  with different marked encodings(see Encoding): they are translated to UTF-8 beforecomparison.Raw vectors should not really be considered to have an order, but thenumeric order of the byte representation is used.At least one of x and y must be an atomic vector, but ifthe other is a list R attempts to coerce it to the type of the atomicvector: this will succeed if the list is made up of elements of lengthone that can be coerced to the correct type.If the two arguments are atomic vectors of different types, one iscoerced to the type of the other, the (decreasing) order of precedencebeing character, complex, numeric, integer, logical and raw.Missing values (NA) and NaN values areregarded as non-comparable even to themselves, so comparisonsinvolving them will always result in NA.  Missing values canalso result when character strings are compared and one is not validin the current collation locale.Language objects such as symbols and calls are deparsed tocharacter strings before comparison.
There are three different assignment operators: two of themhave leftwards and rightwards forms.The operators <- and = assign into the environment inwhich they are evaluated.  The  operator <- can be usedanywhere, whereas the operator = is only allowed at the toplevel (e.g., in the complete expression typed at the command prompt)or as one of the subexpressions in a braced list of expressions.The operators <<- and ->> are normally only used infunctions, and cause a search to be made through parent environmentsfor an existing definition of the variable being assigned.  If sucha variable is found (and its binding is not locked) then its valueis redefined, otherwise assignment takes place in the globalenvironment.  Note that their semantics differ from that in the Slanguage, but are useful in conjunction with the scoping rules ofR.  See ‘The R Language Definition’ manual for furtherdetails and examples.In all the assignment operator expressions, x can be a nameor an expression defining a part of an object to be replaced (e.g.,z[[1]]).  A syntactic name does not need to be quoted,though it can be (preferably by backticks).The leftwards forms of assignment <- = <<- group right to left,the other from left to right.
There are three different assignment operators: two of themhave leftwards and rightwards forms.The operators <- and = assign into the environment inwhich they are evaluated.  The  operator <- can be usedanywhere, whereas the operator = is only allowed at the toplevel (e.g., in the complete expression typed at the command prompt)or as one of the subexpressions in a braced list of expressions.The operators <<- and ->> are normally only used infunctions, and cause a search to be made through parent environmentsfor an existing definition of the variable being assigned.  If sucha variable is found (and its binding is not locked) then its valueis redefined, otherwise assignment takes place in the globalenvironment.  Note that their semantics differ from that in the Slanguage, but are useful in conjunction with the scoping rules ofR.  See ‘The R Language Definition’ manual for furtherdetails and examples.In all the assignment operator expressions, x can be a nameor an expression defining a part of an object to be replaced (e.g.,z[[1]]).  A syntactic name does not need to be quoted,though it can be (preferably by backticks).The leftwards forms of assignment <- = <<- group right to left,the other from left to right.
The binary comparison operators are generic functions: methods can bewritten for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)Comparison of strings in character vectors is lexicographic within thestrings using the collating sequence of the locale in use: seelocales.  The collating sequence of locales such asen_US is normally different from C (which should useASCII) and can be surprising.  Beware of making any assumptionsabout the collation order: e.g. in Estonian Z comes betweenS and T, and collation is not necessarilycharacter-by-character – in Danish aa sorts as a singleletter, after z.  In Welsh ng may or may not be a singlesorting unit: if it is it follows g.  Some platforms maynot respect the locale and always sort in numerical order of the bytesin an 8-bit locale, or in Unicode code-point order for a UTF-8 locale (andmay not sort in the same order for the same language in differentcharacter sets).  Collation of non-letters (spaces, punctuation signs,hyphens, fractions and so on) is even more problematic.Character strings can be compared  with different marked encodings(see Encoding): they are translated to UTF-8 beforecomparison.Raw vectors should not really be considered to have an order, but thenumeric order of the byte representation is used.At least one of x and y must be an atomic vector, but ifthe other is a list R attempts to coerce it to the type of the atomicvector: this will succeed if the list is made up of elements of lengthone that can be coerced to the correct type.If the two arguments are atomic vectors of different types, one iscoerced to the type of the other, the (decreasing) order of precedencebeing character, complex, numeric, integer, logical and raw.Missing values (NA) and NaN values areregarded as non-comparable even to themselves, so comparisonsinvolving them will always result in NA.  Missing values canalso result when character strings are compared and one is not validin the current collation locale.Language objects such as symbols and calls are deparsed tocharacter strings before comparison.
There are three different assignment operators: two of themhave leftwards and rightwards forms.The operators <- and = assign into the environment inwhich they are evaluated.  The  operator <- can be usedanywhere, whereas the operator = is only allowed at the toplevel (e.g., in the complete expression typed at the command prompt)or as one of the subexpressions in a braced list of expressions.The operators <<- and ->> are normally only used infunctions, and cause a search to be made through parent environmentsfor an existing definition of the variable being assigned.  If sucha variable is found (and its binding is not locked) then its valueis redefined, otherwise assignment takes place in the globalenvironment.  Note that their semantics differ from that in the Slanguage, but are useful in conjunction with the scoping rules ofR.  See ‘The R Language Definition’ manual for furtherdetails and examples.In all the assignment operator expressions, x can be a nameor an expression defining a part of an object to be replaced (e.g.,z[[1]]).  A syntactic name does not need to be quoted,though it can be (preferably by backticks).The leftwards forms of assignment <- = <<- group right to left,the other from left to right.
The binary comparison operators are generic functions: methods can bewritten for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)Comparison of strings in character vectors is lexicographic within thestrings using the collating sequence of the locale in use: seelocales.  The collating sequence of locales such asen_US is normally different from C (which should useASCII) and can be surprising.  Beware of making any assumptionsabout the collation order: e.g. in Estonian Z comes betweenS and T, and collation is not necessarilycharacter-by-character – in Danish aa sorts as a singleletter, after z.  In Welsh ng may or may not be a singlesorting unit: if it is it follows g.  Some platforms maynot respect the locale and always sort in numerical order of the bytesin an 8-bit locale, or in Unicode code-point order for a UTF-8 locale (andmay not sort in the same order for the same language in differentcharacter sets).  Collation of non-letters (spaces, punctuation signs,hyphens, fractions and so on) is even more problematic.Character strings can be compared  with different marked encodings(see Encoding): they are translated to UTF-8 beforecomparison.Raw vectors should not really be considered to have an order, but thenumeric order of the byte representation is used.At least one of x and y must be an atomic vector, but ifthe other is a list R attempts to coerce it to the type of the atomicvector: this will succeed if the list is made up of elements of lengthone that can be coerced to the correct type.If the two arguments are atomic vectors of different types, one iscoerced to the type of the other, the (decreasing) order of precedencebeing character, complex, numeric, integer, logical and raw.Missing values (NA) and NaN values areregarded as non-comparable even to themselves, so comparisonsinvolving them will always result in NA.  Missing values canalso result when character strings are compared and one is not validin the current collation locale.Language objects such as symbols and calls are deparsed tocharacter strings before comparison.
The binary comparison operators are generic functions: methods can bewritten for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)Comparison of strings in character vectors is lexicographic within thestrings using the collating sequence of the locale in use: seelocales.  The collating sequence of locales such asen_US is normally different from C (which should useASCII) and can be surprising.  Beware of making any assumptionsabout the collation order: e.g. in Estonian Z comes betweenS and T, and collation is not necessarilycharacter-by-character – in Danish aa sorts as a singleletter, after z.  In Welsh ng may or may not be a singlesorting unit: if it is it follows g.  Some platforms maynot respect the locale and always sort in numerical order of the bytesin an 8-bit locale, or in Unicode code-point order for a UTF-8 locale (andmay not sort in the same order for the same language in differentcharacter sets).  Collation of non-letters (spaces, punctuation signs,hyphens, fractions and so on) is even more problematic.Character strings can be compared  with different marked encodings(see Encoding): they are translated to UTF-8 beforecomparison.Raw vectors should not really be considered to have an order, but thenumeric order of the byte representation is used.At least one of x and y must be an atomic vector, but ifthe other is a list R attempts to coerce it to the type of the atomicvector: this will succeed if the list is made up of elements of lengthone that can be coerced to the correct type.If the two arguments are atomic vectors of different types, one iscoerced to the type of the other, the (decreasing) order of precedencebeing character, complex, numeric, integer, logical and raw.Missing values (NA) and NaN values areregarded as non-comparable even to themselves, so comparisonsinvolving them will always result in NA.  Missing values canalso result when character strings are compared and one is not validin the current collation locale.Language objects such as symbols and calls are deparsed tocharacter strings before comparison.
The binary comparison operators are generic functions: methods can bewritten for them individually or via theOps group generic function.  (SeeOps for how dispatch is computed.)Comparison of strings in character vectors is lexicographic within thestrings using the collating sequence of the locale in use: seelocales.  The collating sequence of locales such asen_US is normally different from C (which should useASCII) and can be surprising.  Beware of making any assumptionsabout the collation order: e.g. in Estonian Z comes betweenS and T, and collation is not necessarilycharacter-by-character – in Danish aa sorts as a singleletter, after z.  In Welsh ng may or may not be a singlesorting unit: if it is it follows g.  Some platforms maynot respect the locale and always sort in numerical order of the bytesin an 8-bit locale, or in Unicode code-point order for a UTF-8 locale (andmay not sort in the same order for the same language in differentcharacter sets).  Collation of non-letters (spaces, punctuation signs,hyphens, fractions and so on) is even more problematic.Character strings can be compared  with different marked encodings(see Encoding): they are translated to UTF-8 beforecomparison.Raw vectors should not really be considered to have an order, but thenumeric order of the byte representation is used.At least one of x and y must be an atomic vector, but ifthe other is a list R attempts to coerce it to the type of the atomicvector: this will succeed if the list is made up of elements of lengthone that can be coerced to the correct type.If the two arguments are atomic vectors of different types, one iscoerced to the type of the other, the (decreasing) order of precedencebeing character, complex, numeric, integer, logical and raw.Missing values (NA) and NaN values areregarded as non-comparable even to themselves, so comparisonsinvolving them will always result in NA.  Missing values canalso result when character strings are compared and one is not validin the current collation locale.Language objects such as symbols and calls are deparsed tocharacter strings before comparison.
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
The left-hand side is optional, and one-sided formulae are used insome contexts.A formula has mode call.  It can be subsetted by[[: the components are ~, the left-hand side (ifpresent) and the right-hand side in that order.
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
This queries the internal table that manages the DLLs.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
Data frames can be indexed in several modes.  When [ and[[ are used with a single vector index (x[i] orx[[i]]), they index the data frame as if it were a list.  Inthis usage a drop argument is ignored, with a warning.There is no data.frame method for $, so x$nameuses the default method which treats x as a list (with partialmatching of column names if the match is unique, seeExtract).  The replacement method (for $) checksvalue for the correct number of rows, and replicates it if necessary.When [ and [[ are used with two indices (x[i, j]and x[[i, j]]) they act like indexing a matrix:  [[ canonly be used to select one element.  Note that for each selectedcolumn, xj say, typically (if it is not matrix-like), theresulting column will be xj[i], and hence rely on thecorresponding [ method, see the examples section.If [ returns a data frame it will have unique (and non-missing)row names, if necessary transforming the row names usingmake.unique.  Similarly, if columns are selected columnnames will be transformed to be unique if necessary (e.g., if columnsare selected more than once, or if more than one column of a givenname is selected if the data frame has duplicate column names).When drop = TRUE, this is applied to the subsetting of anymatrices contained in the data frame as well as to the data frame itself.The replacement methods can be used to add whole column(s) by specifyingnon-existent column(s), in which case the column(s) are added at theright-hand edge of the data frame and numerical indices must becontiguous to existing indices.  On the other hand, rows can be addedat any row after the current last row, and the columns will bein-filled with missing values.  Missing values in the indices are notallowed for replacement.For [ the replacement value can be a list: each element of thelist is used to replace (part of) one column, recycling the list asnecessary.  If columns specified by number are created, the names(if any) of the corresponding list elements are used to name thecolumns.  If the replacement is not selecting rows, list values cancontain NULL elements which will cause the correspondingcolumns to be deleted.  (See the Examples.)Matrix indexing (x[i] with a logical or a 2-column integermatrix i) using [ is not recommended.  For extraction,x is first coerced to a matrix. For replacement, logicalmatrix indices must be of the same dimension as x.Replacements are done one column at a time, with multiple typecoercions possibly taking place.Both [ and [[ extraction methods partially match rownames.  By default neither partially match column names, but [[will if exact = FALSE (and with a warning if exact =  NA).  If you want to exact matching on row names usematch, as in the examples.
The default algorithm (method = "left.kept") used is similarto that of S.  For a single string it works as follows.First spaces at the ends of the string are stripped.Then (if necessary) any other spaces are stripped.Next, lower case vowels are removed followed by lower case consonants.Finally if the abbreviation is still longer than minlengthupper case letters and symbols are stripped.Characters are always stripped from the end of the strings first.  Ifan element of names.arg contains more than one word (words areseparated by spaces) then at least one letter from each word will beretained.Missing (NA) values are unaltered.If use.classes is FALSE then the only distinction is tobe between letters and space.
These are internal generic primitive functions: methodscan be defined for them individually or via theMath group generic.  For complexarguments (and the default method), z, abs(z) ==  Mod(z) and sqrt(z) == z^0.5.abs(x) returns an integer vector when x isinteger or logical.
The arc-tangent of two arguments atan2(y, x) returns the anglebetween the x-axis and the vector from the origin to (x, y),i.e., for positive arguments atan2(y, x) == atan(y/x).Angles are in radians, not degrees, for the standard versions (i.e., aright angle is π/2), and in ‘half-rotations’ forcospi etc.cospi(x), sinpi(x), and tanpi(x) are accuratefor x values which are multiples of a half.All except atan2 are internal generic primitivefunctions: methods can be defined for them individually or via theMath group generic.These are all wrappers to system calls of the same name (with prefixc for complex arguments) where available.  (cospi,sinpi, and tanpi are part of a C11 extensionand provided by e.g. macOS and Solaris: where not yetavailable call to cos etc are used, with special casesfor  multiples of a half.)
These are internal generic primitive functions: methodscan be defined for them individually or via theMath group generic.Branch cuts are consistent with the inverse trigonometric functionsasin et seq, and agree with those defined in Abramowitzand Stegun, figure 4.7, page 86.   The behaviour actually on the cutsfollows the C99 standard which requires continuity coming round theendpoint in a counter-clockwise direction.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
Top-level tasks are individual expressionsrather than entire lines of input.  Thus an inputline of the form expression1 ; expression2will give rise to 2 top-level tasks.A top-level task callback is called with the expression for thetop-level task, the result of the top-level task, a logical valueindicating whether it was successfully completed or not (always TRUEat present), and a logical value indicating whether the result wasprinted or not.  If the data argument was specified in the callto addTaskCallback, that value is given as the fifth argument.The callback function should return a logical value.If the value is FALSE, the callback is removed from the tasklist and will not be called again by this mechanism.If the function returns TRUE, it is kept in the list andwill be called on the completion of the next top-level task.
The Levenshtein edit distance is used as measure of approximateness:it is the (possibly cost-weighted) total number of insertions,deletions and substitutions required to transform one string intoanother.This uses the tre code by Ville Laurikari(https://github.com/laurikari/tre), which supports MBCScharacter matching.The main effect of useBytes is to avoid errors/warnings aboutinvalid inputs and spurious matches in multibyte locales.It inhibits the conversion of inputs with marked encodings, and isforced if any input is found which is marked as "bytes" (seeEncoding).
The Levenshtein edit distance is used as measure of approximateness:it is the (possibly cost-weighted) total number of insertions,deletions and substitutions required to transform one string intoanother.This uses the tre code by Ville Laurikari(https://github.com/laurikari/tre), which supports MBCScharacter matching.The main effect of useBytes is to avoid errors/warnings aboutinvalid inputs and spurious matches in multibyte locales.It inhibits the conversion of inputs with marked encodings, and isforced if any input is found which is marked as "bytes" (seeEncoding).
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
This is a generic function: methods can be defined for itdirectly or via the Summary group generic.For this to work properly, the arguments ... should beunnamed, and dispatch is on the first argument.Coercion of types other than integer (raw, double, complex, character,list) gives a warning as this is often unintentional.This is a primitive function.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
These functions differ only in the default values for theirarguments.
These functions differ only in the default values for theirarguments.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
This is a generic function: methods can be defined for itdirectly or via the Summary group generic.For this to work properly, the arguments ... should beunnamed, and dispatch is on the first argument.Coercion of types other than integer (raw, double, complex, character,list) gives a warning as this is often unintentional.This is a primitive function.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
The NA of character type is distinct from the string"NA".  Programmers who need to specify an explicit missingstring should use NA_character_ (rather than "NA") or setelements to NA using is.na<-.is.na and anyNA are generic: you can writemethods to handle specific classes of objects, seeInternalMethods.Function is.na<- may provide a safer way to set missingness.It behaves differently for factors, for example.Numerical computations using NA will normally result inNA: a possible exception is where NaN is alsoinvolved, in which case either might result (which may depend onthe R platform).  However, this is not guaranteed and future CPUsand/or compilers may behave differently. Dynamic binary translation mayalso impact this behavior (with valgrind, computations using NAmay result in NaN even when no NaN is involved).Logical computations treat NA as a missing TRUE/FALSEvalue, and so may return TRUE or FALSE if the expressiondoes not depend on the NA operand.The default method for anyNA handles atomic vectors without aclass and NULL.  It calls any(is.na(x)) on objects withclasses and for recursive = FALSE, on lists and pairlists.
The NA of character type is distinct from the string"NA".  Programmers who need to specify an explicit missingstring should use NA_character_ (rather than "NA") or setelements to NA using is.na<-.is.na and anyNA are generic: you can writemethods to handle specific classes of objects, seeInternalMethods.Function is.na<- may provide a safer way to set missingness.It behaves differently for factors, for example.Numerical computations using NA will normally result inNA: a possible exception is where NaN is alsoinvolved, in which case either might result (which may depend onthe R platform).  However, this is not guaranteed and future CPUsand/or compilers may behave differently. Dynamic binary translation mayalso impact this behavior (with valgrind, computations using NAmay result in NaN even when no NaN is involved).Logical computations treat NA as a missing TRUE/FALSEvalue, and so may return TRUE or FALSE if the expressiondoes not depend on the NA operand.The default method for anyNA handles atomic vectors without aclass and NULL.  It calls any(is.na(x)) on objects withclasses and for recursive = FALSE, on lists and pairlists.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
NA
NA
NA
NA
If X is not an array but an object of a class with a non-nulldim value (such as a data frame), apply attemptsto coerce it to an array via as.matrix if it is two-dimensional(e.g., a data frame) or via as.array.FUN is found by a call to match.fun and typicallyis either a function or a symbol (e.g., a backquoted name) or acharacter string specifying a function to be searched for from theenvironment of the call to apply.Arguments in ... cannot have the same name as any of theother arguments, and care may be needed to avoid partial matching toMARGIN or FUN.  In general-purpose code it is goodpractice to name the first three arguments if ... is passedthrough: this both avoids partial matching to MARGINor FUN and ensures that a sensible error message is given ifarguments named X, MARGIN or FUN are passedthrough ....
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
This function is mainly used interactively to print the argument listof a function.  For programming, consider using formalsinstead.
An array in R can have one, two or more dimensions.  It is simply avector which is stored with additional attributes giving thedimensions (attribute "dim") and optionally names for thosedimensions (attribute "dimnames").A two-dimensional array is the same thing as a matrix.One-dimensional arrays often look like vectors, but may be handleddifferently by some functions: str does distinguishthem in recent versions of R.The "dim" attribute is an integer vector of length one or morecontaining non-negative values: the product of the values must matchthe length of the array.The "dimnames" attribute is optional: if present it is a listwith one component for each dimension, either NULL or acharacter vector of the length given by the element of the"dim" attribute for that dimension.is.array is a primitive function.For a list array, the print methods prints entries of lengthnot one in the form integer,7 indicating the type and length.
NA
An array in R can have one, two or more dimensions.  It is simply avector which is stored with additional attributes giving thedimensions (attribute "dim") and optionally names for thosedimensions (attribute "dimnames").A two-dimensional array is the same thing as a matrix.One-dimensional arrays often look like vectors, but may be handleddifferently by some functions: str does distinguishthem in recent versions of R.The "dim" attribute is an integer vector of length one or morecontaining non-negative values: the product of the values must matchthe length of the array.The "dimnames" attribute is optional: if present it is a listwith one component for each dimension, either NULL or acharacter vector of the length given by the element of the"dim" attribute for that dimension.is.array is a primitive function.For a list array, the print methods prints entries of lengthnot one in the form integer,7 indicating the type and length.
An array in R can have one, two or more dimensions.  It is simply avector which is stored with additional attributes giving thedimensions (attribute "dim") and optionally names for thosedimensions (attribute "dimnames").A two-dimensional array is the same thing as a matrix.One-dimensional arrays often look like vectors, but may be handleddifferently by some functions: str does distinguishthem in recent versions of R.The "dim" attribute is an integer vector of length one or morecontaining non-negative values: the product of the values must matchthe length of the array.The "dimnames" attribute is optional: if present it is a listwith one component for each dimension, either NULL or acharacter vector of the length given by the element of the"dim" attribute for that dimension.is.array is a primitive function.For a list array, the print methods prints entries of lengthnot one in the form integer,7 indicating the type and length.
returns an unevaluated function call, that is, anunevaluated expression which consists of the named function applied tothe given arguments (name must be a string which givesthe name of a function to be called).  Note that although the call isunevaluated, the arguments ... are evaluated.call is a primitive, so the first argument istaken as name and the remaining arguments as arguments for theconstructed call: if the first argument is named the name mustpartially match name.is used to determine whether x is a call (i.e.,of mode "call" or "(").  Note thatis.call(x) is strictly equivalent totypeof(x) == "language".is.language() is also true for calls (but alsofor symbols and expressions whereis.call() is false).Objects of mode "list" can be coerced to mode "call".The first element of the list becomes the function part of the call,so should be a function or the name of one (as a symbol; a character string will not do).If you think of using as.call(<string>), consider usingstr2lang(*) which is an efficient version ofparse(text=*).Note that call() and as.call(), whenapplicable, are much preferable to these parse() basedapproaches.All three are primitive functions.as.call is generic: you can write methods to handle specificclasses of objects, see InternalMethods.
as.character and is.character are generic: you canwrite methods to handle specific classes of objects,see InternalMethods.  Further, for as.character thedefault method calls as.vector, so dispatch is first onmethods for as.character and then for methods for as.vector.as.character represents real and complex numbers to 15 significantdigits (technically the compiler's setting of the ISO C constantDBL_DIG, which will be 15 on machines supporting IEC60559arithmetic according to the C99 standard).  This ensures that all thedigits in the result will be reliable (and not the result ofrepresentation error), but does mean that conversion to character andback to numeric may change the number.  If you want to convert numbersto character with the maximum possible precision, useformat.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
as.character and is.character are generic: you canwrite methods to handle specific classes of objects,see InternalMethods.  Further, for as.character thedefault method calls as.vector, so dispatch is first onmethods for as.character and then for methods for as.vector.as.character represents real and complex numbers to 15 significantdigits (technically the compiler's setting of the ISO C constantDBL_DIG, which will be 15 on machines supporting IEC60559arithmetic according to the C99 standard).  This ensures that all thedigits in the result will be reliable (and not the result ofrepresentation error), but does mean that conversion to character andback to numeric may change the number.  If you want to convert numbersto character with the maximum possible precision, useformat.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
as.character and is.character are generic: you canwrite methods to handle specific classes of objects,see InternalMethods.  Further, for as.character thedefault method calls as.vector, so dispatch is first onmethods for as.character and then for methods for as.vector.as.character represents real and complex numbers to 15 significantdigits (technically the compiler's setting of the ISO C constantDBL_DIG, which will be 15 on machines supporting IEC60559arithmetic according to the C99 standard).  This ensures that all thedigits in the result will be reliable (and not the result ofrepresentation error), but does mean that conversion to character andback to numeric may change the number.  If you want to convert numbersto character with the maximum possible precision, useformat.
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
The format and as.character methods and strftimeconvert objects from the classes "POSIXlt" and"POSIXct" to character vectors.strptime converts character vectors to class "POSIXlt":its input x is first converted by as.character.Each input string is processed as far as necessary for the formatspecified: any trailing characters are ignored.strftime is a wrapper for format.POSIXlt, and it andformat.POSIXct first convert to class "POSIXlt" bycalling as.POSIXlt (so they also work for class"Date").  Note that only that conversion depends on thetime zone.The usual vector re-cycling rules are applied to x andformat so the answer will be of length of the longer of thesevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months, the AM/PM indicator (if used) and the separators in outputformats such as %x and %X, via the setting ofthe LC_TIME locale category.  The ‘currentlocale’ of the descriptions might mean the locale in use at the startof the R session or when these functions are first used.  (For input,the locale-specific conversions can be changed by callingSys.setlocale with category LC_TIME (orLC_ALL).  For output, what happens depends on the OS butusually works.)The details of the formats are platform-specific, but the following arelikely to be widely available: most are defined by the POSIX standard.A conversion specification is introduced by %, usuallyfollowed by a single letter or O or E and then a singleletter.  Any character in the format string not part of a conversionspecification is interpreted literally (and %% gives%).  Widely implemented conversion specifications includeAbbreviated weekday name in the currentlocale on this platform.  (Also matches full name on input:in some locales there are no abbreviations of names.)Full weekday name in the current locale.  (Alsomatches abbreviated name on input.)Abbreviated month name in the current locale onthis platform.  (Also matches full name on input: insome locales there are no abbreviations of names.)Full month name in the current locale.  (Alsomatches abbreviated name on input.)Date and time.   Locale-specific on output,"%a %b %e %H:%M:%S %Y" on input.Century (00–99): the integer part of the yeardivided by 100.Day of the month as decimal number (01–31).Date format such as %m/%d/%y: the C99standard says it should be that exact format (but not all OSescomply).Day of the month as decimal number (1–31), witha leading space for a single-digit number.Equivalent to %Y-%m-%d (the ISO 8601 dateformat).The last two digits of the week-based year(see %V).  (Accepted but ignored on input.)The week-based year (see %V) as a decimalnumber.  (Accepted but ignored on input.)Equivalent to %b.Hours as decimal number (00–23).  As a specialexception strings such as 24:00:00 are accepted for input,since ISO 8601 allows these.Hours as decimal number (01–12).Day of year as decimal number (001–366):  Forinput, 366 is only valid in a leap year.Month as decimal number (01–12).Minute as decimal number (00–59).Newline on output, arbitrary whitespace on input.AM/PM indicator in the locale.  Used inconjunction with %I and not with %H.  Anempty string in some locales (for example on some OSes,non-English European locales including Russia). The behaviour isundefined if used for input in such a locale.Some platforms accept %P for output, which uses a lower-caseversion (%p may also use lower case): others will outputP.For output, the 12-hour clock time (using thelocale's AM or PM): only defined in some locales, and on some OSesmisleading in locales which do not define an AM/PM indicator.For input, equivalent to %I:%M:%S %p.Equivalent to %H:%M.Second as integer (00–61), allowing forup to two leap-seconds (but POSIX-compliant implementationswill ignore leap seconds).Tab on output, arbitrary whitespace on input.Equivalent to %H:%M:%S.Weekday as a decimal number (1–7, Monday is 1).Week of the year as decimal number (00–53) usingSunday as the first day 1 of the week (and typically with thefirst Sunday of the year as day 1 of week 1).  The US convention.Week of the year as decimal number (01–53) asdefined in ISO 8601.If the week (starting on Monday) containing 1 January has four ormore days in the new year, then it is considered week 1.  Otherwise, itis the last week of the previous year, and the next week is week1.  (Accepted but ignored on input.)Weekday as decimal number (0–6, Sunday is 0).Week of the year as decimal number (00–53) usingMonday as the first day of week (and typically with thefirst Monday of the year as day 1 of week 1).  The UK convention.Date.  Locale-specific on output,"%y/%m/%d" on input.Time.  Locale-specific on output,"%H:%M:%S" on input.Year without century (00–99).  On input, values00 to 68 are prefixed by 20 and 69 to 99 by 19 – that is thebehaviour specified by the 2018 POSIX standard, but it doesalso say ‘it is expected that in a future version thedefault century inferred from a 2-digit year will change’.Year with century.  Note that whereas there was nozero in the original Gregorian calendar, ISO 8601:2004 defines itto be valid (interpreted as 1BC): seehttps://en.wikipedia.org/wiki/0_(year).  However, the standardsalso say that years before 1582 in its calendar should only be usedwith agreement of the parties involved.For input, only years 0:9999 are accepted.Signed offset in hours and minutesfrom UTC, so -0800 is 8 hours behind UTC. Values up to+1400 are accepted.  (Standard only for output.  For inputR currently supports it on all platforms.)(Output only.)  Time zone abbreviation as acharacter string (empty if not available).  This may not be reliablewhen a time zone has changed abbreviations over the years.Where leading zeros are shown they will be used on output but areoptional on input.  Names are matched case-insensitively on input:whether they are capitalized on output depends on the platform and thelocale.  Note that abbreviated names are platform-specific (althoughthe standards specify that in the C locale they must be thefirst three letters of the capitalized English name: this conventionis widely used in English-language locales but for example the Frenchmonth abbreviations are not the same on any two of Linux, macOS, Solarisand Windows). Knowing what the abbreviations are is essentialif you wish to use %a, %b or %h as part of aninput format: see the examples for how to check.When %z or %Z is used for output with anobject with an assigned time zone an attempt is made to use the valuesfor that time zone — but it is not guaranteed to succeed.Not in the standards and less widely implemented areThe 24-hour clock time with single digits precededby a blank.The 12-hour clock time with single digits precededby a blank.(Output only.) The number of seconds since theepoch.(Output only.) Similar to %c, often"%a %b %e %H:%M:%S %Z %Y". May depend on the locale.For output there are also %O[dHImMUVwWy] which may emitnumbers in an alternative locale-dependent format (e.g., romannumerals), and %E[cCyYxX] which can use an alternative‘era’ (e.g., a different religious calendar).  Which of theseare supported is OS-dependent.  These are accepted for input, but withthe standard interpretation.Specific to R is %OSn, which for output gives the secondstruncated to 0 <= n <= 6 decimal places (and if %OS isnot followed by a digit, it uses the setting ofgetOption("digits.secs"), or if that is unset, n =  0).  Further, for strptime %OS will input secondsincluding fractional seconds.  Note that %S does not readfractional parts on output. The behaviour of other conversion specifications (and even if othercharacter sequences commencing with % are conversionspecifications) is system-specific.  Some systems document that theuse of multi-byte characters in format is unsupported: UTF-8locales are unlikely to cause a problem.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
If the argument dnn is not supplied, the internal functionlist.names is called to compute the ‘dimname names’.  If thearguments in ... are named, those names are used.  For theremaining arguments, deparse.level = 0 gives an empty name,deparse.level = 1 uses the supplied argument if it is a symbol,and deparse.level = 2 will deparse the argument.Only when exclude is specified (i.e., not by default) andnon-empty, will table potentially drop levels of factorarguments.useNA controls if the table includes counts of NAvalues: the allowed values correspond to never ("no"), only if the count ispositive ("ifany") and even for zero counts ("always").Note the somewhat “pathological” case of two different kinds ofNAs which are treated differently, depending on bothuseNA and exclude, see d.patho in the‘Examples:’ below.Both exclude and useNA operate on an “all or none”basis.  If you want to control the dimensions of a multiway tableseparately, modify each argument using factor oraddNA.Non-factor arguments a are coerced via factor(a,    exclude=exclude).  Since R 3.4.0, care is taken not tocount the excluded values (where they were included in the NAcount, previously).The summary method for class "table" (used for objectscreated by table or xtabs) which gives basicinformation and performs a chi-squared test for independence offactors (note that the function chisq.test currentlyonly handles 2-d tables).
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
double creates a double-precision vector of the specifiedlength.  The elements of the vector are all equal to 0.It is identical to numeric.as.double is a generic function.  It is identical toas.numeric.  Methods should return an object of base type"double".is.double is a test of double type.R has no single precision data type.  All real numbers arestored in double precision format.  The functions as.singleand single are identical to as.double and doubleexcept they set the attribute Csingle that is used in the.C and .Fortran interface, and they areintended only to be used in that context.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
This is a primitive generic function: you can write methods tohandle specific classes of objects, see InternalMethods.
‘Expression’ here is not being used in its colloquial sense,that of mathematical expressions.  Those are calls (seecall) in R, and an R expression vector is a list ofcalls, symbols etc, for example as returned by parse.As an object of mode "expression" is a list, it can besubsetted by [, [[ or $, the latter two extractingindividual calls etc.  The replacement forms of these operators can beused to replace or delete elements.expression and is.expression are primitive functions.expression is ‘special’: it does not evaluate its arguments.
‘Expression’ here is not being used in its colloquial sense,that of mathematical expressions.  Those are calls (seecall) in R, and an R expression vector is a list ofcalls, symbols etc, for example as returned by parse.As an object of mode "expression" is a list, it can besubsetted by [, [[ or $, the latter two extractingindividual calls etc.  The replacement forms of these operators can beused to replace or delete elements.expression and is.expression are primitive functions.expression is ‘special’: it does not evaluate its arguments.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
NA
NA
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
Integer vectors exist so that data can be passed to C or Fortran codewhich expects them, and so that (small) integer data can be representedexactly and compactly.Note that current implementations of R use 32-bit integers forinteger vectors, so the range of representable integers is restrictedto about +/-2*10^9: doubles canhold much larger integers exactly.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
TRUE and FALSE are reserved words denoting logicalconstants in the R language, whereas T and F are globalvariables whose initial values set to these.  All four arelogical(1) vectors.Logical vectors are coerced to integer vectors in contexts where anumerical value is required, with TRUE being mapped to1L, FALSE to 0L and NA to NA_integer_.
TRUE and FALSE are reserved words denoting logicalconstants in the R language, whereas T and F are globalvariables whose initial values set to these.  All four arelogical(1) vectors.Logical vectors are coerced to integer vectors in contexts where anumerical value is required, with TRUE being mapped to1L, FALSE to 0L and NA to NA_integer_.
If one of nrow or ncol is not given, an attempt ismade to infer it from the length of data and the otherparameter.  If neither is given, a one-column matrix is returned.If there are too few elements in data to fill the matrix,then the elements in data are recycled.  If data haslength zero, NA of an appropriate type is used for atomicvectors (0 for raw vectors) and NULL for lists.is.matrix returns TRUE if x is a vector and has a"dim" attribute of length 2 and FALSE otherwise.Note that a data.frame is not a matrix by thistest.  The function is generic: you can write methods to handlespecific classes of objects, see InternalMethods.as.matrix is a generic function.  The method for data frameswill return a character matrix if there is only atomic columns and anynon-(numeric/logical/complex) column, applying as.vectorto factors and format to other non-character columns.Otherwise, the usual coercion hierarchy (logical < integer < double <complex) will be used, e.g., all-logical data frames will be coercedto a logical matrix, mixed logical-integer will give a integer matrix,etc.The default method for as.matrix calls as.vector(x), andhence e.g. coerces factors to character vectors.When coercing a vector, it produces a one-column matrix, andpromotes the names (if any) of the vector to the rownames of the matrix.is.matrix is a primitive function.The print method for a matrix gives a rectangular layout withdimnames or indices.  For a list matrix, the entries of length notone are printed in  the form integer,7 indicating the typeand length.
If one of nrow or ncol is not given, an attempt ismade to infer it from the length of data and the otherparameter.  If neither is given, a one-column matrix is returned.If there are too few elements in data to fill the matrix,then the elements in data are recycled.  If data haslength zero, NA of an appropriate type is used for atomicvectors (0 for raw vectors) and NULL for lists.is.matrix returns TRUE if x is a vector and has a"dim" attribute of length 2 and FALSE otherwise.Note that a data.frame is not a matrix by thistest.  The function is generic: you can write methods to handlespecific classes of objects, see InternalMethods.as.matrix is a generic function.  The method for data frameswill return a character matrix if there is only atomic columns and anynon-(numeric/logical/complex) column, applying as.vectorto factors and format to other non-character columns.Otherwise, the usual coercion hierarchy (logical < integer < double <complex) will be used, e.g., all-logical data frames will be coercedto a logical matrix, mixed logical-integer will give a integer matrix,etc.The default method for as.matrix calls as.vector(x), andhence e.g. coerces factors to character vectors.When coercing a vector, it produces a one-column matrix, andpromotes the names (if any) of the vector to the rownames of the matrix.is.matrix is a primitive function.The print method for a matrix gives a rectangular layout withdimnames or indices.  For a list matrix, the entries of length notone are printed in  the form integer,7 indicating the typeand length.
If one of nrow or ncol is not given, an attempt ismade to infer it from the length of data and the otherparameter.  If neither is given, a one-column matrix is returned.If there are too few elements in data to fill the matrix,then the elements in data are recycled.  If data haslength zero, NA of an appropriate type is used for atomicvectors (0 for raw vectors) and NULL for lists.is.matrix returns TRUE if x is a vector and has a"dim" attribute of length 2 and FALSE otherwise.Note that a data.frame is not a matrix by thistest.  The function is generic: you can write methods to handlespecific classes of objects, see InternalMethods.as.matrix is a generic function.  The method for data frameswill return a character matrix if there is only atomic columns and anynon-(numeric/logical/complex) column, applying as.vectorto factors and format to other non-character columns.Otherwise, the usual coercion hierarchy (logical < integer < double <complex) will be used, e.g., all-logical data frames will be coercedto a logical matrix, mixed logical-integer will give a integer matrix,etc.The default method for as.matrix calls as.vector(x), andhence e.g. coerces factors to character vectors.When coercing a vector, it produces a one-column matrix, andpromotes the names (if any) of the vector to the rownames of the matrix.is.matrix is a primitive function.The print method for a matrix gives a rectangular layout withdimnames or indices.  For a list matrix, the entries of length notone are printed in  the form integer,7 indicating the typeand length.
noquote returns its argument as an object of class"noquote".  There is a method for c() and subscriptmethod ("[.noquote") which ensures that the class is not lostby subsetting.  The print method (print.noquote) printscharacter strings without quotes ("...." is printed as ....).If right is specified in a call print(x, right=*), ittakes precedence over a possible right setting of x,e.g., created by x <- noquote(*, right=TRUE).These functions exist both as utilities and as an example of using (S3)class and object orientation.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
Names are limited to 10,000 bytes (and were to 256 bytes in versionsof R before 2.13.0).as.name first coerces its argument internally to a charactervector (so methods for as.character are not used).  It thentakes the first element and provided it is not "", returns asymbol of that name (and if the element is NA_character_, thename is `NA`).as.name is implemented as as.vector(x, "symbol"),and hence will dispatch methods for the generic function as.vector.is.name and is.symbol are primitive functions.
NULL can be indexed (see Extract) in just about anysyntactically legal way: whether it makes sense or not, the result isalways NULL.  Objects with value NULL can be changed byreplacement operators and will be coerced to the type of theright-hand side.NULL is also used as the empty pairlist: see theexamples. Because pairlists are often promoted to lists, you mayencounter NULL being promoted to an empty list.Objects with value NULL cannot have attributes as there is onlyone null object: attempts to assign them are either an error(attr) or promote the object to an empty list withattribute(s) (attributes and structure).
NULL can be indexed (see Extract) in just about anysyntactically legal way: whether it makes sense or not, the result isalways NULL.  Objects with value NULL can be changed byreplacement operators and will be coerced to the type of theright-hand side.NULL is also used as the empty pairlist: see theexamples. Because pairlists are often promoted to lists, you mayencounter NULL being promoted to an empty list.Objects with value NULL cannot have attributes as there is onlyone null object: attempts to assign them are either an error(attr) or promote the object to an empty list withattribute(s) (attributes and structure).
numeric is identical to double (and real).It creates a double-precision vector of the specified length with eachelement equal to 0.as.numeric is a generic function, but S3 methods must bewritten for as.double.  It is identical to as.double.is.numeric is an internal generic primitivefunction: you can write methods to handle specific classes of objects,see InternalMethods.  It is not the same asis.double.  Factors are handled by the default method,and there are methods for classes "Date","POSIXt" and "difftime" (all of whichreturn false).  Methods for is.numeric should only return trueif the base type of the class is double or integerand values can reasonably be regarded as numeric(e.g., arithmetic on them makes sense, and comparison should be donevia the base type).
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The as.POSIX* functions convert an object to one of the twoclasses used to represent date/times (calendar dates plus time to thenearest second).  They can convert objects of the other class and ofclass "Date" to these classes.  Dates without times aretreated as being at midnight UTC.They can also convert character strings of the formats"2001-02-03" and "2001/02/03" optionally followed bywhite space and a time in the format "14:52" or"14:52:03".  (Formats such as "01/02/03" are ambiguousbut can be converted via a format specification bystrptime.)  Fractional seconds are allowed.Alternatively, format can be specified for character vectors orfactors: if it is not specified and no standard format works forall non-NA inputs an error is thrown.If format is specified, remember that some of the formatspecifications are locale-specific, and you may need to set theLC_TIME category appropriately viaSys.setlocale.  This most often affects the use of%b, %B (month names) and %p (AM/PM).Logical NAs can be converted to either of the classes, but noother logical vectors can be.If you are given a numeric time as the number of seconds since anepoch, see the examples.Character input is first converted to class "POSIXlt" bystrptime: numeric input is first converted to"POSIXct".  Any conversion that needs to go between the twodate-time classes requires a time zone: conversion from"POSIXlt" to "POSIXct" will validate times in theselected time zone.  One issue is what happens at transitionsto and from DST, for example in the UKare respectively invalid (the clocks went forward at 1:00 GMT to 2:00BST) and ambiguous (the clocks went back at 2:00 BST to 1:00 GMT).  Whathappens in such cases is OS-specific: one should expect the first tobe NA, but the second could be interpreted as either BST orGMT (and common OSes give both possible values).  Note too (seestrftime) that OS facilities may not format invalidtimes correctly.
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The raw type is intended to hold raw bytes.  It is possible to extractsubsequences of bytes, and to replace elements (but only by elementsof a raw vector).  The relational operators (see Comparison,using the numerical order of the byte representation) work, as do thelogical operators (see Logic) with a bitwise interpretation.A raw vector is printed with each byte separately represented as apair of hex digits.  If you want to see a character representation(with escape sequences for non-printing characters) userawToChar.Coercion to raw treats the input values as representing small(decimal) integers, so the input is first coerced to integer, and thenvalues which are outside the range [0 ... 255] or areNA are set to 0 (the nul byte).as.raw and is.raw are primitive functions.
double creates a double-precision vector of the specifiedlength.  The elements of the vector are all equal to 0.It is identical to numeric.as.double is a generic function.  It is identical toas.numeric.  Methods should return an object of base type"double".is.double is a test of double type.R has no single precision data type.  All real numbers arestored in double precision format.  The functions as.singleand single are identical to as.double and doubleexcept they set the attribute Csingle that is used in the.C and .Fortran interface, and they areintended only to be used in that context.
double creates a double-precision vector of the specifiedlength.  The elements of the vector are all equal to 0.It is identical to numeric.as.double is a generic function.  It is identical toas.numeric.  Methods should return an object of base type"double".is.double is a test of double type.R has no single precision data type.  All real numbers arestored in double precision format.  The functions as.singleand single are identical to as.double and doubleexcept they set the attribute Csingle that is used in the.C and .Fortran interface, and they areintended only to be used in that context.
Names are limited to 10,000 bytes (and were to 256 bytes in versionsof R before 2.13.0).as.name first coerces its argument internally to a charactervector (so methods for as.character are not used).  It thentakes the first element and provided it is not "", returns asymbol of that name (and if the element is NA_character_, thename is `NA`).as.name is implemented as as.vector(x, "symbol"),and hence will dispatch methods for the generic function as.vector.is.name and is.symbol are primitive functions.
If the argument dnn is not supplied, the internal functionlist.names is called to compute the ‘dimname names’.  If thearguments in ... are named, those names are used.  For theremaining arguments, deparse.level = 0 gives an empty name,deparse.level = 1 uses the supplied argument if it is a symbol,and deparse.level = 2 will deparse the argument.Only when exclude is specified (i.e., not by default) andnon-empty, will table potentially drop levels of factorarguments.useNA controls if the table includes counts of NAvalues: the allowed values correspond to never ("no"), only if the count ispositive ("ifany") and even for zero counts ("always").Note the somewhat “pathological” case of two different kinds ofNAs which are treated differently, depending on bothuseNA and exclude, see d.patho in the‘Examples:’ below.Both exclude and useNA operate on an “all or none”basis.  If you want to control the dimensions of a multiway tableseparately, modify each argument using factor oraddNA.Non-factor arguments a are coerced via factor(a,    exclude=exclude).  Since R 3.4.0, care is taken not tocount the excluded values (where they were included in the NAcount, previously).The summary method for class "table" (used for objectscreated by table or xtabs) which gives basicinformation and performs a chi-squared test for independence offactors (note that the function chisq.test currentlyonly handles 2-d tables).
If the argument dnn is not supplied, the internal functionlist.names is called to compute the ‘dimname names’.  If thearguments in ... are named, those names are used.  For theremaining arguments, deparse.level = 0 gives an empty name,deparse.level = 1 uses the supplied argument if it is a symbol,and deparse.level = 2 will deparse the argument.Only when exclude is specified (i.e., not by default) andnon-empty, will table potentially drop levels of factorarguments.useNA controls if the table includes counts of NAvalues: the allowed values correspond to never ("no"), only if the count ispositive ("ifany") and even for zero counts ("always").Note the somewhat “pathological” case of two different kinds ofNAs which are treated differently, depending on bothuseNA and exclude, see d.patho in the‘Examples:’ below.Both exclude and useNA operate on an “all or none”basis.  If you want to control the dimensions of a multiway tableseparately, modify each argument using factor oraddNA.Non-factor arguments a are coerced via factor(a,    exclude=exclude).  Since R 3.4.0, care is taken not tocount the excluded values (where they were included in the NAcount, previously).The summary method for class "table" (used for objectscreated by table or xtabs) which gives basicinformation and performs a chi-squared test for independence offactors (note that the function chisq.test currentlyonly handles 2-d tables).
The atomic modes are "logical", "integer","numeric" (synonym "double"), "complex","character" and "raw".If mode = "any", is.vector may return TRUE forthe atomic modes, list and expression.For any mode, it will return FALSE if x has anyattributes except names.  (This is incompatible with S.)  On the otherhand, as.vector removes all attributes including namesfor results of atomic mode (but not those of mode "list" nor"expression").Note that factors are not vectors; is.vector returnsFALSE and as.vector converts a factor to a charactervector for mode = "any".
The atomic modes are "logical", "integer","numeric" (synonym "double"), "complex","character" and "raw".If mode = "any", is.vector may return TRUE forthe atomic modes, list and expression.For any mode, it will return FALSE if x has anyattributes except names.  (This is incompatible with S.)  On the otherhand, as.vector removes all attributes including namesfor results of atomic mode (but not those of mode "list" nor"expression").Note that factors are not vectors; is.vector returnsFALSE and as.vector converts a factor to a charactervector for mode = "any".
The arc-tangent of two arguments atan2(y, x) returns the anglebetween the x-axis and the vector from the origin to (x, y),i.e., for positive arguments atan2(y, x) == atan(y/x).Angles are in radians, not degrees, for the standard versions (i.e., aright angle is π/2), and in ‘half-rotations’ forcospi etc.cospi(x), sinpi(x), and tanpi(x) are accuratefor x values which are multiples of a half.All except atan2 are internal generic primitivefunctions: methods can be defined for them individually or via theMath group generic.These are all wrappers to system calls of the same name (with prefixc for complex arguments) where available.  (cospi,sinpi, and tanpi are part of a C11 extensionand provided by e.g. macOS and Solaris: where not yetavailable call to cos etc are used, with special casesfor  multiples of a half.)
These are internal generic primitive functions: methodscan be defined for them individually or via theMath group generic.Branch cuts are consistent with the inverse trigonometric functionsasin et seq, and agree with those defined in Abramowitzand Stegun, figure 4.7, page 86.   The behaviour actually on the cutsfollows the C99 standard which requires continuity coming round theendpoint in a counter-clockwise direction.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
The values of the splits can also be obtained (less efficiently) bysplit(x, slice.index(x, MARGIN)).apply always simplifies common length results, so attempting to split via apply(x, MARGIN, identity) does notwork (as it simply gives x).  By chaining asplit withlapply or vapply, one can obtain variantsof apply which do not auto-simplify.
Note that isS4 does not rely on the methodspackage, so in particular it can be used to detect the need torequire that package.asS3 uses the value ofcomplete to control whether an attempt is made to transformobject into a valid object of the implied S3 class.  Ifcomplete is TRUE,then an object from an S4 class extending an S3 class will betransformed into an S3 object with the corresponding S3 class (seeS3Part).  This includes classes extending thepseudo-classes array and matrix: such objects will havetheir class attribute set to NULL.isS4 is primitive.
Note that isS4 does not rely on the methodspackage, so in particular it can be used to detect the need torequire that package.asS3 uses the value ofcomplete to control whether an attempt is made to transformobject into a valid object of the implied S3 class.  Ifcomplete is TRUE,then an object from an S4 class extending an S3 class will betransformed into an S3 object with the corresponding S3 class (seeS3Part).  This includes classes extending thepseudo-classes array and matrix: such objects will havetheir class attribute set to NULL.isS4 is primitive.
There are no restrictions on the name given as x: it can be anon-syntactic name (see make.names).The pos argument can specify the  environment in which to assignthe object in any of several ways: as -1 (the default),as a positive integer (the position in the search list); asthe character string name of an element in the search list; or as anenvironment (including using sys.frame toaccess the currently active function calls).The envir argument is an alternative way to specify anenvironment, but is primarily for back compatibility.assign does not dispatch assignment methods, so it cannot beused to set elements of vectors, names, attributes, etc.Note that assignment to an attached list or data frame changes theattached copy and not the original object: see attachand with.
The arc-tangent of two arguments atan2(y, x) returns the anglebetween the x-axis and the vector from the origin to (x, y),i.e., for positive arguments atan2(y, x) == atan(y/x).Angles are in radians, not degrees, for the standard versions (i.e., aright angle is π/2), and in ‘half-rotations’ forcospi etc.cospi(x), sinpi(x), and tanpi(x) are accuratefor x values which are multiples of a half.All except atan2 are internal generic primitivefunctions: methods can be defined for them individually or via theMath group generic.These are all wrappers to system calls of the same name (with prefixc for complex arguments) where available.  (cospi,sinpi, and tanpi are part of a C11 extensionand provided by e.g. macOS and Solaris: where not yetavailable call to cos etc are used, with special casesfor  multiples of a half.)
The arc-tangent of two arguments atan2(y, x) returns the anglebetween the x-axis and the vector from the origin to (x, y),i.e., for positive arguments atan2(y, x) == atan(y/x).Angles are in radians, not degrees, for the standard versions (i.e., aright angle is π/2), and in ‘half-rotations’ forcospi etc.cospi(x), sinpi(x), and tanpi(x) are accuratefor x values which are multiples of a half.All except atan2 are internal generic primitivefunctions: methods can be defined for them individually or via theMath group generic.These are all wrappers to system calls of the same name (with prefixc for complex arguments) where available.  (cospi,sinpi, and tanpi are part of a C11 extensionand provided by e.g. macOS and Solaris: where not yetavailable call to cos etc are used, with special casesfor  multiples of a half.)
These are internal generic primitive functions: methodscan be defined for them individually or via theMath group generic.Branch cuts are consistent with the inverse trigonometric functionsasin et seq, and agree with those defined in Abramowitzand Stegun, figure 4.7, page 86.   The behaviour actually on the cutsfollows the C99 standard which requires continuity coming round theendpoint in a counter-clockwise direction.
When evaluating a variable or function name R searches forthat name in the databases listed by search.  The firstname of the appropriate type is used.By attaching a data frame (or list) to the search path it is possibleto refer to the variables in the data frame by their names alone,rather than as components of the data frame (e.g., in the example below,height rather than women$height).By default the database is attached in position 2 in the search path,immediately after the user's workspace and before all previouslyattached packages and previously attached databases.  This can bealtered to attach later in the search path with the pos option,but you cannot attach at pos = 1.The database is not actually attached.  Rather, a new environment iscreated on the search path and the elements of a list (includingcolumns of a data frame) or objects in a save file or an environmentare copied into the new environment.  If you use<<- or assign to assign to an attacheddatabase, you only alter the attached copy, not the original object.(Normal assignment will place a modified version in the user'sworkspace: see the examples.)  For this reason attach can leadto confusion.One useful ‘trick’ is to use what = NULL (or equivalently alength-zero list) to create a new environment on the search path intowhich objects can be assigned by assign orload or sys.source.Names starting "package:" are reserved forlibrary and should not be used by end users.  Attachedfiles are by default given the name file:what.  Thename argument given for the attached environment will be usedby search and can be used as the argument toas.environment.There are hooks to attach user-defined table objects of class"UserDefinedDatabase", supported by the Omegahat packageRObjectTables.
The functions loadNamespace and attachNamespace areusually called implicitly when library is used to load a namespace and any imports needed.  However it may be useful at times tocall these functions directly.loadNamespace loads the specified name space and registers it inan internal data base.  A request to load a name space when one of thatname is already loaded has no effect.  The arguments have the samemeaning as the corresponding arguments to library, whosehelp page explains the details of how a particular installed packagecomes to be chosen.  After loading, loadNamespace looks for ahook function named .onLoad as an internal variable inthe name space (it should not be exported).  Partial loading is usedto support installation with lazy-loading.Optionally the package licence is checked during loading: see section‘Licenses’ in the help for library.loadNamespace does not attach the name space it loads to thesearch path.  attachNamespace can be used to attach a framecontaining the exported values of a name space to the search path (butthis is almost always done via library).  Thehook function .onAttach is run after the name spaceexports are attached.requireNamespace is a wrapper for loadNamespaceanalogous to require that returns a logical value.loadedNamespaces returns a character vector of the names ofthe loaded name spaces.isNamespaceLoaded(pkg) is equivalent to but more efficient thanpkg %in% loadedNamespaces().unloadNamespace can be used to attempt to force a name space tobe unloaded.  If the name space is attached, it is firstdetached, thereby running a .onDetach or.Last.lib function in the name space if one is exported.  Anerror is signaled and the name space is not unloaded if the name spaceis imported by other loaded name spaces.  If defined, a hook function.onUnload is run before removing the name space from theinternal registry.See the comments in the help for detach about someissues with unloading and reloading name spaces.
These functions provide access to a single attribute of an object.The replacement form causes the named attribute to take the valuespecified (or create a new attribute with the value given).The extraction function first looks for an exact match to whichamongst the attributes of x, then (unless exact = TRUE)a unique partial match.(Setting options(warnPartialMatchAttr = TRUE) causespartial matches to give warnings.)The replacement function only uses exact matches.Note that some attributes (namely class,comment, dim, dimnames,names, row.names andtsp) are treated specially and have restrictions onthe values which can be set.  (Note that this is not true oflevels which should be set for factors via thelevels replacement function.)The extractor function allows (and does not match) empty and missingvalues of which: the replacement function does not.NULL objects cannot have attributes and attempting toassign one by attr gives an error.Both are primitive functions.
all.equal is a generic function, dispatching methods on thetarget argument.  To see the available methods, usemethods("all.equal"), but note that the default methodalso does some dispatching, e.g. using the raw method for logicaltargets.Remember that arguments which follow ... must be specified by(unabbreviated) name.  It is inadvisable to pass unnamed arguments in... as these will match different arguments in differentmethods.Numerical comparisons for scale = NULL (the default) aretypically on relative difference scale unless the target valuesare close to zero:  First, the mean absolute difference of the twonumerical vectors is computed.  If this is smaller thantolerance or not finite, absolute differences are used,otherwise relative differences scaled by the mean absolutetarget value.Note that these comparisons are computed only for those vector elementswhere target is not NA and differs from current.If countEQ is true, the equal and NA cases arecounted in determining “sample” size.If scale is numeric (and positive), absolute comparisons aremade after scaling (dividing) by scale.For complex target, the modulus (Mod) of thedifference is used: all.equal.numeric is called so argumentstolerance and scale are available.The list method compares components oftarget and current recursively, passing all otherarguments, as long as both are “list-like”, i.e., fulfilleither is.vector or is.list.The environment method works via the list method,and is also used for reference classes (unless a specificall.equal method is defined).The method for date-time objects uses all.equal.numeric tocompare times (in "POSIXct" representation) with adefault tolerance of 0.001 seconds, ignoring scale.A time zone mismatch between target and current isreported unless check.tzone = FALSE.attr.all.equal is used for comparingattributes, returning NULL or acharacter vector.
These functions provide access to a single attribute of an object.The replacement form causes the named attribute to take the valuespecified (or create a new attribute with the value given).The extraction function first looks for an exact match to whichamongst the attributes of x, then (unless exact = TRUE)a unique partial match.(Setting options(warnPartialMatchAttr = TRUE) causespartial matches to give warnings.)The replacement function only uses exact matches.Note that some attributes (namely class,comment, dim, dimnames,names, row.names andtsp) are treated specially and have restrictions onthe values which can be set.  (Note that this is not true oflevels which should be set for factors via thelevels replacement function.)The extractor function allows (and does not match) empty and missingvalues of which: the replacement function does not.NULL objects cannot have attributes and attempting toassign one by attr gives an error.Both are primitive functions.
Unlike attr it is not an error to set attributes on aNULL object: it will first be coerced to an empty list.Note that some attributes (namely class,comment, dim, dimnames,names, row.names andtsp) are treated specially and have restrictions onthe values which can be set.  (Note that this is not true oflevels which should be set for factors via thelevels replacement function.)Attributes are not stored internally as a list and should be thoughtof as a set and not a vector, i.e, the order of the elements ofattributes() does not matter.  This is also reflected byidentical()'s behaviour with the default argumentattrib.as.set = TRUE.  Attributes must have unique names (andNA is taken as "NA", not a missing value).Assigning attributes first removes all attributes, then sets anydim attribute and then the remaining attributes in the ordergiven: this ensures that setting a dim attribute always precedesthe dimnames attribute.The mostattributes assignment takes special care for thedim, names and dimnamesattributes, and assigns them only when known to be valid whereas anattributes assignment would give an error if any are not.  Itis principally intended for arrays, and should be used with care onclassed objects.  For example, it does not check thatrow.names are assigned correctly for data frames.The names of a pairlist are not stored as attributes, but are reportedas if they were (and can be set by the replacement form ofattributes).NULL objects cannot have attributes and attempts toassign them will promote the object to an empty list.Both assignment and replacement forms of attributes areprimitive functions.
Unlike attr it is not an error to set attributes on aNULL object: it will first be coerced to an empty list.Note that some attributes (namely class,comment, dim, dimnames,names, row.names andtsp) are treated specially and have restrictions onthe values which can be set.  (Note that this is not true oflevels which should be set for factors via thelevels replacement function.)Attributes are not stored internally as a list and should be thoughtof as a set and not a vector, i.e, the order of the elements ofattributes() does not matter.  This is also reflected byidentical()'s behaviour with the default argumentattrib.as.set = TRUE.  Attributes must have unique names (andNA is taken as "NA", not a missing value).Assigning attributes first removes all attributes, then sets anydim attribute and then the remaining attributes in the ordergiven: this ensures that setting a dim attribute always precedesthe dimnames attribute.The mostattributes assignment takes special care for thedim, names and dimnamesattributes, and assigns them only when known to be valid whereas anattributes assignment would give an error if any are not.  Itis principally intended for arrays, and should be used with care onclassed objects.  For example, it does not check thatrow.names are assigned correctly for data frames.The names of a pairlist are not stored as attributes, but are reportedas if they were (and can be set by the replacement form ofattributes).NULL objects cannot have attributes and attempts toassign them will promote the object to an empty list.Both assignment and replacement forms of attributes areprimitive functions.
NA
NA
Solves a system of linear equations where the coefficient matrix isupper (or ‘right’, ‘R’) or lower (‘left’,‘L’) triangular.x <- backsolve   (R, b) solves R x = b, andx <- forwardsolve(L, b) solves L x = b, respectively.The r/l must have at least k rows and columns,and x must have at least k rows.This is a wrapper for the level-3 BLAS routine dtrsm.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
tilde expansion of the path is done except on Windows.Trailing path separators are removed before dissecting the path,and for dirname any trailing file separators are removedfrom the result.
If expon.scaled = TRUE, exp(-x) I(x;nu),or exp(x) K(x;nu) are returned.For nu < 0, formulae 9.1.2 and 9.6.2 from Abramowitz &Stegun  are applied (which is probably suboptimal), except forbesselK which is symmetric in nu.The current algorithms will give warnings about accuracy loss forlarge arguments.  In some cases, these warnings are exaggerated, andthe precision is perfect.  For large nu, say in the order ofmillions, the current algorithms are rarely useful.
If expon.scaled = TRUE, exp(-x) I(x;nu),or exp(x) K(x;nu) are returned.For nu < 0, formulae 9.1.2 and 9.6.2 from Abramowitz &Stegun  are applied (which is probably suboptimal), except forbesselK which is symmetric in nu.The current algorithms will give warnings about accuracy loss forlarge arguments.  In some cases, these warnings are exaggerated, andthe precision is perfect.  For large nu, say in the order ofmillions, the current algorithms are rarely useful.
If expon.scaled = TRUE, exp(-x) I(x;nu),or exp(x) K(x;nu) are returned.For nu < 0, formulae 9.1.2 and 9.6.2 from Abramowitz &Stegun  are applied (which is probably suboptimal), except forbesselK which is symmetric in nu.The current algorithms will give warnings about accuracy loss forlarge arguments.  In some cases, these warnings are exaggerated, andthe precision is perfect.  For large nu, say in the order ofmillions, the current algorithms are rarely useful.
If expon.scaled = TRUE, exp(-x) I(x;nu),or exp(x) K(x;nu) are returned.For nu < 0, formulae 9.1.2 and 9.6.2 from Abramowitz &Stegun  are applied (which is probably suboptimal), except forbesselK which is symmetric in nu.The current algorithms will give warnings about accuracy loss forlarge arguments.  In some cases, these warnings are exaggerated, andthe precision is perfect.  For large nu, say in the order ofmillions, the current algorithms are rarely useful.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
If domain is NULL or "", and gettextor ngettext  is called from a function in the namespace ofpackage pkg the domain is set to "R-pkg".  Otherwisethere is no default domain.If a suitable domain is found, each character string is offered fortranslation, and replaced by its translation into the current languageif one is found.  The value (logical) NA suppresses anytranslation.The language to be used for message translation is determined byyour OS default and/or the locale setting at R's startup, seeSys.getlocale(), and notably the LANGUAGE environmentvariable.Conventionally the domain for R warning/error messages in packagepkg is "R-pkg", and that for C-level messages is "pkg".For gettext, leading and trailing whitespace is ignored whenlooking for the translation.ngettext is used where the message needs to vary by a singleinteger.  Translating such messages is subject to very specific rulesfor different languages: see the GNU Gettext Manual.  The stringwill often contain a single instance of %d to be used insprintf.  If English is used, msg1 is returned ifn == 1 and msg2 in all other cases.bindtextdomain is a wrapper for the C function of the samename: your system may have a man page for it.  With anon-NULL dirname it specifies where to look for messagecatalogues: with domain = NULL it returns the current location.
Each element of an integer vector has 32 bits.Pairwise operations can result in integer NA.Shifting is done assuming the values represent unsigned integers.
Each element of an integer vector has 32 bits.Pairwise operations can result in integer NA.Shifting is done assuming the values represent unsigned integers.
Each element of an integer vector has 32 bits.Pairwise operations can result in integer NA.Shifting is done assuming the values represent unsigned integers.
Each element of an integer vector has 32 bits.Pairwise operations can result in integer NA.Shifting is done assuming the values represent unsigned integers.
Each element of an integer vector has 32 bits.Pairwise operations can result in integer NA.Shifting is done assuming the values represent unsigned integers.
Each element of an integer vector has 32 bits.Pairwise operations can result in integer NA.Shifting is done assuming the values represent unsigned integers.
For the first form, fun can be a character stringnaming the function to be manipulated, which is searched for from theparent frame.  If it is not specified, the function callingbody is used.The bodies of all but the simplest are braced expressions, that iscalls to {: see the ‘Examples’ section for how tocreate such a call.
For the first form, fun can be a character stringnaming the function to be manipulated, which is searched for from theparent frame.  If it is not specified, the function callingbody is used.The bodies of all but the simplest are braced expressions, that iscalls to {: see the ‘Examples’ section for how tocreate such a call.
NA
break breaks out of a for, while or repeatloop; control is transferred to the first statement outside theinner-most loop. next halts the processing of the currentiteration and advances the looping index.  Both break andnext apply only to the innermost of nested loops.Note that it is a common mistake to forget to put braces ({ .. })around your statements, e.g., after if(..) or for(....).In particular, you should not have a newline between } andelse to avoid a syntax error in entering a if ... elseconstruct at the keyboard or via source.For that reason, one (somewhat extreme) attitude of defensive programmingis to always use braces, e.g., for if clauses.The seq in a for loop is evaluated at the start ofthe loop; changing it subsequently does not affect the loop.  Ifseq has length zero the body of the loop is skipped. Otherwise thevariable var is assigned in turn the value of each element ofseq. You can assign to var within the body of the loop,but this will not affect the next iteration.  When the loop terminates,var remains as a variable containing its latest value.
A call to browser can be included in the body of a function.When reached, this causes a pause in the execution of thecurrent expression and allows access to the R interpreter.The purpose of the text and condition arguments are toallow helper programs (e.g., external debuggers) to insert specificvalues here, so that the specific call to browser (perhaps its locationin a source file) can be identified and special processing can beachieved.  The values can be retrieved by calling browserTextand browserCondition.The purpose of the expr argument is to allow for the illusionof conditional debugging. It is an illusion, because execution isalways paused at the call to browser, but control is only passedto the evaluator described below if expr is not FALSE aftercoercion to logical.In most cases it is going to be more efficient to use an ifstatement in the calling program, but in some cases using this argumentwill be simpler.The skipCalls argument should be used when the browser()call is nested within another debugging function:  it will look furtherup the call stack to report its location.At the browser prompt the user can enter commands or R expressions,followed by a newline.  The commands areexit the browserand continue execution at the next statement.synonym for c.finish execution of the current loop or functionprint this list of commandsevaluate the next statement, stepping over function calls.  For byte compiled functions interrupted bybrowser calls, n is equivalent to c.evaluate the next statement, stepping intofunction calls.  Again, byte compiled functions makes equivalent to c.print a stack trace of all active function calls.invoke a "resume" restart if one isavailable; interpreted as an R expression otherwise. Typically"resume" restarts are established for continuing from userinterrupts.exit the browser and the current evaluation andreturn to the top-level prompt.Leading and trailing whitespace is ignored, except for an empty line.Handling of empty lines depends on the "browserNLdisabled" option; if it is TRUE, empty lines are ignored.  If not, an empty line is the same as n (or s, if it was used most recently).Anything else entered at the browser prompt is interpreted as anR expression to be evaluated in the calling environment: inparticular typing an object name will cause the object to be printed,and ls() lists the objects in the calling frame.  (If you wantto look at an object with a name such as n, print itexplicitly, or use autoprint via (n).The number of lines printed for the deparsed call can be limited bysetting options(deparse.max.lines).The browser prompt is of the form Browse[n]>: herevar{n} indicates the ‘browser level’.  The browser canbe called when browsing (and often is when debug is inuse), and each recursive call increases the number.  (The actualnumber is the number of ‘contexts’ on the context stack: thisis usually 2 for the outer level of browsing and 1 whenexamining dumps in debugger.)This is a primitive function but does argument matching in thestandard way.
Each call to browser can supply either a text string or a condition.The functions browserText and browserCondition provide waysto retrieve those values.  Since there can be multiple browser contextsactive at any time we also support retrieving values from the differentcontexts.  The innermost (most recently initiated) browser context isnumbered 1: other contexts are numbered sequentially.browserSetDebug provides a mechanism for initiating the browser inone of the calling functions.  See sys.frame for a morecomplete discussion of the calling stack. To use browserSetDebugyou select some calling function, determine how far back it is in the callstack and call browserSetDebug with n set to that value.Then, by typing c at the browser prompt you will cause evaluationto continue, and provided there are no intervening calls to browser orother interrupts, control will halt again once evaluation has returned tothe closure specified.  This is similar to the up functionality in gdbor the "step out" functionality in other debuggers.
Each call to browser can supply either a text string or a condition.The functions browserText and browserCondition provide waysto retrieve those values.  Since there can be multiple browser contextsactive at any time we also support retrieving values from the differentcontexts.  The innermost (most recently initiated) browser context isnumbered 1: other contexts are numbered sequentially.browserSetDebug provides a mechanism for initiating the browser inone of the calling functions.  See sys.frame for a morecomplete discussion of the calling stack. To use browserSetDebugyou select some calling function, determine how far back it is in the callstack and call browserSetDebug with n set to that value.Then, by typing c at the browser prompt you will cause evaluationto continue, and provided there are no intervening calls to browser orother interrupts, control will halt again once evaluation has returned tothe closure specified.  This is similar to the up functionality in gdbor the "step out" functionality in other debuggers.
Each call to browser can supply either a text string or a condition.The functions browserText and browserCondition provide waysto retrieve those values.  Since there can be multiple browser contextsactive at any time we also support retrieving values from the differentcontexts.  The innermost (most recently initiated) browser context isnumbered 1: other contexts are numbered sequentially.browserSetDebug provides a mechanism for initiating the browser inone of the calling functions.  See sys.frame for a morecomplete discussion of the calling stack. To use browserSetDebugyou select some calling function, determine how far back it is in the callstack and call browserSetDebug with n set to that value.Then, by typing c at the browser prompt you will cause evaluationto continue, and provided there are no intervening calls to browser orother interrupts, control will halt again once evaluation has returned tothe closure specified.  This is similar to the up functionality in gdbor the "step out" functionality in other debuggers.
builtins() returns an unsorted list of the objects in thesymbol table, that is all the objects in the base environment.These are the built-in objects plus any that have been addedsubsequently when the base package was loaded.  It is less confusingto use ls(baseenv(), all.names = TRUE).builtins(TRUE) returns an unsorted list of the names of internalfunctions, that is those which can be accessed as.Internal(foo(args ...)) for foo in the list.
A data frame is split by row into data framessubsetted by the values of one or more factors, and functionFUN is applied to each subset in turn.For the default method, an object with dimensions (e.g., a matrix) iscoerced to a data frame and the data frame method applied.  Otherobjects are also coerced to a data frame, but FUN is appliedseparately to (subsets of) each column of the data frame.
A data frame is split by row into data framessubsetted by the values of one or more factors, and functionFUN is applied to each subset in turn.For the default method, an object with dimensions (e.g., a matrix) iscoerced to a data frame and the data frame method applied.  Otherobjects are also coerced to a data frame, but FUN is appliedseparately to (subsets of) each column of the data frame.
A data frame is split by row into data framessubsetted by the values of one or more factors, and functionFUN is applied to each subset in turn.For the default method, an object with dimensions (e.g., a matrix) iscoerced to a data frame and the data frame method applied.  Otherobjects are also coerced to a data frame, but FUN is appliedseparately to (subsets of) each column of the data frame.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The output type is determined from the highest type of the componentsin the hierarchy NULL < raw < logical < integer < double < complex < character< list < expression.  Pairlists are treated as lists, whereas non-vectorcomponents (such as names / symbols and calls)are treated as one-element listswhich cannot be unlisted even if recursive = TRUE.Note that in R < 4.1.0, factors were treated only viatheir internal integer codes: now there isc.factor method which combines factors into a factor.c is sometimes used for its side effect of removing attributesexcept names, for example to turn an array into a vector.as.vector is a more intuitive way to do this, but also dropsnames.  Note that methods other than the default are not requiredto do this (and they will almost certainly preserve a class attribute).This is a primitive function.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
noquote returns its argument as an object of class"noquote".  There is a method for c() and subscriptmethod ("[.noquote") which ensures that the class is not lostby subsetting.  The print method (print.noquote) printscharacter strings without quotes ("...." is printed as ....).If right is specified in a call print(x, right=*), ittakes precedence over a possible right setting of x,e.g., created by x <- noquote(*, right=TRUE).These functions exist both as utilities and as an example of using (S3)class and object orientation.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
See the description of options("warn") for thecircumstances under which there is a last.warning object andwarnings() is used.  In essence this is if options(warn =    0) and warning has been called at least once.Note that the length(last.warning) is maximallygetOption("nwarnings") (at the time the warnings aregenerated) which is 50 by default.  To increase, use somethinglike It is possible that last.warning refers to the last recordedwarning and not to the last warning, for example if options(warn) hasbeen changed or if a catastrophic error occurred.
returns an unevaluated function call, that is, anunevaluated expression which consists of the named function applied tothe given arguments (name must be a string which givesthe name of a function to be called).  Note that although the call isunevaluated, the arguments ... are evaluated.call is a primitive, so the first argument istaken as name and the remaining arguments as arguments for theconstructed call: if the first argument is named the name mustpartially match name.is used to determine whether x is a call (i.e.,of mode "call" or "(").  Note thatis.call(x) is strictly equivalent totypeof(x) == "language".is.language() is also true for calls (but alsofor symbols and expressions whereis.call() is false).Objects of mode "list" can be coerced to mode "call".The first element of the list becomes the function part of the call,so should be a function or the name of one (as a symbol; a character string will not do).If you think of using as.call(<string>), consider usingstr2lang(*) which is an efficient version ofparse(text=*).Note that call() and as.call(), whenapplicable, are much preferable to these parse() basedapproaches.All three are primitive functions.as.call is generic: you can write methods to handle specificclasses of objects, see InternalMethods.
callCC provides a non-local exit mechanism that can be usefulfor early termination of a computation.  callCC callsfun with one argument, an exit function.  The exitfunction takes a single argument, the intended return value.  If thebody of fun calls the exit function then the call tocallCC immediately returns, with the value supplied to the exitfunction as the value returned by callCC.
NA
chartr translates each character in x that is specifiedin old to the corresponding character specified in new.Ranges are supported in the specifications, but character classes andrepeated characters are not.  If old contains more charactersthan new, an error is signaled; if it contains fewer characters, theextra characters at the end of new are ignored.tolower and toupper convert upper-case characters in acharacter vector to lower-case, or vice versa.  Non-alphabeticcharacters are left unchanged.  More than one character can be mappedto a single upper-case character.casefold is a wrapper for tolower and toupperprovided for compatibility with S-PLUS.
cat is useful for producing output in user-defined functions.It converts its arguments to character vectors, concatenatesthem to a single character vector, appends the given sep = string(s) to each element and then outputs them.No linefeeds are output unless explicitly requested by "\n"or if generated by filling (if argument fill is TRUE ornumeric).If file is a connection and open for writing it is written fromits current position.  If it is not open, it is opened for theduration of the call in "wt" mode and then closed again.Currently only atomic vectors and names are handled,together with NULL and other zero-length objects (which produceno output).  Character strings are output ‘as is’ (unlikeprint.default which escapes non-printable characters andbackslash — use encodeString if you want to outputencoded strings using cat).  Other types of R object should beconverted (e.g., by as.character or format)before being passed to cat.  That includes factors, which areoutput as integer vectors.cat converts numeric/complex elements in the same way asprint (and not in the same way as as.characterwhich is used by the S equivalent), so options"digits" and "scipen" are relevant.  However, it usesthe minimum field width necessary for each element, rather than thesame field width for all elements.
The functions cbind and rbind are S3 generic, withmethods for data frames.  The data frame method will be used if atleast one argument is a data frame and the rest are vectors ormatrices.  There can be other methods; in particular, there is one fortime series objects.  See the section on ‘Dispatch’ for howthe method to be used is selected.  If some of the arguments are of anS4 class, i.e., isS4(.) is true, S4 methods are soughtalso, and the hidden cbind / rbind functionsfrom package methods maybe called, which in turn build oncbind2 or rbind2, respectively.  In thatcase, deparse.level is obeyed, similarly to the default method.In the default method, all the vectors/matrices must be atomic (seevector) or lists.  Expressions are not allowed.Language objects (such as formulae and calls) and pairlists will becoerced to lists: other objects (such as names and external pointers)will be included as elements in a list result.  Any classes the inputsmight have are discarded (in particular, factors are replaced by theirinternal codes).If there are several matrix arguments, they must all have the samenumber of columns (or rows) and this will be the number of columns (orrows) of the result.  If all the arguments are vectors, the number ofcolumns (rows) in the result is equal to the length of the longestvector.  Values in shorter arguments are recycled to achieve thislength (with a warning if they are recycled onlyfractionally).When the arguments consist of a mix of matrices and vectors the numberof columns (rows) of the result is determined by the number of columns(rows) of the matrix arguments.  Any vectors have their valuesrecycled or subsetted to achieve this length.For cbind (rbind), vectors of zero length (includingNULL) are ignored unless the result would have zero rows(columns), for S compatibility.(Zero-extent matrices do not occur in S3 and are not ignored in R.)Matrices are restricted to less than 2^31 rows andcolumns even on 64-bit systems.  So input vectors have the same lengthrestriction: as from R 3.2.0 input matrices with more elements (butmeeting the row and column restrictions) are allowed.
The functions cbind and rbind are S3 generic, withmethods for data frames.  The data frame method will be used if atleast one argument is a data frame and the rest are vectors ormatrices.  There can be other methods; in particular, there is one fortime series objects.  See the section on ‘Dispatch’ for howthe method to be used is selected.  If some of the arguments are of anS4 class, i.e., isS4(.) is true, S4 methods are soughtalso, and the hidden cbind / rbind functionsfrom package methods maybe called, which in turn build oncbind2 or rbind2, respectively.  In thatcase, deparse.level is obeyed, similarly to the default method.In the default method, all the vectors/matrices must be atomic (seevector) or lists.  Expressions are not allowed.Language objects (such as formulae and calls) and pairlists will becoerced to lists: other objects (such as names and external pointers)will be included as elements in a list result.  Any classes the inputsmight have are discarded (in particular, factors are replaced by theirinternal codes).If there are several matrix arguments, they must all have the samenumber of columns (or rows) and this will be the number of columns (orrows) of the result.  If all the arguments are vectors, the number ofcolumns (rows) in the result is equal to the length of the longestvector.  Values in shorter arguments are recycled to achieve thislength (with a warning if they are recycled onlyfractionally).When the arguments consist of a mix of matrices and vectors the numberof columns (rows) of the result is determined by the number of columns(rows) of the matrix arguments.  Any vectors have their valuesrecycled or subsetted to achieve this length.For cbind (rbind), vectors of zero length (includingNULL) are ignored unless the result would have zero rows(columns), for S compatibility.(Zero-extent matrices do not occur in S3 and are not ignored in R.)Matrices are restricted to less than 2^31 rows andcolumns even on 64-bit systems.  So input vectors have the same lengthrestriction: as from R 3.2.0 input matrices with more elements (butmeeting the row and column restrictions) are allowed.
These are generic functions: methods can be defined for themindividually or via the Math groupgeneric.Note that for rounding off a 5, the IEC 60559 standard (see also‘IEEE 754’) is expected to be used, ‘go to the even digit’.Therefore round(0.5) is 0 and round(-1.5) is-2.  However, this is dependent on OS services and onrepresentation error (since e.g. 0.15 is not representedexactly, the rounding rule applies to the represented number and notto the printed number, and so round(0.15, 1) could be either0.1 or 0.2).Rounding to a negative number of digits means rounding to a power often, so for example round(x, digits = -2) rounds to the nearesthundred.For signif the recognized values of digits are1...22, and non-missing values are rounded to the nearestinteger in that range.  Complex numbers are rounded to retain thespecified number of digits in the larger of the components.  Eachelement of the vector is rounded individually, unlike printing.These are all primitive functions.
This function is particularly useful when abbreviations are allowed infunction arguments, and need to be uniquely expanded with respect to atarget table of possible values.
as.character and is.character are generic: you canwrite methods to handle specific classes of objects,see InternalMethods.  Further, for as.character thedefault method calls as.vector, so dispatch is first onmethods for as.character and then for methods for as.vector.as.character represents real and complex numbers to 15 significantdigits (technically the compiler's setting of the ISO C constantDBL_DIG, which will be 15 on machines supporting IEC60559arithmetic according to the C99 standard).  This ensures that all thedigits in the result will be reliable (and not the result ofrepresentation error), but does mean that conversion to character andback to numeric may change the number.  If you want to convert numbersto character with the maximum possible precision, useformat.
Exact matches are preferred to partial matches (those where the valueto be matched has an exact match to the initial part of the target,but the target is longer).If there is a single exact match or no exact match and a uniquepartial match then the index of the matching value is returned; ifmultiple exact or multiple partial matches are found then 0 isreturned and if no match is found then nomatch is returned.NA values are treated as the string constant "NA".
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
chartr translates each character in x that is specifiedin old to the corresponding character specified in new.Ranges are supported in the specifications, but character classes andrepeated characters are not.  If old contains more charactersthan new, an error is signaled; if it contains fewer characters, theextra characters at the end of new are ignored.tolower and toupper convert upper-case characters in acharacter vector to lower-case, or vice versa.  Non-alphabeticcharacters are left unchanged.  More than one character can be mappedto a single upper-case character.casefold is a wrapper for tolower and toupperprovided for compatibility with S-PLUS.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
NA
chol is generic: the description here applies to the defaultmethod.Note that only the upper triangular part of x is used, sothat R'R = x when x is symmetric.If pivot = FALSE and x is not non-negative definite anerror occurs.  If x is positive semi-definite (i.e., some zeroeigenvalues) an error will also occur as a numerical tolerance is used.If pivot = TRUE, then the Choleski decomposition of a positivesemi-definite x can be computed.  The rank of x isreturned as attr(Q, "rank"), subject to numerical errors.The pivot is returned as attr(Q, "pivot").  It is no longerthe case that t(Q) %*% Q equals x.  However, settingpivot <- attr(Q, "pivot") and oo <- order(pivot), itis true that t(Q[, oo]) %*% Q[, oo] equals x,or, alternatively, t(Q) %*% Q equals x[pivot,    pivot].  See the examples.The value of tol is passed to LAPACK, with negative valuesselecting the default tolerance of (usually) nrow(x) *  .Machine$double.neg.eps * max(diag(x)).  The algorithm terminates oncethe pivot is less than tol.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
chol is generic: the description here applies to the defaultmethod.Note that only the upper triangular part of x is used, sothat R'R = x when x is symmetric.If pivot = FALSE and x is not non-negative definite anerror occurs.  If x is positive semi-definite (i.e., some zeroeigenvalues) an error will also occur as a numerical tolerance is used.If pivot = TRUE, then the Choleski decomposition of a positivesemi-definite x can be computed.  The rank of x isreturned as attr(Q, "rank"), subject to numerical errors.The pivot is returned as attr(Q, "pivot").  It is no longerthe case that t(Q) %*% Q equals x.  However, settingpivot <- attr(Q, "pivot") and oo <- order(pivot), itis true that t(Q[, oo]) %*% Q[, oo] equals x,or, alternatively, t(Q) %*% Q equals x[pivot,    pivot].  See the examples.The value of tol is passed to LAPACK, with negative valuesselecting the default tolerance of (usually) nrow(x) *  .Machine$double.neg.eps * max(diag(x)).  The algorithm terminates oncethe pivot is less than tol.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
NA
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
Here, we describe the so called “S3” classes (and methods). For“S4” classes (and methods), see ‘Formal classes’ below.Many R objects have a class attribute, a character vectorgiving the names of the classes from which the object inherits.(Functions oldClass and oldClass<- get and set theattribute, which can also be done directly.)If the object does not have a class attribute, it has an implicitclass, notably "matrix", "array", "function" or"numeric" or the result oftypeof(x) (which is similar to mode(x)),but for type "language" and mode "call",where the following extra classes exist for the corresponding functioncalls:if, while, for, =, <-, (,{, call.Note that for objects x of an implicit (or an S4) class, when a(S3) generic function foo(x) is called, method dispatch may usemore classes than are returned by class(x), e.g., for a numericmatrix, the foo.numeric() method may apply.  The exact fullcharacter vector of the classes whichUseMethod() uses, is available as .class2(x) sinceR version 4.0.0.  (This also applies to S4 objects when S3 dispatch isconsidered, see below.)Beware that using .class2() for other reasons than didactical,diagnostical or for debugging may rather be a misuse than smart.NULL objects (of implicit class "NULL") cannot haveattributes (hence no class attribute) and attempting to assign aclass is an error.When a generic function fun is applied to an object with classattribute c("first", "second"), the system searches for afunction called fun.first and, if it finds it, applies it tothe object.  If no such function is found, a function calledfun.second is tried.  If no class name produces a suitablefunction, the function fun.default is used (if it exists).  Ifthere is no class attribute, the implicit class is tried, then thedefault method.The function class prints the vector of names of classes anobject inherits from.  Correspondingly, class<- sets theclasses an object inherits from.  Assigning an empty character vector orNULL removes the class attribute, as for oldClass<- ordirect attribute setting.  Whereas it is clearer to explicitly assignNULL to remove the class, using an empty vector is more natural ine.g., class(x) <- setdiff(class(x), "ts").unclass returns (a copy of) its argument with its classattribute removed.  (It is not allowed for objects which cannot becopied, namely environments and external pointers.)inherits indicates whether its first argument inherits from anyof the classes specified in the what argument.  If whichis TRUE then an integer vector of the same length aswhat is returned.  Each element indicates the position in theclass(x) matched by the element of what; zero indicatesno match. If which is FALSE then TRUE isreturned by inherits if any of the names in what matchwith any class.isa tests whether x is an object of class(es) as givenin what by using is if x is an S4object, and otherwise giving TRUE iff all elements ofclass(x) are contained in what.All but inherits and isa are primitive functions.
Here, we describe the so called “S3” classes (and methods). For“S4” classes (and methods), see ‘Formal classes’ below.Many R objects have a class attribute, a character vectorgiving the names of the classes from which the object inherits.(Functions oldClass and oldClass<- get and set theattribute, which can also be done directly.)If the object does not have a class attribute, it has an implicitclass, notably "matrix", "array", "function" or"numeric" or the result oftypeof(x) (which is similar to mode(x)),but for type "language" and mode "call",where the following extra classes exist for the corresponding functioncalls:if, while, for, =, <-, (,{, call.Note that for objects x of an implicit (or an S4) class, when a(S3) generic function foo(x) is called, method dispatch may usemore classes than are returned by class(x), e.g., for a numericmatrix, the foo.numeric() method may apply.  The exact fullcharacter vector of the classes whichUseMethod() uses, is available as .class2(x) sinceR version 4.0.0.  (This also applies to S4 objects when S3 dispatch isconsidered, see below.)Beware that using .class2() for other reasons than didactical,diagnostical or for debugging may rather be a misuse than smart.NULL objects (of implicit class "NULL") cannot haveattributes (hence no class attribute) and attempting to assign aclass is an error.When a generic function fun is applied to an object with classattribute c("first", "second"), the system searches for afunction called fun.first and, if it finds it, applies it tothe object.  If no such function is found, a function calledfun.second is tried.  If no class name produces a suitablefunction, the function fun.default is used (if it exists).  Ifthere is no class attribute, the implicit class is tried, then thedefault method.The function class prints the vector of names of classes anobject inherits from.  Correspondingly, class<- sets theclasses an object inherits from.  Assigning an empty character vector orNULL removes the class attribute, as for oldClass<- ordirect attribute setting.  Whereas it is clearer to explicitly assignNULL to remove the class, using an empty vector is more natural ine.g., class(x) <- setdiff(class(x), "ts").unclass returns (a copy of) its argument with its classattribute removed.  (It is not allowed for objects which cannot becopied, namely environments and external pointers.)inherits indicates whether its first argument inherits from anyof the classes specified in the what argument.  If whichis TRUE then an integer vector of the same length aswhat is returned.  Each element indicates the position in theclass(x) matched by the element of what; zero indicatesno match. If which is FALSE then TRUE isreturned by inherits if any of the names in what matchwith any class.isa tests whether x is an object of class(es) as givenin what by using is if x is an S4object, and otherwise giving TRUE iff all elements ofclass(x) are contained in what.All but inherits and isa are primitive functions.
Several character strings can be pushed back on one or more occasions.The occasions form a stack, so the first line to be retrieved will bethe first string from the last call to pushBack.  Lines whichare pushed back are read prior to the normal input from theconnection, by the normal text-reading functions such asreadLines and scan.Pushback is only allowed for readable connections in text mode.Not all uses of connections respect pushbacks, in particular the inputconnection is still wired directly, so for example parsingcommands from the console and scan("") ignore pushbacks onstdin.When character strings with a marked encoding (seeEncoding) are pushed back they are converted to thecurrent encoding if encoding = "".  This may involverepresenting characters as <U+xxxx> if they cannot beconverted.  They will be converted to UTF-8 if encoding =  "UTF-8" or left as-is if encoding = "bytes".
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
stdin(), stdout() and stderr() are standardconnections corresponding to input, output and error on the consolerespectively (and not necessarily to file streams).  They are text-modeconnections of class "terminal" which cannot be opened orclosed, and are read-only, write-only and write-only respectively.The stdout() and stderr() connections can bere-directed by sink (and in some circumstances theoutput from stdout() can be split: see the help page).The encoding for stdin() when redirected canbe set by the command-line flag --encoding.nullfile() returns filename of the null device ("/dev/null"on Unix, "nul:" on Windows).showConnections returns a matrix of information.  If aconnection object has been lost or forgotten, getConnectionwill take a row number from the table and return a connection objectfor that connection, which can be used to close the connection,for example.  However, if there is no R level object referring to theconnection it will be closed automatically at the next garbagecollection (except for gzcon connections).closeAllConnections closes (and destroys) all userconnections, restoring all sink diversions as it doesso.isatty returns true if the connection is one of the class"terminal" connections and it is apparently connected to aterminal, otherwise false.  This may not be reliable in embeddedapplications, including GUI consoles.
NA
These functions are equivalent to use of apply withFUN = mean or FUN = sum with appropriate margins, butare a lot faster.  As they are written for speed, they blur over someof the subtleties of NaN and NA.  If na.rm =    FALSE and either NaN or NA appears in a sum, theresult will be one of NaN or NA, but which might beplatform-dependent.Notice that omission of missing values is done on a per-column orper-row basis, so column means may not be over the same set of rows,and vice versa.  To use only complete rows or columns, first selectthem with na.omit or complete.cases(possibly on the transpose of x).The versions with an initial dot in the name (.colSums() etc)are ‘bare-bones’ versions for use in programming: they applyonly to numeric (like) matrices and do not name the result.
The extractor functions try to do something sensible for anymatrix-like object x.  If the object has dimnamesthe first component is used as the row names, and the second component(if any) is used for the column names.  For a data frame, rownamesand colnames eventually call row.names andnames respectively, but the latter are preferred.If do.NULL is FALSE, a character vector (of lengthNROW(x) or NCOL(x)) is returned in anycase, prepending prefix to simple numbers, if there are nodimnames or the corresponding component of the dimnames is NULL.The replacement methods for arrays/matrices coerce vector and factorvalues of value to character, but do not dispatch methods foras.character.For a data frame, value for rownames should be acharacter vector of non-duplicated and non-missing names (this isenforced), and for colnames a character vector of (preferably)unique syntactically-valid names.  In both cases, value will becoerced by as.character, and setting colnameswill convert the row names to character.
The extractor functions try to do something sensible for anymatrix-like object x.  If the object has dimnamesthe first component is used as the row names, and the second component(if any) is used for the column names.  For a data frame, rownamesand colnames eventually call row.names andnames respectively, but the latter are preferred.If do.NULL is FALSE, a character vector (of lengthNROW(x) or NCOL(x)) is returned in anycase, prepending prefix to simple numbers, if there are nodimnames or the corresponding component of the dimnames is NULL.The replacement methods for arrays/matrices coerce vector and factorvalues of value to character, but do not dispatch methods foras.character.For a data frame, value for rownames should be acharacter vector of non-duplicated and non-missing names (this isenforced), and for colnames a character vector of (preferably)unique syntactically-valid names.  In both cases, value will becoerced by as.character, and setting colnameswill convert the row names to character.
These functions are equivalent to use of apply withFUN = mean or FUN = sum with appropriate margins, butare a lot faster.  As they are written for speed, they blur over someof the subtleties of NaN and NA.  If na.rm =    FALSE and either NaN or NA appears in a sum, theresult will be one of NaN or NA, but which might beplatform-dependent.Notice that omission of missing values is done on a per-column orper-row basis, so column means may not be over the same set of rows,and vice versa.  To use only complete rows or columns, first selectthem with na.omit or complete.cases(possibly on the transpose of x).The versions with an initial dot in the name (.colSums() etc)are ‘bare-bones’ versions for use in programming: they applyonly to numeric (like) matrices and do not name the result.
These arguments are captured before the standard R command lineprocessing takes place.  This means that they are the unmodifiedvalues.  This is especially useful with the --argscommand-line flag to R, as all of the command line after that flagis skipped.
NA
NA
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
NA
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
NA
The arc-tangent of two arguments atan2(y, x) returns the anglebetween the x-axis and the vector from the origin to (x, y),i.e., for positive arguments atan2(y, x) == atan(y/x).Angles are in radians, not degrees, for the standard versions (i.e., aright angle is π/2), and in ‘half-rotations’ forcospi etc.cospi(x), sinpi(x), and tanpi(x) are accuratefor x values which are multiples of a half.All except atan2 are internal generic primitivefunctions: methods can be defined for them individually or via theMath group generic.These are all wrappers to system calls of the same name (with prefixc for complex arguments) where available.  (cospi,sinpi, and tanpi are part of a C11 extensionand provided by e.g. macOS and Solaris: where not yetavailable call to cos etc are used, with special casesfor  multiples of a half.)
These are internal generic primitive functions: methodscan be defined for them individually or via theMath group generic.Branch cuts are consistent with the inverse trigonometric functionsasin et seq, and agree with those defined in Abramowitzand Stegun, figure 4.7, page 86.   The behaviour actually on the cutsfollows the C99 standard which requires continuity coming round theendpoint in a counter-clockwise direction.
The arc-tangent of two arguments atan2(y, x) returns the anglebetween the x-axis and the vector from the origin to (x, y),i.e., for positive arguments atan2(y, x) == atan(y/x).Angles are in radians, not degrees, for the standard versions (i.e., aright angle is π/2), and in ‘half-rotations’ forcospi etc.cospi(x), sinpi(x), and tanpi(x) are accuratefor x values which are multiples of a half.All except atan2 are internal generic primitivefunctions: methods can be defined for them individually or via theMath group generic.These are all wrappers to system calls of the same name (with prefixc for complex arguments) where available.  (cospi,sinpi, and tanpi are part of a C11 extensionand provided by e.g. macOS and Solaris: where not yetavailable call to cos etc are used, with special casesfor  multiples of a half.)
NA
On most platforms, C stack information is recorded when R isinitialized and used for stack-checking.  If this information isunavailable, the size will be returned as NA, andstack-checking is not performed.The information on the stack base address is thought to be accurate onWindows, Linux (using glibc), macOS and FreeBSD but a heuristicis used on other platforms.  Because this might be slightlyinaccurate, the current usage could be estimated as negative.  (Theheuristic is not used on embedded uses of R on platforms where thestack base information is not thought to be accurate.)The ‘evaluation depth’ is the number of nested R expressionscurrently under evaluation: this has a limit controlled byoptions("expressions").
These are generic functions: methods can be defined for themindividually or via the Math group generic.
These are generic functions: methods can be defined for themindividually or via the Math group generic.
These are generic functions: methods can be defined for themindividually or via the Math group generic.
These are generic functions: methods can be defined for themindividually or via the Math group generic.
This reports what curl -I -L or curl -I wouldreport.  For a ftp:// URL the ‘headers’ are a record ofthe conversation between client and server before data transfer.Only 500 header lines will be reported: there is a limit of 20redirections so this should suffice (and even 20 would indicateproblems).If argument timeout is not set to a positive integer this usesgetOption("timeout") which defaults to 60 seconds.  Asthe request cannot be interrupted you may want to consider a shortervalue.To see all the details of the interaction with the server(s) setoptions(internet.info = 1).HTTP[S] servers are allowed to refuse requests to read the headers andsome do: this will result in a status of 405.For possible issues with secure URLs (especially on Windows) seedownload.file.There is a security risk in not verifying certificates, but as onlythe headers are captured it is slight.  Usually looking at the URL ina browser will reveal what the problem is (and it may well bemachine-specific).
When breaks is specified as a single number, the range of thedata is divided into breaks pieces of equal length, and thenthe outer limits are moved away by 0.1% of the range to ensure thatthe extreme values both fall within the break intervals.  (If xis a constant vector, equal-length intervals are created, one ofwhich includes the single value.)If a labels parameter is specified, its values are used to namethe factor levels.  If none is specified, the factor level labels areconstructed as "(b1, b2]", "(b2, b3]" etc. forright = TRUE and as "[b1, b2)", ... if right =    FALSE.In this case, dig.lab indicates the minimum number of digitsshould be used in formatting the numbers b1, b2, ....A larger value (up to 12) will be used if needed to distinguishbetween any pair of endpoints: if this fails labels such as"Range3" will be used.  Formatting is done byformatC.The default method will sort a numeric vector of breaks, butother methods are not required to and labels will correspond tothe intervals after sorting.As from R 3.2.0, getOption("OutDec") is consulted when labelsare constructed for labels = NULL.
Note that the default for right differs from thedefault method.  Using include.lowest =    TRUE will include both ends of the range of dates.Using breaks = "quarter" will create intervals of 3 calendarmonths, with the intervals beginning on January 1, April 1,July 1 or October 1 (based upon min(x)) as appropriate.A vector of breaks will be sorted before use: labels shouldcorrespond to the sorted vector.
When breaks is specified as a single number, the range of thedata is divided into breaks pieces of equal length, and thenthe outer limits are moved away by 0.1% of the range to ensure thatthe extreme values both fall within the break intervals.  (If xis a constant vector, equal-length intervals are created, one ofwhich includes the single value.)If a labels parameter is specified, its values are used to namethe factor levels.  If none is specified, the factor level labels areconstructed as "(b1, b2]", "(b2, b3]" etc. forright = TRUE and as "[b1, b2)", ... if right =    FALSE.In this case, dig.lab indicates the minimum number of digitsshould be used in formatting the numbers b1, b2, ....A larger value (up to 12) will be used if needed to distinguishbetween any pair of endpoints: if this fails labels such as"Range3" will be used.  Formatting is done byformatC.The default method will sort a numeric vector of breaks, butother methods are not required to and labels will correspond tothe intervals after sorting.As from R 3.2.0, getOption("OutDec") is consulted when labelsare constructed for labels = NULL.
Note that the default for right differs from thedefault method.  Using include.lowest =    TRUE will include both ends of the range of dates.Using breaks = "quarter" will create intervals of 3 calendarmonths, with the intervals beginning on January 1, April 1,July 1 or October 1 (based upon min(x)) as appropriate.A vector of breaks will be sorted before use: labels shouldcorrespond to the sorted vector.
NA
A data frame is a list of variables of the same number of rows withunique row names, given class "data.frame".  If no variablesare included, the row names determine the number of rows.The column names should be non-empty, and attempts to use empty nameswill have unsupported results.  Duplicate column names are allowed,but you need to use check.names = FALSE for data.frameto generate such a data frame.  However, not all operations on dataframes will preserve duplicated column names: for example matrix-likesubsetting will force column names in the result to be unique.data.frame converts each of its arguments to a data frame bycalling as.data.frame(optional = TRUE).  As that is ageneric function, methods can be written to change the behaviour ofarguments according to their classes: R comes with many such methods.Character variables passed to data.frame are converted tofactor columns unless protected by I or argumentstringsAsFactors is false.  If a list or dataframe or matrix is passed to data.frame it is as if eachcomponent or column had been passed as a separate argument (except formatrices protected by I).Objects passed to data.frame should have the same number ofrows, but atomic vectors (see is.vector), factors andcharacter vectors protected by I will be recycled awhole number of times if necessary (including as elements of listarguments).If row names are not supplied in the call to data.frame, therow names are taken from the first component that has suitable names,for example a named vector or a matrix with rownames or a data frame.(If that component is subsequently recycled, the names are discardedwith a warning.)  If row.names was supplied as NULL or nosuitable component was found the row names are the integer sequencestarting at one (and such row names are considered to be‘automatic’, and not preserved by as.matrix).If row names are supplied of length one and the data frame has asingle row, the row.names is taken to specify the row names andnot a column (by name or number).Names are removed from vector inputs not protected by I.default.stringsAsFactors is a utility that takesgetOption("stringsAsFactors") and ensures the result isTRUE or FALSE (or throws an error if the value is notNULL).  This function is deprecated now and will no longerbe available in the future.
Logical and factor columns are converted to integers.  Charactercolumns are first converted to factors and then to integers. Any othercolumn which is not numeric (according to is.numeric) isconverted by as.numeric or, for S4 objects,as(, "numeric").  If all columns are integer (afterconversion) the result is an integer matrix, otherwise a numeric(double) matrix.
NA
When a function flagged for debugging is entered, normal executionis suspended and the body of function is executed one statement at atime.  A new browser context is initiated for each step(and the previous one destroyed).At the debug prompt the user can enter commands or R expressions,followed by a newline.  The commands are described in thebrowser help topic.To debug a function which is defined inside another function,single-step through to the end of its definition, and then calldebug on its name.If you want to debug a function not starting at the very beginning,use trace(..., at = *) or setBreakpoint.Using debug is persistent, and unless debugging is turned offthe debugger will be entered on every invocation (note that if thefunction is removed and replaced the debug state is not preserved).Use debugonce() to enter the debugger only the next time thefunction is invoked.To debug an S4 method by explicit signature, usesignature. When specified, signature indicates the method offun to be debugged. Note that debugging is implemented slightlydifferently for this case, as it uses the trace machinery, rather thanthe debugging bit. As such, text and condition cannot bespecified in combination with a non-null signature. For methodswhich implement the .local rematching mechanism, the.local closure itself is the one that will be ultimatelydebugged (see isRematched).isdebugged returns TRUE if a) signature is NULLand the closure fun has been debugged, or b) signature is notNULL, fun is an S4 generic, and the method of funfor that signature has been debugged. In all other cases, it returnsFALSE.The number of lines printed for the deparsed call when a function isentered for debugging can be limited by settingoptions(deparse.max.lines).When debugging is enabled on a byte compiled function then theinterpreted version of the function will be used until debugging isdisabled.
When a function flagged for debugging is entered, normal executionis suspended and the body of function is executed one statement at atime.  A new browser context is initiated for each step(and the previous one destroyed).At the debug prompt the user can enter commands or R expressions,followed by a newline.  The commands are described in thebrowser help topic.To debug a function which is defined inside another function,single-step through to the end of its definition, and then calldebug on its name.If you want to debug a function not starting at the very beginning,use trace(..., at = *) or setBreakpoint.Using debug is persistent, and unless debugging is turned offthe debugger will be entered on every invocation (note that if thefunction is removed and replaced the debug state is not preserved).Use debugonce() to enter the debugger only the next time thefunction is invoked.To debug an S4 method by explicit signature, usesignature. When specified, signature indicates the method offun to be debugged. Note that debugging is implemented slightlydifferently for this case, as it uses the trace machinery, rather thanthe debugging bit. As such, text and condition cannot bespecified in combination with a non-null signature. For methodswhich implement the .local rematching mechanism, the.local closure itself is the one that will be ultimatelydebugged (see isRematched).isdebugged returns TRUE if a) signature is NULLand the closure fun has been debugged, or b) signature is notNULL, fun is an S4 generic, and the method of funfor that signature has been debugged. In all other cases, it returnsFALSE.The number of lines printed for the deparsed call when a function isentered for debugging can be limited by settingoptions(deparse.max.lines).When debugging is enabled on a byte compiled function then theinterpreted version of the function will be used until debugging isdisabled.
When a function flagged for debugging is entered, normal executionis suspended and the body of function is executed one statement at atime.  A new browser context is initiated for each step(and the previous one destroyed).At the debug prompt the user can enter commands or R expressions,followed by a newline.  The commands are described in thebrowser help topic.To debug a function which is defined inside another function,single-step through to the end of its definition, and then calldebug on its name.If you want to debug a function not starting at the very beginning,use trace(..., at = *) or setBreakpoint.Using debug is persistent, and unless debugging is turned offthe debugger will be entered on every invocation (note that if thefunction is removed and replaced the debug state is not preserved).Use debugonce() to enter the debugger only the next time thefunction is invoked.To debug an S4 method by explicit signature, usesignature. When specified, signature indicates the method offun to be debugged. Note that debugging is implemented slightlydifferently for this case, as it uses the trace machinery, rather thanthe debugging bit. As such, text and condition cannot bespecified in combination with a non-null signature. For methodswhich implement the .local rematching mechanism, the.local closure itself is the one that will be ultimatelydebugged (see isRematched).isdebugged returns TRUE if a) signature is NULLand the closure fun has been debugged, or b) signature is notNULL, fun is an S4 generic, and the method of funfor that signature has been debugged. In all other cases, it returnsFALSE.The number of lines printed for the deparsed call when a function isentered for debugging can be limited by settingoptions(deparse.max.lines).When debugging is enabled on a byte compiled function then theinterpreted version of the function will be used until debugging isdisabled.
A data frame is a list of variables of the same number of rows withunique row names, given class "data.frame".  If no variablesare included, the row names determine the number of rows.The column names should be non-empty, and attempts to use empty nameswill have unsupported results.  Duplicate column names are allowed,but you need to use check.names = FALSE for data.frameto generate such a data frame.  However, not all operations on dataframes will preserve duplicated column names: for example matrix-likesubsetting will force column names in the result to be unique.data.frame converts each of its arguments to a data frame bycalling as.data.frame(optional = TRUE).  As that is ageneric function, methods can be written to change the behaviour ofarguments according to their classes: R comes with many such methods.Character variables passed to data.frame are converted tofactor columns unless protected by I or argumentstringsAsFactors is false.  If a list or dataframe or matrix is passed to data.frame it is as if eachcomponent or column had been passed as a separate argument (except formatrices protected by I).Objects passed to data.frame should have the same number ofrows, but atomic vectors (see is.vector), factors andcharacter vectors protected by I will be recycled awhole number of times if necessary (including as elements of listarguments).If row names are not supplied in the call to data.frame, therow names are taken from the first component that has suitable names,for example a named vector or a matrix with rownames or a data frame.(If that component is subsequently recycled, the names are discardedwith a warning.)  If row.names was supplied as NULL or nosuitable component was found the row names are the integer sequencestarting at one (and such row names are considered to be‘automatic’, and not preserved by as.matrix).If row names are supplied of length one and the data frame has asingle row, the row.names is taken to specify the row names andnot a column (by name or number).Names are removed from vector inputs not protected by I.default.stringsAsFactors is a utility that takesgetOption("stringsAsFactors") and ensures the result isTRUE or FALSE (or throws an error if the value is notNULL).  This function is deprecated now and will no longerbe available in the future.
Both eval.env and assign.env default to the currently activeenvironment.The expression assigned to a promise by delayedAssign willnot be evaluated until it is eventually ‘forced’.  This happens whenthe variable is first accessed.When the promise is eventually forced, it is evaluated within theenvironment specified by eval.env (whose contents may have changed inthe meantime).  After that, the value is fixed and the expression willnot be evaluated again.
These functions turn unevaluated expressions (where ‘expression’is taken in a wider sense than the strict concept of a vector ofmode and type (typeof)"expression" used in expression) into characterstrings (a kind of inverse to parse).A typical use of this is to create informative labels for data setsand plots.  The example shows a simple use of this facility.  It usesthe functions deparse and substitute to create labelsfor a plot which are character string versions of the actual argumentsto the function myplot.The default for the backtick option is not to quote singlesymbols but only composite expressions.  This is a compromise toavoid breaking existing code.Using control = c("all", "hexDigits") comes closest to making deparse()an inverse of parse() (but we have not yet seen an example where"all", now including "digits17", would not have been asgood).  However, not all objects are deparse-able even with these optionsand a warning will be issued if the function recognizes that it is beingasked to do the impossible.Unless control contains "digits17" or "hexDigits",(or "all" or "exact" which include one of these), numericand complex vectors are converted using 15 significant digits:see as.character for more details.width.cutoff is a lower bound for the line lengths: deparsing aline proceeds until at least width.cutoff bytes havebeen output and e.g. arg = value expressions will not be splitacross lines.deparse1() is a simple utility added in R 4.0.0 to ensure astring result (character vector of length one),typically used in name construction, asdeparse1(substitute(.)).
These functions turn unevaluated expressions (where ‘expression’is taken in a wider sense than the strict concept of a vector ofmode and type (typeof)"expression" used in expression) into characterstrings (a kind of inverse to parse).A typical use of this is to create informative labels for data setsand plots.  The example shows a simple use of this facility.  It usesthe functions deparse and substitute to create labelsfor a plot which are character string versions of the actual argumentsto the function myplot.The default for the backtick option is not to quote singlesymbols but only composite expressions.  This is a compromise toavoid breaking existing code.Using control = c("all", "hexDigits") comes closest to making deparse()an inverse of parse() (but we have not yet seen an example where"all", now including "digits17", would not have been asgood).  However, not all objects are deparse-able even with these optionsand a warning will be issued if the function recognizes that it is beingasked to do the impossible.Unless control contains "digits17" or "hexDigits",(or "all" or "exact" which include one of these), numericand complex vectors are converted using 15 significant digits:see as.character for more details.width.cutoff is a lower bound for the line lengths: deparsing aline proceeds until at least width.cutoff bytes havebeen output and e.g. arg = value expressions will not be splitacross lines.deparse1() is a simple utility added in R 4.0.0 to ensure astring result (character vector of length one),typically used in name construction, asdeparse1(substitute(.)).
The determinant function uses an LU decomposition and thedet function is simply a wrapper around a call todeterminant.Often, computing the determinant is not what you should be doingto solve a given problem.
This is most commonly used with a single number argument referring to aposition on the search list, and can also be used with a unquoted orquoted name of an item on the search list such as package:tools.If a package has a namespace, detaching it does not by default unloadthe namespace (and may not even with unload = TRUE), anddetaching will not in general unload any dynamically loaded compiledcode (DLLs); see getLoadedDLLs andlibrary.dynam.unload.  Further, registered S3 methodsfrom the namespace will not be removed, and because S3 methods arenot tagged to their source on registration, it is in general notpossible to safely un-register the methods associated with a givenpackage. If you use library on a package whosenamespace is loaded, it attaches the exports of the already loadednamespace.  So detaching and re-attaching a package may not refreshsome or all components of the package, and is inadvisable. The mostreliable way to completely detach a package is to restart R.
The determinant function uses an LU decomposition and thedet function is simply a wrapper around a call todeterminant.Often, computing the determinant is not what you should be doingto solve a given problem.
The determinant function uses an LU decomposition and thedet function is simply a wrapper around a call todeterminant.Often, computing the determinant is not what you should be doingto solve a given problem.
dput opens file and deparses the object x intothat file.  The object name is not written (unlike dump).If x is a function the associated environment is stripped.Hence scoping information can be lost.Deparsing an object is difficult, and not always possible.  With thedefault control, dput() attempts to deparse in a waythat is readable, but for more complex or unusual objects (seedump), not likelyto be parsed as identical to the original.  Use control = "all"for the most complete deparsing; use control = NULL for thesimplest deparsing, not even including attributes.dput will warn if fewer characters were written to a file thanexpected, which may indicate a full or corrupt file system.To display saved source rather than deparsing the internalrepresentation include "useSource" in control.  Rcurrently saves source only for function definitions.  If you do notcare about source representation (e.g., for a data object), for speedset options(keep.source = FALSE) when calling source.
diag has four distinct usages:x is a matrix, when it extracts the diagonal.x is missing and nrow is specified, it returnsan identity matrix.x is a scalar (length-one vector) and the onlyargument, it returns a square identity matrix of size given by the scalar.x is a ‘numeric’ (complex,numeric, integer, logical, orraw) vector, either of length at least 2 or therewere further arguments.  This returns a matrix with the givendiagonal and zero off-diagonal entries.It is an error to specify nrow or ncol in the first case.
diag has four distinct usages:x is a matrix, when it extracts the diagonal.x is missing and nrow is specified, it returnsan identity matrix.x is a scalar (length-one vector) and the onlyargument, it returns a square identity matrix of size given by the scalar.x is a ‘numeric’ (complex,numeric, integer, logical, orraw) vector, either of length at least 2 or therewere further arguments.  This returns a matrix with the givendiagonal and zero off-diagonal entries.It is an error to specify nrow or ncol in the first case.
diff is a generic function with a default method and ones forclasses "ts", "POSIXt" and"Date".NA's propagate.
diff is a generic function with a default method and ones forclasses "ts", "POSIXt" and"Date".NA's propagate.
diff is a generic function with a default method and ones forclasses "ts", "POSIXt" and"Date".NA's propagate.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
diff is a generic function with a default method and ones forclasses "ts", "POSIXt" and"Date".NA's propagate.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
The functions dim and dim<- are internal genericprimitive functions.dim has a method for data.frames, which returnsthe lengths of the row.names attribute of x andof x (as the numbers of rows and columns respectively).
The functions dim and dim<- are internal genericprimitive functions.dim has a method for data.frames, which returnsthe lengths of the row.names attribute of x andof x (as the numbers of rows and columns respectively).
The functions dim and dim<- are internal genericprimitive functions.dim has a method for data.frames, which returnsthe lengths of the row.names attribute of x andof x (as the numbers of rows and columns respectively).
The functions dimnames and dimnames<- are generic.For an array (and hence in particular, for amatrix), they retrieve or set the dimnamesattribute (see attributes) of the object.  A listvalue can have names, and these will be used to label thedimensions of the array where appropriate.The replacement method for arrays/matrices coerces vector and factorelements of value to character, but does not dispatch methodsfor as.character.  It coerces zero-length elements toNULL, and a zero-length list to NULL.  If valueis a list shorter than the number of dimensions, it is extended withNULLs to the needed length.Both have methods for data frames.  The dimnames of a data frame areits row.names and its names.  For thereplacement method each component of value will be coerced byas.character.For a 1D matrix the names are the same thing as the(only) component of the dimnames.Both are primitive functions.provideDimnames(x) provides dimnames where“missing”, such that its result has characterdimnames for each component.  If unique is true as by default,they are unique within each component via make.unique(*,    sep=sep).
The functions dimnames and dimnames<- are generic.For an array (and hence in particular, for amatrix), they retrieve or set the dimnamesattribute (see attributes) of the object.  A listvalue can have names, and these will be used to label thedimensions of the array where appropriate.The replacement method for arrays/matrices coerces vector and factorelements of value to character, but does not dispatch methodsfor as.character.  It coerces zero-length elements toNULL, and a zero-length list to NULL.  If valueis a list shorter than the number of dimensions, it is extended withNULLs to the needed length.Both have methods for data frames.  The dimnames of a data frame areits row.names and its names.  For thereplacement method each component of value will be coerced byas.character.For a 1D matrix the names are the same thing as the(only) component of the dimnames.Both are primitive functions.provideDimnames(x) provides dimnames where“missing”, such that its result has characterdimnames for each component.  If unique is true as by default,they are unique within each component via make.unique(*,    sep=sep).
The functions dimnames and dimnames<- are generic.For an array (and hence in particular, for amatrix), they retrieve or set the dimnamesattribute (see attributes) of the object.  A listvalue can have names, and these will be used to label thedimensions of the array where appropriate.The replacement method for arrays/matrices coerces vector and factorelements of value to character, but does not dispatch methodsfor as.character.  It coerces zero-length elements toNULL, and a zero-length list to NULL.  If valueis a list shorter than the number of dimensions, it is extended withNULLs to the needed length.Both have methods for data frames.  The dimnames of a data frame areits row.names and its names.  For thereplacement method each component of value will be coerced byas.character.For a 1D matrix the names are the same thing as the(only) component of the dimnames.Both are primitive functions.provideDimnames(x) provides dimnames where“missing”, such that its result has characterdimnames for each component.  If unique is true as by default,they are unique within each component via make.unique(*,    sep=sep).
The functions dimnames and dimnames<- are generic.For an array (and hence in particular, for amatrix), they retrieve or set the dimnamesattribute (see attributes) of the object.  A listvalue can have names, and these will be used to label thedimensions of the array where appropriate.The replacement method for arrays/matrices coerces vector and factorelements of value to character, but does not dispatch methodsfor as.character.  It coerces zero-length elements toNULL, and a zero-length list to NULL.  If valueis a list shorter than the number of dimensions, it is extended withNULLs to the needed length.Both have methods for data frames.  The dimnames of a data frame areits row.names and its names.  For thereplacement method each component of value will be coerced byas.character.For a 1D matrix the names are the same thing as the(only) component of the dimnames.Both are primitive functions.provideDimnames(x) provides dimnames where“missing”, such that its result has characterdimnames for each component.  If unique is true as by default,they are unique within each component via make.unique(*,    sep=sep).
NA
dir.exists checks that the paths exist (in the same sense asfile.exists) and are directories.dir.create creates the last element of the path, unlessrecursive = TRUE.  Trailing path separators are discarded.The mode will be modified by the umask setting in the same wayas for the system function mkdir.  What modes can be set isOS-dependent, and it is unsafe to assume that more than three octaldigits will be used.  For more details see your OS's documentation on thesystem call mkdir, e.g. man 2 mkdir (and not that onthe command-line utility of that name).One of the idiosyncrasies of Windows is that directory creation mayreport success but create a directory with a different name, forexample dir.create("G.S.") creates ‘"G.S"’.  This isundocumented, and what are the precise circumstances is unknown (andmight depend on the version of Windows).  Also avoid directory nameswith a trailing space.Sys.chmod sets the file permissions of one or more files.It may not be supported on a system (when a warning is issued).See the comments for dir.create for how modes are interpreted.Changing mode on a symbolic link is unlikely to work (nor benecessary).  For more details see your OS's documentation on thesystem call chmod, e.g. man 2 chmod (and not that onthe command-line utility of that name).  Whether this changes thepermission of a symbolic link or its target is OS-dependent (althoughto change the target is more common, and POSIX does not support modesfor symbolic links: BSD-based Unixes do, though).Sys.umask sets the umask and returns the previous value:as a special case mode = NA just returns the current value.It may not be supported (when a warning is issued and "0"is returned).  For more details see your OS's documentation on thesystem call umask, e.g. man 2 umask.How modes are handled depends on the file system, even on Unix-alikes(although their documentation is often written assuming a POSIX filesystem).  So treat documentation cautiously if you are using, say, aFAT/FAT32 or network-mounted file system.See files for how file paths with marked encodings are interpreted.  
dir.exists checks that the paths exist (in the same sense asfile.exists) and are directories.dir.create creates the last element of the path, unlessrecursive = TRUE.  Trailing path separators are discarded.The mode will be modified by the umask setting in the same wayas for the system function mkdir.  What modes can be set isOS-dependent, and it is unsafe to assume that more than three octaldigits will be used.  For more details see your OS's documentation on thesystem call mkdir, e.g. man 2 mkdir (and not that onthe command-line utility of that name).One of the idiosyncrasies of Windows is that directory creation mayreport success but create a directory with a different name, forexample dir.create("G.S.") creates ‘"G.S"’.  This isundocumented, and what are the precise circumstances is unknown (andmight depend on the version of Windows).  Also avoid directory nameswith a trailing space.Sys.chmod sets the file permissions of one or more files.It may not be supported on a system (when a warning is issued).See the comments for dir.create for how modes are interpreted.Changing mode on a symbolic link is unlikely to work (nor benecessary).  For more details see your OS's documentation on thesystem call chmod, e.g. man 2 chmod (and not that onthe command-line utility of that name).  Whether this changes thepermission of a symbolic link or its target is OS-dependent (althoughto change the target is more common, and POSIX does not support modesfor symbolic links: BSD-based Unixes do, though).Sys.umask sets the umask and returns the previous value:as a special case mode = NA just returns the current value.It may not be supported (when a warning is issued and "0"is returned).  For more details see your OS's documentation on thesystem call umask, e.g. man 2 umask.How modes are handled depends on the file system, even on Unix-alikes(although their documentation is often written assuming a POSIX filesystem).  So treat documentation cautiously if you are using, say, aFAT/FAT32 or network-mounted file system.See files for how file paths with marked encodings are interpreted.  
tilde expansion of the path is done except on Windows.Trailing path separators are removed before dissecting the path,and for dirname any trailing file separators are removedfrom the result.
If quote is FALSE, the default, then the arguments areevaluated (in the calling environment, not in envir).  Ifquote is TRUE then each argument is quoted (seequote) so that the effect of argument evaluation is toremove the quotes – leaving the original arguments unevaluated when thecall is constructed.The behavior of some functions, such as substitute,will not be the same for functions evaluated using do.call asif they were evaluated from the interpreter.  The precise semanticsare currently undefined and subject to change.
NA
double creates a double-precision vector of the specifiedlength.  The elements of the vector are all equal to 0.It is identical to numeric.as.double is a generic function.  It is identical toas.numeric.  Methods should return an object of base type"double".is.double is a test of double type.R has no single precision data type.  All real numbers arestored in double precision format.  The functions as.singleand single are identical to as.double and doubleexcept they set the attribute Csingle that is used in the.C and .Fortran interface, and they areintended only to be used in that context.
dput opens file and deparses the object x intothat file.  The object name is not written (unlike dump).If x is a function the associated environment is stripped.Hence scoping information can be lost.Deparsing an object is difficult, and not always possible.  With thedefault control, dput() attempts to deparse in a waythat is readable, but for more complex or unusual objects (seedump), not likelyto be parsed as identical to the original.  Use control = "all"for the most complete deparsing; use control = NULL for thesimplest deparsing, not even including attributes.dput will warn if fewer characters were written to a file thanexpected, which may indicate a full or corrupt file system.To display saved source rather than deparsing the internalrepresentation include "useSource" in control.  Rcurrently saves source only for function definitions.  If you do notcare about source representation (e.g., for a data object), for speedset options(keep.source = FALSE) when calling source.
The purpose of the functions is to provide a simple means of markupfor quoting text to be used in the R output, e.g., in warnings orerror messages.The choice of the appropriate quotation marks depends on both thelocale and the available character sets.  Older Unix/X11 fontsdisplayed the grave accent (ASCII code 0x60) and the apostrophe (0x27)in a way that they could also be used as matching open and closesingle quotation marks.  Using modern fonts, or non-Unix systems,these characters no longer produce matching glyphs.  Unicode providesleft and right single quotation mark characters (U+2018 and U+2019);if Unicode markup cannot be assumed to be available, it seems goodpractice to use the apostrophe as a non-directional single quotationmark.Similarly, Unicode has left and right double quotation mark characters(U+201C and U+201D); if only ASCII's typewriter characteristics can beemployed, than the ASCII quotation mark (0x22) should be used as boththe left and right double quotation mark.Some other locales also have the directional quotation marks, notablyon Windows.  TeX uses grave and apostrophe for the directional singlequotation marks, and doubled grave and doubled apostrophe for thedirectional double quotation marks.What rendering is used depends on q which by default depends onthe options setting for useFancyQuotes.  If thisis FALSE then the undirectionalASCII quotation style is used.  If this is TRUE (the default),Unicode directional quotes are used are used where available(currently, UTF-8 locales on Unix-alikes and all Windows localesexcept C): if set to "UTF-8" UTF-8 markup is used(whatever the current locale). If set to "TeX", TeX-stylemarkup is used.  Finally, if this is set to a character vector oflength four, the first two entries are used for beginning and endingsingle quotes and the second two for beginning and ending doublequotes: this can be used to implement non-English quoting conventionssuch as the use of guillemets.Where fancy quotes are used, you should be aware that they may not berendered correctly as not all fonts include the requisite glyphs: forexample some have directional single quotes but not directional doublequotes.
NA
The method for class "factor" is currently equivalent tofactor(x, exclude=exclude).  For the data frame method, youshould rarely specify exclude “globally” for all factorcolumns; rather the default uses the same factor-specificexclude as the factor method itself.The except argument follow the usual indexing rules.
The method for class "factor" is currently equivalent tofactor(x, exclude=exclude).  For the data frame method, youshould rarely specify exclude “globally” for all factorcolumns; rather the default uses the same factor-specificexclude as the factor method itself.The except argument follow the usual indexing rules.
The method for class "factor" is currently equivalent tofactor(x, exclude=exclude).  For the data frame method, youshould rarely specify exclude “globally” for all factorcolumns; rather the default uses the same factor-specificexclude as the factor method itself.The except argument follow the usual indexing rules.
If some of the objects named do not exist (in scope), they areomitted, with a warning.  If file is a file and no objectsexist then no file is created.sourceing may not produce an identical copy ofdumped objects.  A warning is issued if it is likely thatproblems will arise, for example when dumping exotic or complexobjects (see the Note).dump will also warn if fewer characters were written to a filethan expected, which may indicate a full or corrupt file system.A dump file can be sourced into another R (orperhaps S) session, but the functions save andsaveRDS are designed tobe used for transporting R data, and will work with R objects thatdump does not handle.  For maximal reproducibility usecontrol = c("all", "hexNumeric").To produce a more readable representation of an object, usecontrol = NULL.  This will skip attributes, and will make othersimplifications that make source less likely to produce anidentical copy.  See deparse for details.To deparse the internal representation of a function rather thandisplaying the saved source, use control = c("keepInteger",    "warnIncomplete", "keepNA").  This will lose all formatting andcomments, but may be useful in those cases where the saved source isno longer correct.Promises will normally only be encountered by users as a result oflazy-loading (when the default evaluate = TRUE is essential)and after the use of delayedAssign,when evaluate = FALSE might be intended.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
These are generic functions with methods for vectors (includinglists), data frames and arrays (including matrices).For the default methods, and whenever there are equivalent methoddefinitions for duplicated and anyDuplicated,anyDuplicated(x, ...) is a “generalized” shortcut forany(duplicated(x, ...)), in the sense that it returns theindex i of the first duplicated entry x[i] ifthere is one, and 0 otherwise.  Their behaviours may bedifferent when at least one of duplicated andanyDuplicated has a relevant method.duplicated(x, fromLast = TRUE) is equivalent to but faster thanrev(duplicated(rev(x))).The array method calculates for each element of the sub-arrayspecified by MARGIN if the remaining dimensions are identicalto those for an earlier (or later, when fromLast = TRUE) element(in row-major order).  This would most commonly be used to findduplicated rows (the default) or columns (with MARGIN = 2).Note that MARGIN = 0 returns an array of the samedimensionality attributes as x.Missing values ("NA") are regarded as equal, numeric andcomplex ones differing from NaN; character strings will be compared in a“common encoding”; for details, see match (andunique) which use the same concept.Values in incomparables will never be marked as duplicated.This is intended to be used for a fairly small set of values and willnot be efficient for a very large set.Except for factors, logical and raw vectors the default nmax = NA isequivalent to nmax = length(x).  Since a hash table of size8*nmax bytes is allocated, setting nmax suitably cansave large amounts of memory.  For factors it is automatically set tothe smaller of length(x) and the number of levels plus one (forNA).  If nmax is set too small there is liable to be anerror: nmax = 1 is silently ignored.Long vectors are supported for the default method ofduplicated, but may only be usable if nmax is supplied.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
See the description of options("warn") for thecircumstances under which there is a last.warning object andwarnings() is used.  In essence this is if options(warn =    0) and warning has been called at least once.Note that the length(last.warning) is maximallygetOption("nwarnings") (at the time the warnings aregenerated) which is 50 by default.  To increase, use somethinglike It is possible that last.warning refers to the last recordedwarning and not to the last warning, for example if options(warn) hasbeen changed or if a catastrophic error occurred.
The objects dyn.load loads are called ‘dynamicallyloadable libraries’ (abbreviated to ‘DLL’) on all platformsexcept macOS, which uses the term for a different sortof object.  On Unix-alikes they are also called ‘dynamicshared objects’ (‘DSO’), or ‘shared objects’ forshort.  (The POSIX standards use ‘executable object file’,but no one else does.)See ‘See Also’ and the ‘Writing R Extensions’ and‘R Installation and Administration’ manuals for how to createand install a suitable DLL.Unfortunately a very few platforms (e.g., Compaq Tru64) do not handlethe PACKAGE argument correctly, and may incorrectly findsymbols linked into R.The additional arguments to dyn.load mirror the differentaspects of the mode argument to the dlopen() routine on POSIXsystems.  They are available so that users can exercise greater controlover the loading process for an individual library.  In general, thedefault values are appropriate and you should override them only ifthere is good reason and you understand the implications.The local argument allows one to control whether the symbols inthe DLL being attached are visible to other DLLs.  While maintainingthe symbols in their own namespace is good practice, the ability toshare symbols across related ‘chapters’ is useful in manycases.  Additionally, on certain platforms and versions of anoperating system, certain libraries must have their symbols loadedglobally to successfully resolve all symbols.One should be careful of the potential side-effect of using lazyloading via the now argument as FALSE.  If a routine iscalled that has a missing symbol, the process will terminateimmediately.  The intended use is for library developers to call withvalue TRUE to check that all symbols are actually resolved andfor regular users to call with FALSE so that missing symbolscan be ignored and the available ones can be called.The initial motivation for adding these was to avoid such terminationin the _init() routines of the Java virtual machine library.However, symbols loaded locally may not be (read probably) availableto other DLLs.  Those added to the global table are available to allother elements of the application and so can be shared across twodifferent DLLs.Some (very old) systems do not provide (explicit) support forlocal/global and lazy/eager symbol resolution.  This can be the sourceof subtle bugs.  One can arrange to have warning messages emitted whenunsupported options are used.  This is done by setting either of theoptions verbose or warn to be non-zero via theoptions function.There is a short discussion of these additional arguments with someexample code available athttp://www.stat.ucdavis.edu/~duncan/R/dynload/.
The objects dyn.load loads are called ‘dynamicallyloadable libraries’ (abbreviated to ‘DLL’) on all platformsexcept macOS, which uses the term for a different sortof object.  On Unix-alikes they are also called ‘dynamicshared objects’ (‘DSO’), or ‘shared objects’ forshort.  (The POSIX standards use ‘executable object file’,but no one else does.)See ‘See Also’ and the ‘Writing R Extensions’ and‘R Installation and Administration’ manuals for how to createand install a suitable DLL.Unfortunately a very few platforms (e.g., Compaq Tru64) do not handlethe PACKAGE argument correctly, and may incorrectly findsymbols linked into R.The additional arguments to dyn.load mirror the differentaspects of the mode argument to the dlopen() routine on POSIXsystems.  They are available so that users can exercise greater controlover the loading process for an individual library.  In general, thedefault values are appropriate and you should override them only ifthere is good reason and you understand the implications.The local argument allows one to control whether the symbols inthe DLL being attached are visible to other DLLs.  While maintainingthe symbols in their own namespace is good practice, the ability toshare symbols across related ‘chapters’ is useful in manycases.  Additionally, on certain platforms and versions of anoperating system, certain libraries must have their symbols loadedglobally to successfully resolve all symbols.One should be careful of the potential side-effect of using lazyloading via the now argument as FALSE.  If a routine iscalled that has a missing symbol, the process will terminateimmediately.  The intended use is for library developers to call withvalue TRUE to check that all symbols are actually resolved andfor regular users to call with FALSE so that missing symbolscan be ignored and the available ones can be called.The initial motivation for adding these was to avoid such terminationin the _init() routines of the Java virtual machine library.However, symbols loaded locally may not be (read probably) availableto other DLLs.  Those added to the global table are available to allother elements of the application and so can be shared across twodifferent DLLs.Some (very old) systems do not provide (explicit) support forlocal/global and lazy/eager symbol resolution.  This can be the sourceof subtle bugs.  One can arrange to have warning messages emitted whenunsupported options are used.  This is done by setting either of theoptions verbose or warn to be non-zero via theoptions function.There is a short discussion of these additional arguments with someexample code available athttp://www.stat.ucdavis.edu/~duncan/R/dynload/.
The pos argument can specify the environment in which to lookfor the object in any of several ways: as a positive integer (theposition in the search list); as the character stringname of an element in the search list; or as anenvironment (including using sys.frameto access the currently active function calls).  The default of-1 indicates the current environment of the call toget. The envir argument is an alternative way tospecify an environment.These functions look to see if each of the name(s) x have avalue bound to it in the specified environment.  If inherits isTRUE and a value is not found for x in the specifiedenvironment, the enclosing frames of the environment are searcheduntil the name x is encountered.  See environmentand the ‘R Language Definition’ manual for details about thestructure of environments and their enclosures.If mode is specified then only objects of that type are sought.mode here is a mixture of the meanings of typeofand mode: "function" covers primitive functionsand operators, "numeric", "integer" and "double"all refer to any numeric type, "symbol" and "name" areequivalent but "language" must be used (and not"call" or "(").For mget, the values of mode and ifnotfound canbe either the same length as x or of length 1.  The argumentifnotfound must be a list containing either the value to use ifthe requested item is not found or a function of one argument whichwill be called if the item is not found, with argument the name of theitem being requested.dynGet() is somewhat experimental and to be used insideanother function.  It looks for an object in the callers, i.e.,the sys.frame()s of the function.  Use with caution.
NA
If symmetric is unspecified, isSymmetric(x)determines if the matrix is symmetric up to plausible numericalinaccuracies.  It is surer and typically much faster to set the valueyourself.Computing the eigenvectors is the slow part for large matrices.Computing the eigendecomposition of a matrix is subject to errors on areal-world computer: the definitive analysis is Wilkinson (1965).  Allyou can hope for is a solution to a problem suitably close tox.  So even though a real asymmetric x may have analgebraic solution with repeated real eigenvalues, the computedsolution may be of a similar matrix with complex conjugate pairs ofeigenvalues.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code (most often 1): these canonly be interpreted by detailed study of the FORTRAN code.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
Character strings in R can be declared to be encoded in"latin1" or "UTF-8" or as "bytes".  Thesedeclarations can be read by Encoding, which will return acharacter vector of values "latin1", "UTF-8""bytes" or "unknown", or set, when value isrecycled as needed and other values are silently treated as"unknown".  ASCII strings will never be marked with a declaredencoding, since their representation is the same in all supportedencodings.  Strings marked as "bytes" are intended to benon-ASCII strings which should be manipulated as bytes, and neverconverted to a character encoding (so writing them to a text file issupported only by writeLines(useBytes = TRUE)).enc2native and enc2utf8 convert elements of charactervectors to the native encoding or UTF-8 respectively, taking anymarked encoding into account.  They are primitive functions,designed to do minimal copying.There are other ways for character strings to acquire a declaredencoding apart from explicitly setting it (and these have changed asR has evolved).  The parser marks strings containing \u or\U escapes.  Functions scan,read.table, readLines, andparse have an encoding argument that is used todeclare encodings, iconv declares encodings from itsto argument, and console input in suitable locales is alsodeclared.  intToUtf8 declares its output as"UTF-8", and output text connections (seetextConnection) are marked if running in asuitable locale.  Under some circumstances (see its help page)source(encoding=) will mark encodings of characterstrings it outputs.Most character manipulation functions will set the encoding on outputstrings if it was declared on the corresponding input.  These includechartr, strsplit(useBytes = FALSE),tolower and toupper as well assub(useBytes = FALSE) and gsub(useBytes =  FALSE).  Note that such functions do not preserve theencoding, but if they know the input encoding and that the string hasbeen successfully re-encoded (to the current encoding or UTF-8), theymark the output.substr does preserve the encoding, andchartr, tolower and toupperpreserve UTF-8 encoding on systems with Unicode wide characters.  Withtheir fixed and perl options, strsplit,sub and gsub will give a marked UTF-8 result ifany of the inputs are UTF-8.paste and sprintf return elements markedas bytes if any of the corresponding inputs is marked as bytes, andotherwise marked as UTF-8 if any of the inputs is marked as UTF-8.match, pmatch, charmatch,duplicated and unique all match in UTF-8if any of the elements are marked as UTF-8.There is some ambiguity as to what is meant by a ‘Latin-1’locale, since some OSes (notably Windows) make use of characterpositions undefined (or used for control characters) in the ISO 8859-1character set.  How such characters are interpreted issystem-dependent but as from R 3.5.0 they are if possible interpretedas per Windows codepage 1252 (which Microsoft calls ‘WindowsLatin 1 (ANSI)’) when converting to e.g. UTF-8.
Character strings in R can be declared to be encoded in"latin1" or "UTF-8" or as "bytes".  Thesedeclarations can be read by Encoding, which will return acharacter vector of values "latin1", "UTF-8""bytes" or "unknown", or set, when value isrecycled as needed and other values are silently treated as"unknown".  ASCII strings will never be marked with a declaredencoding, since their representation is the same in all supportedencodings.  Strings marked as "bytes" are intended to benon-ASCII strings which should be manipulated as bytes, and neverconverted to a character encoding (so writing them to a text file issupported only by writeLines(useBytes = TRUE)).enc2native and enc2utf8 convert elements of charactervectors to the native encoding or UTF-8 respectively, taking anymarked encoding into account.  They are primitive functions,designed to do minimal copying.There are other ways for character strings to acquire a declaredencoding apart from explicitly setting it (and these have changed asR has evolved).  The parser marks strings containing \u or\U escapes.  Functions scan,read.table, readLines, andparse have an encoding argument that is used todeclare encodings, iconv declares encodings from itsto argument, and console input in suitable locales is alsodeclared.  intToUtf8 declares its output as"UTF-8", and output text connections (seetextConnection) are marked if running in asuitable locale.  Under some circumstances (see its help page)source(encoding=) will mark encodings of characterstrings it outputs.Most character manipulation functions will set the encoding on outputstrings if it was declared on the corresponding input.  These includechartr, strsplit(useBytes = FALSE),tolower and toupper as well assub(useBytes = FALSE) and gsub(useBytes =  FALSE).  Note that such functions do not preserve theencoding, but if they know the input encoding and that the string hasbeen successfully re-encoded (to the current encoding or UTF-8), theymark the output.substr does preserve the encoding, andchartr, tolower and toupperpreserve UTF-8 encoding on systems with Unicode wide characters.  Withtheir fixed and perl options, strsplit,sub and gsub will give a marked UTF-8 result ifany of the inputs are UTF-8.paste and sprintf return elements markedas bytes if any of the corresponding inputs is marked as bytes, andotherwise marked as UTF-8 if any of the inputs is marked as UTF-8.match, pmatch, charmatch,duplicated and unique all match in UTF-8if any of the elements are marked as UTF-8.There is some ambiguity as to what is meant by a ‘Latin-1’locale, since some OSes (notably Windows) make use of characterpositions undefined (or used for control characters) in the ISO 8859-1character set.  How such characters are interpreted issystem-dependent but as from R 3.5.0 they are if possible interpretedas per Windows codepage 1252 (which Microsoft calls ‘WindowsLatin 1 (ANSI)’) when converting to e.g. UTF-8.
This escapes backslash and the control characters \a (bell),\b (backspace), \f (formfeed), \n (line feed),\r (carriage return), \t (tab) and \v(vertical tab) as well as any non-printable characters in asingle-byte locale, which are printed in octal notation (\xyzwith leading zeroes).Which characters are non-printable depends on the current locale.Windows' reporting of printable characters is unreliable, so there allother control characters are regarded as non-printable, and allcharacters with codes 32–255 as printable in a single-byte locale.See print.default for how non-printable characters arehandled in multi-byte locales.If quote is a single or double quote any embedded quote of thesame type is escaped.  Note that justification is of the quotedstring, hence spaces are added outside the quotes.
Character strings in R can be declared to be encoded in"latin1" or "UTF-8" or as "bytes".  Thesedeclarations can be read by Encoding, which will return acharacter vector of values "latin1", "UTF-8""bytes" or "unknown", or set, when value isrecycled as needed and other values are silently treated as"unknown".  ASCII strings will never be marked with a declaredencoding, since their representation is the same in all supportedencodings.  Strings marked as "bytes" are intended to benon-ASCII strings which should be manipulated as bytes, and neverconverted to a character encoding (so writing them to a text file issupported only by writeLines(useBytes = TRUE)).enc2native and enc2utf8 convert elements of charactervectors to the native encoding or UTF-8 respectively, taking anymarked encoding into account.  They are primitive functions,designed to do minimal copying.There are other ways for character strings to acquire a declaredencoding apart from explicitly setting it (and these have changed asR has evolved).  The parser marks strings containing \u or\U escapes.  Functions scan,read.table, readLines, andparse have an encoding argument that is used todeclare encodings, iconv declares encodings from itsto argument, and console input in suitable locales is alsodeclared.  intToUtf8 declares its output as"UTF-8", and output text connections (seetextConnection) are marked if running in asuitable locale.  Under some circumstances (see its help page)source(encoding=) will mark encodings of characterstrings it outputs.Most character manipulation functions will set the encoding on outputstrings if it was declared on the corresponding input.  These includechartr, strsplit(useBytes = FALSE),tolower and toupper as well assub(useBytes = FALSE) and gsub(useBytes =  FALSE).  Note that such functions do not preserve theencoding, but if they know the input encoding and that the string hasbeen successfully re-encoded (to the current encoding or UTF-8), theymark the output.substr does preserve the encoding, andchartr, tolower and toupperpreserve UTF-8 encoding on systems with Unicode wide characters.  Withtheir fixed and perl options, strsplit,sub and gsub will give a marked UTF-8 result ifany of the inputs are UTF-8.paste and sprintf return elements markedas bytes if any of the corresponding inputs is marked as bytes, andotherwise marked as UTF-8 if any of the inputs is marked as UTF-8.match, pmatch, charmatch,duplicated and unique all match in UTF-8if any of the elements are marked as UTF-8.There is some ambiguity as to what is meant by a ‘Latin-1’locale, since some OSes (notably Windows) make use of characterpositions undefined (or used for control characters) in the ISO 8859-1character set.  How such characters are interpreted issystem-dependent but as from R 3.5.0 they are if possible interpretedas per Windows codepage 1252 (which Microsoft calls ‘WindowsLatin 1 (ANSI)’) when converting to e.g. UTF-8.
Character strings in R can be declared to be encoded in"latin1" or "UTF-8" or as "bytes".  Thesedeclarations can be read by Encoding, which will return acharacter vector of values "latin1", "UTF-8""bytes" or "unknown", or set, when value isrecycled as needed and other values are silently treated as"unknown".  ASCII strings will never be marked with a declaredencoding, since their representation is the same in all supportedencodings.  Strings marked as "bytes" are intended to benon-ASCII strings which should be manipulated as bytes, and neverconverted to a character encoding (so writing them to a text file issupported only by writeLines(useBytes = TRUE)).enc2native and enc2utf8 convert elements of charactervectors to the native encoding or UTF-8 respectively, taking anymarked encoding into account.  They are primitive functions,designed to do minimal copying.There are other ways for character strings to acquire a declaredencoding apart from explicitly setting it (and these have changed asR has evolved).  The parser marks strings containing \u or\U escapes.  Functions scan,read.table, readLines, andparse have an encoding argument that is used todeclare encodings, iconv declares encodings from itsto argument, and console input in suitable locales is alsodeclared.  intToUtf8 declares its output as"UTF-8", and output text connections (seetextConnection) are marked if running in asuitable locale.  Under some circumstances (see its help page)source(encoding=) will mark encodings of characterstrings it outputs.Most character manipulation functions will set the encoding on outputstrings if it was declared on the corresponding input.  These includechartr, strsplit(useBytes = FALSE),tolower and toupper as well assub(useBytes = FALSE) and gsub(useBytes =  FALSE).  Note that such functions do not preserve theencoding, but if they know the input encoding and that the string hasbeen successfully re-encoded (to the current encoding or UTF-8), theymark the output.substr does preserve the encoding, andchartr, tolower and toupperpreserve UTF-8 encoding on systems with Unicode wide characters.  Withtheir fixed and perl options, strsplit,sub and gsub will give a marked UTF-8 result ifany of the inputs are UTF-8.paste and sprintf return elements markedas bytes if any of the corresponding inputs is marked as bytes, andotherwise marked as UTF-8 if any of the inputs is marked as UTF-8.match, pmatch, charmatch,duplicated and unique all match in UTF-8if any of the elements are marked as UTF-8.There is some ambiguity as to what is meant by a ‘Latin-1’locale, since some OSes (notably Windows) make use of characterpositions undefined (or used for control characters) in the ISO 8859-1character set.  How such characters are interpreted issystem-dependent but as from R 3.5.0 they are if possible interpretedas per Windows codepage 1252 (which Microsoft calls ‘WindowsLatin 1 (ANSI)’) when converting to e.g. UTF-8.
startsWith() is equivalent to but much faster thanor alsowhere prefix is not to contain special regular expressioncharacters (and for grepl, x does not contain missingvalues, see below).The code has an optimized branch for the most common usage in whichprefix or suffix is of length one, and is furtheroptimized in a UTF-8 or 8-byte locale if that is an ASCII string.
The typical use of substitute is to create informative labelsfor data sets and plots.The myplot example below shows a simple use of this facility.It uses the functions deparse and substituteto create labels for a plot which are character string versionsof the actual arguments to the function myplot.Substitution takes place by examining each component of the parse treeas follows: If it is not a bound symbol in env, it isunchanged.  If it is a promise object, i.e., a formal argument to afunction or explicitly created using delayedAssign(),the expression slot of the promise replaces the symbol.  If it is anordinary variable, its value is substituted, unless env is.GlobalEnv in which case the symbol is left unchanged.Both quote and substitute are ‘special’primitive functions which do not evaluate their arguments.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
eval evaluates the expr argument in theenvironment specified by envir and returns the computed value.If envir is not specified, then the default isparent.frame() (the environment where the call toeval was made).Objects to be evaluated can be of types call orexpression or name (when the name is lookedup in the current scope and its binding is evaluated), a promiseor any of the basic types such as vectors, functions and environments(which are returned unchanged).The evalq form is equivalent to eval(quote(expr), ...).eval evaluates its first argument in the current scopebefore passing it to the evaluator: evalq avoids this.eval.parent(expr, n) is a shorthand foreval(expr, parent.frame(n)).If envir is a list (such as a data frame) or pairlist, it iscopied into a temporary environment (with enclosure enclos),and the temporary environment is used for evaluation.  So ifexpr changes any of the components named in the (pair)list, thechanges are lost.If envir is NULL it is interpreted as an empty list sono values could be found in envir and look-up goes directly toenclos.local evaluates an expression in a local environment.  It isequivalent to evalq except that its default argument creates anew, empty environment.  This is useful to create anonymous recursivefunctions and as a kind of limited namespace feature since variablesdefined in the environment are not visible from the outside.
eval evaluates the expr argument in theenvironment specified by envir and returns the computed value.If envir is not specified, then the default isparent.frame() (the environment where the call toeval was made).Objects to be evaluated can be of types call orexpression or name (when the name is lookedup in the current scope and its binding is evaluated), a promiseor any of the basic types such as vectors, functions and environments(which are returned unchanged).The evalq form is equivalent to eval(quote(expr), ...).eval evaluates its first argument in the current scopebefore passing it to the evaluator: evalq avoids this.eval.parent(expr, n) is a shorthand foreval(expr, parent.frame(n)).If envir is a list (such as a data frame) or pairlist, it iscopied into a temporary environment (with enclosure enclos),and the temporary environment is used for evaluation.  So ifexpr changes any of the components named in the (pair)list, thechanges are lost.If envir is NULL it is interpreted as an empty list sono values could be found in envir and look-up goes directly toenclos.local evaluates an expression in a local environment.  It isequivalent to evalq except that its default argument creates anew, empty environment.  This is useful to create anonymous recursivefunctions and as a kind of limited namespace feature since variablesdefined in the environment are not visible from the outside.
eval evaluates the expr argument in theenvironment specified by envir and returns the computed value.If envir is not specified, then the default isparent.frame() (the environment where the call toeval was made).Objects to be evaluated can be of types call orexpression or name (when the name is lookedup in the current scope and its binding is evaluated), a promiseor any of the basic types such as vectors, functions and environments(which are returned unchanged).The evalq form is equivalent to eval(quote(expr), ...).eval evaluates its first argument in the current scopebefore passing it to the evaluator: evalq avoids this.eval.parent(expr, n) is a shorthand foreval(expr, parent.frame(n)).If envir is a list (such as a data frame) or pairlist, it iscopied into a temporary environment (with enclosure enclos),and the temporary environment is used for evaluation.  So ifexpr changes any of the components named in the (pair)list, thechanges are lost.If envir is NULL it is interpreted as an empty list sono values could be found in envir and look-up goes directly toenclos.local evaluates an expression in a local environment.  It isequivalent to evalq except that its default argument creates anew, empty environment.  This is useful to create anonymous recursivefunctions and as a kind of limited namespace feature since variablesdefined in the environment are not visible from the outside.
The where argument can specify the environment in which to lookfor the object in any of several ways: as an integer (the position inthe search list); as the character string name of anelement in the search list; or as an environment(including using sys.frame to access the currently activefunction calls).  The envir argument is an alternative way tospecify an environment, but is primarily there for back compatibility.This function looks to see if the name x has a value bound toit in the specified environment.  If inherits is TRUE anda value is not found for x in the specified environment, theenclosing frames of the environment are searched until the name xis encountered.  See environment and the ‘RLanguage Definition’ manual for details about the structure ofenvironments and their enclosures.Warning:inherits = TRUE is the default behaviour for R but not for S.If mode is specified then only objects of that type are sought.The mode may specify one of the collections "numeric" and"function" (see mode): any member of thecollection will suffice.  (This is true even if a member of acollection is specified, so for example mode = "special" willseek any type of function.)
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
NA
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
‘Expression’ here is not being used in its colloquial sense,that of mathematical expressions.  Those are calls (seecall) in R, and an R expression vector is a list ofcalls, symbols etc, for example as returned by parse.As an object of mode "expression" is a list, it can besubsetted by [, [[ or $, the latter two extractingindividual calls etc.  The replacement forms of these operators can beused to replace or delete elements.expression and is.expression are primitive functions.expression is ‘special’: it does not evaluate its arguments.
The reports the versions of third-party software libraries in use.These are often external but might have been compiled into R when itwas installed.With dynamic linking, these are the versions of the libraries linkedto in this session: with static linking, of those compiled in.
TRUE and FALSE are reserved words denoting logicalconstants in the R language, whereas T and F are globalvariables whose initial values set to these.  All four arelogical(1) vectors.Logical vectors are coerced to integer vectors in contexts where anumerical value is required, with TRUE being mapped to1L, FALSE to 0L and NA to NA_integer_.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The mode value can be the exclusive or of the following valuestest for existence.test for execute permission.test for write permission.test for read permission.Permission will be computed for real user ID and real group ID (ratherthan the effective IDs).Please note that it is not a good idea to use this function to testbefore trying to open a file.  On a multi-tasking system, it ispossible that the accessibility of a file will change between the timeyou call file.access() and the time you try to open the file.It is better to wrap file open attempts in try.
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
NA
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
What constitutes a ‘file’ is OS-dependent but includesdirectories.  (However, directory names must not include a trailingbackslash or slash on Windows.)  See also the section in the help forfile.exists on case-insensitive file systems.The file ‘mode’ follows POSIX conventions, giving three octaldigits summarizing the permissions for the file owner, the owner'sgroup and for anyone respectively.  Each digit is the logicalor of read (4), write (2) and execute/search (1) permissions.See files for how file paths with marked encodings are interpreted.On most systems symbolic links are followed, so information is givenabout the file to which the link points rather than about the link.
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
What constitutes a ‘file’ is OS-dependent but includesdirectories.  (However, directory names must not include a trailingbackslash or slash on Windows.)  See also the section in the help forfile.exists on case-insensitive file systems.The file ‘mode’ follows POSIX conventions, giving three octaldigits summarizing the permissions for the file owner, the owner'sgroup and for anyone respectively.  Each digit is the logicalor of read (4), write (2) and execute/search (1) permissions.See files for how file paths with marked encodings are interpreted.On most systems symbolic links are followed, so information is givenabout the file to which the link points rather than about the link.
What constitutes a ‘file’ is OS-dependent but includesdirectories.  (However, directory names must not include a trailingbackslash or slash on Windows.)  See also the section in the help forfile.exists on case-insensitive file systems.The file ‘mode’ follows POSIX conventions, giving three octaldigits summarizing the permissions for the file owner, the owner'sgroup and for anyone respectively.  Each digit is the logicalor of read (4), write (2) and execute/search (1) permissions.See files for how file paths with marked encodings are interpreted.On most systems symbolic links are followed, so information is givenabout the file to which the link points rather than about the link.
The implementation is designed to be fast (faster thanpaste) as this function is used extensively in R itself.It can also be used for environment paths such as PATH andR_LIBS with fsep = .Platform$path.sep.Trailing path separators are invalid for Windows file paths apart from‘/’ and ‘d:/’ (although some functions/utilities do acceptthem), so a trailing / or \ is removed there.
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
This function provides the core of the R help system, but it can beused for other purposes as well, such as page.How the pager is implemented is highly system-dependent.The basic Unix version concatenates the files (using the headers) to atemporary file, and displays it in the pager selected by thepager argument, which is a character vector specifying a systemcommand (a full path or a command found on the PATH) to run onthe set of files.  The ‘factory-fresh’ default is to use‘R_HOME/bin/pager’, which is a shell script running the command-linespecified by the environment variable PAGER whose default is setat configuration, usually to less.  On a Unix-alikemore is used if pager is empty.Most GUI systems will use a separate pager window for each file, andlet the user leave it up while R continues running.  The selection ofsuch pagers could either be done using special pager names beingintercepted by lower-level code (such as "internal" and"console" on Windows), or by letting pager be an Rfunction which will be called with arguments (files, header,    title, delete.file) corresponding to the first four arguments offile.show and take care of interfacing to the GUI.The R.app GUI on macOS uses its internal pager irrespectiveof the setting of pager.Not all implementations will honour delete.file.  Inparticular, using an external pager on Windows does not, as there isno way to know when the external application has finished with thefile.
What constitutes a ‘file’ is OS-dependent but includesdirectories.  (However, directory names must not include a trailingbackslash or slash on Windows.)  See also the section in the help forfile.exists on case-insensitive file systems.The file ‘mode’ follows POSIX conventions, giving three octaldigits summarizing the permissions for the file owner, the owner'sgroup and for anyone respectively.  Each digit is the logicalor of read (4), write (2) and execute/search (1) permissions.See files for how file paths with marked encodings are interpreted.On most systems symbolic links are followed, so information is givenabout the file to which the link points rather than about the link.
The ... arguments are concatenated to form one characterstring: you can specify the files separately or as one vector.All of these functions expand path names: see path.expand.file.create creates files with the given names if they do notalready exist and truncates them if they do.  They are created withthe maximal read/write permissions allowed by the‘umask’ setting (where relevant).  By default a warningis given (with the reason) if the operation fails.file.exists returns a logical vector indicating whether thefiles named by its argument exist.  (Here ‘exists’ is in thesense of the system's stat call: a file will be reported asexisting only if you have the permissions needed by stat.Existence can also be checked by file.access, whichmight use different permissions and so obtain a different result.Note that the existence of a file does not imply that it is readable:for that use file.access.)  What constitutes a‘file’ is system-dependent, but should include directories.(However, directory names must not include a trailing backslash orslash on Windows.)  Note that if the file is a symbolic link on aUnix-alike, the result indicates if the link points to an actual file,not just if the link exists.Lastly, note the different function exists whichchecks for existence of R objects.file.remove attempts to remove the files named in its argument.On most Unix platforms ‘file’ includes emptydirectories, symbolic links, fifos and sockets.  On Windows,‘file’ means a regular file and not, say, an empty directory.file.rename attempts to rename files (and from andto must be of the same length).  Where file permissions allowthis will overwrite an existing element of to.  This is subjectto the limitations of the OS's corresponding system call (seesomething like man 2 rename on a Unix-alike): in particularin the interpretation of ‘file’: most platforms will not renamefiles from one file system to another.  NB: This means thatrenaming a file from a temporary directory to the user's filespace orduring package installation will often fail.  (On Windows,file.rename can rename files but not directories acrossvolumes.)  On platforms which allow directories to be renamed,typically neither or both of from and to must adirectory, and if to exists it must be an empty directory.file.append attempts to append the files named by itssecond argument to those named by its first.  The R subscriptrecycling rule is used to align names given in vectorsof different lengths.file.copy works in a similar way to file.append but withthe arguments in the natural order for copying.  Copying to existingdestination files is skipped unless overwrite = TRUE.  Theto argument can specify a single existing directory.  Ifcopy.mode = TRUE file read/write/execute permissions are copiedwhere possible, restricted by ‘umask’.  (On Windows thisapplies only to files.)  Other security attributes such as ACLs are notcopied.  On a POSIX filesystem the targets of symbolic links will becopied rather than the links themselves, and hard links are copiedseparately.  Using copy.date = TRUE may or may not copy thetimestamp exactly (for example, fractional seconds may be omitted),but is more likely to do so as from R 3.4.0.file.symlink and file.link make symbolic and hard linkson those file systems which support them.  For file.symlink theto argument can specify a single existing directory.  (Unix andmacOS native filesystems support both.  Windows has hard links tofiles on NTFS file systems and concepts related to symbolic links onrecent versions: see the section below on the Windows version of thishelp page.  What happens on a FAT or SMB-mounted file system is OS-specific.)File arguments with a marked encoding (see Encoding areif possible translated to the native encoding, except on Windows whereUnicode file operations are used (so marking as UTF-8 can be used toaccess file paths not in the native encoding on suitable filesystems).
If init is given, Reduce logically adds it to the start(when proceeding left to right) or the end of x, respectively.If this possibly augmented vector v has n > 1 elements,Reduce successively applies f to the elements of vfrom left to right or right to left, respectively.  I.e., a leftreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,and returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce doesr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})and returns r_1 = f(v_1, r_2).  (E.g., if v is thesequence (2, 3, 4) and f is division, left and right reduce give(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)If v has only a single element, this is returned; if there areno elements, NULL is returned.  Thus, it is ensured thatf is always called with 2 arguments.The current implementation is non-recursive to ensure stability andscalability.Reduce is patterned after Common Lisp's reduce.  Areduce is also known as a fold (e.g., in Haskell) or an accumulate(e.g., in the C++ Standard Template Library).  The accumulativeversion corresponds to Haskell's scan functions.Filter applies the unary predicate function f to eachelement of x, coercing to logical if necessary, and returns thesubset of x for which this gives true.  Note that possibleNA values are currently always taken as false; control overNA handling may be added in the future.  Filtercorresponds to filter in Haskell or remove-if-not inCommon Lisp.Find and Position are patterned after Common Lisp'sfind-if and position-if, respectively.  If there is anelement for which the predicate function gives true, then the first orlast such element or its position is returned depending on whetherright is false (default) or true, respectively.  If there is nosuch element, the value specified by nomatch is returned.  Thecurrent implementation is not optimized for performance.Map is a simple wrapper to mapply which does notattempt to simplify the result, similar to Common Lisp's mapcar(with arguments being recycled, however).  Future versions may allowsome control of the result type.Negate corresponds to Common Lisp's complement.  Given a(predicate) function f, it creates a function which returns thelogical negation of what f returns.
If init is given, Reduce logically adds it to the start(when proceeding left to right) or the end of x, respectively.If this possibly augmented vector v has n > 1 elements,Reduce successively applies f to the elements of vfrom left to right or right to left, respectively.  I.e., a leftreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,and returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce doesr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})and returns r_1 = f(v_1, r_2).  (E.g., if v is thesequence (2, 3, 4) and f is division, left and right reduce give(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)If v has only a single element, this is returned; if there areno elements, NULL is returned.  Thus, it is ensured thatf is always called with 2 arguments.The current implementation is non-recursive to ensure stability andscalability.Reduce is patterned after Common Lisp's reduce.  Areduce is also known as a fold (e.g., in Haskell) or an accumulate(e.g., in the C++ Standard Template Library).  The accumulativeversion corresponds to Haskell's scan functions.Filter applies the unary predicate function f to eachelement of x, coercing to logical if necessary, and returns thesubset of x for which this gives true.  Note that possibleNA values are currently always taken as false; control overNA handling may be added in the future.  Filtercorresponds to filter in Haskell or remove-if-not inCommon Lisp.Find and Position are patterned after Common Lisp'sfind-if and position-if, respectively.  If there is anelement for which the predicate function gives true, then the first orlast such element or its position is returned depending on whetherright is false (default) or true, respectively.  If there is nosuch element, the value specified by nomatch is returned.  Thecurrent implementation is not optimized for performance.Map is a simple wrapper to mapply which does notattempt to simplify the result, similar to Common Lisp's mapcar(with arguments being recycled, however).  Future versions may allowsome control of the result type.Negate corresponds to Common Lisp's complement.  Given a(predicate) function f, it creates a function which returns thelogical negation of what f returns.
find.package returns path to the locations where thegiven packages are found.  If lib.loc is NULL, thenloaded namespaces are searched before the libraries.  If a package isfound more than once, the first match is used.  Unless quiet =  TRUE a warning will be given about the named packages which are notfound, and an error if none are.  If verbose is true, warningsabout packages found more than once are given.  For a package to bereturned it must contain a either a ‘Meta’ subdirectory or a‘DESCRIPTION’ file containing a valid version field, butit need not be installed (it could be a source package iflib.loc was set suitably).find.package is not usually the right tool to find out if apackage is available for use: the only way to do that is to userequire to try to load it.  It need not be installed forthe correct platform, it might have a version requirement not met bythe running version of R, there might be dependencies which are notavailable, ....path.package returns the paths from which the named packageswere loaded, or if none were named, for all currently attached packages.Unless quiet = TRUE it will warn if some of the packages namedare not attached, and given an error if none are.packageNotFoundError creates an error condition object of classpackageNotFoundError for signaling errors. The condition objectcontains the fields package and lib.loc.  
The function findInterval finds the index of one vector x inanother, vec, where the latter must be non-decreasing.  Wherethis is trivial, equivalent to apply( outer(x, vec, ">="), 1, sum),as a matter of fact, the internal algorithm uses interval searchensuring O(n * log(N)) complexity wheren <- length(x) (and N <- length(vec)).  For (almost)sorted x, it will be even faster, basically O(n).This is the same computation as for the empirical distributionfunction, and indeed, findInterval(t, sort(X)) isidentical to n * Fn(t;    X[1],..,X[n]) where Fn is the empirical distributionfunction of X[1],..,X[n].When rightmost.closed = TRUE, the result for x[j] = vec[N]( = max(vec)), is N - 1 as for all othervalues in the last interval.left.open = TRUE is occasionally useful, e.g., for survival data.For (anti-)symmetry reasons, it is equivalent to using“mirrored” data, i.e., the following is always true:where N <- length(vec) as above.
The functions .subset and .subset2 are essentiallyequivalent to the [ and [[ operators,except that methods dispatch does not take place.  This is to avoidexpensive unclassing when applying the default method to an object.  Theyshould not normally be invoked by end users.  Note that unlike theoperators they are builtins and not specials (all arguments areevaluated) and hence do not allow missing arguments..getRequiredPackages2 attaches all the packages mentioned in theDepends field: failure to find a package is an error.  It alsochecks the versions of the packages found against the Depends field..getRequiredPackages is a wrapper to.getRequiredPackages2 using a ‘DESCRIPTION’ file.The function .isMethodsDispatchOn() returns TRUE ifthe S4 method dispatch has been turned on in the evaluator (usually byloading package methods).  It is meant for R internal use only.sys.save.image is a system function that is called by q()and its GUI analogs; sys.load.image is called by the startup code.These functions should not be called directly and are subject to change.sys.save.image closes all connections first, to ensure that itis able to open a connection to save the image.  This is appropriatewhen called from q() and allies, but reinforces the warningthat it should not be called directly.row.names can be stored internally in compact form..set_row_names(n) generates that form for automatic row namesof length n, to be assigned toattr(<a data frame>, "row.names").  .row_names_infogives information on the internal form of the row names for a dataframe: for details of what information see the argument type..GenericArgsEnv and .ArgsEnv are environments thatcontain closures with the argument lists that the primitives wouldhave had had they been closures.  All the primitives that are internalS3 generics have corresponding members of .GenericArgsEnv andthe remaining non-language-element primitives correspond to.ArgsEnv.  See the ‘R Internals’ manual for furtherdetails.  They are used by args andprint.default and the QC functions codocand checkS3methods.findPackageEnv is invoked by the unserialize code to set asaved environment if possible..TAOCP1997init is the initialization code for the"Knuth-TAOCP" RNG..gt and .gtn are callbacks from rank andis.unsorted used for (S3 or S4) classed objects..primTrace and .primUntrace are the primitivefunctions underlying trace and untracerespectively..Date, .POSIXct, .POSIXlt and .difftimeare class generators..cache_class caches the inheritance of an S4 class for use inS3 method dispatch.  With NULL second argument it returns thecached inheritance, for diagnostic use..popath is a variable created at startup which records wherethe translations package in use is..detach is a ‘bare-bones’ version of detach foruse in other R packages..maskedMsg is a utility called both from attach()and library() for consistency to produce the warning message.Objects starting .C_ and .F_ are references toregistered C and Fortran entry points.Only on Windows:.fixupGFortranStdout and .fixupGFortranStderr are helper functionsto enable standard output and standard error units in gfortran whenexecuting external code via system and system2. By default, theseunits are disabled by the Windows profile when running inside RGui.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
These are generic functions: methods can be defined for themindividually or via the Math groupgeneric.Note that for rounding off a 5, the IEC 60559 standard (see also‘IEEE 754’) is expected to be used, ‘go to the even digit’.Therefore round(0.5) is 0 and round(-1.5) is-2.  However, this is dependent on OS services and onrepresentation error (since e.g. 0.15 is not representedexactly, the rounding rule applies to the represented number and notto the printed number, and so round(0.15, 1) could be either0.1 or 0.2).Rounding to a negative number of digits means rounding to a power often, so for example round(x, digits = -2) rounds to the nearesthundred.For signif the recognized values of digits are1...22, and non-missing values are rounded to the nearestinteger in that range.  Complex numbers are rounded to retain thespecified number of digits in the larger of the components.  Eachelement of the vector is rounded individually, unlike printing.These are all primitive functions.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
break breaks out of a for, while or repeatloop; control is transferred to the first statement outside theinner-most loop. next halts the processing of the currentiteration and advances the looping index.  Both break andnext apply only to the innermost of nested loops.Note that it is a common mistake to forget to put braces ({ .. })around your statements, e.g., after if(..) or for(....).In particular, you should not have a newline between } andelse to avoid a syntax error in entering a if ... elseconstruct at the keyboard or via source.For that reason, one (somewhat extreme) attitude of defensive programmingis to always use braces, e.g., for if clauses.The seq in a for loop is evaluated at the start ofthe loop; changing it subsequently does not affect the loop.  Ifseq has length zero the body of the loop is skipped. Otherwise thevariable var is assigned in turn the value of each element ofseq. You can assign to var within the body of the loop,but this will not affect the next iteration.  When the loop terminates,var remains as a variable containing its latest value.
force forces the evaluation of a formal argument.  This canbe useful if the argument will be captured in a closure by the lexicalscoping rules and will later be altered by an explicit assignment oran implicit assignment in a loop or an apply function.
forceAndCall calls the function FUN with argumentsspecified in ....  If the value of FUN is a closurethen the first n arguments to the function are evaluated(i.e. their delayed evaluation promises are forced) before executingthe function body.  If the value of FUN is a primitive thenthe call FUN(...) is evaluated in the usual way.forceAndCall is intended to help defining higher orderfunctions like apply to behave more reasonably when theresult returned by the function applied is a closure that captured itsarguments.
For the first form, fun can also be a character string namingthe function to be manipulated, which is searched for in envir,by default from the parentframe.  If it is not specified, the function calling formals isused.Only closures have formals, not primitive functions.
For the first form, fun can also be a character string namingthe function to be manipulated, which is searched for in envir,by default from the parentframe.  If it is not specified, the function calling formals isused.Only closures have formals, not primitive functions.
format is a generic function.  Apart from the methods describedhere there are methods for dates (see format.Date),date-times (see format.POSIXct) and for other classes suchas format.octmode and format.dist.format.data.frame formats the data frame column by column,applying the appropriate method of format for each column.Methods for columns are often similar to as.character but offermore control.  Matrix and data-frame columns will be converted toseparate columns in the result, and character columns (normally all)will be given class "AsIs".format.factor converts the factor to a character vector andthen calls the default method (and so justify applies).format.AsIs deals with columns of complicated objects thathave been extracted from a data frame.  Character objects and (atomic)matrices are passed to the default method (and so width doesnot apply).Otherwise it calls toString to convert the objectto character (if a vector or list, element by element) and thenright-justifies the result.Justification for character vectors (and objects converted tocharacter vectors by their methods) is done on display width (seenchar), taking double-width characters and the renderingof special characters (as escape sequences, including escapingbackslash but not double quote: see print.default) intoaccount.  Thus the width is as displayed by print(quote =  FALSE) and not as displayed by cat.  Character stringsare padded with blanks to the display width of the widest.  (Ifna.encode = FALSE missing character strings are not included inthe width computations and are not encoded.)Numeric vectors are encoded with the minimum number of decimal placesneeded to display all the elements to at least the digitssignificant digits.  However, if all the elements then have trailingzeroes, the number of decimal places is reduced untilnsmall is reached or at least oneelement has a non-zero final digit; see also the argumentdocumentation for big.*, small.* etc, above.  See thenote in print.default about digits >= 16.Raw vectors are converted to their 2-digit hexadecimal representationby as.character.format.default(x) now provides a “minimal” string whenisS4(x) is true.The internal code respects the optiongetOption("OutDec") for the ‘decimal mark’, so ifthis is set to something other than "." then it takes precedenceover argument decimal.mark.
format is a generic function.  Apart from the methods describedhere there are methods for dates (see format.Date),date-times (see format.POSIXct) and for other classes suchas format.octmode and format.dist.format.data.frame formats the data frame column by column,applying the appropriate method of format for each column.Methods for columns are often similar to as.character but offermore control.  Matrix and data-frame columns will be converted toseparate columns in the result, and character columns (normally all)will be given class "AsIs".format.factor converts the factor to a character vector andthen calls the default method (and so justify applies).format.AsIs deals with columns of complicated objects thathave been extracted from a data frame.  Character objects and (atomic)matrices are passed to the default method (and so width doesnot apply).Otherwise it calls toString to convert the objectto character (if a vector or list, element by element) and thenright-justifies the result.Justification for character vectors (and objects converted tocharacter vectors by their methods) is done on display width (seenchar), taking double-width characters and the renderingof special characters (as escape sequences, including escapingbackslash but not double quote: see print.default) intoaccount.  Thus the width is as displayed by print(quote =  FALSE) and not as displayed by cat.  Character stringsare padded with blanks to the display width of the widest.  (Ifna.encode = FALSE missing character strings are not included inthe width computations and are not encoded.)Numeric vectors are encoded with the minimum number of decimal placesneeded to display all the elements to at least the digitssignificant digits.  However, if all the elements then have trailingzeroes, the number of decimal places is reduced untilnsmall is reached or at least oneelement has a non-zero final digit; see also the argumentdocumentation for big.*, small.* etc, above.  See thenote in print.default about digits >= 16.Raw vectors are converted to their 2-digit hexadecimal representationby as.character.format.default(x) now provides a “minimal” string whenisS4(x) is true.The internal code respects the optiongetOption("OutDec") for the ‘decimal mark’, so ifthis is set to something other than "." then it takes precedenceover argument decimal.mark.
format is a generic function.  Apart from the methods describedhere there are methods for dates (see format.Date),date-times (see format.POSIXct) and for other classes suchas format.octmode and format.dist.format.data.frame formats the data frame column by column,applying the appropriate method of format for each column.Methods for columns are often similar to as.character but offermore control.  Matrix and data-frame columns will be converted toseparate columns in the result, and character columns (normally all)will be given class "AsIs".format.factor converts the factor to a character vector andthen calls the default method (and so justify applies).format.AsIs deals with columns of complicated objects thathave been extracted from a data frame.  Character objects and (atomic)matrices are passed to the default method (and so width doesnot apply).Otherwise it calls toString to convert the objectto character (if a vector or list, element by element) and thenright-justifies the result.Justification for character vectors (and objects converted tocharacter vectors by their methods) is done on display width (seenchar), taking double-width characters and the renderingof special characters (as escape sequences, including escapingbackslash but not double quote: see print.default) intoaccount.  Thus the width is as displayed by print(quote =  FALSE) and not as displayed by cat.  Character stringsare padded with blanks to the display width of the widest.  (Ifna.encode = FALSE missing character strings are not included inthe width computations and are not encoded.)Numeric vectors are encoded with the minimum number of decimal placesneeded to display all the elements to at least the digitssignificant digits.  However, if all the elements then have trailingzeroes, the number of decimal places is reduced untilnsmall is reached or at least oneelement has a non-zero final digit; see also the argumentdocumentation for big.*, small.* etc, above.  See thenote in print.default about digits >= 16.Raw vectors are converted to their 2-digit hexadecimal representationby as.character.format.default(x) now provides a “minimal” string whenisS4(x) is true.The internal code respects the optiongetOption("OutDec") for the ‘decimal mark’, so ifthis is set to something other than "." then it takes precedenceover argument decimal.mark.
The usual vector re-cycling rules are applied to x andformat so the answer will be of length that of the longer of thevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months.The as.Date methods accept character strings, factors, logicalNA and objects of classes "POSIXlt" and"POSIXct".  (The last is converted to days by ignoringthe time after midnight in the representation of the time in specifiedtime zone, default UTC.)  Also objects of class "date" (frompackage date) and "dates" (frompackage chron).  Character strings are processedas far as necessary for the format specified: any trailing charactersare ignored.as.Date will accept numeric data (the number of days since anepoch), but only if origin is supplied.The format and as.character methods ignore anyfractional part of the date.
format is a generic function.  Apart from the methods describedhere there are methods for dates (see format.Date),date-times (see format.POSIXct) and for other classes suchas format.octmode and format.dist.format.data.frame formats the data frame column by column,applying the appropriate method of format for each column.Methods for columns are often similar to as.character but offermore control.  Matrix and data-frame columns will be converted toseparate columns in the result, and character columns (normally all)will be given class "AsIs".format.factor converts the factor to a character vector andthen calls the default method (and so justify applies).format.AsIs deals with columns of complicated objects thathave been extracted from a data frame.  Character objects and (atomic)matrices are passed to the default method (and so width doesnot apply).Otherwise it calls toString to convert the objectto character (if a vector or list, element by element) and thenright-justifies the result.Justification for character vectors (and objects converted tocharacter vectors by their methods) is done on display width (seenchar), taking double-width characters and the renderingof special characters (as escape sequences, including escapingbackslash but not double quote: see print.default) intoaccount.  Thus the width is as displayed by print(quote =  FALSE) and not as displayed by cat.  Character stringsare padded with blanks to the display width of the widest.  (Ifna.encode = FALSE missing character strings are not included inthe width computations and are not encoded.)Numeric vectors are encoded with the minimum number of decimal placesneeded to display all the elements to at least the digitssignificant digits.  However, if all the elements then have trailingzeroes, the number of decimal places is reduced untilnsmall is reached or at least oneelement has a non-zero final digit; see also the argumentdocumentation for big.*, small.* etc, above.  See thenote in print.default about digits >= 16.Raw vectors are converted to their 2-digit hexadecimal representationby as.character.format.default(x) now provides a “minimal” string whenisS4(x) is true.The internal code respects the optiongetOption("OutDec") for the ‘decimal mark’, so ifthis is set to something other than "." then it takes precedenceover argument decimal.mark.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
format is a generic function.  Apart from the methods describedhere there are methods for dates (see format.Date),date-times (see format.POSIXct) and for other classes suchas format.octmode and format.dist.format.data.frame formats the data frame column by column,applying the appropriate method of format for each column.Methods for columns are often similar to as.character but offermore control.  Matrix and data-frame columns will be converted toseparate columns in the result, and character columns (normally all)will be given class "AsIs".format.factor converts the factor to a character vector andthen calls the default method (and so justify applies).format.AsIs deals with columns of complicated objects thathave been extracted from a data frame.  Character objects and (atomic)matrices are passed to the default method (and so width doesnot apply).Otherwise it calls toString to convert the objectto character (if a vector or list, element by element) and thenright-justifies the result.Justification for character vectors (and objects converted tocharacter vectors by their methods) is done on display width (seenchar), taking double-width characters and the renderingof special characters (as escape sequences, including escapingbackslash but not double quote: see print.default) intoaccount.  Thus the width is as displayed by print(quote =  FALSE) and not as displayed by cat.  Character stringsare padded with blanks to the display width of the widest.  (Ifna.encode = FALSE missing character strings are not included inthe width computations and are not encoded.)Numeric vectors are encoded with the minimum number of decimal placesneeded to display all the elements to at least the digitssignificant digits.  However, if all the elements then have trailingzeroes, the number of decimal places is reduced untilnsmall is reached or at least oneelement has a non-zero final digit; see also the argumentdocumentation for big.*, small.* etc, above.  See thenote in print.default about digits >= 16.Raw vectors are converted to their 2-digit hexadecimal representationby as.character.format.default(x) now provides a “minimal” string whenisS4(x) is true.The internal code respects the optiongetOption("OutDec") for the ‘decimal mark’, so ifthis is set to something other than "." then it takes precedenceover argument decimal.mark.
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
NA
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
The format and as.character methods and strftimeconvert objects from the classes "POSIXlt" and"POSIXct" to character vectors.strptime converts character vectors to class "POSIXlt":its input x is first converted by as.character.Each input string is processed as far as necessary for the formatspecified: any trailing characters are ignored.strftime is a wrapper for format.POSIXlt, and it andformat.POSIXct first convert to class "POSIXlt" bycalling as.POSIXlt (so they also work for class"Date").  Note that only that conversion depends on thetime zone.The usual vector re-cycling rules are applied to x andformat so the answer will be of length of the longer of thesevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months, the AM/PM indicator (if used) and the separators in outputformats such as %x and %X, via the setting ofthe LC_TIME locale category.  The ‘currentlocale’ of the descriptions might mean the locale in use at the startof the R session or when these functions are first used.  (For input,the locale-specific conversions can be changed by callingSys.setlocale with category LC_TIME (orLC_ALL).  For output, what happens depends on the OS butusually works.)The details of the formats are platform-specific, but the following arelikely to be widely available: most are defined by the POSIX standard.A conversion specification is introduced by %, usuallyfollowed by a single letter or O or E and then a singleletter.  Any character in the format string not part of a conversionspecification is interpreted literally (and %% gives%).  Widely implemented conversion specifications includeAbbreviated weekday name in the currentlocale on this platform.  (Also matches full name on input:in some locales there are no abbreviations of names.)Full weekday name in the current locale.  (Alsomatches abbreviated name on input.)Abbreviated month name in the current locale onthis platform.  (Also matches full name on input: insome locales there are no abbreviations of names.)Full month name in the current locale.  (Alsomatches abbreviated name on input.)Date and time.   Locale-specific on output,"%a %b %e %H:%M:%S %Y" on input.Century (00–99): the integer part of the yeardivided by 100.Day of the month as decimal number (01–31).Date format such as %m/%d/%y: the C99standard says it should be that exact format (but not all OSescomply).Day of the month as decimal number (1–31), witha leading space for a single-digit number.Equivalent to %Y-%m-%d (the ISO 8601 dateformat).The last two digits of the week-based year(see %V).  (Accepted but ignored on input.)The week-based year (see %V) as a decimalnumber.  (Accepted but ignored on input.)Equivalent to %b.Hours as decimal number (00–23).  As a specialexception strings such as 24:00:00 are accepted for input,since ISO 8601 allows these.Hours as decimal number (01–12).Day of year as decimal number (001–366):  Forinput, 366 is only valid in a leap year.Month as decimal number (01–12).Minute as decimal number (00–59).Newline on output, arbitrary whitespace on input.AM/PM indicator in the locale.  Used inconjunction with %I and not with %H.  Anempty string in some locales (for example on some OSes,non-English European locales including Russia). The behaviour isundefined if used for input in such a locale.Some platforms accept %P for output, which uses a lower-caseversion (%p may also use lower case): others will outputP.For output, the 12-hour clock time (using thelocale's AM or PM): only defined in some locales, and on some OSesmisleading in locales which do not define an AM/PM indicator.For input, equivalent to %I:%M:%S %p.Equivalent to %H:%M.Second as integer (00–61), allowing forup to two leap-seconds (but POSIX-compliant implementationswill ignore leap seconds).Tab on output, arbitrary whitespace on input.Equivalent to %H:%M:%S.Weekday as a decimal number (1–7, Monday is 1).Week of the year as decimal number (00–53) usingSunday as the first day 1 of the week (and typically with thefirst Sunday of the year as day 1 of week 1).  The US convention.Week of the year as decimal number (01–53) asdefined in ISO 8601.If the week (starting on Monday) containing 1 January has four ormore days in the new year, then it is considered week 1.  Otherwise, itis the last week of the previous year, and the next week is week1.  (Accepted but ignored on input.)Weekday as decimal number (0–6, Sunday is 0).Week of the year as decimal number (00–53) usingMonday as the first day of week (and typically with thefirst Monday of the year as day 1 of week 1).  The UK convention.Date.  Locale-specific on output,"%y/%m/%d" on input.Time.  Locale-specific on output,"%H:%M:%S" on input.Year without century (00–99).  On input, values00 to 68 are prefixed by 20 and 69 to 99 by 19 – that is thebehaviour specified by the 2018 POSIX standard, but it doesalso say ‘it is expected that in a future version thedefault century inferred from a 2-digit year will change’.Year with century.  Note that whereas there was nozero in the original Gregorian calendar, ISO 8601:2004 defines itto be valid (interpreted as 1BC): seehttps://en.wikipedia.org/wiki/0_(year).  However, the standardsalso say that years before 1582 in its calendar should only be usedwith agreement of the parties involved.For input, only years 0:9999 are accepted.Signed offset in hours and minutesfrom UTC, so -0800 is 8 hours behind UTC. Values up to+1400 are accepted.  (Standard only for output.  For inputR currently supports it on all platforms.)(Output only.)  Time zone abbreviation as acharacter string (empty if not available).  This may not be reliablewhen a time zone has changed abbreviations over the years.Where leading zeros are shown they will be used on output but areoptional on input.  Names are matched case-insensitively on input:whether they are capitalized on output depends on the platform and thelocale.  Note that abbreviated names are platform-specific (althoughthe standards specify that in the C locale they must be thefirst three letters of the capitalized English name: this conventionis widely used in English-language locales but for example the Frenchmonth abbreviations are not the same on any two of Linux, macOS, Solarisand Windows). Knowing what the abbreviations are is essentialif you wish to use %a, %b or %h as part of aninput format: see the examples for how to check.When %z or %Z is used for output with anobject with an assigned time zone an attempt is made to use the valuesfor that time zone — but it is not guaranteed to succeed.Not in the standards and less widely implemented areThe 24-hour clock time with single digits precededby a blank.The 12-hour clock time with single digits precededby a blank.(Output only.) The number of seconds since theepoch.(Output only.) Similar to %c, often"%a %b %e %H:%M:%S %Z %Y". May depend on the locale.For output there are also %O[dHImMUVwWy] which may emitnumbers in an alternative locale-dependent format (e.g., romannumerals), and %E[cCyYxX] which can use an alternative‘era’ (e.g., a different religious calendar).  Which of theseare supported is OS-dependent.  These are accepted for input, but withthe standard interpretation.Specific to R is %OSn, which for output gives the secondstruncated to 0 <= n <= 6 decimal places (and if %OS isnot followed by a digit, it uses the setting ofgetOption("digits.secs"), or if that is unset, n =  0).  Further, for strptime %OS will input secondsincluding fractional seconds.  Note that %S does not readfractional parts on output. The behaviour of other conversion specifications (and even if othercharacter sequences commencing with % are conversionspecifications) is system-specific.  Some systems document that theuse of multi-byte characters in format is unsupported: UTF-8locales are unlikely to cause a problem.
The format and as.character methods and strftimeconvert objects from the classes "POSIXlt" and"POSIXct" to character vectors.strptime converts character vectors to class "POSIXlt":its input x is first converted by as.character.Each input string is processed as far as necessary for the formatspecified: any trailing characters are ignored.strftime is a wrapper for format.POSIXlt, and it andformat.POSIXct first convert to class "POSIXlt" bycalling as.POSIXlt (so they also work for class"Date").  Note that only that conversion depends on thetime zone.The usual vector re-cycling rules are applied to x andformat so the answer will be of length of the longer of thesevectors.Locale-specific conversions to and from character strings are usedwhere appropriate and available.  This affects the names of the daysand months, the AM/PM indicator (if used) and the separators in outputformats such as %x and %X, via the setting ofthe LC_TIME locale category.  The ‘currentlocale’ of the descriptions might mean the locale in use at the startof the R session or when these functions are first used.  (For input,the locale-specific conversions can be changed by callingSys.setlocale with category LC_TIME (orLC_ALL).  For output, what happens depends on the OS butusually works.)The details of the formats are platform-specific, but the following arelikely to be widely available: most are defined by the POSIX standard.A conversion specification is introduced by %, usuallyfollowed by a single letter or O or E and then a singleletter.  Any character in the format string not part of a conversionspecification is interpreted literally (and %% gives%).  Widely implemented conversion specifications includeAbbreviated weekday name in the currentlocale on this platform.  (Also matches full name on input:in some locales there are no abbreviations of names.)Full weekday name in the current locale.  (Alsomatches abbreviated name on input.)Abbreviated month name in the current locale onthis platform.  (Also matches full name on input: insome locales there are no abbreviations of names.)Full month name in the current locale.  (Alsomatches abbreviated name on input.)Date and time.   Locale-specific on output,"%a %b %e %H:%M:%S %Y" on input.Century (00–99): the integer part of the yeardivided by 100.Day of the month as decimal number (01–31).Date format such as %m/%d/%y: the C99standard says it should be that exact format (but not all OSescomply).Day of the month as decimal number (1–31), witha leading space for a single-digit number.Equivalent to %Y-%m-%d (the ISO 8601 dateformat).The last two digits of the week-based year(see %V).  (Accepted but ignored on input.)The week-based year (see %V) as a decimalnumber.  (Accepted but ignored on input.)Equivalent to %b.Hours as decimal number (00–23).  As a specialexception strings such as 24:00:00 are accepted for input,since ISO 8601 allows these.Hours as decimal number (01–12).Day of year as decimal number (001–366):  Forinput, 366 is only valid in a leap year.Month as decimal number (01–12).Minute as decimal number (00–59).Newline on output, arbitrary whitespace on input.AM/PM indicator in the locale.  Used inconjunction with %I and not with %H.  Anempty string in some locales (for example on some OSes,non-English European locales including Russia). The behaviour isundefined if used for input in such a locale.Some platforms accept %P for output, which uses a lower-caseversion (%p may also use lower case): others will outputP.For output, the 12-hour clock time (using thelocale's AM or PM): only defined in some locales, and on some OSesmisleading in locales which do not define an AM/PM indicator.For input, equivalent to %I:%M:%S %p.Equivalent to %H:%M.Second as integer (00–61), allowing forup to two leap-seconds (but POSIX-compliant implementationswill ignore leap seconds).Tab on output, arbitrary whitespace on input.Equivalent to %H:%M:%S.Weekday as a decimal number (1–7, Monday is 1).Week of the year as decimal number (00–53) usingSunday as the first day 1 of the week (and typically with thefirst Sunday of the year as day 1 of week 1).  The US convention.Week of the year as decimal number (01–53) asdefined in ISO 8601.If the week (starting on Monday) containing 1 January has four ormore days in the new year, then it is considered week 1.  Otherwise, itis the last week of the previous year, and the next week is week1.  (Accepted but ignored on input.)Weekday as decimal number (0–6, Sunday is 0).Week of the year as decimal number (00–53) usingMonday as the first day of week (and typically with thefirst Monday of the year as day 1 of week 1).  The UK convention.Date.  Locale-specific on output,"%y/%m/%d" on input.Time.  Locale-specific on output,"%H:%M:%S" on input.Year without century (00–99).  On input, values00 to 68 are prefixed by 20 and 69 to 99 by 19 – that is thebehaviour specified by the 2018 POSIX standard, but it doesalso say ‘it is expected that in a future version thedefault century inferred from a 2-digit year will change’.Year with century.  Note that whereas there was nozero in the original Gregorian calendar, ISO 8601:2004 defines itto be valid (interpreted as 1BC): seehttps://en.wikipedia.org/wiki/0_(year).  However, the standardsalso say that years before 1582 in its calendar should only be usedwith agreement of the parties involved.For input, only years 0:9999 are accepted.Signed offset in hours and minutesfrom UTC, so -0800 is 8 hours behind UTC. Values up to+1400 are accepted.  (Standard only for output.  For inputR currently supports it on all platforms.)(Output only.)  Time zone abbreviation as acharacter string (empty if not available).  This may not be reliablewhen a time zone has changed abbreviations over the years.Where leading zeros are shown they will be used on output but areoptional on input.  Names are matched case-insensitively on input:whether they are capitalized on output depends on the platform and thelocale.  Note that abbreviated names are platform-specific (althoughthe standards specify that in the C locale they must be thefirst three letters of the capitalized English name: this conventionis widely used in English-language locales but for example the Frenchmonth abbreviations are not the same on any two of Linux, macOS, Solarisand Windows). Knowing what the abbreviations are is essentialif you wish to use %a, %b or %h as part of aninput format: see the examples for how to check.When %z or %Z is used for output with anobject with an assigned time zone an attempt is made to use the valuesfor that time zone — but it is not guaranteed to succeed.Not in the standards and less widely implemented areThe 24-hour clock time with single digits precededby a blank.The 12-hour clock time with single digits precededby a blank.(Output only.) The number of seconds since theepoch.(Output only.) Similar to %c, often"%a %b %e %H:%M:%S %Z %Y". May depend on the locale.For output there are also %O[dHImMUVwWy] which may emitnumbers in an alternative locale-dependent format (e.g., romannumerals), and %E[cCyYxX] which can use an alternative‘era’ (e.g., a different religious calendar).  Which of theseare supported is OS-dependent.  These are accepted for input, but withthe standard interpretation.Specific to R is %OSn, which for output gives the secondstruncated to 0 <= n <= 6 decimal places (and if %OS isnot followed by a digit, it uses the setting ofgetOption("digits.secs"), or if that is unset, n =  0).  Further, for strptime %OS will input secondsincluding fractional seconds.  Note that %S does not readfractional parts on output. The behaviour of other conversion specifications (and even if othercharacter sequences commencing with % are conversionspecifications) is system-specific.  Some systems document that theuse of multi-byte characters in format is unsupported: UTF-8locales are unlikely to cause a problem.
format.pval is mainly an auxiliary function forprint.summary.lm etc., and does separate formatting forfixed, floating point and very small values; those less thaneps are formatted as "< [eps]" (where ‘[eps]’stands for format(eps, digits)).
For factors, the frequency of the first maxsum - 1most frequent levels is shown, and the less frequent levels aresummarized in "(Others)" (resulting in at most maxsumfrequencies).The functions summary.lm and summary.glm are examplesof particular methods which summarize the results produced bylm and glm.
For numbers, formatC() calls prettyNum() when neededwhich itself calls .format.zeros(*, replace=replace.zero).(“when needed”: when zero.print is notNULL, drop0trailing is true, or one of big.mark,small.mark, or decimal.mark is not at default.)If you set format it overrides the setting of mode, soformatC(123.45, mode = "double", format = "d") gives 123.The rendering of scientific format is platform-dependent: some systemsuse n.ddde+nnn or n.dddenn rather than n.ddde+nn.formatC does not necessarily align the numbers on the decimalpoint, so formatC(c(6.11, 13.1), digits = 2, format = "fg") givesc("6.1", " 13").  If you want common formatting for severalnumbers, use format.prettyNum is the utility function for prettifying x.x can be complex (or format(<complex>)), here.  Ifx is not a character, format(x[i], ...) is applied toeach element, and then it is left unchanged if all the other argumentsare at their defaults.  Use the input.d.mark argument forprettyNum(x) when x is a character vector notresulting from something like format(<number>) with a period asdecimal mark.Because gsub is used to insert the big.markand small.mark, special characters need escaping.  In particular,to insert a single backslash, use "\\\\".The C doubles used for R numerical vectors have signed zeros, whichformatC may output as -0, -0.000 ....There is a warning if big.mark and decimal.mark are thesame: that would be confusing to those reading the output.
After extracting the vectors of items and corresponding descriptionsfrom the arguments, both are coerced to character vectors.In table style, items with more than indent - 3 characters aredisplayed on a line of their own.
Solves a system of linear equations where the coefficient matrix isupper (or ‘right’, ‘R’) or lower (‘left’,‘L’) triangular.x <- backsolve   (R, b) solves R x = b, andx <- forwardsolve(L, b) solves L x = b, respectively.The r/l must have at least k rows and columns,and x must have at least k rows.This is a wrapper for the level-3 BLAS routine dtrsm.
The names in an argument list can be back-quoted non-standard names(see ‘backquote’).If value is missing, NULL is returned.  If it is asingle expression, the value of the evaluated expression is returned.(The expression is evaluated as soon as return is called, inthe evaluation frame of the function and before anyon.exit expression is evaluated.)If the end of a function is reached without calling return, thevalue of the last evaluated expression is returned.The shorthand form \(x) x + 1 is parsed as function(x) x    + 1. It may be helpful in making code containing simple functionexpressions more readable.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
A call of gc causes a garbage collection to take place.This will also take place automatically without user intervention, and theprimary purpose of calling gc is for the report on memoryusage.  For an accurate report full = TRUE should be used.It can be useful to call gc after a large objecthas been removed, as this may prompt R to return memory to theoperating system.R allocates space for vectors in multiples of 8 bytes: hence thereport of "Vcells", a relic of an earlier allocator (that useda vector heap).When gcinfo(TRUE) is in force, messages are sent to the messageconnection at each garbage collection of the formHere the last two lines give the current memory usage rounded up tothe next 0.1Mb and as a percentage of the current trigger value.The first line gives a breakdown of the number of garbage collectionsat various levels (for an explanation see the ‘R Internals’ manual).
Due to timer resolution this may be under-estimate.This is a primitive.
A call of gc causes a garbage collection to take place.This will also take place automatically without user intervention, and theprimary purpose of calling gc is for the report on memoryusage.  For an accurate report full = TRUE should be used.It can be useful to call gc after a large objecthas been removed, as this may prompt R to return memory to theoperating system.R allocates space for vectors in multiples of 8 bytes: hence thereport of "Vcells", a relic of an earlier allocator (that useda vector heap).When gcinfo(TRUE) is in force, messages are sent to the messageconnection at each garbage collection of the formHere the last two lines give the current memory usage rounded up tothe next 0.1Mb and as a percentage of the current trigger value.The first line gives a breakdown of the number of garbage collectionsat various levels (for an explanation see the ‘R Internals’ manual).
