x
これらの単項演算子や二項演算子は、数値ベクトルや複素数ベクトル（あるいは、それらを強制できるオブジェクト）に対して算術演算を行います。
<code>"Date"</code>クラスの演算子。

<code>Date</code>クラスには、<code>Ops</code>メソッドと、<code>+</code>と<code>-</code>専用のメソッドがあります。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
正規シーケンスの生成。
エクスポートされた変数や内部変数へのアクセス、すなわち<span style="font-family：courier new, Courier; color：ネームスペース内の <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクト (遅延ロードされたデータ・セットを含む) にアクセスします。
エクスポートされた変数や内部変数へのアクセス、つまり<span style="font-family：(遅延ロードされたデータセットを含む)：ネームスペース内の<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>オブジェクト（遅延ロードされたデータ・セットを含む）にアクセスします。
これらの演算子は、生のベクトル、論理ベクトル、数値に似たベクトルに作用します。
整数を16進数形式に変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
整数を8進数形式に変換または印刷します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
原子ベクトルの値の比較を可能にする二項演算子。
開括弧<code>(</code>)と開中括弧<code>{</code>は、<span style="font-family：の<span style="font-family: Courier New, Courier; color：#666666;"><b>R</b></span>の<code>.Primitive</code>関数です。

事実上、<code>(</code>は意味的には恒等式<code>function(x) x</code>と等価ですが、<code>{</code>は少し面白いです。
ベクトル、行列、配列、リストに作用する演算子。
オブジェクトのクラスを変更して、それを「そのまま」扱うことを示す。
データ・フレームの部分集合の抽出や置換。
カレンダーの日付を表すクラス<code>"Date"</code>の説明。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドは、これらの "時差 "を呼び出します。
ベクトル、行列、配列、リストに作用する演算子。
この関数は、<span style="font-family：font-family: Courier New, Courier; color：<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span> セッションに現在ロードされている DLL (<code>dyn load</code> を参照) を指定します。
因子の部分集合を抽出または置換する。
整数を16進数形式に変換または印刷します。その際、最大値を表示するのに必要な桁数だけ、必要に応じて先頭のゼロを使用します。
ベクトル，行列，配列，リストに対して作用する演算子で，一部を抽出したり置換したりする。
文字列を引用符なしで表示します。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルな S3 クラスと、それに関連するメソッド。
必要に応じて先頭のゼロを使用し、最大値を表示するために必要な桁数で、8進数形式の整数を変換または表示します。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
暦日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
ベクトル、行列、配列、リストに作用する演算子。
<code>table</code>は、クロス分類因子を使用して、各因子レベルの組み合わせにおけるカウントの分割表を構築する。
<code>warnings</code>とその<code>print</code>メソッドは、変数<code>last.warning</code>を見やすい形で表示する。
ベクトル、行列、配列、リストに作用する演算子。
データ・フレームの部分集合の抽出や置換。
カレンダーの日付を表すクラス <code>"Date"</code> の説明。
因子のサブセットを抽出または置換します。
パッケージ・バージョンを含む数値バージョンを表すシンプルな S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
ベクトル、行列、配列、リストに作用する演算子。
データ・フレームの部分集合の抽出または置換。
因子の部分集合の抽出または置換。
パッケージ・バージョンを含む数値バージョンを表現するシンプルな S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表す <code>"POSIXlt"</code> と <code>"POSIXct"</code> クラスの説明。
ベクトル、行列、配列、リストに作用する演算子。
データ・フレームの部分集合の抽出や置換。
カレンダーの日付を表すクラス<code>"Date"</code>の説明。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドは、これらの "時差 "を呼び出す。
因子の部分集合の抽出と置換。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
開括弧<code>(</code>)と開中括弧<code>{</code>は、<span style="font-family：の<span style="font-family: Courier New, Courier; color：#666666;"><b>R</b></span>の<code>.Primitive</code>関数です。

事実上、<code>(</code>は、意味的には同一性<code>function(x) x</code>と等価ですが、<code>{</code>の方が少し面白いです。
形式的な(S4)クラス構造を持つオブジェクトのスロットの内容を抽出または置換する。
形式的な(S4)クラス構造を持つオブジェクトのスロットの内容を抽出または置換する。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
時間間隔の作成、印刷、およびいくつかの演算。  <code>print()</code>メソッドは、これらの "時間差 "を呼び出します。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（または、それらに強制できるオブジェクト）に対して算術演算を行います。
時間間隔の作成、印刷、およびいくつかの演算。  <code>print()</code>メソッドは、これらの "時差 "を呼び出します。
これらの演算子は、生のベクトル、論理ベクトル、数値に似たベクトルに作用します。
整数を16進数形式に変換または印刷します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
8進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数で変換または表示する。
これらの演算子は、生のベクトル、論理ベクトル、および数値に似たベクトルに作用します。
2つの行列が適合する場合、2つの行列を乗算します。  一方の引数がベクトルの場合、行行列または列行列に昇格され、2つの引数を適合させる。  両方が同じ長さのベクトルであれば、（行列としての）内積を返します。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
<code>match</code>は、その第2引数における第1引数の(最初の)マッチの位置のベクトルを返します。

<code>%in%</code>は二項演算子としてより直感的なインターフェイスで、左オペランドが一致するかどうかを示す論理ベクトルを返す。
配列<code>X</code>と<code>Y</code>の外積は、次元<code>c(dim(X), dim(Y))</code>の配列<code>A</code>となり、要素<code>A[c(arrayindex.x, arrayindex.y)] = FUN(X[arrayindex.x], Y[arrayindex.y], ...)</code>となります。
2つの配列 <code>X</code> と <code>Y</code> の一般化されたクロネッカー積を計算します。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制できるオブジェクト）に対して算術演算を行います。
これらの単項演算子および二項演算子は、数値ベクトルまたは複素数ベクトル（またはそれらに強制することができるオブジェクト）に対して算術演算を行います。
<code>"Date"</code>クラスの演算子。

<code>Date</code>クラスには、<code>Ops</code>メソッドと、<code>+</code>と<code>-</code>専用のメソッドがあります。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
アトミック・ベクトルの値の比較を可能にする二項演算子。
名前に値を代入する。
名前に値を代入する。
アトミックベクトル内の値の比較を可能にする二項演算子
名前に値を代入する。
アトミックベクトル内の値の比較を可能にする二項演算子
原子ベクトル内の値の比較を可能にする二項演算子。
アトミック・ベクター内の値の比較を可能にする二項演算子。
これらの演算子は、生ベクトル、論理ベクトル、および数値ライクベクトルに作用する。
最大値を表示するのに必要な桁数の整数を16進数形式に変換または表示する。
8進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数で変換または表示する。
これらの演算子は、生のベクトル、論理ベクトル、数値に似たベクトルに作用する。
チルダは、モデル式の左辺と右辺を区切るのに使われます。
ベクトル、行列、配列、リストに作用する演算子。
この関数は、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> セッションに現在ロードされている DLL (<code>dyn load</code> を参照)。
パッケージ・バージョンを含む数値バージョンを表すシンプルな S3 クラスと、関連するメソッド。
ベクトル、行列、配列、リストに作用する演算子。
データフレームのサブセットを抽出または置換します。
<code>strict = TRUE</code> でない限り、文字列を少なくとも <code>minlength</code> 文字に省略します。
<code>abs(x)</code> は x の絶対値を計算し、 <code>sqrt(x)</code> は x の(主)平方根 <i>√{x}</i> を計算します。

命名は、CやFortranのようなコンピュータ言語の標準に従っている。
これらの関数は明らかな三角関数を与える。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算します。

<code>cospi(x)</code>、<code>sinpi(x)</code>、<code>tanpi(x)</code>は、<code>cos(π*x)</code>、<code>sin(π*x)</code>、<code>tan(π*x)</code>を計算する。
これらの関数は明らかな双曲線関数を与える。  これらはそれぞれ、双曲線余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接(または'<em>面積余弦</em>'など)を計算します。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスを表します。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
<code>factor</code>関数は、ベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバーシップ関数と強制関数です。
<code>addTaskCallback</code>は、トップレベルのタスクが完了するたびに呼び出されるR関数を登録します。

<code>removeTaskCallback</code>は、<code>addTaskCallback</code>によって登録された関数の登録を解除します。

これらは、タスク完了アクションを管理するための内部/ネイティブメカニズムへの低レベルアクセスを提供します：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> 言語レベルで <span style="font-family：を管理するための言語レベル</span style="font: Courier New, Courier; color：#各タスクの完了時に呼び出される<span style="font: Courier New;"><b>R</b></span> 関数を管理します。
一般化レーベンシュタイン編集距離(ある文字列を別の文字列に変換するのに必要な挿入、削除、置換の最小の加重数)を使って、文字列<code>x</code>(2番目の引数)の各要素内で<code>pattern</code>(1番目の引数)に近似一致するものを検索します。
一般化レーベンシュタイン編集距離（ある文字列を別の文字列に変換するのに必要な、挿入、削除、置換の最小可能加重数）を使って、文字列<code>x</code>（2番目の引数）の各要素内の<code>パターン</code>（1番目の引数）に近似的にマッチするものを検索する。
両方の<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
論理ベクトルのセットが与えられたとき、すべての値は真でしょうか？
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト <code>x</code> と <code>y</code> が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    <code>if</code>式の中で<code>all.equal</code>を直接使用しないでください-適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
<code>all.equal(x, y)</code> は、<span style="font-family：Courier New, Courier; color：#"><b>R</b></span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
式または呼び出しで出現するすべての名前を含む文字ベクトルを返します。
式または呼び出しで出現するすべての名前を含む文字ベクトルを返す。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
論理ベクトルの集合が与えられたとき、値の少なくとも1つは真か？
<code>duplicated()</code>は、ベクトルまたはデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、<code>TRUE</code>の代わりに正の整数添字を返す。
<code>NA</code> は、欠測インジケータを含む長さ1の論理定数です。  <code>NA</code>は、raw以外のvectortypeに強制することができる。  <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code>は、欠損値をサポートする他の原子ベクトル型の定数です：の予約語です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。

汎用関数<code>is.na</code>は、どの要素が欠けているかを示す。

汎用関数<code>is.na&lt;-</code>は要素を<code>NA</code>に設定する。

汎用関数 <code>anyNA</code> は、<code>any(is.na(x))</code> を（特に原子ベクトルに対して）可能な限り高速に実装したものです。
<code>NA</code> は、欠測インジケータを含む長さ1の論理定数です。  <code>NA</code>はrawを除く他のvectortypeに強制することができる。  <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code>という定数もあり、これらはすべて<span style="font-family：の予約語です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。

汎用関数<code>is.na</code>は、どの要素が欠けているかを示す。

ジェネリック関数<code>is.na&lt;-</code>は要素を<code>NA</code>に設定する。

汎用関数<code>anyNA</code>は、<code>any(is.na(x))</code>を（特に原子ベクトルに対して）可能な限り高速に実装しています。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
次元を並べ替えて配列を転置し、オプションでサイズを変更します。
次元を並べ替えて配列を転置し、必要に応じてサイズを変更する。
次元を並べ替えて配列を転置し、必要に応じてサイズを変更する。
ベクトルに要素を追加する。
Vector関数は、配列または行列の余白に関数を適用して得られたベクトルまたは配列、または値のリストを返します。
<span style="font-family：color：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>の算術演算子に加え、<span style="font-family: Courier New; color: #666666;"><b>R</b></span> の複素数演算をサポートする基本関数。
関数またはプリミティブの引数名と対応するデフォルト値を表示します。
配列を作成またはテストする。
論理オブジェクトの<code>TRUE</code>インデックスを与え、配列インデックスを使用できるようにします。
配列を作成またはテストします。
配列を作成またはテストする。
<code>mode</code> <code>"call"</code> (または<code>"("</code>, 詳細を参照)のオブジェクトを作成またはテストする。
<code>"character"</code>型のオブジェクトを作成またはテストする。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
文字表現と、カレンダーの日付を表す<code>"Date"</code>クラスのオブジェクトを変換する関数。
<code>"character"</code>型のオブジェクトの作成またはテスト。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供します。
<code>"character"</code>型のオブジェクトを作成またはテストする。
整数を16進数形式に変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
パッケージのバージョンを含む数値バージョンを表現するためのシンプルな S3 クラスと、関連するメソッド。
必要に応じて先行ゼロを使用し、最大値を表示するために必要な桁数の8進数形式で整数を変換または表示します。
文字表現と<code>"POSIXlt"</code>および<code>"POSIXct"</code>クラスのオブジェクトの間で変換する関数。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、すなわちソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
<span style="font-family：color：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>の算術演算子に加えて、<span style="font: Courier New; color: 666666;"><b>R</b></span> の複素数演算をサポートする基本関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
カレンダーの日付を表すクラス<code>"Date"</code>の説明。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であれば強制する関数
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかを調べる、または可能であればそれを強制する関数。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
パッケージ・バージョンと関連するメソッドを含む、数値バージョンを表現するためのシンプルなS3クラス。
オブジェクトがデータフレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
オブジェクトがデータ・フレームであるかどうかをチェックしたり、可能であれば強制したりする関数。
<code>table</code>は、クロス分類因子を使用して、各因子レベルの組み合わせにおけるカウントの分割表を作成します。
オブジェクトがデータフレームであるかどうかをチェックする関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
文字表現と、カレンダーの日付を表す<code>"Date"</code>クラスのオブジェクトを変換する関数。
文字表現と、カレンダーの日付を表す<code>"Date"</code>クラスのオブジェクトを変換する関数。
文字表現と暦日付を表す <code>"Date"</code> クラスのオブジェクトを変換する関数。
文字表現と暦日付を表す <code>"Date"</code> クラスのオブジェクトを変換する関数。
文字表現と暦日付を表す <code>"Date"</code> クラスのオブジェクトを変換する関数。
文字表現と暦日付を表す <code>"Date"</code> クラスのオブジェクトを変換する関数。
文字表現と、カレンダーの日付を表す <code>"Date"</code> クラスのオブジェクトを変換する関数。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドは、これらの "時差 "を呼び出します。
倍精度ベクトルの作成、強制、テスト。
時間間隔の作成、印刷、いくつかの算術。  <code>print()</code>メソッドは、これらの "時差 "を呼び出します。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>クラスのオブジェクトを操作する関数。
<span style="font-family：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> オブジェクトを<code>environment</code>に強制する汎用関数です。  数値または文字列は、検索パス上の対応する環境に変換されます。
モード<code>"expression"</code>のオブジェクトを作成またはテストします。
モード<code>"expression"</code>のオブジェクトを生成またはテストします。
関数 <code>factor</code> は、ベクトルを因子として符号化するために使用されます（'category' や 'enumerated type' という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバーシップ関数と強制関数です。
<code>as.function</code>はオブジェクトを関数に変換するための汎用関数です。

<code>as.function.default</code>は<code>x</code>というリストで動作します。<code>x</code>は正式な引数リストと<code>"call"</code>モードの式またはオブジェクトの連結を含んでいなければなりません。
<code>as.function</code>は、オブジェクトを関数に変換するための汎用関数です。

<code>as.function.default</code>は、<code>x</code>というリストで動作します。<code>x</code>は、正式な引数リストと、関数本体となる<code>"call"</code>モードの式またはオブジェクトの連結を含んでいなければなりません。
整数を16進数形式に変換または表示します。最大値を表示するのに必要な桁数で、必要に応じて先頭のゼロを使用します。
<code>"integer"</code>型のオブジェクトを作成またはテストする。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
<span style="font-family：font-family: Courier New, Courier; color：#666666;"><b>R</b></span>リスト。
カレンダーの日付を表すクラス<code>"Date"</code>の説明。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドは、これらの "時差 "を呼び出します。
<span style="font-family：courier new, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
<span style="font-family：font-family: Courier New, Courier; color：#666666;"><b>R</b></span>リスト。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
パッケージ・バージョンを含む数値バージョンを表すシンプルな S3 クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
<code>"logical"</code>型のオブジェクトと基本logical定数の作成とテスト。
<code>"logical"</code>型のオブジェクトと、basiclogical定数を作成またはテストする。
<code>matrix</code> は、与えられた値の集合から行列を作成します。

<code>as.matrix</code>は引数を行列に変えようとする。

<code>is.matrix</code> は、引数が（厳密な）行列であるかどうかを調べます。
<code>matrix</code> は与えられた値の集合から行列を作成します。

<code>as.matrix</code>は引数を行列に変えようとする。

<code>is.matrix</code> は、引数が（厳密な）行列であるかどうかを調べます。
<code>matrix</code> は与えられた値の集合から行列を作成します。

<code>as.matrix</code>は引数を行列に変えようとする。

<code>is.matrix</code>は引数が(厳密な)行列であるかどうかをテストします。
文字列を引用符なしで表示する。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>というカレンダーの日付と時刻を表すクラスの説明。
名前」（「シンボル」とも呼ばれる）は、<span style="font-family：font-family: Courier New, Courier; color：(もしあれば、その名前に束縛されたオブジェクトの値ではなく)名前によって<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>オブジェクトを参照する方法です。

<code>as.name</code>と<code>as.symbol</code>は同じである。

<code>is.symbol</code>と同一の<code>is.name</code>は、引数が名前かどうかに応じて<code>TRUE</code>または<code>FALSE</code>を返します。
<code>NULL</code> はヌルオブジェクトを <span style="font-family：font-family: Courier New, Courier; color：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>: これは予約語です。  <code>NULL</code>は、値が未定義の式や関数からよく返されます。
<code>NULL</code>は、<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>: これは予約語です。  <code>NULL</code>は、値が未定義の式や関数からよく返されます。
<code>is.numeric</code>は、オブジェクトが数値として解釈可能であるかどうかの一般的なテストです。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
8進数形式で整数を変換または表示します。最大値を表示するために必要な桁数だけ、必要に応じて先頭のゼロを使用します。
<code>factor</code>関数は、ベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
<span style="font-family：を構築し、チェックする関数です：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
カレンダーの日付と時刻を表す<code>"POSIXlt"</code>と<code>"POSIXct"</code>クラスのオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> のオブジェクトを操作する関数。
カレンダー日時を表すクラス <code>"POSIXlt"</code> および <code>"POSIXct"</code> のオブジェクトを操作する関数。
<code>qr</code> は行列の QR 分解を行います。
<code>"raw"</code>型のオブジェクトを作成またはテストする。
倍精度ベクトルの作成、変換、テストを行います。
倍精度ベクトルの作成、変換、テスト。
名前」（「シンボル」とも呼ばれる）は、<span style="font-family：font-family: Courier New, Courier; color：もしその名前にバインドされているオブジェクトがあれば、その値ではなく）名前によって<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>オブジェクトを参照する方法です。

<code>as.name</code>と<code>as.symbol</code>は同じである。

<code>is.symbol</code>と同一の<code>is.name</code>は、引数が名前かどうかによって<code>TRUE</code>または<code>FALSE</code>を返す。
<code>table</code>は、因子レベルの各組み合わせでのカウントの分割表を構築するために、分類横断因子を使用します。
<code>table</code>は、因子レベルの各組み合わせにおけるカウントの分割表を構築するために、分類横断因子を使用する。
<code>vector</code>は、与えられた長さとモードのベクトルを生成する。

<code>as.vector</code>はジェネリックで、引数を<code>mode</code>モードのvectorに強制しようとします(デフォルトは、最も便利なvectorモードに強制します)。

<code>is.vector</code>は、<code>x</code>が<em>名前</em>以外の属性を持たない指定されたモードのベクトルであれば<code>TRUE</code>を返します。  そうでなければ<code>FALSE</code>を返します。
<code>vector</code> は与えられた長さとモードのベクトルを生成します。

<code>as.vector</code>はジェネリックで、引数を<code>mode</code>モードのvectorに強制しようとします(デフォルトは、最も便利なvectorモードに強制します)。

<code>is.vector</code>は、<code>x</code>が<em>名前</em>以外の属性を持たない指定されたモードのベクトルであれば<code>TRUE</code>を返します。  そうでなければ<code>FALSE</code>を返します。
これらの関数は明らかな三角関数を与えます。  これらはそれぞれ余弦、正弦、正接、円弧余弦、円弧正弦、円弧正接、2引数の円弧正接を計算します。

<code>cospi(x)</code>、<code>sinpi(x)</code>、<code>tanpi(x)</code>は、<code>cos(π*x)</code>、<code>sin(π*x)</code>、<code>tan(π*x)</code>を計算する。
これらの関数は明らかな双曲線関数を与える。  これらはそれぞれ、双曲線の余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接（または'<em>面積余弦</em>'など）を計算します。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span>名前空間の特別な性質のために見えるだけです。
配列や行列を余白で分割します。
オブジェクトが S4 クラスのインスタンスであるかどうかをテストします。
オブジェクトが S4 クラスのインスタンスであるかどうかをテストします。
環境内の名前に値を代入します。
これらの関数は明らかな三角関数を与えます。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および 2 つの引数を持つアーク・タンジェントを計算します。

<code>cospi(x)</code>、<code>sinpi(x)</code>、<code>tanpi(x)</code>は、<code>cos(π*x)</code>、<code>sin(π*x)</code>、<code>tan(π*x)</code>を計算する。
これらの関数は明らかな三角関数を与える。  これらはそれぞれ、余弦、正弦、正接、円弧余弦、円弧正弦、円弧正接、2引数の円弧正接を計算します。

<code>cospi(x)</code>, <code>sinpi(x)</code>, <code>tanpi(x)</code>, compute<code>cos(pi*x)</code>, <code>sin(pi*x)</code>, <code>tan(pi*x)</code>.
これらの関数は明らかな双曲線関数を与える。  これらはそれぞれ、双曲線の余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接(または'<em>面積余弦</em>'など)を計算する。
データベースは<span style="font-family：クーリエ・ニュー、クーリエ; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 検索パスにアタッチされます。  これは、データベースが<span style="font-family：で検索されることを意味します：#そのため、データベース内のオブジェクトは、名前を指定するだけでアクセスできる。
名前空間をロード、アンロードする関数。
オブジェクトの特定の属性を取得または設定する。
<code>all.equal(x, y)</code> は、<span style="font-family：font-family: Courier New, Courier; color：</span>オブジェクト<code>x</code>と<code>y</code>が「ほぼ等しい」ことをテストします。  両者が異なる場合、比較はある程度行われ、差分のレポートが返されます。    適切であれば、<code>isTRUE(all.equal(...))</code>または<code>identical</code>を使用してください。
オブジェクトの特定の属性を取得または設定します。
これらの関数は、オブジェクトの属性にアクセスします。以下の最初の書式は、オブジェクトの属性リストを返します。代わりの書式は、代入の右側のリストをオブジェクトの属性として使用します（適切な場合）。
これらの関数はオブジェクトの属性にアクセスします。以下の最初のフォームはオブジェクトの属性リストを返します。
<code>autoload</code>は、<code>autoloader</code>という名前の評価約束を作成し、<code>.AutoloadEnv</code>環境に<code>name</code>という名前で格納します：color：<span style="font: Courier New; color: #666666;"><b>R</b></span> が <code>name<//code> を評価しようとすると、<code>autoloader</code> が実行され、パッケージがロードされ、<code>name</code> が新しいパッケージの環境で再評価されます。  その結果、<span style="font-family：Courier New, Courier; color：#666666;"><b>R</b></span>は<code>package</code>がロードされたかのように振る舞いますが、メモリを占有しません。

<code>.Autoloaded</code>は、オートローディングが約束されたパッケージの名前を格納します。
<code>autoload</code>は<code>autoloader</code>を作成し、<code>.AutoloadEnv</code>環境に<code>name</code>という名前で格納します：color：<span style="font: Courier New; color: #666666;"><b>R</b></span> が <code>name<//code> を評価しようとすると、<code>autoloader</code> が実行され、パッケージがロードされ、<code>name</code> が新しいパッケージの環境で再評価されます。  その結果、<span style="font-family：Courier New, Courier; color：#666666;"><b>R</b></span>は<code>package</code>がロードされたかのように振る舞いますが、メモリを占有しません。

<code>.Autoloaded</code>は、オートローディングが約束されているパッケージの名前を含む。
三角連立一次方程式を解きます。
環境の取得、設定、テスト、作成。
<code>basename</code> は lastpath separator (もしあれば) までのパスをすべて削除します。

<code>dirname</code> は、最後のパスセパレータを除いた<code>path</code>の部分、またはパスセパレータがない場合は<code>"."</code>を返します。
整数次と分数次のBessel関数, 第一種と第二種の, <i>J(nu)</i> と <i>Y(nu)</i>, および, 修正Bessel関数(第一種と第三種の), <i>I(nu)</i> と <i>K(nu)</i>.
整数および分数次のベッセル関数，第1種および第2種，<i>J(ν)</i>および<i>Y(ν)</i>，ならびに変形ベッセル関数（第1種および第3種），<i>I(ν)</i>および<i>K(ν)</i>．
整数および分数次のベッセル関数，第1種および第2種，<i>J(ν)</i>および<i>Y(ν)</i>，ならびに変形ベッセル関数（第1種および第3種），<i>I(ν)</i>および<i>K(ν)</i>．
整数次と分数次のベッセル関数，第1種と第2種，<i>J(ν)</i>と<i>Y(ν)</i>，および修正ベッセル関数（第1種と第3種），<i>I(ν)</i>と<i>K(ν)</i>．
ベータ関数とガンマ関数に関連する特殊な数学関数。
これらの関数は、環境の調整や環境内のバインディングのためのインターフェイスを表す。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができる。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数を関数にリンクすることができます。
このビルドでネイティブ言語サポート（NLS）が有効になっている場合、<span style="font-family：color：#(<code>bindtextdomain()</code>の例を参照してください)、文字ベクトルを翻訳しようとするか、翻訳を見つける場所を設定します。
要素をビットの集合と見なした整数ベクトルに対する論理演算。
要素をビットの集合と見なした整数ベクトルに対する論理演算。
要素をビットの集合と見なした整数ベクトルに対する論理演算
要素をビットの集合とみなす整数ベクトルに関する論理演算
要素をビットの集合とみなす整数ベクトルに関する論理演算
要素をビットの集合とみなす整数ベクトルに対する論理演算
関数の<em>body</em>を取得または設定します。これは基本的に関数定義のすべてですが、形式引数(<code>formals</code>)は'詳細'を参照してください。
関数の<em>body</em>を取得または設定します。関数の<em>body</em>は、基本的に関数の定義のすべてですが、正式な引数(<code>formals<//code>)も含みます。
LISPのbackquoteマクロのアナローグである。  <code>bquote</code>は、<code>.()</code>で包まれた項が指定された<code>where</code>環境で評価されることを除いて、その引数を引用します。もし<code>splice = TRUE</code>ならば、<code>..()</code>でラップされた項は評価され、呼び出しにスプライスされる。
これらは<span style="font-family：の基本的な制御フロー構成である：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の基本的な制御フロー構成です。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
式の実行を中断し、<code>browser</code>が呼び出された環境を検査できるようにします。
browserの呼び出しは、text引数かcondition引数を与えることでコンテキストを提供することができる。  これらの関数は、これらの引数のいずれかを取得するために使用することができます。
ブラウザへの呼び出しは、text引数またはcondition引数のいずれかを与えることで、コンテキストを提供することができる。  これらの関数は、これらの引数のいずれかを取得するために使用することができます。
ブラウザへの呼び出しは、text引数または条件引数のいずれかを指定することで、コンテキストを提供することができます。  これらの関数は、これらの引数のいずれかを取得するために使用できます。
すべての組み込みオブジェクトの名前を返します。  これらは<span style="font-family：color：font-family: Courier New, Courier; color: #666666;"><b>R</b></span> インタプリタのシンボルテーブルから直接取得されます。
関数<code>by</code>は、データ・フレームに適用される<code>tapply</code>のオブジェクト指向ラッパーです。
関数 <code>by</code> は、データ・フレームに適用される<code>tapply</code>のオブジェクト指向ラッパーです。
関数 <code>by</code> は、データ・フレームに適用される<code>tapply</code>のオブジェクト指向ラッパーです。
コネクション、すなわち圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数です。
これは引数を結合する汎用関数です。

デフォルトのメソッドは、引数を結合してベクトルを形成します。すべての引数は、返される値の型である共通の型に強制され、名前以外のすべての属性は削除されます。
カレンダーの日付を表すクラス <code>"Date"</code>の説明。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの「時差」を呼び出します。
<code>factor</code>関数は、ベクトルを因子として符号化するのに使われます（因子には'category'と'enumerated type'という用語も使われます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
文字列を引用符なしで表示する
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと関連するメソッド。
カレンダーの日付と時刻を表す <code>"POSIXlt"</code> と <code>"POSIXct"</code> クラスの説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
<code>warnings</code>とその<code>print</code>メソッドは、変数<code>last.warning</code>を見やすい形で表示します。
<code>mode</code> <code>"call"</code>（または<code>"("</code>、詳細参照）のオブジェクトを作成またはテストします。
Schemeのcallの下方向のみのバージョンで、現在の継続を持つ。
<span style="font-family：のこのビルドにコンパイルされているオプション機能について報告する：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>にコンパイルされたオプション機能について報告する。
文字ベクトル内の文字、特に大文字から小文字、またはその逆を変換します。
表現を連結してオブジェクトを出力する。  <code>cat</code>は、<code>print</code>よりはるかに少ない変換しか行わない。
vector、matrix、data-frameの一連の引数を取り、それぞれ<em>c</em>列、<em>r</em>行で結合します。  これらは、他の<span style="font-family：color：#666666;"><b>R</b></span>クラス用のメソッドを持つ汎用関数です。
vector, matrix, data-frame の引数をとり、それぞれ <em>c</em>olumns, <em>r</em>ows で結合します。  これらは、他の<span style="font-family：color：#666666;"><b>R</b></span>クラス用のメソッドを持つ汎用関数です。
<code>ceiling</code>は一つの数値引数<code>x</code>を取り、<code>x</code>の対応する要素より小さくない最小の整数を含む数値ベクトルを返します。

<code>floor</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より大きくない最大の整数を含む数値ベクトルを返します。

<code>trunc</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の値を <code>0</code> に向かって切り捨てた整数を含む数値ベクトルを返す。

<code>round</code> は、第一引数の値を指定された小数点以下の桁数(デフォルトは0)に丸めます。  5を四捨五入する場合の "round to even "については'詳細'を参照。

<code>signif</code> は、第一引数の値を指定された有効桁数に丸めます。   したがって、<code>numeric</code> <code>x</code> の場合、<code>signif(x, dig)</code> は <code>round(x, dig - ceiling(log10(abs(x))))</code> と同じになります。
第二引数の要素の中で第一引数の要素に一意に一致するものを探します。  成功すればこの要素を返し、そうでなければ第3引数で指定されたアクションを実行する。
<code>"character"</code>型のオブジェクトを作成またはテストする。
<code>charmatch</code> は、第2引数の要素の中から第1引数の要素にマッチするものを探す。
<code>"raw"</code>型のオブジェクトの変換と操作。
文字ベクトル内の文字、特に大文字から小文字への変換、またはその逆。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
呼び出し元の<code>...</code>にある余計な引数について警告する。  例えば、正式な<code>...</code>引数を必要とするが、それを使用しないS3メソッドで使用することができる。  これは、(<code>chkDots()</code>の呼び出し元である)問題の関数を呼び出す際のユーズドエラーをキャッチするのに役立ちます。
実対称正定値正方行列のコレスキー分解を計算せよ。
実対称正定値正方行列のコレスキー分解を計算せよ．
対称正定値正方行列のコレスキー分解を求めよ。  同様に，<i>(X'X)^(-1)</i>を<i>X</i>のQR分解の(<i>R</i>部分から計算する。
ベータ関数とガンマ関数に関連する特殊な数学関数。
<span style="font-family：Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向プログラミングに使用できるシンプルな汎用関数機構を備えています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向プログラミングに使えるシンプルなジェネリック関数のメカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
テキスト行をコネクションにプッシュバックする関数と、現在プッシュバックされている行数を照会する関数。
コネクションを作成、オープン、クローズする関数。すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」への接続を作成、オープン、クローズする関数。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（<code>"srcref"</code>）、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>時などです。
接続の側面を表示する。
amatrixのようなオブジェクトの列番号を示す整数の行列、または列ラベルの因数を返す。
数値配列（またはデータ・フレーム）の行と列の合計と平均を作成します。
行列状オブジェクトの行名または列名の取得または設定
行列のようなオブジェクトの行や列の名前を取得したり設定したりする。
数値配列（またはデータ・フレーム）の行と列の合計と平均を作成する。
<span style="font-family：color：<span style="font-family: Courier New, Courier; "color: #666666;"><b>R</b></span> セッションが呼び出されたときに与えられたコマンドライン引数のコピーにアクセスできます。
これらの関数は、<span style="font-family：color：font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの <em>comment</em> 属性を設定します。  これは通常、<code>data.frame</code>やモデルの適合に役立ちます。

他の<code>属性</code>とは逆に、<code>コメント</code>は（<code>print</code>または<code>print.default</code>によって）印刷されない。

<code>NULL</code> または長さゼロの文字ベクトルを代入すると、コメントは削除されます。
これらの関数は、<span style="font-family：color：font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトに対して <em>comment</em> 属性を設定します。  これは通常、<code>data.frame</code>やモデルの適合に役立ちます。

他の<code>属性</code>とは逆に、<code>コメント</code>は（<code>print</code>または<code>print.default</code>によって）印刷されない。

<code>NULL</code> または長さゼロの文字ベクトルを代入すると、コメントは削除されます。
<span style="font-family：color：</span>の算術演算子<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>に加え、<span style="font-family: Courier New; color: #666666;"><b>R</b></span>の複雑な算術をサポートする基本関数があります。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
これらの関数は、エラーや警告を含む異常な状態を処理する機構を提供する。
これらの関数は、エラーや警告を含む異常な状態を扱うための機構を提供する。
これらの関数は、エラーや警告を含む異常な状態を処理するための機構を提供する。
<code>library</code> と <code>require</code> は、アドオンパッケージをロードし、アタッチする。
<code>conflicts</code> は、<code>search</code> パス上の 2 つ以上の場所に同じ名前で存在するオブジェクトを報告します。  これは、意図しないマスキングを発見するのに役立ちます。
<span style="font-family：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span>の算術演算子<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>に加えて、<span style="font-family: "Courier New; color: #666666;"><b>R</b></span>の複素数演算をサポートする基本関数があります。
<span style="font-family：クーリエ・ニュー、クーリエ; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> Who-is-whoでは、<span style="font-family：(フォント: Courier New, Courier; color：font-family: Courier New, Courier; "color: #666666;"><b>R</b></span>の開発に大きく貢献した人物を説明する。
これらの関数は明らかな三角関数を与える。  これらの関数は、余弦、正弦、正接、円弧余弦、円弧正弦、円弧正接、および2つの引数の円弧正接を計算する。

<code>cospi(x)</code>、<code>sinpi(x)</code>、<code>tanpi(x)</code>は、<code>cos(π*x)</code>、<code>sin(π*x)</code>、<code>tan(π*x)</code>を計算する。
これらの関数は明らかな双曲線関数を与える。  これらはそれぞれ、双曲線の余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接(または'<em>面積余弦</em>'など)を計算します。
これらの関数は明らかな三角関数を与える。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算します。

<code>cospi(x)</code>, <code>sinpi(x)</code>, <code>tanpi(x)</code> は、<code>cos(π*x)</code>, <code>sin(pi*x)</code>, <code>tan(pi*x)</code> を計算します。
引数として行列 <code>x</code> と <code>y</code> が与えられた場合、行列のクロス積を返します。  これは、形式的には、<code>t(x) %*% y</code> (<code>crossprod</code>) または<code>x %*% t(y)</code> (<code>tcrossprod</code>) の呼び出しと等価です（しかし、通常は、それより若干高速です）。
C スタックのサイズと使用量に関する情報を報告する (利用可能な場合)。
引数の要素の累積和、積、最小値または最大値を要素とするベクトルを返します。
引数の要素の累積和、積、最小値または最大値を要素とするベクトルを返します。
引数の要素の累積和、積、極小値または極大値を要素とするベクトルを返します。
引数の要素の累積和、積、最小値または最大値を要素とするベクトルを返します。
<code>http://</code>、<code>ftp://</code>、<code>https://</code>、<code>ftps://</code> のようなサポートされているプロトコルの URL のヘッダを取得する。すべてのプラットフォームでサポートされているわけではないオプションの関数。
<code>cut</code> は、<code>x</code> の範囲を区間に分割し、<code>x</code> の値をどの区間に該当するかによってコード化します。  一番左の区間はレベル1に対応し、次の一番左はレベル2に対応します。
<code>cut</code>のメソッドは日付-時間オブジェクトに適用されます。
<code>cut</code> は、<code>x</code> の範囲を区間に分割し、<code>x</code> の値をどの区間に該当するかによってコード化します。  一番左の区間はレベル1に対応し、次の一番左はレベル2に対応します。
date-timeオブジェクトに適用される<code>cut</code>のメソッド。
任意の<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトのクラスを決定する。
関数<code>data.frame()</code>はデータ・フレームを作成します。データ・フレームは、行列やリストの特性の多くを共有する、緊密に結合された変数の集まりで、<span style="font-family：クーリエ・ニュー、クーリエ; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>のモデリング・ソフトウェアで基本的なデータ構造として使用されています。
データフレーム内のすべての変数を数値モードに変換し、それらを行列の列として結合した行列を返します。  因子と順序付き因子は、それらの内部コードに置き換えられます。
現在のシステムの日付と時刻を文字列で返します。
<code>text</code>と<code>condition</code>引数は、<code>browser</code>呼び出しで与えられるものと同じです。  これらは、ブラウザが入力されると、ユーザによって取得され、どのブレークポイントが有効化されたかを識別するためのメカニズムを提供します。
<code>text</code>と<code>condition</code>引数は、<code>browser</code>呼び出しで与えられるものと同じです。  これらは、ブラウザが入力されると、ユーザによって取得され、どのブレークポイントが有効化されたかを識別するためのメカニズムを提供します。
<code>text</code>と<code>condition</code>引数は、<code>browser</code>呼び出しで与えられるものと同じです。  これらは、ブラウザが入力されると、ユーザによって取得され、ユーザがどのブレークポイントが有効化されたかを識別するためのメカニズムを提供します。
関数<code>data.frame()</code>は、データ・フレームを作成します。データ・フレームは、行列やリストの特性の多くを共有する、緊密に結合された変数の集まりで、ほとんどの<span style="font-family：クーリエ・ニュー、クーリエ; color：#666666;"><b>R</b></span>のモデリング・ソフトウェアで基本的なデータ構造として使われている。
<code>delayedAssign</code>は、<em>promise</em>を作成し、その値が要求された場合、与えられた式を評価します。  これは、<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> が(解釈される)関数の評価に使用する<em>遅延評価</em>メカニズムに直接アクセスできます。
未評価の式を文字列に変換する。
評価されない式を文字列に変換する。
<code>det</code>は行列の行列式を計算します。  <code>determinant</code>は行列式のモジュラスと符号を別々に返す汎用関数です。
データベースを切り離す、つまり、利用可能な<span style="font-family：font-family: Courier New, Courier; color：#666666;"><b>R</b></span>オブジェクトです。  通常これは、<code>attach</code>された<code>data.frame</code>か、<code>library</code>によってアタッチされたパッケージです。
<code>det</code> は行列の行列式を計算します。  <code>determinant</code> は、行列式のモジュラスと符号を別々に返す汎用関数です。
<code>det</code> は行列式を計算します。  <code>determinant</code>は、行列式のモジュラス、対数スケール、行列式の符号を別々に返す汎用関数です。
<span style="font-family：のASCIIテキスト表現を書き込みます：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの ASCII テキスト表現をファイルに書き込みます：color：<span style="font: Courier New, Courier; "color: #666666;"><b>R</b></span>コンソール、または接続を使用するか、オブジェクトを再作成します。
行列の対角を抜き出したり置き換えたり、対角行列を構築する。
行列の対角を抽出または置換、または対角行列を作成します。
適切に遅延および反復された差分を返します。
関数は、適切に遅延および反復された差分を返します。
適切な遅延および反復された差分関数を返します。
時間間隔の作成、印刷、およびいくつかの演算。  <code>print()</code>メソッドは、これらの「時間差」を呼び出します。
適切に遅延され、反復された差分を返す。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドは、これらの "時間差 "を呼び出します。
ベータ関数とガンマ関数に関連する特殊な数学関数。
オブジェクトの次元を取得または設定する。
オブジェクトの寸法の取得または設定
オブジェクトの次元の取得または設定
オブジェクトの dimnames の取得または設定
オブジェクトの dimnames を取得または設定する。
オブジェクトの dimnames を取得または設定する。
オブジェクトのdimnamesの取得または設定
これらの関数は、指定されたディレクトリ内のファイル名やディレクトリ名の文字ベクトルを生成します。
これらの関数は、コンピュータのファイル・システムに対する低レベルのインタフェースを提供します。
これらの関数は、コンピュータのファイルシステムへの低レベルのインタフェースを提供します。
<code>basename</code> は、(もしあれば) lastpath separator までのパスをすべて削除する。

<code>dirname</code>は、<code>path</code>から最後のパス区切り文字を除いた部分、またはパス区切り文字がない場合は<code>"."</code>を返します。
<code>do.call</code>は、関数名と渡される引数のリストから関数コールを構築し、実行します。
<code>dontCheck</code>関数は、<code>identity</code>と同じですが、<code>R CMD check</code>コード解析では、<code>x</code>のチェックを抑制するディレクティブとして解釈されます。  現在のところ、これは<code>checkFF(registration = TRUE)</code>が外部関数呼び出しの<code>.NAME</code>引数をチェックする場合にのみ使用されます。
倍精度ベクトルを作成、強制、またはテストします。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> オブジェクトの ASCII テキスト表現をファイルに書き込みます：color：<span style="font: Courier New, Courier; "color: #666666;"><b>R</b></span>コンソールや接続を使用したり、オブジェクトを再作成したりすることができます。
適切なシングルクォーテーションとダブルクォーテーションを組み合わせて、テキストをシングルクォーテーションまたはダブルクォーテーションします。
1レベルしかない配列の次元を削除する。
関数<code>droplevels</code>は、<code>factor</code>や、より一般的にはデータ・フレーム内の因子から未使用のレベルを削除するために使用されます。
関数 <code>droplevels</code> は、<code>factor</code> から、あるいは、より一般的には、データフレーム内の因子から、未使用のレベルを落とすために使用されます。
関数 <code>droplevels</code> は、<code>factor</code> から、またはより一般的にはデータ・フレーム内の因子から、未使用のレベルを削除するために使用されます。
この関数は、<span style="font-family：color：<code>dump</code> ファイルは通常、別の<span style="font-family：font-family: Courier New, Courier; color：<b>R</b></span> セッションに入れることができます。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、"一般化された "より効率的なバージョン <code>any(duplicated(.))</code>であり、単に<code>TRUE</code>の代わりに正の整数添字を返します。
<code>duplicated()</code>は、ベクトルやデータフレームのどの要素が、より小さい添え字を持つ要素と重複しているかを判定し、どの要素（行）が重複しているかを示す論理ベクトルを返します。

<code>anyDuplicated(.)</code>は、より効率的なバージョン <code>any(duplicated(.))</code>を "一般化 "したもので、<code>TRUE</code>の代わりに正の整数インデックスを返します。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>カレンダーの日付と時刻を表すクラスの説明。
<code>warnings</code>とその<code>print</code>メソッドは、変数<code>last.warning</code>を楽しい形式で表示します。
DLL（共有オブジェクトとしても知られている）をロードまたはアンロードし、C関数またはFortranサブルーチンが利用可能かどうかをテストする。
DLL（共有オブジェクトとしても知られている）をロードまたはアンロードし、C関数またはFortranサブルーチンが利用可能かどうかをテストする。
オブジェクト(<code>get</code>)またはゼロ個以上のオブジェクト(<code>mget</code>)を名前で検索する。
<code>eapply</code> は、<code>environment</code> から指定された値に <code>FUN</code> を適用し、結果をリストとして返します。  usercは、全ての名前付きオブジェクトが使用されるように要求することができます（通常、ドットで始まる名前は使用されません）。  出力はソートされず、囲む環境は検索されません。
数値（ダブル、整数、論理）または複素行列の固有値および固有ベクトルを計算します。
環境の取得、設定、テスト、作成。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりします。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりする。
<code>encodeString</code>は、<code>print.default</code>と同じ方法で文字ベクトル内の文字列をエスケープし、オプションでエンコードされた文字列をフィールド幅内に収める。
文字ベクトルに対して宣言されたエンコーディングを読み込んだり設定したりします。
文字ベクトルに対して宣言されたエンコーディングを読んだり設定したりします。
<code>x</code> のエントリが、それぞれ文字列 (のエントリ) <code>prefix</code> または <code>suffix</code> で始まるか終わるかを決定します。
<code>substitute</code> は、(未評価の)式 <code>expr</code> のパースツリーを返します。

<code>quote</code> は単に引数を返します。引数は評価されず、どのようなR式でもかまいません。

<code>enquote</code>はシンプルな1行ユーティリティで、<code>Foo(...)</code>という形式の呼び出しを<code>quote(Foo(...))</code>という呼び出しに変換します。  これは通常、<code>call</code>を早期評価から保護するために使用されます。
環境の取得、設定、テスト、作成
環境の取得、設定、テスト、作成。
環境の取得、設定、テスト、作成。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数と関数をリンクすることができます。
環境の取得、設定、テスト、作成。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 式を指定された環境で評価する。
<span style="font-family：を評価する：<span style="font: Courier New, Courier; "color: #666666;"><b>R</b></span> 式を指定された環境で評価する。
<span style="font-family：を評価する：#指定された環境で<span style="font: Courier New, Courier;"><b>R</b></span> 式を評価する。
<span style="font-family：font: Courier New, Courier; color：#与えられた名前の<span style="font: Courier New;"><b>R</b></span> オブジェクトを探し、場合によってはそれを返す。
<code>log</code>は対数を計算し、デフォルトでは自然対数、<code>log10</code>は常用(すなわち、底10)対数、<code>log2</code>は常用(すなわち、底2)対数を計算します。一般的な形式<code>log(x, base)</code>は底<code>base</code>で対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算します。
与えられたベクトルまたは因子の全ての組み合わせからデータフレームを作成する。  この方法の正確な詳細については、戻り値の説明を参照してください。
<code>log</code>は対数を計算し、デフォルトでは自然対数、<code>log10</code>は常用(つまり、底10)対数、<code>log2</code>は常用(つまり、底2)対数を計算します。一般的な形式<code>log(x, base)</code>は底<code>base</code>を持つ対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算します。
モード <code>"expression"</code> のオブジェクトを作成またはテストします。
使用された（外部の）サードパーティ製ソフトウェアのバージョンを報告する。
<code>"logical"</code> 型のオブジェクト、および basiclogical 定数を作成またはテストします。
<code>factor</code>関数は、ベクトルを因子として符号化するために使用される（'category'と'enumerated type'という用語も因子に対して使用される）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバーシップ関数と強制関数です。
ベータ関数とガンマ関数に関連する特別な数学関数。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」接続を作成、オープン、クローズする機能。
ユーザーのファイルシステム上のファイルに関する情報にアクセスするユーティリティ関数。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
対話的にファイルを選択する。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
これらの関数は、コンピュータのファイルシステムに低レベルのインターフェイスを提供します。
これらの関数は、コンピュータのファイルシステムに低レベルのインターフェイスを提供します。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ関数。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ機能。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ関数。
プラットフォームに依存しない方法でコンポーネントからファイルへのパスを構築します。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインターフェイスを提供します。
1つまたは複数の(プレーンな)テキストファイルを、プラットフォーム固有の方法で、通常は「ページャー」を介して表示します。
ユーザーのファイルシステム上のファイルに関する情報を抽出するユーティリティ関数。
これらの関数は、コンピュータのファイルシステムに対する低レベルのインタフェースを提供する。
<code>Reduce</code>は、バイナリ関数を使用して、与えられたベクトルの要素と、おそらく与えられた初期値とを連続して結合する。<code>Filter</code>は、述語(論理)関数が真を与えるベクトルの要素を抽出する。  <code>Find</code>と<code>Position</code>は、それぞれそのような要素の最初か最後と、ベクトル内の位置を与えます。  <code>Map</code> は、与えられたベクトルの対応する要素に関数を適用します。  <code>Negate</code> は与えられた関数の否定を生成する。
<code>Reduce</code>は2進関数を使用して、与えられたベクトルの要素と与えられた初期値を連続的に結合します。<code>Filter</code>は述語(論理)関数が真を与えるベクトルの要素を抽出します。  <code>Find</code>と<code>Position</code>は、それぞれそのような要素の最初か最後と、ベクトル内の位置を与えます。  <code>Map</code> は、与えられたベクトルの対応する要素に関数を適用します。  <code>Negate</code> は与えられた関数の否定を生成する。
つ以上のパッケージへのパスを見つける。
<code>vec</code>の減少しないブレークポイントのベクトルが与えられた場合、<code>x</code>の各要素を含む区間を見つける、if<code>i &lt;- findInterval(x,v)</code>, <code>x</code><i>v[i[j]] ≤ x[j] &lt; v[i[j] + 1]</i> の各インデックス <code>j</code> に対して, <i>v[0] := - Inf</i>, <i>v[N+1] := + Inf</i>, <code>N &lt;- length(v)</code>.2つの境界では、オプションの引数<code>rightmost.closed</code>と<code>all.inside</code>によって、返されるインデックスが1だけ異なるかもしれません。
基本パッケージの内部オブジェクトのほとんどは、基本名前空間の特別な性質のために、ユーザから見えるだけです。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
<code>ceiling</code> は、単一の数値引数 <code>x</code> を取り、 <code>x</code> の対応する要素より小さくない最小の整数を含む数値ベクトルを返します。

<code>floor</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より大きくない最大の整数を含む数値ベクトルを返します。

<code>trunc</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の値を <code>0</code> に向かって切り捨てた整数を含む数値ベクトルを返す。

<code>round</code> は、第一引数の値を指定された小数点以下の桁数(デフォルトは0)に丸めます。  5を四捨五入する場合の "round to even "については'詳細'を参照。

<code>signif</code> は、第一引数の値を指定された有効桁数に丸めます。   したがって、<code>numeric</code> <code>x</code> の場合、<code>signif(x, dig)</code> は <code>round(x, dig - ceiling(log10(abs(x))))</code> と同じになります。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」を作成、オープン、クローズする関数です。
コネクションを作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
これらは<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の基本的な制御フロー構成です。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語である。
関数の引数の評価を強制する。
関数がクロージャである場合、呼び出しの前に強制的に指定された数の先行引数で関数を呼び出します。
<code>関数</code>の形式引数を取得または設定する。
<code>関数</code>の形式引数を取得または設定する。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトをきれいに印刷する。
<span style="font-family：font: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトをきれいに印刷する。
<span style="font-family：font: Courier New, Courier; color：<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトをきれいに印刷する。
文字表現と、カレンダーの日付を表す<code>"Date"</code>クラスのオブジェクトを変換する関数。
<span style="font-family：をフォーマットします：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> オブジェクトを整形し、きれいに印刷します。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時差 "を呼び出します。
<span style="font-family：Courier New, Courier; color：<span style="font: Courier New; color: #666666;"><b>R</b></span> オブジェクトをきれいに印刷する。
整数を16進数形式に変換または印刷し、最大値を表示するのに必要な桁数だけ、必要に応じて先頭のゼロを使用する。
<code>format(x, digits, nsmall)</code> がどのようにフォーマットされるかの情報が返されます。
<code>library</code>と<code>require</code>はアドオンパッケージをロードしてアタッチします。
パッケージのバージョンを含む数値バージョンを表現するシンプルな S3 クラスと、関連するメソッド。
8進数形式の整数を、必要に応じて先頭のゼロを使用して、最大値を表示するのに必要な桁数だけ変換または表示します。
<code>library</code>と<code>require</code>は、アドオン・パッケージをロードし、アタッチします。
<code>"POSIXlt"</code> および <code>"POSIXct"</code>クラスのオブジェクトと文字表現との変換関数。
文字表現と、暦日時を表すクラス <code>"POSIXlt"</code> および <code>"POSIXct"</code> のオブジェクトを変換する関数。
<code>format.pval</code>は、p値をフォーマットするためのものです。
<code>summary</code>は、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第1引数の<code>class</code>に依存する特定の<code>メソッド</code>を呼び出します。
<code>formatC()</code>は、<code>C</code>スタイルの書式指定を使用して、個別に柔軟に数値を書式設定します。

<code>prettyNum()</code>は、<code>format.default</code>にもあるように、(おそらくフォーマットされた)数字を「きれいにする」ために使われる。

<code>.format.zeros(x)</code>は、<code>prettyNum()</code>の補助関数で、フォーマットされた数値のベクトル<code>x</code>のゼロを再フォーマットします。
項目とその説明のベクトルを 2 列表や LaTeX 形式の説明リストとして整形します。
三角連立一次方程式を解きます。
これらの関数は、<span style="font-family：color：#666666;"><b>R</b></span>言語における新しい関数を定義するためのベースとなるメカニズムです。
ベータ関数とガンマ関数に関連する特別な数学関数。
<code>gc</code>の呼び出しは、ガベージコレクションを行わせる。<code>gcinfo</code>は、自動コレクションがサイレント(<code>verbose = FALSE</code>)か、メモリ使用統計(<code>verbose = TRUE</code>)のどちらかになるようにフラグを設定する。
この関数は、<span style="font-family：color：GC タイミングが有効になっている間、<span style="font-family: Courier New; color: #666666;"><b>R</b></span> セッションでこれまでにガベージコレクションに費やされた時間を報告します。
<code>gc</code> を呼び出すと、ガベージコレクションが行われます。<code>gcinfo</code> はフラグを設定し、自動コレクションがサイレント (<code>verbose = FALSE</code>) か、メモリ使用量の統計を表示 (<code>verbose = TRUE</code>) するようにします。
(ほぼ)すべてのメモリ割り当てに対してガベージコレクションを引き起こす。  また、<span style="font-family：また、<span style="font-family: Courier New, Courier; color：また、<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> の実行が非常に遅くなります。
(ほぼ) すべてのメモリ割り当てでガベージコレクションを引き起こします。メモリ保護のバグを見つけることを意図しています。  また、<span style="font-family：また、<span style="font-family: Courier New, Courier; color：<b>R</b></span> の実行は、残念ながら非常に遅くなります。
オブジェクトの名前で検索する(<code>get</code>)か、0個以上のオブジェクトを検索する(<code>mget</code>)。
<span style="font-family：font-family: Courier New, Courier; color：与えられた名前の<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span>オブジェクトを探し、場合によってはそれを返す。
接続の側面を表示する。
これは<span style="font-family：から呼び出される内部関数です：<code>.C</code>/<code>.Call</code>/<code>.Fortran</code>/<code>.External</code>呼び出しの名前空間を決定するために、<span style="font-family: Courier New; color: #666666;"><b>R</b></span>のCコードから呼び出される内部関数です。呼び出しが名前空間内の関数から行われた場合、その名前空間に関連付けられているDLLを見つけることができます。  この目的は、これらのネイティブ呼び出しで<code>PACKAGE</code>引数を使用することを避け、パッケージのバージョンをより良くサポートすることです。

これは内部関数であり、将来的には内部Cコードに移行される可能性があるため、<span style="font-family：color：#666666;"><b>R</b></span>プログラマーは使用しないでください。
これは<span style="font-family：から呼び出される内部関数です：これは、<code>.C</code>/<code>.Call</code>/<code>.Fortran</code>/<code>.External</code>呼び出しの名前空間を決定するために、<span style="font: Courier New; color: #666666;"><b>R</b></span>のCコードから呼び出される内部関数です。呼び出しが名前空間内の関数から行われた場合、その名前空間に関連付けられているDLLを見つけることができます。  この目的は、これらのネイティブ呼び出しで<code>PACKAGE</code>引数を使用することを避け、パッケージのバージョンをより良くサポートすることです。

これは内部関数であり、将来的には内部Cコードに移行される可能性があるため、<span style="font-family：color：#666666;"><b>R</b></span>プログラマーは使用しないでください。
接続の表示
この関数を使用すると、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、および将来的なセキュリティの強化のために、R に登録されている DLL 内のルーチンのセットを照会できます。この関数は、DLL 内の各登録ルーチンについて、<code>.C</code>、<code>.Call</code>、<code>.Fortran</code>、<code>.External</code> という異なるインターフェイスの説明を提供します。
この関数を使用すると、動的検索、ネイティブ・ルーチン呼び出し時のエラー処理、および将来的なセキュリティの強化のために、R に登録されている DLL 内のルーチンのセットを照会できます。この関数は、異なるインタフェース、つまり <code>.C</code>、<code>.Call</code>、<code>.Fortran</code>、<code>.External</code> の DLL 内の各登録ルーチンの説明を提供します。
この関数を使用すると、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、および将来的なセキュリティの強化のためにRに登録されたDLL内のルーチンのセットを照会できます。この関数は、異なるインタフェース、すなわち<code>.C</code>、<code>.Call</code>、<code>.Fortran</code>、および<code>.External</code>について、DLL内の登録された各ルーチンの説明を提供します。
ベクトル、行列、配列、リストに作用する演算子。
<code>stop</code> は、現在の式の実行を停止し、エラー・アクションを実行します。

<code>geterrmessage</code>は最後のエラーメッセージを与える。
名前空間オブジェクトへのリフレクションをサポートする内部関数。
これらの関数を使用すると、パッケージのアタッチ/デタッチやネームスペースの(アン)ロードの前に実行されるアクションを設定できます。
この関数は、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> セッションで現在ロードされている DLL (<code>dyn load</code> を参照) を指定します。
名前空間オブジェクトに対するリフレクションをサポートする内部関数。
名前空間オブジェクトへのリフレクションをサポートする内部関数。
名前空間オブジェクトへのリフレクションをサポートする内部関数。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のために見えるだけです。
名前空間オブジェクトのリフレクションをサポートする内部関数。
名前空間オブジェクトに対するリフレクションをサポートする内部関数。
名前空間オブジェクトへの参照をサポートする内部関数。
これは、1 つ以上の動的にロードされた、または 'エクスポートされた' 組み込みネイティブ・シンボルの説明を見つけて返します。  各シンボル名に対して、シンボルの名前、シンボルが配置されているライブラリ、利用可能であれば、シンボルが期待する引数の数、どのインタフェースで呼び出されるべきか(すなわち、<code>.Call</code>、<code>.C</code>、<code>.Fortran</code>、または<code>.External</code>)に関する情報を返します。さらに、これはシンボルのアドレスを返し、これを他のCルーチンに渡すことができる。  具体的には、これは異なるダイナミックにロードされたパッケージ・ライブラリ間でシンボルを明示的に共有する方法を提供する。  また、シンボルが解決された場所を問い合わせる方法を提供し、動的解決に関連する奇妙な動作の診断に役立ちます。
ユーザーが、<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> が計算し、結果を表示する方法に影響を与える、さまざまなグローバル <em>option</em> を設定できます。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
これらの関数は、ソースファイルや、より一般的には「ソース参照」（<code>"srcref"</code>）、つまりソースコードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：これは、<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>セッション、つまり<code>options(keep.source = TRUE)</code>のときに利用できます。
これは、各トップレベルタスクの終了時に呼び出される、現在登録されているタスクコールバックの名前（または識別子）を取得する方法を提供します。
このビルドでネイティブ言語サポート(NLS)が有効になっている場合、<span style="font-family：font-family: Courier New, Courier; color：#(<code>bindtextdomain()</code>の例を参照してください)、文字ベクトルを翻訳しようとするか、翻訳がどこで見つかるかを設定します。
C 関数 <code>sprintf</code> のラッパーで、整形されたテキストと変数値の組み合わせを含む文字ベクトルを返す。
<code>getwd</code> は、<span style="font-family：font-family: Courier New, Courier; color：<code>setwd(dir)</code>は作業ディレクトリを<code>dir</code>に設定するために使われる。
レベルのパターンを指定して因子を生成する。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
環境の取得、設定、テスト、作成。
<code>grep</code>、<code>grepl</code>、<code>regexpr</code>、<code>gregexpr</code>、<code>regexec</code>、<code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>にマッチするものを検索する。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全マッチの置換を行う。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>にマッチするものを検索します。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全マッチの置換を行う。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>にマッチするものを検索します。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全マッチの置換を行う。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>にマッチするものを検索します。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全マッチの置換を行う。
<code>grepRaw</code>は、rawベクトル<code>x</code>内の部分文字列<code>pattern</code>のマッチを検索する。
<code>grouping</code>は、同じ値が隣接するように最初の引数を並べ替えた並べ替えを返す。  属性として返されるのは、グループ分割と最大グループサイズである。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>にマッチするものを検索します。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全てのマッチの置換を行う。
<code>gzcon</code> は既存の接続をラップする変更された接続を提供し、その接続を通して読み込みの伸長や書き込みの圧縮を行う。  標準的な <code>gzip</code> ヘッダが想定されている。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
オブジェクトのクラスを変更して、それが「そのまま」扱われるべきであることを示す。
これは、エンコーディング間で文字ベクトルを変換するためにシステム機能を使用します： 'i'は'国際化'を意味します。
i'は'internationalization'を表す。
ICUによる照合順序を制御する（<span style="font-family：courier new, Courier; color：#666666;"><b>R</b></span>ビルドのオプション部分)。
ICUによる照合順序を制御する（<span style="font-family：color：#666666;"><b>R</b></span>ビルドのオプション部分)。
2つのオブジェクトが<em>正確に</em>等しいかどうかをテストする安全で信頼できる方法です。  この場合は<code>TRUE</code>を、それ以外の場合は<code>FALSE</code>を返します。
引数を返す些細な同一性関数。
以上が<span style="font-family：color：#666666;"><b>R</b></span>言語の基本的な制御フロー構成です。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語です。
<code>ifelse</code>は、<code>test</code>の要素が<code>TRUE</code>か<code>FALSE</code>かによって、<code>yes</code>か<code>no</code>のどちらかの要素で満たされた<code>test</code>と同じ形の値を返します。
<span style="font-family：の複素数演算をサポートする基本関数です：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>の算術演算子に加え、<span style="font: Courier New; color: 666666;"><b>R</b></span> の複素数演算をサポートする基本関数。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のために見えるだけです。
単一の<span style="font-family：を1つ書くための関数です：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトをファイルに書き込み、それをリストアする関数です。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; "color: #666666;"><b>R</b></span> は、オブジェクト指向スタイルのプログラミングに使用できるシンプルなジェネリック関数のメカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
<code>"integer"</code>型のオブジェクトを作成またはテストします。
<code>interaction</code>は、与えられた因子の相互作用を表す因子を計算します。  <code>interaction</code>の結果は常に順序なしである。
<span style="font-family：Courier New, Courier; color：<span style="font: Courier New; color: #666666;"><b>R</b></span> がインタラクティブに使用されている場合は<code>TRUE</code>を、そうでない場合は<code>FALSE</code>を返します。
2つのベクトルに対して<b>集合</b>和、交、(非対称!)差、等式、メンバシップを行います。
<code>"raw"</code>型のオブジェクトとの変換と操作。
UTF-8でエンコードされた文字ベクトルとUTF-32でエンコードされた整数ベクトルとの変換。
ベクトル内の等しい値のランの長さと値を計算する。
オブジェクトの（一時的な）不可視コピーを返す。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
配列の作成やテストを行います。
<code>is.atomic</code> は、<code>x</code> がアトミック型（または <code>NULL</code>）であれば <code>TRUE</code>を返し、そうでなければ <code>FALSE</code>を返します。

<code>is.recursive</code>は、<code>x</code>が再帰的な(リストのような)構造を持っていれば<code>TRUE</code>を返し、そうでなければ<code>FALSE</code>を返します。
<code>mode</code> <code>"call"</code> (または<code>"("</code>, 詳細を参照)のオブジェクトを作成またはテストする。
<code>"character"</code> 型のオブジェクトを作成またはテストする。
<span style="font-family：color：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>の算術演算子に加え、<span style="font-family: Courier New; color: #666666;"><b>R</b></span>の複素数演算をサポートする基本関数。
オブジェクトがデータ・フレームであるかどうかをチェックする関数、または可能であればそれを強制する関数。
倍精度ベクトルの作成、共有、テスト。
2つのベクトルに対して、<b>集合</b>和、交、(非対称！)差、等式、メンバシップを実行します。
環境の取得、設定、テスト、作成。
モード<code>"expression"</code>のオブジェクトを作成またはテストします。
関数<code>factor</code>は、ベクトルを因子として符号化するために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバーシップ関数と強制関数です。
<code>is.finite</code>と<code>is.infinite</code>は、<code>x</code>と同じ長さのベクトルを返します。

<code>Inf</code>と<code>-Inf</code>は正と負の無限大で、<code>NaN</code>は'Not a Number'を意味します。  (これらは、数値や複素数の実部と虚部に適用されますが、整数ベクトルの値には適用されません)。  <code>Inf</code> と <code>NaN</code> は、<span style="font-family：color：#666666;"><b>R</b></span>言語の予約語である。
引数が(プリミティブな)関数であるかどうかをチェックします。
<code>is.finite</code>と<code>is.infinite</code>は、<code>x</code>と同じ長さのベクトルを返し、どの要素が有限（無限でなく、欠落していない）か無限かを示します。

<code>Inf</code>と<code>-Inf</code>は正と負の無限大で、<code>NaN</code>は'Not a Number'を意味します。  (これらは、数値や複素数の実部と虚部に適用されますが、整数ベクトルの値には適用されません)。  <code>Inf</code> と <code>NaN</code> は、<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。
<code>"integer"</code>型のオブジェクトを作成またはテストします。
<code>is.language</code> は、もし <code>x</code> が変数 <code>名</code>、<code>コール</code>、<code>式</code> であれば、<code>TRUE</code> を返します。
両方の<span style="font-family：color：<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
DLL (共有オブジェクトとしても知られています) をロードまたはアンロードし、C 関数または Fortran サブルーチンが利用可能かどうかをテストします。
<code>"logical"</code>型のオブジェクト、および基本logical定数を作成またはテストする。
<code>matrix</code> は、与えられた値の集合から行列を作成する。

<code>as.matrix</code>は引数を行列に変えようとする。

<code>is.matrix</code> は、引数が(厳密な)行列であるかどうかをテストします。
<code>NA</code> は、欠測インジケータを含む長さ 1 の論理定数です。  <code>NA</code>は、raw以外のvectortypeに強制することができます。  <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code>という定数もあり、これらはすべて<span style="font-family：の予約語です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。

汎用関数<code>is.na</code>は、どの要素が欠けているかを示す。

ジェネリック関数<code>is.na&lt;-</code>は要素を<code>NA</code>に設定する。

汎用関数 <code>anyNA</code> は、<code>any(is.na(x))</code> を（特に原子ベクトルに対して）可能な限り高速に実装したものです。
<code>NA</code> は、欠測インジケータを含む長さ1の論理定数です。  <code>NA</code>は、rawを除く他のvectortypeに強制することができる。  <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code>という定数もあり、これらはすべて<span style="font-family：の予約語です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。

汎用関数<code>is.na</code>は、どの要素が欠けているかを示す。

ジェネリック関数<code>is.na&lt;-</code>は要素を<code>NA</code>に設定する。

汎用関数<code>anyNA</code>は、<code>any(is.na(x))</code>を（特に原子ベクトルに対して）可能な限り高速に実装しています。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
<code>NA</code> は、欠測インジケータを含む長さ1の論理定数である。  <code>NA</code>はrawを除く他のvectortypeに強制することができる。  <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code>という定数もあり、これらはすべて<span style="font-family：の予約語です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。

汎用関数<code>is.na</code>は、どの要素が欠けているかを示す。

ジェネリック関数<code>is.na&lt;-</code>は要素を<code>NA</code>に設定する。

汎用関数<code>anyNA</code>は、<code>any(is.na(x))</code>を（特に原子ベクトルに対して）可能な限り高速に実装したものである。
<code>NA</code> は、欠測インジケータを含む長さ1の論理定数です。  <code>NA</code>はrawを除く他のvectortypeに強制することができる。  <code>NA_integer_</code>, <code>NA_real_</code>, <code>NA_complex_</code>, <code>NA_character_</code>は、欠損値をサポートする他の原子ベクトル型の定数です：の予約語です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の予約語です。

汎用関数<code>is.na</code>は、どの要素が欠けているかを示す。

ジェネリック関数<code>is.na&lt;-</code>は要素を<code>NA</code>に設定する。

汎用関数<code>anyNA</code>は、<code>any(is.na(x))</code>を（特に原子ベクトルに対して）可能な限り高速に実装したものです。
関数<code>factor</code>は、ベクトルを因子として符号化するために使用されます(因子には'category'と'enumerated type'という用語も使用されます)。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
名前'（'シンボル'とも呼ばれる）は、<span style="font-family：color：もしその名前にバインドされているオブジェクトがあれば、その値ではなく）名前によって<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>オブジェクトを参照する方法です。

<code>as.name</code>と<code>as.symbol</code>は同じである。

<code>is.symbol</code>と同一の<code>is.name</code>は、引数が名前であるかどうかに応じて<code>TRUE</code>または<code>FALSE</code>を返します。
<code>is.finite</code>と<code>is.infinite</code>は、<code>x</code>と同じ長さのベクトルを返し、どの要素が有限（無限でなく、欠落していない）か無限かを示します。

<code>Inf</code>と<code>-Inf</code>は正と負の無限大で、<code>NaN</code>は'Not a Number'を意味します。  (これらは、数値や複素数の実部と虚部に適用されますが、整数ベクトルの値には適用されません)。  <code>Inf</code> と <code>NaN</code> は、<span style="font-family：color：#font-family:CourierNew,Courier;"><b>R</b></span>言語の予約語です。
<code>NULL</code>は、<span style="font-family：font-family: Courier New, Courier; color：font-family: Courier New, Courier; color: #666666;"><b>R</b></span>: 予約語です。  <code>NULL</code>は、値が未定義の式や関数からよく返されます。
<code>is.numeric</code>は、オブジェクトが数値として解釈可能であるかどうかの一般的なテストです。
パッケージ・バージョンと関連するメソッドを含む数値バージョンを表現するためのシンプルなS3クラスです。
<code>is.numeric</code>は、オブジェクトが数値として解釈可能かどうかの一般的なテストです。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時間差 "を呼び出します。
<code>"numeric"</code>型のオブジェクトを作成または強制します。<code>is.numeric</code>は、オブジェクトが数値として解釈可能であるかどうかの、より一般的なテストです。
むしろ内部使用のための関数です。  オブジェクト<code>x</code>が<span style="font-family：font-family: Courier New, Courier; color：font-family: Courier New; color: #666666;"><b>R</b></span> 内部の <code>OBJECT</code> ビットが設定されていれば<code>TRUE</code>、そうでなければ<code>FALSE</code>となります。  <code>OBJECT</code>ビットは、<code>"class"</code>属性が追加されたときにセットされ、その属性が削除されたときに削除されます。  (S4オブジェクトは常にそうあるべきです)。
<code>factor</code>関数は、ベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
<span style="font-family：を構築し、チェックする関数です：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
引数が(プリミティブ)関数かどうかをチェックします。
<code>qr</code>は行列のQR分解を行う。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> の下で実行されているかどうかをテストする。
<code>"raw"</code>型のオブジェクトを作成またはテストする。
<code>is.atomic</code>は、<code>x</code>がアトミック型(または<code>NULL</code>)であれば<code>TRUE</code>を返し、そうでなければ<code>FALSE</code>を返します。

<code>is.recursive</code> は <code>x</code> が再帰的な(リストのような)構造を持っていれば <code>TRUE</code> を返し、そうでなければ <code>FALSE</code> を返す。
<code>is.single</code> はエラーを報告する。  Rには単精度の値はありません。
名前」（「シンボル」としても知られている）は、<span style="font-family：font-family: Courier New, Courier; color：#もしその名前にバインドされているオブジェクトがあれば、その値ではありません）。

<code>as.name</code>と<code>as.symbol</code>は同じである。

<code>is.symbol</code>と同一の<code>is.name</code>は、引数が名前かどうかによって<code>TRUE</code>または<code>FALSE</code>を返す。
<code>table</code>は、因子レベルの各組み合わせにおけるカウントの分割表を構築するために、分類横断因子を使用します。
オブジェクトが（増加順に）ソートされていないかどうかを、ソートのコストをかけずにテストする。
<code>vector</code> は、与えられた長さとモードのベクトルを生成する。

<code>as.vector</code>はジェネリックで、引数を<code>mode</code>モードのvectorに強制しようとします（デフォルトは、最も便利なvectorモードに強制します）。

<code>is.vector</code>は、<code>x</code>が<em>名前</em>以外の属性を持たない指定されたモードのベクトルであれば<code>TRUE</code>を返します。  そうでなければ <code>FALSE</code> を返す。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向スタイルのプログラミングに使用できるシンプルなジェネリック関数のメカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
接続の表示面。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のためにのみ見える。
<code>text</code>と<code>condition</code>引数は、<code>browser</code>呼び出しで与えられるものと同じです。  これらは、ブラウザが入力されるとユーザによって取得され、ユーザがどのブレークポイントが有効化されたかを識別するためのメカニズムを提供します。
これらの演算子は、生のベクトル、論理ベクトル、数値のようなベクトルに作用します。
接続を作成、オープン、クローズするための関数、つまり、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のために見えるだけです。
名前空間のロードとアンロードを行う関数。
数値表現から日時を作成するための便利なラッパー。
数値表現から日時を作成するための便利なラッパー。
コネクション、すなわち圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供します。
オブジェクトがS4クラスのインスタンスであるかどうかのテスト。
接続を再配置する関数
現在、<code>isSymmetric(Z)</code>が真であるためには、<code>複素</code>行列<code>Z</code>が "エルミート "でなければならない。
現在、行列メソッドのみが実装されており、<code>isSymmetric(Z)</code>が真となるためには、<code>複素</code>行列 <code>Z</code>が "エルミート "でなければなりません。
これらの演算子は生ベクトル、論理ベクトル、数的ベクトルに作用する。
数値ベクトルに少量のノイズを加える。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付-時刻クラスのメソッドについては、ここに文書化されています。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付-時刻クラスのメソッドについては、ここに記述されています。
正規（正方）行列の条件数は、行列の<em>ノルム</em>とその逆行列（または擬似逆行列）のノルムの積であり、したがって行列のノルムの種類に依存します。

<code>kappa()</code>は, デフォルトで行列の2ノルム条件数, または<i>QR</i>分解の<i>R</i>行列の(おそらく線形適合の)推定値を計算します.  2-ノルム条件数は, 行列の最大の特異値と最小の<em>非ゼロ</em>特異値の比であることを示すことができます.

<code>rcond()</code>は、<b>r</b>eciprocal<b>cond</b>ition numberの近似値を計算します。
正則（正方）行列の条件数は、行列の<em>ノルム</em>とその逆行列（または擬似逆行列）のノルムの積であり、したがって行列のノルムの種類に依存します。

<code>kappa()</code>は, デフォルトで行列の2ノルム条件数, または<i>QR</i>分解の<i>R</i>行列の(おそらく線形適合の)推定値を計算します.  2-ノルム条件数は, 行列の最大の特異値と最小の<em>非ゼロ</em>特異値の比であることを示すことができます.

<code>rcond()</code>は<b>r</b>eciprocal<b>cond</b>ition numberの近似値を計算します。
正則（正方）行列の条件数は、行列の<em>ノルム</em>とその逆行列（または擬似逆行列）のノルムの積であり、したがって行列のノルムの種類に依存します。

<code>kappa()</code>は, デフォルトで行列の2ノルム条件数, または<i>QR</i>分解の<i>R</i>行列の(おそらく線形適合の)推定値を計算します.  2-ノルム条件数は, 行列の最大の特異値と最小の<em>非ゼロ</em>特異値の比であることが示されます.

<code>rcond()</code>は<b>r</b>eciprocal<b>cond</b>ition numberの近似値を計算します。
正則（正方）行列の条件数は、行列の<em>ノルム</em>とその逆行列（または擬似逆行列）のノルムの積であり、したがって行列のノルムの種類に依存します。

<code>kappa()</code>は, デフォルトで行列の2ノルム条件数, または<i>QR</i>分解の<i>R</i>行列の(おそらく線形適合の)推定値を計算します.  2-ノルム条件数は, 行列の最大の特異値と最小の<em>非ゼロ</em>特異値の比であることが示されます.

<code>rcond()</code>は<b>r</b>eciprocal<b>cond</b>ition numberの近似を計算します。
2つの配列 <code>X</code> と <code>Y</code> の一般化クロネッカー積を計算します。
ローカライズ情報を報告する。
<code>LAPACK</code>実装が使用されている共有オブジェクトファイルの名前を報告する。
使用中のLAPACKのバージョンを報告する。
矩形行列の特異値分解を計算する。
例えば、印刷やプロットで使用するために、オブジェクトからラベルの適切なセットを見つける。  汎用関数。
例えば印刷やプロットで使用するために、オブジェクトからラベルの適切なセットを見つける。  一般的な関数です。
<code>lapply</code> は、<code>X</code> と同じ長さのリストを返し、その要素は、<code>X</code> の対応する要素に <code>FUN</code> を適用した結果です。

<code>sapply</code>は、<code>lapply</code>の使いやすいバージョンであり、ラッパーです。デフォルトでは、ベクトル、行列、または、<code>simplify = "array"</code>の場合、適切であれば、<code>simplify2array()</code>を適用して配列を返します。<code>sapply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> は、<code>lapply(x, f)</code> と同じです。

<code>vapply</code>は<code>sapply</code>に似ているが、戻り値の型があらかじめ指定されているため、より安全に（そして時にはより速く）使うことができる。

<code>replicate</code>は、<code>sapply</code>の一般的な使用法のラッパーであり、（通常は乱数生成を伴う）式の繰り返し評価を行う。

<code>simplify2array()</code>は、<code>simplify</code>が偽でないときに<code>sapply()</code>から呼び出されるユーティリティで、<code>mapply()</code>からも同様に呼び出されます。
<span style="font-family：のデータベースを遅延ロードする内部関数です：font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトのデータベースを遅延ロードする内部関数です。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font: Courier New, Courier; "color: #666666;"><b>R</b></span> オブジェクトのデータベースを遅延ロードする内部関数です。
基本パッケージの内部オブジェクトのほとんどは、基本名前空間の特別な性質のために、ユーザが見ることができるものだけです。
ベータ関数とガンマ関数に関連する特別な数学関数。
ベータ関数およびガンマ関数に関連する特殊な数学関数。
ベクトル(リストを含む)や因数、その他の<span style="font-family：Courier New, Courier; color：メソッドが定義されている<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの長さを取得または設定します。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
ベクトル(リストを含む)や因数、その他の<span style="font-family：font-family: Courier New, Courier; color：メソッドが定義されている<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクト。
カレンダーの日付を表すクラス <code>"Date"</code>の説明。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時差 "を呼び出します。
ベクトル(リストを含む)や因数、その他の<span style="font-family：Courier New, Courier; color：メソッドが定義されている<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>オブジェクトの長さを取得または設定します。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
<code>list</code> または atomicvector (<code>is.atomic</code>) の各要素の長さを、整数または数値ベクトルとして取得。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> に組み込まれている定数。
<span style="font-family：に組み込まれている定数です：<span style="font: Courier New, Courier;"><b>R</b></span> に組み込まれている定数です。
<code>levels</code>は、変数のlevels属性へのアクセスを提供します。最初の形式は、引数のlevelsの値を返し、2番目の形式は、その属性を設定します。
<code>levels</code> は、変数の levels 属性へのアクセスを提供します。最初の形式は、引数の levels の値を返し、2 番目の形式は、属性を設定します。
<code>levels</code> は、変数の levels 属性へのアクセスを提供します。第 1 の形式は、引数の levels の値を返し、第 2 の形式は属性を設定します。
<code>levels</code> は、変数の levels 属性へのアクセスを提供します。最初の形式は、引数の levels の値を返し、2番目は属性を設定します。
ベータ関数とガンマ関数に関連する特殊な数学関数。
ベータ関数とガンマ関数に関連する特殊な数学関数。
使用中の<code>libcurl</code>のバージョンを報告する。
<code>libcurl</code> と <code>require</code> は、アドオンパッケージをロードしてアタッチする。
コンパイル済みコードの指定されたファイルがまだロードされていない場合はロードし、ロードされていない場合はアンロードします。
コンパイルされたコードの指定されたファイルがすでにロードされていない場合、それをロードするか、ロードを解除します。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> が配布されているライセンス条項。
<span style="font-family：</span>が配布されるライセンス条項です：<span style="font: Courier New; color: #666666;"><b>R</b></span>が配布されるライセンス条項。
<span style="font-family：の両方を構築し、強制し、チェックする関数です：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リストの構築とチェックを行う関数です。
これらの関数は、指定されたディレクトリのファイル名やディレクトリ名の文字ベクトルを生成します。
これらの関数は、指定されたディレクトリ内のファイル名やディレクトリ名の文字ベクトルを生成します。
変数のリストからデータフレームを作成する。
<em>named</em> <code>リスト x</code>から、すべてのリスト成分をオブジェクトとして含む<code>環境</code>を作成するか、<code>x</code>から既存の環境に "マルチアサイン "する。
関数 <code>save</code> で書き込んだデータセットを再ロードする。
名前空間をロード、アンロードする関数。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のためにのみ見える。
名前空間をロードおよびアンロードする関数。
<span style="font-family：を評価する</span style="font-family: Courier New, Courier; color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> 式を指定された環境で評価します。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスを表します。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数を関数にリンクしたりすることができます。
<code>log</code>は対数を計算し、デフォルトでは自然対数、<code>log10</code>は常用(つまり、底10)対数、<code>log2</code>は常用(つまり、底2)対数を計算します。一般的な形式<code>log(x, base)</code>は底<code>base</code>で対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>についても正確に計算します。
<code>log</code> は対数を計算し、デフォルトでは自然対数、<code>log10</code> は常用(つまり、底10)対数、<code>log2</code> は常用(つまり、底2)対数を計算します。一般的な形式 <code>log(x, base)</code> は底<code>base</code>を持つ対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>についても正確に計算します。
<code>log</code> は対数を計算し、デフォルトでは自然対数、<code>log10</code> は常用(つまり、底10)対数、<code>log2</code> は常用(つまり、底2)対数を計算します。一般的な形式 <code>log(x, base)</code> は底<code>base</code>を持つ対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>についても正確に計算します。
<code>log</code> は対数を計算し、デフォルトでは自然対数、<code>log10</code> は常用(つまり、底10)対数、<code>log2</code> は常用(つまり、底2)対数を計算します。一般的な形式 <code>log(x, base)</code> は底<code>base</code>を持つ対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>についても正確に計算します。
<code>log</code> は対数を計算し、デフォルトでは自然対数、<code>log10</code> は常用(つまり、底10)対数、<code>log2</code> は常用(つまり、底2)対数を計算します。一般的な形式 <code>log(x, base)</code> は底<code>base</code>を持つ対数を計算します。

<code>log1p(x)</code>は<i>log(1+x)</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。

<code>exp</code>は指数関数を計算する。

<code>expm1(x)</code>は<i>exp(x) - 1</i>を<i>|x| &lt;&lt; 1</i>に対しても正確に計算する。
<code>"logical"</code>型のオブジェクト、および基本logical定数を作成またはテストします。
下三角形または上三角形に <code>TRUE</code> を持つ、与えられた行列と同じ大きさの論理の行列を返します。
<code>ls</code> と <code>objects</code> は、指定された環境のオブジェクトの名前を文字列のベクトルで返します。  トップ・レベルのプロンプトで引数なしで呼び出された場合、 <code>ls</code> は、ユーザが定義したデータ・セットと関数を表示する。  <code>ls</code>は、関数内部で引数無しで呼び出された場合、その関数のローカル変数名を返します: これは、<code>browser</code>と併用すると便利です。
文字ベクトルから構文的に有効な名前を作る。
重複にシーケンス番号を付加することにより、文字ベクトルの要素を一意にします。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスです。  環境と個々のバインディングをロックしたり、変数と関数をリンクしたりすることができます。
<code>Reduce</code>は、バイナリ関数を使用して、与えられたベクトルと与えられた初期値の要素を連続的に結合します。<code>Filter</code>は、述語（論理）関数が真を与えるベクトルの要素を抽出します。  <code>Find</code>と<code>Position</code>は、それぞれそのような要素の最初か最後と、ベクトル内の位置を与えます。  <code>Map</code> は、与えられたベクトルの対応する要素に関数を適用します。  <code>Negate</code> は与えられた関数の否定を生成します。
<code>mapply</code>は、<code>sapply</code>の多変量バージョンである。<code>mapply</code>は、各...引数の最初の要素、2番目の要素、3番目の要素...に<code>FUN</code>を適用する。

<code>.mapply()</code>は、<code>mapply()</code>の素のバージョンであり、例えば他の関数で使用される。
配列形式の分割表に対して、与えられたマージンまたはマージンの集合に対する表入力の合計を計算する。
配列形式の分割表に対して、与えられたマージンまたはマージンの集合に対する表入力の合計を計算する。
<code>mat.or.vec</code>は、<code>nc</code>が1より大きい場合は、<code>nr</code> by <code>nc</code>のゼロ行列を作成し、<code>nc</code>が1に等しい場合は、長さ<code>nr</code>のゼロベクトルを作成します。
<code>match</code> は、最初の引数の(最初の)マッチの位置のベクトルを2番目の引数に返します。

<code>%in%</code>は二項演算子としてより直感的なインターフェイスで、左オペランドにマッチするかどうかを示す論理ベクトルを返します。
<code>match.arg</code>は<code>arg</code>を<code>choices</code>で指定された候補値のテーブルとマッチさせます。
<code>match.call</code>は、指定された全ての引数をフルネームで指定した呼び出しを返します。
引数として関数を取る関数の内部で呼び出された場合、他の型のオブジェクトとの望ましくないマッチングを避けながら、目的の関数オブジェクトを抽出します。
グループ・ジェネリック・メソッドは、<code>Math</code>、<code>Ops</code>、<code>Summary</code>、<code>Complex</code>の4つのあらかじめ指定された関数グループに対して定義することができます：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> にはこれらの名前のオブジェクトはありませんが、<span class="pkg">methods</span> パッケージにはあります)。

グループの個々のメンバーに対して定義されたメソッドは、グループ全体に対して定義されたメソッドよりも優先されます。
カレンダーの日付を表すクラス<code>"Date"</code>の説明。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの「時差」を呼び出します。
<code>factor</code>関数は、ベクトルを因子として符号化するのに使われます（因子には'category'と'enumerated type'という用語も使われます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>は、カレンダーの日付と時刻を表すクラスの説明です。
<code>matrix</code> は、与えられた値の集合から行列を作成します。

<code>as.matrix</code>は引数を行列に変えようとする。

<code>is.matrix</code> は、引数が（厳密な）行列であるかどうかを調べます。
入力値の(正規または<b>p</b>並列の)最大値と最小値を返します。

<code>pmax*()</code>と <code>pmin*()</code>は、1つ以上のベクトルを引数として取り、それらを共通の長さに再利用し、引数ベクトルの<em>'parallel'</em>最大値（または最小値）を与える単一のベクトルを返します。
行列の各行の最大位置を求め, ランダムに同値を解消する.
(トリミングされた)算術平均の汎用関数。
カレンダーの日付を表すクラス <code>"Date"</code> の説明。
(切り詰めた)算術平均の汎用関数
時間間隔の作成、印刷、いくつかの算術演算。  <code>print()</code>メソッドは、これらの「時差」を呼び出します。
カレンダーの日付と時刻を表すクラス<code>"POSIXlt"</code>と<code>"POSIXct"</code>の説明。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
現在の<span style="font-family：color：#666666;"><b>R</b></span>プロセス。
現在の <span style="font-family：font-family: Courier New, Courier; color：#666666;"><b>R</b></span>プロセス。
生のベクトルに対するメモリ内圧縮または展開。
生のベクトルに対するメモリ内圧縮または展開。
<code>SEXPREC</code>タイプ別にconsセルの使用状況を一覧表示。
2つのデータフレームを共通の列名や行名でマージしたり、データベースの<em>join</em>操作の他のバージョンを実行します。
2つのデータフレームを共通の列または行名でマージするか、データベースの<em>join</em>操作の他のバージョンを実行します。
2つのデータフレームを共通の列名または行名でマージするか、データベースの<em>join</em>操作の他のバージョンを実行する。
引数から診断メッセージを生成する。
オブジェクトの名前による検索(<code>get</code>)、または0個以上のオブジェクトの検索(<code>mget</code>)。
入力値の(正規または<b>p</b>並列の)最大値と最小値を返す。

<code>pmax*()</code>と<code>pmin*()</code>は、1つ以上のベクトルを引数として取り、それらを共通の長さにリサイクルし、引数ベクトルの<em>'parallel'</em>最大値（または最小値）を与える単一のベクトルを返します。
<code>missing</code>は、関数の引数として値が指定されたかどうかをテストするために使用することができます。
<span style="font-family：color：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>の算術演算子に加えて、<span style="font-family: Courier New; color: 666666;"><b>R</b></span>の複素数演算をサポートする基本関数。
mode' (一種の 'type') や <span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの'mode'(一種の'型')または'storagemode'を取得または設定する。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの'モード'(一種の'型')、または保存モードを設定します。
<span style="font-family：に組み込まれている定数：<span style="font: Courier New, Courier; "color: #666666;"><b>R</b></span> に組み込まれた定数。
<span style="font-family：に組み込まれている定数です：<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span>に組み込まれている定数です。
曜日、月、四半期、またはユリウス時間(ある起点からの日数)を抽出します。  これらは汎用的な関数です。内部の日付時刻クラスのメソッドについては、ここに文書化されています。
曜日、月、四半期、またはユリウス時間(ある起点からの日数)を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
これらの関数はオブジェクトの属性にアクセスします。以下の最初の形式はオブジェクトの属性リストを返します。
オブジェクトの名前を取得または設定する関数です。
カレンダーの日付と時刻を表すクラス<code>"POSIXlt"</code>と<code>"POSIXct"</code>の説明。
オブジェクトの名前を取得または設定する関数。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のために見えるだけです。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span> 名前空間の特別な性質によってのみ見える。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span> 名前空間の特別な性質によってのみ見える。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span> 名前空間の特別な性質によってのみ見える。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span>名前空間の特別な性質によってのみ見える。
<code>nargs</code>は、関数本体内で使用された場合、<em>空白にされた位置引数</em>も含めて、その関数に供給された引数の数を返します。
<code>nchar</code> は、引数として文字ベクトルを取り、その要素に <code>x</code> の対応する要素のサイズを含むベクトルを返します。内部的には、これはメソッドを定義できるジェネリックである（内部メソッド参照）。

<code>nzchar</code> は、文字ベクトルの要素が空でない文字列かどうかを調べる高速な方法です。
<code>nrow</code>と<code>ncol</code>は、<code>x</code>に存在する行または列の数を返します。<code>NCOL</code>と<code>NROW</code>は、<code>as.matrix()</code>または<code>cbind()</code>と互換性があり、0長のベクトルであっても、ベクトルを1列の行列として扱うのと同じことを行います。
<code>nrow</code>と<code>ncol</code>は、<code>x</code>に存在する行または列の数を返します。<code>NCOL</code>と<code>NROW</code>は、<code>as.matrix()</code>または<code>cbind()</code>と互換性があり、0長ベクトルであっても、ベクトルを1列の行列として扱うのと同じことを行います。
<code>Reduce</code>は、バイナリ関数を使用して、与えられたベクトルの要素と、おそらく与えられた初期値とを連続して結合します。<code>Filter</code>は、述語(論理)関数が真を与えるベクトルの要素を抽出します。  <code>Find</code>と<code>Position</code>は、それぞれそのような要素の最初か最後と、ベクトル内の位置を与えます。  <code>Map</code> は、与えられたベクトルの対応する要素に関数を適用します。  <code>Negate</code> は与えられた関数の否定を生成します。
環境の取得、設定、テスト、作成。
これらは<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の基本的な制御フロー構成です。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語です。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向スタイルのプログラミングに使用できるシンプルな汎用関数メカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数の最初の引数のクラスか、<code>UseMethod</code>または<code>NextMethod</code>の引数として与えられたオブジェクトのクラスに基づいて行われます。
このビルドでネイティブ言語サポート (NLS) が有効になっている場合、<span style="font-family：color：もし<span style="font-family: Courier New; color: #666666;"><b>R</b></span> (<code>bindtextdomain()</code>の例を参照)のこのビルドでネイティブ言語サポート(NLS)が有効になっていた場合、文字ベクトルの翻訳を試みるか、翻訳がどこで見つかるかを設定する。
引数が持つレベルの数を返す。
文字列を引用符なしで表示する。
LAPACK を用いて <code>x</code> の行列ノルムを計算する。  ノルムは、<code>type</code> の値によって、1 (<code>"O"</code>)ノルム、無限 (<code>"I"</code>)ノルム、Frobenius (<code>"F"</code>)ノルム、行列の最大モジュラス (<code>"M"</code>)要素、"spectral" または <code>"2"</code>ノルムのいずれかになります。
ユーザが理解しやすい形で表示し、相対パスと絶対パスを比較できるように、ファイルパスをプラットフォーム用の正規形に変換する。
<code>nrow</code>と<code>ncol</code>は、<code>x</code>に存在する行または列の数を返します。<code>NCOL</code>と<code>NROW</code>は、<code>as.matrix()</code>または<code>cbind()</code>と互換性があり、0長のベクトルであっても、ベクトルを1列の行列として扱うのと同じことを行います。
<code>nrow</code>と<code>ncol</code>は、<code>x</code>に存在する行または列の数を返します。<code>NCOL</code>と<code>NROW</code>は、<code>as.matrix()</code>または<code>cbind()</code>と互換性があり、0長ベクトルであっても、ベクトルを1列の行列として扱うのと同じことを行います。
コネクションのアスペクトを表示します。
<code>"numeric"</code>型のオブジェクトを作成または強制します。<code>is.numeric</code>は、オブジェクトが数値として解釈可能であるかどうかのより一般的なテストです。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと、関連するメソッド。
<code>"raw"</code>型のオブジェクトへの変換と操作、ビットまたは "packed "8ビットとして使用されます。
<code>"raw"</code>型のオブジェクトの変換と操作。
<code>nchar</code> は、引数として文字ベクトルを取り、その要素に <code>x</code> の対応する要素のサイズを含むベクトルを返します。内部的には、これはメソッドを定義できるジェネリックである(InternalMethodsを参照)。

<code>nzchar</code> は、文字ベクトルの要素が空でない文字列かどうかを調べる高速な方法です。
<code>ls</code> と <code>objects</code> は、指定された環境のオブジェクトの名前を文字列のベクトルで返す。  トップ・レベルのプロンプトで引数なしで呼び出された場合、 <code>ls</code> は、ユーザが定義したデータ・セットと関数を表示する。  <code>ls</code>は、関数内で引数なしで呼び出されると、その関数のローカル変数の名前を返します。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向スタイルのプログラミングに使用できるシンプルなジェネリック関数のメカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向プログラミングに使えるシンプルなジェネリック関数のメカニズムを持っています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
タイムゾーンに関する情報は、<span style="font-family：のタイムゾーンに関する情報は、<span style="font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>におけるタイムゾーンに関する情報です。  <code>Sys.timezone</code>は現在のタイムゾーン名を返します。
<code>on.exit</code>は、引数として与えられた式を、現在の関数が(自然に、あるいはエラーの結果として)終了したときに実行される必要があるものとして記録します。  これは、グラフィカル・パラメーターをリセットしたり、他のクリーンアップ・アクションを実行するのに便利です。

式が提供されない場合、つまり呼び出しが<code>on.exit()</code>の場合、現在の<code>on.exit</code>コードは削除される。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」への接続を作成、オープン、クローズする関数です。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（<code>"srcref"</code>）、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
グループ・ジェネリック・メソッドは、<code>Math</code>、<code>Ops</code>、<code>Summary</code>、<code>Complex</code>の4つのあらかじめ指定された関数のグループに対して定義することができます(ベース<span style="font-family：(これらの名前のオブジェクトは、<span style="font-family: Courier New, Courier; color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> にはこれらの名前のオブジェクトはありませんが、<span class="pkg">methods</span> パッケージにはあります)。

グループの個々のメンバーに対して定義されたメソッドは、グループ全体に対して定義されたメソッドよりも優先されます。
<code>"Date"</code>クラスの演算子。

<code>Date</code>クラスには、<code>Ops</code>メソッドと、<code>+</code>と<code>-</code>専用のメソッドがあります。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時差 "を呼び出します。
<code>factor</code>関数は、ベクトルを因子として符号化するのに使われます（因子には'category'と'enumerated type'という用語も使われます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
<code>factor</code>関数は、ベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>は、カレンダーの日付と時刻を表すクラスの説明です。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>が計算し結果を表示する方法に影響を与える、さまざまなグローバルな<em>オプションを設定</em>することができます。
<code>order</code>は、最初の引数を昇順または降順に並べ替え、さらに引数によって同順位を解消する並べ替えを返します。  <code>sort.list</code>は、1つの引数だけを使って同じことを行います。<br>データ・フレームなどをソートするためにこれらの関数を使う方法については、例を参照してください。
<code>factor</code>関数は、ベクトルを因子としてエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
配列<code>X</code>と<code>Y</code>の外積は、次元<code>c(dim(X), dim(Y))</code>の配列<code>A</code>となり、要素<code>A[c(arrayindex.x, arrayindex.y)] = FUN(X[arrayindex.x], Y[arrayindex.y], ...)</code> となります。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと、関連するメソッド。
これらの関数は、パッケージがアタッチ/デタッチされ、名前空間が（アン）ロードされる前に実行されるアクションをユーザーが設定することを可能にします。
内部ネームスペース・サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span> 名前空間の特別な性質のためにのみ表示されます。
1つ以上のパッケージへのパスを検索する。
引数から診断メッセージを生成する。
<code>"raw"</code>型のオブジェクトへの変換と操作。
<span style="font-family：courier new, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> リスト。
環境の取得、設定、テスト、作成。
環境の取得、設定、テスト、作成。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた<code>environment</code>s（S用語では'フレーム'）へのアクセスを提供します。
<code>parse()</code>は、<code>expression</code>内のパースされたが評価されていない式を返します。

<code>str2expression(s)</code>と<code>str2lang(s)</code>は<code>parse(text=s, keep.source=FALSE)</code>の特別版を返すので、文字列<code>s</code>を式や呼び出しなどに変換するものとみなすことができる。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span>名前空間の特別な性質のために見えるだけです。
文字に変換した後にベクトルを連結する。
文字に変換した後にベクトルを連結する。
パス名を展開する。例えば、先頭のチルダをユーザーのホームディレクトリ (そのプラットフォームで定義されている場合) に置き換える。
1つ以上のパッケージへのパスを検索する。
この<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> セッションで使用されている PCRE のバージョンの設定オプションを報告します。
<span style="font-family：に組み込まれている定数です：<span style="font: Courier New, Courier;"><b>R</b></span> に組み込まれている定数。
接続を作成、オープン、クローズする関数、つまり、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトのプロット用汎用関数です。

単純な散布図では、<code>plot.default</code>が使用されます。しかし、多くの<span style="font-family：color：<code>function</code>s、<code>data.frame</code>s、<code>density</code>オブジェクトなどを含む多くの<span style="font: Courier New; color: #666666;"><b>R</b></span>オブジェクト用の<code>plot</code>メソッドがあります。  これらについては、<code>methods(plot)</code>とそのドキュメントを参照してください。これらのメソッドのほとんどは、伝統的なグラフィックス（<span class="pkg">graphics</span>パッケージ）を使って実装されていますが、これは必須ではありません。

伝統的なグラフィックスで使用されるグラフィカル・パラメータ引数の詳細については、<code>par</code>を参照して下さい。
<code>pmatch<//code>は、第2引数の要素の中から第1引数の要素にマッチするものを探します。
入力値の(正規または<b>p</b>並列の)最大値と最小値を返す。

<code>pmax*()</code>と<code>pmin*()</code>は1つ以上のベクトルを引数として取り、それらを共通の長さに再利用し、引数ベクトルの<em>'parallel</em>最大値(または最小値)を与える単一のベクトルを返します。
入力値の(正規または<b>p</b>平行な)最大値と最小値を返す。

<code>pmax*()</code>と<code>pmin*()</code>は1つ以上のベクトルを引数として取り、それらを共通の長さに再利用し、引数ベクトルの<em>'parallel</em>最大値(または最小値)を与える単一のベクトルを返します。
入力値の(正規または<b>p</b>平行な)最大値と最小値を返す。

<code>pmax*()</code>と<code>pmin*()</code>は1つ以上のベクトルを引数として取り、それらを共通の長さに再利用し、引数ベクトルの<em>'parallel</em>最大値(または最小値)を与える単一のベクトルを返します。
入力値の(正規または<b>p</b>平行な)最大値と最小値を返す。

<code>pmax*()</code>と<code>pmin*()</code>は、1つ以上のベクトルを引数として取り、それらを共通の長さにリサイクルし、引数ベクトルの<em>'parallel'</em>最大値（または最小値）を与える単一のベクトルを返します。
実数または複素数の多項式の零点を求めます。
検索パスの指定された位置の環境を返す。
<code>Reduce</code>は、2進関数を使用して、与えられたベクトルと与えられた初期値の要素を連続して結合します。<code>Filter</code>は、述語(論理)関数が真を与えるベクトルの要素を抽出します。  <code>Find</code>と<code>Position</code>は、それぞれそのような要素の最初か最後と、ベクトル内の位置を与えます。  <code>Map</code> は、与えられたベクトルの対応する要素に関数を適用します。  <code>Negate</code> は与えられた関数の否定を生成する。
<code>x</code>の値の範囲をカバーする<code>n+1</code>個の等間隔の'ラウンド'値のシーケンスを計算する。
<code>x</code>の値の範囲をカバーする<code>n+1</code>個の等間隔の'round'値のシーケンスを計算する。
<code>formatC()</code>は、<code>C</code>スタイルの書式指定を使用して、数値を個別に柔軟に書式設定します。

<code>prettyNum()</code>は、<code>format.default</code>にもあるように、(おそらくフォーマットされた)数字を「きれいにする」ために使われる。

<code>.format.zeros(x)</code>は、<code>prettyNum()</code>の補助関数で、フォーマットされた数値のベクトル<code>x</code>のゼロを再フォーマットします。
<code>print</code>は引数を表示し、それを<em>不可視</em>で返します（<code>invisible(x)</code>経由）。  これは汎用関数であり、新しい<code>クラス</code>のために新しい表示メソッドを簡単に追加することができます。
オブジェクトのクラスを変更して、'そのまま'扱うことを示す。
関数<code>by</code>は、データ・フレームに適用される<code>tapply</code>のオブジェクト指向ラッパーです。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
データ・フレームの印刷
カレンダーの日付を表すクラス<code>"Date"</code>の説明。
<code>print.default</code>は、引数を印刷する汎用<code>print</code>関数の<em>default</em>メソッドです。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの「時間差」を呼び出します。
<code>print</code>は引数を表示し、それを<em>不可視</em>で返します（<code>invisible(x)</code>経由）。  これは、新しい<code>クラス</code>のために新しい印刷メソッドを簡単に追加できることを意味する汎用関数です。
この関数は、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> セッションに現在ロードされている DLL (<code>dyn.load</code> を参照) を取得します。
この関数は、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> セッションに現在ロードされている DLL (<code>dyn.load</code> を参照) です。
この関数を使用すると、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、および将来的なセキュリティーを強化するために、Rに登録されているDLL内のルーチンのセットを照会することができます。この関数は、<code>.C</code>、<code>.Call</code>、<code>.Fortran</code>、および<code>.External</code>という異なるインターフェイスについて、DLLに登録されている各ルーチンの説明を提供します。
数値(double,integer,logical)または複素行列の固有値と固有ベクトルを計算する。
<code>print</code>は引数を表示し、<em>不可視</em>で返します（<code>invisible(x)</code>経由）。  これは、新しい<code>クラス</code>のために新しい印刷メソッドを簡単に追加することができる汎用関数です。
<code>print<//code>は引数を表示し、それを<em>不可視</em>で返します(<code>invisible(x)</code>経由)。  これは汎用的な関数で、新しい <code>class</code> のために新しい表示メソッドを簡単に追加することができます。
整数を16進数形式に変換または表示し、最大値を表示するのに必要な桁数で、 必要に応じて先頭のゼロを使用します。
<code>library</code> と <code>require</code> は、アドオン・パッケージをロードし、アタッチする。
<code>print</code>は引数を表示し、<em>不可視</em>で返します（<code>invisible(x)</code>経由）。  これは汎用的な関数で、新しい<code>class</code>のために新しい印刷メソッドを簡単に追加することができます。
この関数を使用すると、動的検索、ネイティブ・ルーチンを呼び出す際のエラー処理、将来的なセキュリティーを強化するために、Rに登録されているDLL内のルーチンのセットを照会することができます。
文字列を引用符なしで表示します。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルなS3クラスと関連するメソッド。
必要に応じて先頭のゼロを使用し、最大値を表示するために必要な桁数で、8進数形式の整数を変換または表示します。
<code>library</code>と<code>require</code>は、アドオン・パッケージをロードし、アタッチします。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>というカレンダーの日付と時刻を表すクラスの説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
<code>proc.time</code>は、現在実行中の<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> プロセスがすでに費やした時間です。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
ベクトル内の等しい値のランの長さと値を計算する。
<code>print</code>は引数を表示し、それを<em>不可視</em>で返します（<code>invisible(x)</code>経由）。  これは、新しい<code>クラス</code>のために新しい印刷メソッドを簡単に追加できることを意味する汎用関数です。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、すなわちソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常は対話型の<span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果のデータは、印刷やソース・レベルのデバッグに使用され、通常は対話型の<span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
<code>table</code>は、因子レベルの各組み合わせにおけるカウントの分割表を構築するために、分類横断因子を使用します。
<code>warnings</code>とその<code>print</code>メソッドは、変数<code>last.warning</code>を見やすい形で表示します。
<code>summary</code>は、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第1引数の<code>class</code>に依存する特定の<code>メソッド</code>を呼び出します。
<code>print</code>は、引数を表示し、それを<em>不可視</em>で返します（<code>invisible(x)</code>を介して）。  これは、新しい<code>クラス</code>のために新しい印刷メソッドを簡単に追加できることを意味します。
<code>warnings</code> とその <code>print</code> メソッドは、変数 <code>last.warning</code> を見やすい形で表示します。
Sとの互換性のために提供された、行列を表示するための以前のメソッド。
<code>proc.time</code>は、現在実行中の<span style="font-family：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> プロセスがすでに費やした時間です。
<code>prod</code> は引数に含まれる全ての値の積を返します。
<code>margins</code>、すなわち<code>x</code>のエントリを適切なマージン和で割ったものを条件付き比率として返す。
<code>margins</code>、すなわち<code>x</code>のエントリを適切なマージン合計で割ったものを条件付きプロポーションとして返す。
オブジェクトの dimnames を取得または設定します。
ベータ関数とガンマ関数に関連する特別な数学関数。
テキスト行をコネクションにプッシュバックする関数と、現在プッシュバックされている行数を照会する関数。
テキスト行をコネクションにプッシュバックする関数と、現在何行プッシュバックされているかを問い合わせる関数。
関数 <code>quit</code> またはそのエイリアス <code>q</code> は、現在の<span style="font-family：font-family: Courier New, Courier; color：font: Courier New; color: #666666;"><b>R</b></span> セッションを終了する。
<code>qr</code> は行列のQR分解を計算する。
<code>qr</code>は行列のQR分解を行います。
<code>qr</code>は行列のQR分解を行う。
<code>qr</code> は行列の QR 分解を行います．
オブジェクトが構成された元の行列、または分解の成分を返します。
<code>qr</code> は行列の QR 分解を行います。
<code>qr</code> は行列の QR 分解を行います。
オブジェクトが構成された元の行列、または分解の成分を返します。
<code>qr</code> は行列の QR 分解を行います。
<code>qr</code> は行列の QR 分解を行います。
オブジェクトが構成された元の行列、または分解の成分を返します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは一般的な関数です。内部の日付-時刻クラスのメソッドについては、ここに記述されています。
関数 <code>quit</code> またはそのエイリアス <code>q</code> は、現在の<span style="font-family：color：font: Courier New; color: #666666;"><b>R</b></span> セッションを終了します。
<code>substitute</code>は、(未評価の)式<code>expr</code>のパースツリーを返します。

<code>quote</code>は単に引数を返します。引数は評価されず、どのようなR式でもかまいません。

<code>enquote</code>はシンプルな1行ユーティリティで、<code>Foo(...)</code>という形式の呼び出しを<code>quote(Foo(...))</code>という呼び出しに変換します。  これは通常、<code>call</code>を早期評価から保護するために使用されます。
パッケージ・バージョンを含む数値バージョンを表すシンプルな S3 クラスと、関連するメソッド。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> ホームディレクトリ、または<span style="font-family：color：または、<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span> インストールのコンポーネントのフルパス。
<code>R.Version()</code>は、<span style="font-family：color：<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span> が動作しているバージョンの詳細情報を提供します。

<code>R.version</code>は、この情報を保持する変数（<code>list</code>）です（<code>version</code>は、S互換のためのコピーです）。
<code>R.Version()</code>は、<span style="font-family：のバージョンに関する詳細情報を提供します：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> が実行されているバージョンの詳細情報を提供します。

<code>R.version</code>は、この情報を保持する変数（<code>list</code>）です（<code>version</code>は、S互換のためのコピーです）。
<code>R.Version()</code>は、<span style="font-family：のバージョンに関する詳細情報を提供します：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> が実行されているバージョンの詳細情報を提供します。

<code>R.version</code>はこの情報を保持する変数（<code>list</code>）である（そして<code>version</code>はSとの互換性のためのコピーである）。
<code>range</code> は、与えられた全ての引数の最小値と最大値を含むベクトルを返します。
<code>range</code> は、与えられた全ての引数の最小値と最大値を含むベクトルを返します。
sample_ranks関数は、ベクトル内の値の標本順位を返します。  同値(等しい値)や欠損値はいくつかの方法で扱うことができます。
<code>rapply</code>は<code>lapply</code>の再帰バージョンで、<em>どのように</em>結果を構造化するか(<code>how = "."</code>)に柔軟性があります。
<code>"raw"</code>型のオブジェクトを作成またはテストする。
入出力 raw 接続。
入出力 raw 接続。
<code>"raw"</code>型のオブジェクトへの変換と操作。
<code>"raw"</code>型のオブジェクトへの変換と操作。
<code>"raw"</code>型のオブジェクトへの変換と操作。
ベクトル、行列、データフレームの一連の引数をとり、それぞれ<em>c</em>列、<em>r</em>行で結合する。  これらは、他の<span style="font-family：color：#666666;"><b>R</b></span>クラス用のメソッドを持つ汎用関数です。
vector, matrix, data-frame の引数をとり、それぞれ <em>c</em>olumns, <em>r</em>ows で結合します。  これらは、他の<span style="font-family：color：#666666;"><b>R</b></span>クラス用のメソッドを持つ汎用関数です。
正則(正方)行列の条件数は行列の<em>ノルム</em>とその逆行列(または擬似逆行列)のノルムの積であり, 従って行列のノルムの種類に依存する.

<code>kappa()</code>は, デフォルトで行列の2ノルム条件数, または<i>QR</i>分解の<i>R</i>行列の(おそらく線形適合の)推定値を計算します.  2-ノルム条件数は, 行列の最大の特異値と最小の<em>非ゼロ</em>特異値の比であることを示すことができます.

<code>rcond()</code>は<b>r</b>eciprocal<b>cond</b>ition numberの近似値を計算します。
<span style="font-family：color：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>^</code>の算術演算子に加えて、<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>の複素数演算をサポートする基本関数。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトを Debian Control Fileformat のファイルから読み書きします。
接続や未加工ベクトルからバイナリデータを読み書き。
接続上でヌル終端であることを仮定せずに、文字列を接続に転送したり、 接続から文字列を転送したりします。
<code>readline</code>はターミナルから行を読み込む(対話的に使用する場合)。
接続からテキスト行の一部または全部を読み込む。
単一の<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトをファイルに書き込んだり、それを復元する関数。
<span class="file">.Renviron</span>」または「<span class="file">Renviron.site</span>」のようなファイルを、スタートアップのヘルプに記載されているフォーマットで読み込み、そのファイルで定義されている環境変数を設定します。
<code>Recall</code>は、呼び出される関数名のプレースホルダーとして使用されます。  これによって、名前を変更しても動作する再帰関数を定義することができる。
<code>Reduce</code>は、与えられたベクトルと与えられた初期値の要素を連続的に結合するバイナリ関数を使用します。<code>Filter</code>は、述語（論理）関数が真を与えるベクトルの要素を抽出します。  <code>Find</code>と<code>Position</code>は、それぞれそのような要素の最初か最後と、ベクトル内の位置を与えます。  <code>Map</code> は、与えられたベクトルの対応する要素に関数を適用します。  <code>Negate</code> は与えられた関数の否定を生成します。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> 関数を登録し、オブジェクトのガベージコレクション時や、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier;"><b>R</b></span> セッションの終了時に呼び出されます。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>とのマッチを検索します。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全マッチの置換を行う。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内で引数<code>pattern</code>にマッチするものを検索します。

<code>sub</code>と<code>gsub</code>はそれぞれ最初のマッチと全マッチの置換を行う。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">ベース</span>名前空間の特別な性質のために見えるだけです。
内部名前空間サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span> 名前空間の特別な性質によってのみ見ることができます。
<code>regexpr</code>、<code>gregexpr</code>、<code>regexec</code> または <code>gregexec</code> によって得られたマッチデータから、マッチした部分文字列を抽出または置換する。
<code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code> または <code>gregexec</code> によって得られたマッチデータから、マッチした部分文字列を抽出または置換する。
<code>remove</code> と <code>rm</code> は、オブジェクトを削除するために使われる。  これらは、文字列として、あるいは文字ベクトル <code>list</code> で、あるいはその両方を組み合わせて指定することができます。  こうして指定されたオブジェクトはすべて削除される。

<code>envir</code>がNULLの場合、現在アクティブな環境が最初に検索される。

<code>inherits</code> が <code>TRUE</code> の場合、与えられた名前の変数が見つかるまで、与えられたディレクトリの親が検索される。  見つからない変数には警告が表示される。
<code>addTaskCallback</code> は、トップレベルタスクが完了するたびに呼び出されるR関数を登録する。

<code>removeTaskCallback</code>は、<code>addTaskCallback</code>によって登録された関数の登録を解除します。

これらは、タスク完了アクションを管理するための内部/ネイティブメカニズムへの低レベルアクセスを提供します：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> 言語レベルで <span style="font-family：</b></span>を管理するための言語レベル<span style="font: Courier New, Courier; color：#各タスクの完了時に呼び出される<span style="font: Courier New;"><b>R</b></span> 関数を管理します。
<code>rep</code>は<code>x</code>の値を複製します。  これは一般的な関数であり、(内部的な)デフォルトの方法はここに記述されている。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらはジェネリックなので、メソッドを定義することができます（内部メソッド参照）。
<code>rep</code>は<code>x</code>の値を複製します。  これはジェネリック関数であり、(内部的な)デフォルトメソッドはここに記述されている。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらはジェネリックなので、メソッドを定義することができます（内部メソッド参照）。
<code>rep</code>は<code>x</code>の値を複製します。  これはジェネリック関数であり、(内部的な)デフォルトメソッドはここに記述されている。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらは一般的なものであり、メソッドを定義することができます（InternalMethodsを参照）。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時間差 "を呼び出す。
<code>rep</code>は<code>x</code>の値を複製します。  これはgenericfunctionであり、(内部的な)デフォルトのメソッドはここに記述されている。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらは一般的なものであり、メソッドを定義することができます（内部メソッド参照）。
<code>rep</code>は<code>x</code>の値を複製します。  これはジェネリック関数であり、(内部的な)デフォルトメソッドはここに記述されている。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらはジェネリックなので、メソッドを定義することができます(InternalMethodsを参照)。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連するメソッド。
<code>rep</code>は<code>x</code>の値を複製します。  これはgenericfunctionで、(内部的な)デフォルトメソッドはここに記述されています。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらはジェネリックなので、メソッドを定義することができます（内部メソッド参照）。
<code>rep</code>は<code>x</code>の値を複製します。  これはジェネリック関数であり、(内部的な)デフォルトメソッドはここに記述されている。

<code>rep.int</code>と<code>rep_len</code>は、2つのよくあるケースをより高速に簡略化したものである。  内部的には、これらはジェネリックなので、メソッドを定義することができる（InternalMethodsを参照）。
これらは<span style="font-family：これらは<span style="font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語の基本的な制御フロー構成です。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語です。
<code>replace</code>は、<code>list</code>で与えられたインデックスを持つ<code>x</code>の値を<code>values</code>で与えられた値に置き換える。
<code>lapply</code> は <code>X</code> と同じ長さのリストを返し、その要素は <code>X</code> の対応する要素に <code>FUN</code> を適用した結果である。

<code>sapply</code>は、<code>lapply</code>の使いやすいバージョンであり、ラッパーです。デフォルトでは、ベクトル、行列、または、<code>simplify = "array"</code>の場合、適切であれば、<code>simplify2array()</code>を適用して配列を返します。<code>sapply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> は、<code>lapply(x, f)</code> と同じです。

<code>vapply</code>は<code>sapply</code>に似ているが、戻り値の型があらかじめ指定されているため、より安全に（そして時にはより速く）使うことができる。

<code>replicate</code>は、<code>sapply</code>の一般的な使用法のラッパーであり、（通常は乱数生成を伴う）式の繰り返し評価を行う。

<code>simplify2array()</code>は、<code>simplify</code>がfalseでないときに<code>sapply()</code>から呼び出されるユーティリティで、<code>mapply()</code>からも同様に呼び出される。
<code>library</code>と<code>require</code>は、アドオン・パッケージをロードしたりアタッチしたりします。
名前空間のロードとアンロードを行う関数。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
この関数は、内部コードがオブジェクトをコピーするたびにメッセージが出力されるようにオブジェクトをマークします。  Rのメモリ使用量を予測しにくくする主な原因となっています。
これらの関数は、<span style="font-family：color：#666666;"><b>R</b></span>言語における新しい関数を定義するための基本的なメカニズムを提供します。
<code>trace</code>を呼び出すと、任意の関数の選ばれた場所にデバッグコード（例えば、<code>browser</code>や<code>recover</code>への呼び出し）を挿入することができます。  <code>untrace</code>の呼び出しは、トレースをキャンセルします。指定されたメソッドは、汎用関数へのすべての呼び出しをトレースすることなく、同じ方法でトレースすることができます。  トレースコード（<code>tracer</code>）は、任意の<span style="font-family：color：<b>R</b></span> 式です。  <code>tracingState</code>を呼び出すことで、一時的にグローバルにトレースのオン/オフを切り替えることができます。
<code>rev</code>は、引数の逆バージョンを提供します。  これは、ベクトル用のデフォルトメソッドと<code>dendrogram</code>用のメソッドを持つgenericfunctionです。

降順にソートされたベクトルを得るためには、これはもはや必要ない（効率的でもない）ことに注意。
<code>rev</code>は引数の逆バージョンを提供します。  これは、ベクトル用のデフォルトメソッドと<code>dendrogram</code>s用のメソッドを持つgenericfunctionです。

降順にソートされたベクトルを得るためには、これはもはや必要ない（効率的でもない）ことに注意。
ベクトル内の等しい値の列の長さと値を計算します。
<code>remove</code>と<code>rm</code>は、オブジェクトを削除するために使用できる。  これらは文字列として、あるいは文字ベクトル <code>list</code> として、あるいはその両方を組み合わせて指定することができる。  こうして指定されたオブジェクトはすべて削除される。

<code>envir</code>がNULLの場合、現在アクティブな環境が最初に検索される。

<code>inherits</code> が <code>TRUE</code> の場合、与えられた名前の変数が見つかるまで、与えられたディレクトリの親が検索される。  見つからない各変数に対して警告が表示される。
<code>.Random.seed<//code>は整数ベクトルで、乱数生成器(RNG)の<b>状態を<span style="font-family：color：#666666;"><b>R</b></span>における乱数生成の<b>状態</b>を指定します。  これは保存と復元が可能ですが、ユーザーによって変更されるべきではありません。

<code>RNGkind</code>は、使用中のRNGの種類を問い合わせたり設定したりするための、よりフレンドリーなインターフェースです。

<code>RNGversion</code>は、以前の<span style="font-family：color：#666666;"><b>R</b></span>バージョンに設定することができます (再現性のため)。

<code>set.seed</code>は、seedを指定するための推奨される方法です。
<code>.Random.seed</code>は整数ベクトルで、乱数生成のための乱数生成器(RNG)の<b>状態</b>を<span style="font-family：color：#666666;"><b>R</b></span>における乱数生成の<b>状態</b>を指定します。  これは保存と復元が可能ですが、ユーザーによって変更されるべきではありません。

<code>RNGkind</code>は、使用中のRNGの種類を問い合わせたり設定したりするための、よりフレンドリーなインターフェースです。

<code>RNGversion</code>は、以前の<span style="font-family：color：#666666;"><b>R</b></span>バージョンに設定することができます (再現性のため)。

<code>set.seed</code>は、seedを指定するための推奨される方法である。
<code>ceiling</code> は単一の数値引数 <code>x</code> を取り、 <code>x</code> の対応する要素より小さくない最小の整数を含む数値ベクトルを返します。

<code>floor</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より大きくない最大の整数を含む数値ベクトルを返します。

<code>trunc</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の値を <code>0</code> に向かって切り捨てた整数を含む数値ベクトルを返す。

<code>round</code> は、第一引数の値を指定された小数点以下の桁数(デフォルトは0)に丸めます。  5を四捨五入する場合の "round to even "については'詳細'を参照。

<code>signif</code> は、第一引数の値を指定された有効桁数に丸めます。   したがって、<code>numeric</code> <code>x</code> の場合、<code>signif(x, dig)</code> は <code>round(x, dig - ceiling(log10(abs(x))))</code> と同じになります。
日付-時刻オブジェクトを丸めたり切り詰めたりする。
日時オブジェクトを丸めたり切り捨てたりする。
amatrixのようなオブジェクトの行番号を示す整数の行列、または行ラベルを示す係数を返す。
すべてのデータフレームは行名と、重複や欠損のない行数を表す長さの文字ベクトルを持つ。

ここでは<code>data.frame</code>メソッドについて説明する。

<code>`.rowNamesDF&lt;-`</code>は、データフレームの行名を設定する(ジェネリックでない置換)関数で、<code>make.names</code>という追加引数を持ちます。既存のパッケージのレガシーコードを壊すことなく、<code>row.names&lt;-</code>ジェネリックを簡単に変更することができないため、この関数は回避策としてのみ存在します。
全てのデータフレームは行名を持ち、重複や欠損のない行数を長さとする文字ベクトルです。

ここでは<code>data.frame</code>メソッドについて説明する。

<code>`.rowNamesDF&lt;-`</code>は、データフレームの行名を設定する(ジェネリックでない置換)関数で、<code>make.names</code>という追加引数を持ちます。既存のパッケージのレガシーコードを壊すことなく、<code>row.names&lt;-</code>ジェネリックを簡単に変更することができないため、この関数は回避策としてのみ存在します。
全てのデータフレームは行名を持ち、重複や欠損のない行数を長さとする文字ベクトルです。

ここでは<code>data.frame</code>メソッドについて説明する。

<code>`.rowNamesDF&lt;-`</code>は、データフレームの行名を設定する(ジェネリックでない置換)関数で、<code>make.names</code>という追加引数を持ちます。既存のパッケージのレガシーコードを壊すことなく、<code>row.names&lt;-</code>ジェネリックを簡単に変更することができないため、この関数は回避策としてのみ存在します。
全てのデータフレームは行名を持ち、重複や欠損のない行数を長さとする文字ベクトルです。

ここでは<code>data.frame</code>メソッドについて説明する。

<code>`.rowNamesDF&lt;-`</code>は、データフレームの行名を設定する(ジェネリックでない置換)関数で、<code>make.names</code>という追加引数を持ちます。既存のパッケージのレガシーコードを壊すことなく、<code>row.names&lt;-</code>ジェネリックを簡単に変更することができないため、この関数は回避策としてのみ存在します。
全てのデータフレームは行名を持ち、重複や欠損のない行数を長さとする文字ベクトルです。

ここでは<code>data.frame</code>メソッドについて説明する。

<code>`.rowNamesDF&lt;-`</code>は、データフレームの行名を設定する(ジェネリックでない置換)関数で、<code>make.names</code>という追加引数を持ちます。
全てのデータフレームは行名を持ち、重複や欠損のない行数を長さとする文字ベクトルです。

ここでは<code>data.frame</code>メソッドについて説明する。

<code>`.rowNamesDF&lt;-`</code>は、データフレームの行名を設定する(ジェネリックでない置換)関数で、<code>make.names</code>という追加引数を持ちます。既存のパッケージのレガシーコードを壊すことなく、<code>row.names&lt;-`</code>ジェネリックを簡単に変更できないため、この関数は回避策としてのみ存在します。
数値配列(またはデータフレーム)の行と列の合計と平均を作成します。
行列のようなオブジェクトの行名や列名の取得や設定。
行列のようなオブジェクトの行名や列名の取得や設定
グループ化変数の各レベルで、数値行列のようなオブジェクトの行全体の列和を計算する。  <code>rowsum</code> は汎用的で、データフレーム用のメソッドと、ベクトルや行列用のデフォルトメソッドがあります。
グループ化変数の各レベルで、数値行列のようなオブジェクトの行全体の列和を計算します。  <code>rowsum</code>は汎用的で、データフレーム用のメソッドとベクトルや行列用のデフォルトメソッドがあります。
グループ化変数の各レベルで、数値行列のようなオブジェクトの行全体の列和を計算します。  <code>rowsum</code>は汎用的で、データフレーム用のメソッドとベクトルや行列用のデフォルトメソッドがあります。
数値配列(またはデータフレーム)の行と列の合計と平均を書きます。
<code>sample</code>は、<code>x</code>の要素から指定されたサイズのサンプルを、置換ありまたは置換なしで取ります。
<code>sample</code>は、<code>x</code>の要素から指定されたサイズのサンプルを、置換ありまたは置換なしで取ります。
<code>lapply</code> は、<code>X</code> の対応する要素に <code>FUN</code> を適用した結果の、<code>X</code> と同じ長さのリストを返す。

<code>sapply</code>は、<code>lapply</code>の使いやすいバージョンであり、ラッパーです。デフォルトでは、ベクトル、行列、または、<code>simplify = "array"</code>の場合、適切であれば、<code>simplify2array()</code>を適用して配列を返します。<code>sapply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> は、<code>lapply(x, f)</code> と同じです。

<code>vapply</code>は<code>sapply</code>に似ているが、戻り値の型があらかじめ指定されているため、より安全に（そして時にはより速く）使うことができる。

<code>replicate</code>は、<code>sapply</code>の一般的な使用法のラッパーであり、（通常は乱数生成を伴う）式の繰り返し評価を行う。

<code>simplify2array()</code>は、<code>simplify</code>が偽でないときに<code>sapply()</code>から呼ばれるユーティリティで、<code>mapply()</code>からも同様に呼ばれます。
<code>save</code>は<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの外部表現を指定されたファイルに書き込みます。  オブジェクトは、<code>load</code>または<code>attach</code>（場合によっては<code>data</code>）という関数を使うことで、後日ファイルから読み出すことができます。

<code>save.image()</code>は「現在のワークスペースを保存する」、つまり<code>save(list = ls(all.names = TRUE), file = ".RData", envir = .GlobalEnv)</code>のショートカットに過ぎない。
<code>save</code>は<span style="font-family：color：<b>R</b></span> オブジェクトの外部表現を指定されたファイルに書き込みます。  オブジェクトは、<code>load</code>または<code>attach</code>（場合によっては<code>data</code>）という関数を使うことで、後でファイルから読み出すことができます。

<code>save.image()</code>は「現在のワークスペースを保存する」、つまり<code>save(list = ls(all.names = TRUE), file = ".RData", envir = .GlobalEnv)</code>のショートカットに過ぎません。これは<code>q("yes")</code>で起こることでもあります。
単一の<span style="font-family：クーリエ・ニュー、クーリエ; color：<b>R</b></span> オブジェクトをファイルに書き込んだり、それをリストアする関数。
<code>scale</code> はジェネリック関数で、そのデフォルトメソッドは数値行列の列のセンタリングとスケーリングを行います。
<code>scale</code>は、数値行列の列のセンタリングとスケーリングを行う汎用関数です。
コンソールやファイルからデータをベクトルやリストに読み込む。
<code>attach</code>された<em>パッケージ</em>(<code>library</code>を参照)のリストを与え、<span style="font-family：courier new, Courier; color：</span>オブジェクト、通常は<code>data.frames</code>です。
<code>attach</code>された<em>パッケージ</em>(<code>library</code>を参照)のリストを与え、<span style="font-family：courier new, Courier; color：</span>オブジェクト、通常は<code>data.frames</code>です。
接続を再配置する関数。
接続を再配置する関数。
規則的なシーケンスを生成する。  <code>seq</code>はデフォルトのメソッドを持つ標準的なジェネリックです。  <code>seq.int<//code>はプリミティブで、より高速ですが、いくつかの制限があります。  <code>seq_along</code>と<code>seq_len</code>は、2つの一般的なケースに対して非常に高速なプリミティブです。
正規シーケンスを生成する。  <code>seq</code>はデフォルトメソッドを持つ標準的なジェネリックです。  <code>seq.int<//code>はより高速なプリミティブですが、いくつかの制限があります。  <code>seq_along</code>と<code>seq_len</code>は、2つの一般的なケースに対して非常に高速なプリミティブです。
正規シーケンスを生成する。  <code>seq</code>はデフォルトメソッドを持つ標準的なジェネリックです。  <code>seq.int<//code>はより高速なプリミティブですが、いくつかの制限があります。  <code>seq_along</code>と<code>seq_len</code>は、2つの一般的なケースに対して非常に高速なプリミティブです。
カレンダーの日付を表すクラス<code>"Date"</code>のオブジェクトに対する<code>seq</code>のメソッド。
規則的なシーケンスを生成します。  <code>seq</code>は、デフォルトのメソッドを持つ標準的なジェネリックです。  <code>seq.int</code>はプリミティブで、より高速ですが、いくつかの制限があります。  <code>seq_along</code>と<code>seq_len</code>は、2つの一般的なケースに対して非常に高速なプリミティブです。
正規シーケンスを生成する。  <code>seq</code>はデフォルトメソッドを持つ標準的なジェネリックです。  <code>seq.int<//code>はより高速なプリミティブですが、いくつかの制限があります。  <code>seq_along</code>と<code>seq_len</code>は、2つの一般的なケースに対して非常に高速なプリミティブです。
<code>seq</code>のメソッドは日付時刻クラス用です。
デフォルトの<code>sequence</code>メソッドは、並列（およびリサイクル）ベクトル<code>from</code>,<code>by</code>,<code>nvec</code>内の要素<code>i</code>に対してシーケンス<code>seq(from[i], by = by[i], length.out = nvec[i])</code>を生成します。そして、それらのシーケンスを連結した結果を返します。
<code>sequence</code>のデフォルトメソッドは、並列（およびリサイクル）ベクトル<code>from</code>,<code>by</code>,<code>nvec</code>内の要素<code>i</code>に対してシーケンス<code>seq(from[i], by = by[i], length.out = nvec[i])</code>を生成します。そして、これらのシーケンスを連結した結果を返します。
コネクションにシリアライズするためのシンプルな低レベル・インタフェース。
コネクションを作成、オープン、クローズする関数、つまり、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
<code>.Random.seed</code>は整数ベクトルで、<span style="font-family：color：#666666;"><b>R</b></span>における乱数生成の<b>状態</b>を指定します。  これは保存と復元が可能ですが、ユーザーによって変更されるべきではありません。

<code>RNGkind</code>は、使用中のRNGの種類を問い合わせたり設定したりするための、よりフレンドリーなインターフェースです。

<code>RNGversion</code>は、以前の<span style="font-family：color：#666666;"><b>R</b></span>バージョンに設定することができます (再現性のため)。

<code>set.seed</code>はシードを指定するための推奨される方法です。
2つのベクトルに対して <b>set</b> の和、交、(非対称！)差、等式、メンバシップを行います。
2つのベクトルに対して、<b>set</b> union, intersection, (asymmetric!) difference, equality, membership を実行します。
これらの関数を使用すると、パッケージのアタッチ/デタッチやネームスペースの（アン）ロードの前に実行するアクションを設定できます。
内部ネームスペース・サポート関数。  直接呼び出されることは意図されておらず、<span class="pkg">base</span> 名前空間の特別な性質のためにのみ表示されます。
トップレベルの計算や現在のセッションの CPU や経過時間の制限を設定する関数。
トップレベルの計算または現在のセッションの CPU および/または経過時間の制限を設定する関数。
<code>getwd</code> は、<span style="font-family：font-family: Courier New, Courier; color：<code>setwd(dir)</code> は、作業ディレクトリを <code>dir</code> に設定するために使われる。
接続の表示
オペレーティングシステムのシェルに渡す文字列を引用する。
<code>sign</code> は、<code>x</code> の対応する要素の符号を持つベクトルを返す (実数の符号は、それぞれ正、0、負の場合、1、0、<i>-1</i>となる)。

<code>sign</code>は複素数ベクトルでは動作しないことに注意。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供する。
<code>ceiling</code> は、単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より小さくない最小の整数を含む数値ベクトルを返します。

<code>floor</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より大きくない最大の整数を含む数値ベクトルを返します。

<code>trunc</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の値を <code>0</code> に向かって切り捨てた整数を含む数値ベクトルを返す。

<code>round</code> は、第一引数の値を指定された小数点以下の桁数(デフォルトは0)に丸めます。  5を四捨五入する場合の "round to even "については'詳細'を参照。

<code>signif</code> は、第一引数の値を指定された有効桁数に丸めます。   したがって、<code>numeric</code> <code>x</code> の場合、<code>signif(x, dig)</code> は <code>round(x, dig - ceiling(log10(abs(x))))</code> と同じになります。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するためのメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を扱うための機構を提供する。
<code>lapply</code> は、<code>X</code> の対応する要素に <code>FUN</code> を適用した結果の、<code>X</code> と同じ長さのリストを返す。

<code>sapply</code>は、<code>lapply</code>の使いやすいバージョンであり、ラッパーです。デフォルトでは、ベクトル、行列、または、<code>simplify = "array"</code>の場合、適切であれば、<code>simplify2array()</code>を適用して配列を返します。<code>sapply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> は、<code>lapply(x, f)</code> と同じです。

<code>vapply</code>は<code>sapply</code>に似ているが、戻り値の型があらかじめ指定されているため、より安全に（そして時にはより速く）使うことができる。

<code>replicate</code>は、<code>sapply</code>の一般的な使用法のラッパーであり、（通常は乱数生成を伴う）式の繰り返し評価を行う。

<code>simplify2array()</code>は<code>simplify</code>が偽でない時に<code>sapply()</code>から呼ばれるユーティリティで、同様に<code>mapply()</code>からも呼ばれます。
これらの関数は明らかな三角関数を与えます。  これらはそれぞれ、余弦、正弦、接線、円弧余弦、円弧正弦、円弧接線、および2引数の円弧接線を計算します。

<code>cospi(x)</code>, <code>sinpi(x)</code>, <code>tanpi(x)</code>, compute<code>cos(pi*x)</code>, <code>sin(pi*x)</code>, <code>tan(pi*x)</code>.
倍精度ベクトルの作成、強制、テスト。
これらの関数は、明らかな双曲線関数を与える。  これらはそれぞれ、双曲線の余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接(または'<em>面積余弦</em>'など)を計算します。
<code>sink</code>は<span style="font-family：courier new, Courier; color：font="font: Courier New, Courier; color: #666666;"><b>R</b></span> の出力を接続に流用します (そして、そのような流用を止めます)。

<code>sink.number()</code>は、いくつの転用が使用されているかを報告する。

<code>sink.number(type = "message")</code> は、現在エラーメッセージに使用されているコネクションの番号を報告します。
<code>sink</code>は<span style="font-family：Courier New, Courier; color：font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 出力をコネクションに迂回させます(そしてそのような迂回を止めます)。

<code>sink.number()</code>は、いくつの転用が使用されているかを報告する。

<code>sink.number(type="message")</code>は、エラーメッセージに現在使用されているコネクションの番号を報告する。
これらの関数は明らかな三角関数を与えます。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、2引数のアーク・タンジェントを計算します。

<code>cospi(x)</code>, <code>sinpi(x)</code>, <code>tanpi(x)</code> は、<code>cos(pi*x)</code>, <code>sin(pi*x)</code>, <code>tan(pi*x)</code> を計算します。
与えられた配列中のスライス数を示す整数行列を返します。
圧縮ファイル、URL、パイプなど、「一般化されたファイル」を作成、オープン、クローズする関数。
圧縮ファイル、URL、パイプなどの "一般化されたファイル "接続を作成、オープン、クローズする関数。
複数のソケット接続とサーバーソケットのうち、最初のものが利用可能になるのを待つ。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
この汎用関数は<code>a %*% x = b</code>という方程式を<code>x</code>に対して解きます。
この汎用関数は、<code>a %*% x = b</code> for <code>x</code>という方程式を解きます。
<code>qr</code> は行列のQR分解を行います。
ベクトルや因子を(部分的に)昇順または降順に並べ替えます(<em>order</em>)。  データフレームのソートなど、1つ以上の変数に沿った順序付けについては、<code>order<//code>を参照してください。
ベクトルや因子を(部分的に)昇順や降順に並べ替えます(<em>order</em>)。  例えば、データフレームのソートなど、1つ以上の変数に沿った順序付けについては、<code>order<//code>を参照してください。
ベクトルや因子を(部分的に)昇順や降順に並べ替えます(<em>order</em>)。  例えば、データ・フレームのソートなど、1つ以上の変数に沿った順序付けについては、<code>order</code>を参照してください。
<code>order</code>は、最初の引数を昇順または降順に並べ替え、それ以降の引数で同順位を解消する並べ替えを返します。  <code>sort.list</code>は、引数を1つだけ使って同じことを行います。<br>データ・フレームなどをソートするためにこれらの関数を使う方法については、例を参照してください。
ベクトルや因子を(部分的に)昇順または降順に並べ替えます(<em>order</em>)。  1つ以上の変数に沿った順序付け、例えばデータフレームのソートについては、<code>order</code>を参照してください。
<code>source</code>は、<span style="font-family：Courier New, Courier; color：<b>R</b></span> に、指定されたファイルやURL、接続や式から直接入力を受け付けるようにします。  入力は、ファイルの最後に達するまで、そのファイルから読み込まれ、<code>パース</code>されます。

<code>withAutoprint(exprs)</code>は、デフォルトが異なる<code>source(exprs = exprs, ..)</code>のラッパーです。  その主な目的は、<span style="font-family：color：#666666;"><b>R</b></span>コンソールのように。
<code>split</code> はベクトル <code>x</code> のデータを <code>f</code> で定義されたグループに分割します。  置換フォームは、このような分割に対応する値を置換します。  <code>unsplit</code>は<code>split</code>の効果を逆にします。
<code>split</code> は、ベクトル <code>x</code> のデータを <code>f</code> で定義されるグループに分割します。  置換形式は、このような分割に対応する値を置換します。  <code>unsplit</code>は、<code>split</code>の効果を逆にします。
カレンダーの日付を表すクラス <code>"Date"</code> の説明。
<code>split</code> は、ベクトル <code>x</code> のデータを <code>f</code> で定義されたグループに分割します。  置換形式は、このような分割に対応する値を置換します。  <code>unsplit</code>は、<code>split</code>の効果を逆にします。
カレンダーの日付と時刻を表すクラス<code>"POSIXlt"</code>と<code>"POSIXct"</code>の説明。
<code>split</code> は、ベクトル <code>x</code> のデータを <code>f</code> で定義されたグループに分割します。  置換形式は、このような分割に対応する値を置換します。  <code>unsplit</code>は<code>split</code>の効果を逆にします。
<code>split</code> は、ベクトル <code>x</code> のデータを <code>f</code> で定義されるグループに分割します。  置換形式は、このような分割に対応する値を置換します。  <code>unsplit</code>は<code>split</code>の効果を逆にします。
<code>split</code> は、ベクトル <code>x</code> のデータを <code>f</code> で定義されるグループに分割します。  置換形式は、このような分割に対応する値を置換します。  <code>unsplit</code>は<code>split</code>の効果を逆にします。
C 関数 <code>sprintf</code> のラッパーで、テキストと変数値の組をフォーマットした文字ベクトルを返す。
<code>abs(x)</code> は x の絶対値を計算し、<code>sqrt(x)</code> は x の(主)平方根 <i>√{x}</i> を計算します。

命名は、CやFortranのようなコンピュータ言語の標準に従う。
適切なシングルクォーテーションとダブルクォーテーションを組み合わせて、テキストをシングルクォーテーションまたはダブルクォーテーションします。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（<code>"srcref"</code>）、すなわちソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
関数<code>standardGeneric</code>はS4methodsのディスパッチを開始します: <span class="pkg">methods</span>パッケージのリファレンスとドキュメントを参照してください。  通常、この関数の呼び出しは自動的に生成され、プログラマが明示的に行うことはありません。
<code>x</code>のエントリが、それぞれ<code>prefix</code>または<code>suffix</code>の文字列(のエントリ)で始まるか終わるかを決定します。
コネクションのアスペクトを表示する。
コネクションのアスペクトを表示する。
コネクションのアスペクトを表示する。
<code>stop</code> は現在の式の実行を停止し、エラー・アクションを実行する。

<code>geterrmessage</code> は最後のエラーメッセージを与える。
(<code>...</code>または<code>exprs</code>にある)式のどれかが<code>all</code> <code>TRUE</code>でない場合、<code>stop</code>が呼ばれ、(<code>all</code>)trueでなかった<em>最初の</em>式を示すエラーメッセージが生成される。
mode'(一種の'型')、または<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトの'mode'(一種の'型')またはstoragemodeを取得または設定する。
<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクト。
<code>parse()</code>は、<code>expression</code>、<code>call</code>の "リスト "で、パースされたが評価されていない式を返します。

<code>str2expression(s)</code>と<code>str2lang(s)</code>は、<code>parse(text=s, keep.source=FALSE)</code>の特別版を返すので、文字列<code>s</code>を式や呼び出しなどに変換するものとみなすことができる。
<code>parse()</code>は、<code>expression</code>、<code>call</code>sの "リスト "で、解析されたが評価されていない式を返します。

<code>str2expression(s)</code>と<code>str2lang(s)</code>は<code>parse(text=s, keep.source=FALSE)</code>の特別版を返すので、文字列<code>s</code>を式や呼び出しなどに変換するものとみなすことができる。
文字表現と<code>"POSIXlt"</code>および<code>"POSIXct"</code>クラスのオブジェクトの間で変換する関数。
文字表現と、カレンダー日付と時刻を表すクラス<code>"POSIXlt"</code>と<code>"POSIXct"</code>のオブジェクトを変換する関数。
文字ベクトル内の文字列を指定された回数繰り返す（つまり、それぞれの文字列のコピー数を連結する）。
文字ベクトル <code>x</code> の要素を、その中の部分文字列 <code>split</code> に一致する部分文字列に分割する。
C関数の<code>strtol</code>を使って、文字列を指定されたベースに従って整数に変換する。
文字列を指定された表示幅にトリムする。
<code>structure</code>は、与えられたオブジェクトに更なる属性をセットして返す。
入力の各文字列は、まず段落（または空白のみを含む行）に分割される。  そして、段落は単語の境界で改行されることによって整形される。  改行の対象となる列と、段落の最初の行とそれに続くすべての行のインデントは、独立して制御することができます。
<code>grep</code>, <code>grepl</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>, <code>gregexec</code> は、文字ベクトルの各要素内の引数<code>pattern</code>とのマッチを検索する。

<code>sub</code>と<code>gsub</code>は、それぞれ最初のマッチと全マッチの置換を行います。
条件を満たすベクトル、行列、データ・フレームの部分集合を返します。
条件を満たすベクトル、行列、データ・フレームの部分集合を返します。
条件を満たすベクトル、行列、またはデータ・フレームの部分集合を返します。
条件を満たすベクトル、行列、またはデータ・フレームの部分集合を返します。
<code>substitute</code> は、(未評価の)式 <code>expr</code> のパース・ツリーを返します。

<code>quote</code>は単に引数を返します。引数は評価されず、どのようなR式でもかまいません。

<code>enquote</code>はシンプルな1行ユーティリティで、<code>Foo(...)</code>という形式の呼び出しを<code>quote(Foo(...))</code>という呼び出しに変換します。  これは通常、<code>call</code>を早期評価から保護するために使用される。
文字ベクトル内の部分文字列を抽出または置換する。
文字ベクトル内の部分文字列を抽出または置換する。
文字ベクトル内の部分文字列を抽出または置換する。
文字ベクトル内の部分文字列を抽出または置換する。
<code>sum</code> は、引数に含まれる全ての値の合計を返します。
<code>summary<//code>は、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第一引数の<code>class</code>に依存する特定の<code>メソッド</code>を呼び出します。
接続、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
<code>summary</code>は、様々なモデルフィッティング関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第一引数の<code>クラス</code>に依存する特定の<code>メソッド</code>を呼び出します。
グループジェネリックメソッドは、<code>Math</code>、<code>Ops</code>、<code>Summary</code>、<code>Complex</code>の4つのあらかじめ指定された関数のグループに対して定義することができます：(これらの名前のオブジェクトは、<span style="font-family: Courier New, Courier; color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> にはこれらの名前のオブジェクトはありませんが、<span class="pkg">methods</span> パッケージにはあります)。

グループの個々のメンバーに対して定義されたメソッドは、グループ全体に対して定義されたメソッドよりも優先されます。
カレンダーの日付を表すクラス <code>"Date"</code> の説明。
カレンダー日付を表すクラス <code>"Date"</code> の説明。
<code>summary</code>は、様々なモデルフィッティング関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第一引数の<code>class</code>に依存する特定の<code>メソッド</code>を呼び出します。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時差 "を呼び出します。
<code>summary</code>は、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第一引数の<code>class</code>に依存する特定の<code>メソッド</code>を呼び出します。
関数<code>factor</code>は、因子としてベクトルをエンコードするために使用されます（'category'と'enumerated type'という用語も因子に対して使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
<code>summary</code>は、様々なモデル適合関数の結果の要約を生成するために使用される汎用関数です。  この関数は、第1引数の<code>クラス</code>に依存する特定の<code>メソッド</code>を呼び出します。
パッケージバージョンを含む数値バージョンを表現するための単純なS3クラスと、関連するメソッド。
<code>factor</code>関数は、因数としてベクトルをエンコードするために使用されます（'category'と'enumerated type'という用語は、因数に対しても使用されます）。  引数<code>ordered</code>が<code>TRUE</code>の場合、因子レベルは順序付けされていると仮定される。  Sとの互換性のために、関数<code>ordered</code>もある。

<code>is.factor</code>、<code>is.ordered</code>、<code>as.factor</code>、<code>as.ordered</code>は、これらのクラスのメンバシップ関数と強制関数です。
カレンダーの日付と時刻を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
カレンダー日時を表すクラス <code>"POSIXlt"</code> と <code>"POSIXct"</code> の説明。
<code>proc.time</code>は、現在実行中の<span style="font-family：color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> プロセスがすでに費やした時間です。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」（<code>"srcref"</code>）、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
これらの関数は、ソース・ファイルや、より一般的には「ソース参照」(<code>"srcref"</code>)、つまりソース・コードへの参照を扱うためのものです。  結果として得られるデータは、印刷やソース・レベルのデバッグに使用され、通常はインタラクティブな <span style="font-family：(フォント: Courier New, Courier; color：<code>options(keep.source=TRUE)</code>のときです。
<code>table</code>は、因子レベルの各組み合わせにおけるカウントの分割表を構築するために、分類横断因子を使用します。
<code>warnings</code>とその<code>print</code>メソッドは、変数<code>last.warning</code>を見やすい形で表示します。
引数から診断メッセージを生成する。
引数から診断メッセージを生成します。
その引数と（オプションで）その引数が呼び出された式や関数に対応する警告メッセージを生成します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
矩形行列の特異値分解を計算します。
入力配列から要約統計量を掃引して得られた配列を返す。
<code>switch</code>は、<code>EXPR</code>を評価し、それに応じて(<code>...</code>内の)更なる引数の1つを選択する。
これらの関数は、呼び出しスタックのさらに上の関数に関連する<code>environment</code>s('S'の用語では'フレーム')へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた <code>environment</code>s('frames' in S terminology) へのアクセスを提供します。
これらの関数は、コンピュータのファイルシステムへの低レベルのインタフェースを提供する。
<code>Sys.time</code>と<code>Sys.Date</code>は、時間の有無にかかわらず、システムが考える現在の日付を返します。
これらの関数は、呼び出しスタックのさらに上の関数に関連する<code>environment</code>s（S用語では'フレーム'）へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた <code>environment</code>s('frames' in S terminology) へのアクセスを提供する。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた <code>environment</code>s('frames' in S terminology) へのアクセスを提供する。
<code>Sys.getenv</code>は環境変数の値を取得します。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> プロセスのロケールの詳細を取得または設定する。
<span style="font-family：のプロセス ID を取得します：<span style="font-family: Courier New, Courier;"><b>R</b></span> セッションのプロセスIDを取得します。  2つの<span style="font-family：によって保証されています：同時に実行されている<span style="font: Courier New; color: #666666;"><b>R</b></span>セッションが異なるIDを持つことはオペレーティングシステムによって保証されていますが、<span style="font-family：color：しかし、<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> セッションが異なる時間に実行された場合、同じIDを持つ可能性があります。
ファイルパスのワイルドカード展開(「グロビング」とも呼ばれる)を行う関数。
システム情報とユーザー情報を報告します。
基本パッケージの内部オブジェクト。そのほとんどは、基本名前空間の特別な性質のために、ユーザーからしか見えない。
現在のロケールにおける数値および金額表現の詳細を取得します。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた<code>environment</code>s（S用語では'フレーム'）へのアクセスを提供します。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた <code>environment</code>s('frames' in S terminology) へのアクセスを提供する。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた <code>environment</code>s('frames' in S terminology) へのアクセスを提供する。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた <code>environment</code>s('frames' in S terminology) へのアクセスを提供する。
ファイルパスがシンボリックリンクかどうか、シンボリックリンクの場合は何にリンクされているかを、<em>システムコール <code>readlink</code> で調べる。

シンボリックリンクはPOSIXの概念であり、Windowsでは実装されていないが、Unixに似たほとんどのファイルシステムでは実装されている。
基本パッケージの内部オブジェクトは、基本名前空間の特別な性質のために、そのほとんどがユーザから見えるだけである。
<code>Sys.setenv</code>は、環境変数を設定します（<span style="font-family：color：<b>R</b></span> 内から呼び出される他のプロセスや、将来この <span style="font-family：color：font-family: Courier New, Courier; "color: #666666;"><b>R</b></span> プロセスから呼び出されます)。

<code>Sys.unsetenv</code>は環境変数を削除する。
システムコールを使ってファイルやディレクトリの時刻を設定する。
<span style="font-family：courier new, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> プロセスのロケールを設定する。
<span style="font-family：(フォント: Courier New, Courier; color：<span style="font: Courier New, Courier; "color: #666666;"><b>R</b></span> 式の実行を、指定した時間間隔で一時停止します。
与えられたファイル内の式を解析し、指定された環境でそれらを連続的に評価する。
これらの関数は、呼び出しスタックのさらに上の関数に関連付けられた<code>environment</code>s（S用語では'フレーム'）へのアクセスを提供する。
<code>Sys.time</code>と<code>Sys.Date</code>は、時間の有無にかかわらず、システムが考える現在の日付を返します。
タイムゾーンに関する情報は、<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>におけるタイムゾーンに関する情報。  <code>Sys.timezone</code>は、現在のタイムゾーンの名前を返します。
これらの関数は、コンピュータのファイル・システムへの低レベルのインタフェースを提供する。
<code>Sys.setenv</code>は環境変数を設定する（<span style="font-family：color：<b>R</b></span> 内から呼び出される他のプロセスや、この<span style="font-family：color：font-family: Courier New, Courier; "color: #666666;"><b>R</b></span> プロセスから呼び出されます)。

<code>Sys.unsetenv</code>は環境変数を削除する。
これは、システムコマンド <code>which</code> や Windows の anemulation へのインターフェースである。
<code>system</code>は、<code>command</code>で指定されたOSコマンドを呼び出します。
パッケージなどに含まれるファイルの完全なファイル名を検索します。
<code>expr</code>が使用したCPU(その他)時間を返す。
<code>system2</code> は <code>command</code> で指定されたOSコマンドを起動する。
行列または <code>data.frame</code> <code>x</code> が与えられた場合、<code>t</code> は <code>x</code> の転置行列を返します。
<code>"logical"</code>型のオブジェクト、およびbasiclogical定数を作成またはテストする。
行列または <code>data.frame</code> <code>x</code> が与えられた場合、<code>t</code> は <code>x</code> の転置行列を返します。
行列または <code>data.frame</code> <code>x</code>,<code>t</code> が与えられた場合、<code>x</code> の転置行列を返します。
<code>table</code>は、クロス分類因子を用いて、各因子レベルの組み合わせにおけるカウントの分割表を作成する。
<code>tabulate</code>は整数値ベクトル<code>bin</code>を取り、各整数がその中に出現する回数を数える。
これらの関数は明らかな三角関数を与える。  これらはそれぞれ、余弦、正弦、正接、円弧余弦、円弧正弦、円弧正接、2引数の円弧正接を計算する。

<code>cospi(x)</code>、<code>sinpi(x)</code>、<code>tanpi(x)</code>は、<code>cos(π*x)</code>、<code>sin(π*x)</code>、<code>tan(π*x)</code>を計算する。
これらの関数は明らかな双曲線関数を与える。  これらはそれぞれ、双曲線の余弦、正弦、正接、およびそれらの逆、円弧余弦、円弧正弦、円弧正接(または'<em>面積余弦</em>'など)を計算します。
これらの関数は明らかな三角関数を与える。  コサイン、サイン、タンジェント、アーク・コサイン、アーク・サイン、アーク・タンジェント、および2引数のアーク・タンジェントを計算します。

<code>cospi(x)</code>、<code>sinpi(x)</code>、<code>tanpi(x)</code>は、<code>cos(π*x)</code>、<code>sin(π*x)</code>、<code>tan(π*x)</code>を計算する。
ラグド配列の各セルに関数を適用する、つまり、ある因子のレベルのユニークな組み合わせで与えられる値の（空でない）各グループに関数を適用する。
これは、完全に<span style="font-family：color：各トップレベル・タスクの終了時に呼び出されるコールバックやアクションを管理するための、完全に<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>言語のメカニズムを提供します。  基本的には、単一の<span style="font-family：color：#マネージャは、ユーザー・レベル・コールバックのリストを管理するために共有変数にアクセスする関数のコレクションで構成されます。
行列<code>x</code>と<code>y</code>を引数として与え、行列相互積を返す。  これは、形式的には、<code>t(x) %*% y</code> (<code>crossprod</code>) または<code>x %*% t(y)</code> (<code>tcrossprod</code>) の呼び出しと等価です (しかし、通常はそれより若干高速です)。
<code>tempfile</code> は、一時ファイルの名前として使用できる文字列のベクトルを返します。
<code>tempfile</code> は、一時ファイルの名前として使える文字列のベクトルを返す。
入出力テキスト接続。
入出力テキスト接続。
文字ベクトル内の文字、特に大文字から小文字、またはその逆を変換する。
環境<code>envir</code>とそれを囲む環境からトップレベルの<code>environment</code>を見つける。
これは、<code>format</code>のヘルパー関数で、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトを記述する一文字の文字列を生成します。
これは<code>format</code>のヘルパー関数で、<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> オブジェクト。
文字ベクトル内の文字、特に大文字から小文字、またはその逆を変換する。
<code>trace</code>を呼び出すと、デバッグコード(例えば、<code>browser</code>や<code>recover</code>への呼び出し)を任意の関数の選ばれた場所に挿入することができます。  <code>untrace</code>の呼び出しは、トレースをキャンセルします。指定されたメソッドは、汎用関数へのすべての呼び出しをトレースすることなく、同じ方法でトレースすることができます。  トレースコード（<code>tracer</code>）は、任意の<span style="font-family：color：<b>R</b></span> 式です。  <code>tracingState</code>を呼び出すことで、一時的にグローバルにトレースのオン/オフを切り替えることができます。
デフォルトでは、<code>traceback()</code>は、最後に捕捉されなかったエラーのコールスタック、つまりエラーに至った呼び出しのシーケンスを表示します。  また、現在のスタックや任意の呼び出しのリストを表示するのにも使用できる。

<code>.traceback()</code>は上記のコールスタックを<em>返します</em>（そして<code>traceback(x, *)</code>は<code>.traceback(x)</code>の結果をプリントするための便利な関数とみなすことができます）。
この関数は、内部コードがオブジェクトをコピーするたびにメッセージが表示されるようにオブジェクトをマークします。  この関数はRのメモリ使用量を予測しにくくする大きな原因となっています。
<code>trace</code>を呼び出すと、デバッグコード（例えば、<code>browser</code>や<code>recover</code>の呼び出し）を任意の関数の選ばれた場所に挿入することができます。  <code>untrace</code>の呼び出しは、トレースをキャンセルします。指定されたメソッドは、汎用関数へのすべての呼び出しをトレースすることなく、同じ方法でトレースすることができます。  トレースコード（<code>tracer</code>）は、任意の<span style="font-family：color：<b>R</b></span> 式です。  <code>tracingState</code>を呼び出すことで、一時的にグローバルにトレースのオン/オフを切り替えることができます。
<code>transform</code>は汎用関数で、少なくとも現在のところ、データ・フレームから有用なことを行うだけです。  <code>transform.default</code>は、可能であれば最初の引数をデータフレームに変換し、<code>transform.data.frame</code>を呼び出します。
<code>transform</code>は汎用関数で、少なくとも現時点ではデータフレームに対して有用なことを行うだけです。  <code>transform.default</code>は、可能であれば最初の引数をデータフレームに変換し、<code>transform.data.frame</code>を呼び出します。
<code>transform</code>は汎用関数で、少なくとも現時点ではデータフレームに対して有用なことを行うだけです。  <code>transform.default</code>は最初の引数を可能であればデータフレームに変換し、<code>transform.data.frame</code>を呼び出します。
ベータ関数とガンマ関数に関連する特別な数学関数。
文字列から先頭または末尾の空白を除去する。
<code>ceiling</code> は、単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より小さくない最小の整数を含む数値ベクトルを返す。

<code>floor</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の対応する要素より大きくない最大の整数を含む数値ベクトルを返します。

<code>trunc</code> は単一の数値引数 <code>x</code> を取り、<code>x</code> の値を <code>0</code> に向かって切り捨てた整数を含む数値ベクトルを返す。

<code>round</code> は、第一引数の値を指定された小数点以下の桁数(デフォルトは0)に丸めます。  5を四捨五入する場合の "round to even "については'詳細'を参照。

<code>signif</code> は、第一引数の値を指定された有効桁数に丸めます。   したがって、<code>numeric</code> <code>x</code> の場合、<code>signif(x, dig)</code> は <code>round(x, dig - ceiling(log10(abs(x))))</code> と同じになります。
日付-時刻オブジェクトを丸めたり切り詰めたりする。
日時オブジェクトを丸めたり切り捨てたりする。
接続の位置を変更する関数。
接続の位置を変更する関数。
<code>try</code>は、失敗する可能性のある式を実行し、ユーザのコードでエラー回復を処理できるようにするラッパーです。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
<code>typeof</code>は、(<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 内部)タイプやオブジェクトの記憶モードを決定します。
<span style="font-family：を使用してください：<span style="font-family: Courier New; "color: #666666;"><b>R</b></span> は、オブジェクト指向スタイルのプログラミングに使用できるシンプルな汎用関数メカニズムを備えています。  メソッドのディスパッチは、ジェネリック関数への最初の引数のクラスに基づいて行われます。
<code>text</code>と<code>condition</code>引数は、<code>browser</code>の呼び出しで与えられるものと同じです。  これらの引数は、ブラウザが入力されると、ユーザによって取得され、ユーザがどのブレークポイントが有効化されたかを識別するためのメカニズムを提供します。
2つのベクトルに対して、<b>集合</b>和、交、(非対称！)差、等式、メンバシップを実行します。
<code>unique</code> は、<code>x</code>のようなベクトル、データフレーム、配列を返しますが、重複する要素や行は削除されます。
<code>unique</code> は、<code>x</code>のようなベクトル、データフレーム、または配列を返しますが、重複する要素や行は取り除かれます。
<code>unique</code> は、<code>x</code>のようなベクトル、データフレーム、または配列を返しますが、重複する要素や行は削除されます。
<code>unique</code> は、<code>x</code>のようなベクトル、データフレーム、または配列を返しますが、重複する要素や行は削除されます。
<code>unique</code> は <code>x</code> のようなベクトル、データフレーム、配列を返しますが、重複する要素や行は取り除かれます。
パッケージ・バージョンを含む数値バージョンを表現するためのシンプルな S3 クラスと、関連するメソッド。
<code>"POSIXlt"</code>と<code>"POSIXct"</code>カレンダーの日付と時刻を表すクラスの説明。
<code>warnings</code>とその<code>print</code>メソッドは、変数<code>last.warning</code>を見やすい形で表示します。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの「時間差」を呼び出します。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの「時間差」を呼び出す。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの「時間差」を呼び出す。
時間間隔の作成、印刷、いくつかの演算。  <code>print()</code>メソッドはこれらの "時差 "を呼び出す。
これらの関数は、古いバージョンの<span style="font-family：color：#666666;"><b>R</b></span>のみであり、次のリリースと同時に廃止されるかもしれません。
<code>unlink</code> は <code>x</code> で指定されたファイルやディレクトリを削除します。
リスト構造 <code>x</code> が与えられると、<code>unlist</code> はそれを単純化して、<code>x</code> に現れるすべての原子成分を含むベクトルを生成する。
名前空間をロードおよびアンロードする関数。
これらの関数は、環境と環境内のバインディングを調整するためのインターフェイスを表します。  個々のバインディングと同様に環境をロックしたり、変数を関数にリンクしたりすることができます。
<code>names</code> または <code>dimnames</code> 属性の <span style="font-family：の<span style="font-family: Courier New, Courier; color：#"><b>R</b></span>オブジェクトの<code>names</code>または<code>dimnames</code>属性を指定します。
コネクションにシリアライズするためのシンプルな低レベルインターフェイスです。
<code>split</code> は、ベクトル <code>x</code> のデータを <code>f</code> で定義されたグループに分割します。  置換フォームは、このような分割に対応する値を置換します。  <code>unsplit</code>は<code>split</code>の効果を逆転させる。
<code>trace</code>を呼び出すと、デバッグコード（例えば、<code>browser</code>や<code>recover</code>への呼び出し）を任意の関数の選ばれた場所に挿入することができる。  <code>untrace</code>の呼び出しは、トレースをキャンセルします。指定されたメソッドは、汎用関数へのすべての呼び出しをトレースすることなく、同じ方法でトレースすることができます。  トレースコード（<code>tracer</code>）は、任意の<span style="font-family：color：<b>R</b></span> 式です。  トレースは、<code>tracingState</code>を呼び出すことによって、一時的にグローバルにオンまたはオフにすることができます。
この関数は、内部コードがオブジェクトをコピーするたびにメッセージが表示されるようにオブジェクトをマークします。  この関数は、Rのメモリ使用量を予測しにくくする主な原因となっています。
コネクション、すなわち「一般化されたファイル」（圧縮ファイル、URL、パイプなど）を作成、オープン、クローズする関数。
下三角形または上三角形に<code>TRUE</code>を持つ、与えられた行列と同じ大きさの論理の行列を返す。
接続、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」を作成、オープン、クローズする関数。
<span style="font-family：Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> は、オブジェクト指向スタイルのプログラミングに使用できる、シンプルなジェネリック関数のメカニズムを持っています。  メソッド・ディスパッチは、ジェネリック関数への最初の引数のクラスか、<code>UseMethod</code>または<code>NextMethod</code>への引数として供給されたオブジェクトのクラスに基づいて行われます。
UTF-8 でエンコードされた文字ベクトルを、UTF-32 エンコードを表す整数ベクトルへ、または整数ベクトルから UTF-8 エンコードされた文字ベクトルへ変換します。
文字ベクトルの各要素がその暗黙のエンコーディングで有効かどうかをチェックする。
文字ベクトルの各要素が、その impliedencoding で有効かどうかをチェックする。
<code>lapply</code> は <code>X</code> と同じ長さのリストを返し、その各要素は <code>X</code> の対応する要素に <code>FUN</code> を適用した結果である。

<code>sapply</code>は、<code>lapply</code>の使いやすいバージョンであり、ラッパーです。デフォルトでは、ベクトル、行列、または、<code>simplify = "array"</code>の場合、適切であれば、<code>simplify2array()</code>を適用して配列を返します。<code>sapply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> は、<code>lapply(x, f)</code> と同じです。

<code>vapply</code>は<code>sapply</code>に似ているが、戻り値の型があらかじめ指定されているため、より安全に（そして時にはより速く）使うことができる。

<code>replicate</code>は、<code>sapply</code>の一般的な使用法のラッパーであり、（通常は乱数生成を伴う）式の繰り返し評価を行う。

<code>simplify2array()</code>は、<code>simplify</code>が偽でない場合に<code>sapply()</code>から呼ばれるユーティリティで、<code>mapply()</code>からも同様に呼ばれます。
<code>vector</code> は、与えられた長さとモードのベクトルを生成します。

<code>as.vector</code>はジェネリックで、引数を<code>mode</code>モードのvectorに強制しようとします（デフォルトは、最も便利なvectorモードに強制します）。

<code>is.vector</code>は、<code>x</code>が<em>名前</em>以外の属性を持たない指定されたモードのベクトルであれば<code>TRUE</code>を返します。  そうでなければ<code>FALSE</code>を返します。
<code>Vectorize</code> は、引数 <code>FUN</code> のアクションをベクトル化する関数のラッパーを作成します。
<code>R.Version()</code>は、<span style="font-family：color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> が実行されているバージョンの詳細情報を提供します。

<code>R.version</code>は、この情報を保持する変数（<code>list</code>）です（また、<code>version</code>は、Sとの互換性のためのコピーです）。
引数(複数可)と(オプションで)呼び出された式や関数に対応する警告メッセージを生成する。
これらの関数は、エラーや警告を含む異常な状態を処理するメカニズムを提供します。
<code>warnings</code> とその <code>print</code> メソッドは、変数 <code>last.warning</code> を見やすい形で表示します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは汎用的な関数です。内部の日付時刻クラスのメソッドについては、ここで文書化されています。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  内部日付-時刻クラスのメソッドについては、ここで説明します。
曜日、月、四半期、またはユリウス時間（ある起点からの日数）を抽出します。  これらは一般的な関数です。内部の日付-時刻クラスのメソッドについては、ここに記述されています。
論理オブジェクトの<code>TRUE</code>インデックスを与えます。
数値(または論理)ベクトルの(最初の)最小または最大の位置、すなわちインデックスを決定します。
数値(または論理)ベクトルの(最初の)最小値または最大値の位置、すなわちインデックスを決定します。
これらは<span style="font-family：color：#666666;"><b>R</b></span>言語の基本的な制御フロー構成です。  これらはAlgol-likel言語の制御文とほとんど同じように機能する。  これらはすべて予約語です。
<span style="font-family：を評価する：<span style="font-family: Courier New; color: #666666;"><b>R</b></span> 式を、データから構築された環境で評価する。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font: Courier New, Courier; color: #666666;"><b>R</b></span> 式を、データから構築された環境で評価します。
<code>ソース</code>は、<span style="font-family：color：<b>R</b></span> に、指定されたファイルやURL、接続や式から直接入力を受け付けるようにします。  入力は、ファイルの最後に達するまで、そのファイルから読み込まれ、<code>パース</code>されます。

<code>withAutoprint(exprs)</code>は、デフォルトが異なる<code>source(exprs = exprs, ..)</code>のラッパーです。  その主な目的は、<span style="font-family：color：#666666;"><b>R</b></span>コンソールのように。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供します。
<span style="font-family：を評価する：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 式を、データから構築された環境で評価します。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 式をデータから構築された環境で評価します。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 式をデータから構築された環境で評価し、場合によっては元のデータを変更（コピー）する。
これらの関数は、エラーや警告などの異常な状態を処理するメカニズムを提供します。
この関数は式を評価し、その値と自動的に印刷されるかどうかを示すフラグを含む2要素のリストで返します。
データ（通常は行列）<code>x</code>はファイル<code>file</code>に書き込まれます。もし<code>x</code>が2次元行列であれば、<code>file</code>の列が内部表現と同じになるように転置する必要があります。
<span style="font-family：font-family: Courier New, Courier; color：<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> オブジェクトを Debian Control Fileformat のファイルから読み書きします。
接続や未加工ベクトルからバイナリデータを読み書き。
接続上でヌル終端であると仮定せずに、文字列を接続との間で転送する。
接続にテキスト行を書き込む。
これらの演算子は、生のベクトル、論理ベクトル、および数値ライクなベクトルに対して作用します。
データ・フレームで使用する内部補助関数。
<code>x</code>と同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートされる数値ベクトルを生成する汎用補助関数。
パッケージ・バージョンを含む数値バージョンを表現するシンプルなS3クラスと関連するメソッド。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
<code>x</code> と同じ順序でソートする数値ベクトルを生成する汎用補助関数。
接続を作成、オープン、クローズする関数、すなわち、圧縮ファイル、URL、パイプなどの「一般化されたファイル」。
<code>zapsmall</code>は、<code>round(x, digits = dr)</code>を呼び出すための<code>digits</code>引数<code>dr</code>を決定し、(絶対値の最大値と比較して)ゼロに近い値が'ザッピング'される、すなわち、<code>0</code>で置き換えられるようにします。
この関数は、現在のプロットを通る1本以上の直線を追加します。
点のペア間に矢印を引く。
2次元分割表の行と列の独立性からの乖離を示すCohen-Friendly連想プロットを作成する。
現在のプロットに軸を追加し、辺、位置、ラベル、およびその他のオプションを指定できるようにする。
現在のプロットに適切な軸を追加する汎用関数.
<code>"POSIXlt"</code>, <code>"POSIXct"</code>, <code>"Date"</code>クラスのオブジェクトをプロットする関数。
<code>"POSIXlt"</code>、<code>"POSIXct"</code>、<code>"Date"</code>クラスのオブジェクトをプロットする関数。
<span style="font-family：Courier New, Courier; color：#デフォルトでは、<code>axis(side)</code>が使う<code>at</code>値を与えます。
縦棒または横棒の棒グラフを作成します。
垂直または水平のバーを持つ棒グラフを作成します。
この関数は、与えられた色と線種で現在のプロットを囲むボックスを描画します。  <code>bty</code> パラメータは、描画されるボックスのタイプを決定します。  詳細は <code>par</code> を参照。
与えられた（グループ化された）値の箱ひげ図プロットを生成します。
与えられた(グループ化された)値の箱ひげプロットを生成します。
行列の列（または行）を異なるグループとして解釈し、それぞれのaboxplotを描画する。
<code>bxp</code>は、<code>z</code>内の与えられた要約に基づいて箱ひげ図を描画します。通常、<code>boxplot</code>内から呼び出されますが、直接呼び出すこともできます。
カテゴリ変数<code>y</code>の条件付き分布が数値変数<code>x</code>に対してどのように変化するかを記述する条件付き密度を計算し、プロットします。
ユーザー座標でクリッピング領域を設定
<code>split.screen</code>は、現在のデバイスの中に、ある程度、別々のグラフィック・デバイスとして扱えるいくつかの領域を定義します。  これは、1つのデバイス上に複数のプロットを生成するのに便利である。  スクリーン自体も分割することができ、かなり複雑なプロットの配置を可能にする。

<code>screen</code>は描画するスクリーンを選択するのに使われる。

<code>erase.screen</code>は、背景色で塗りつぶされた1つの画面を消去するのに使われる。

<code>close.screen</code>は、指定されたスクリーン定義を削除する。
この関数は、以下のリファレンスで説明されている<b>co</b>nditioning plotsの2つのバリエーションを生成します。
等高線プロットを作成するか、既存のプロットに等高線を追加する。
等高線プロットを作成、または既存のプロットに等高線を追加。
この関数は、以下のリファレンスで説明されている<b>co</b>nditioning plotsの2つのバリエーションを生成します。
区間<code>[from, to]</code>上の関数に対応する曲線を描画します。<code>curve</code>は、変数<code>xname</code>, デフォルト<span class="samp">x</span>の式も描画できます。
クリーブランドのドットプロットを描く。
<code>split.screen</code>は、カレントデバイス内にいくつかの領域を定義し、それらをある程度、別々のグラフィックデバイスとして扱うことができます。  これは、1つのデバイスで複数のプロットを生成するのに便利です。  スクリーン自体も分割することができ、かなり複雑なプロットの配置を可能にする。

<code>screen</code>は描画するスクリーンを選択するのに使われる。

<code>erase.screen</code>は、背景色で塗りつぶされた1つの画面を消去するのに使われる。

<code>close.screen</code>は、指定されたスクリーン定義を削除する。
この関数は、輪郭と輪郭の間の領域を実線で塗りつぶした等高線プロットを作成する(Clevelandはこれをレベルプロットと呼ぶ)。  プロットの右側には、色がz値にどのように対応するかを示すキーが表示されます。
2×2×<i>k</i>分割表の4重表示を現在のグラフィックス・デバイス上に作成し、1つまたは複数の母集団（層）における2つの二項変数の関連を視覚的に検査できるようにする。
この関数(<code>frame</code>は<code>plot.new</code>のエイリアスです)は、現在のプロット(もし存在すれば)を終了させ、新しいグラフィックス・フレームに進めます。  これは、すべての高レベルのプロット関数で使用され、また、複数図領域が使用されているときにプロットをスキップするのにも便利です。
グラフィックス座標系間の変換
グラフィックス座標系間の変換。
<code>grid</code> は、既存のプロットに <code>nx</code> × <code>ny</code> の矩形グリッドを追加します。
汎用関数 <code>hist</code> は、与えられたデータ値のヒストグラムを計算します。  <code>plot = TRUE</code>の場合，<code>"histogram"</code>クラスのオブジェクトが返される前に，<code>plot.histogram</code>によってプロットされます．
汎用関数 <code>hist</code> は，与えられたデータ値のヒストグラムを計算します．  <code>plot = TRUE</code>の場合，<code>"histogram"</code>クラスのオブジェクトが返される前に，<code>plot.histogram</code>によってプロットされます．
<code>identify</code> は，(最初の)マウスボタンが押された時のグラフィックスポインタの位置を読み込みます．  この点がポインタに十分に近ければ、そのインデックスが呼び出し値の一部として返されます。
<code>z</code>の値に対応する色またはグレースケールの矩形のグリッドを作成します。  これは、<em>画像</em>と呼ばれる3次元または空間データを表示するために使用することができます。

<em>NOTE:</em> グリッドはデフォルトでは矩形の集合として描画されます; グリッドをラスター画像として描画するには <code>useRaster</code> 引数を参照してください。

関数<code>hcl.colors</code>は、<code>n</code>で色の数を指定することにより、順序データを表示するのに適した広範囲の連続したカラーパレットを提供します。
<code>z</code> の値に対応する色を持つ、色付きまたはグレースケールの矩形のグリッドを作成します。  これは、<em>画像</em>と呼ばれる3次元または空間データを表示するために使用することができます。

<em>NOTE:</em> グリッドはデフォルトでは矩形の集合として描画されます; グリッドをラスター画像として描画するには <code>useRaster</code> 引数を参照してください。

関数 <code>hcl.colors</code> は、<code>n</code> が希望する色の数を与えることで、順序データを表示するのに適した広範囲の連続したカラーパレットを提供します。
<code>layout</code>は、マトリックス<code>mat</code>と同じ数の行と列にデバイスを分割します。
<code>layout</code> は、それぞれの引数で指定された列幅と行高で、マトリックス <code>mat</code> にあるのと同じ数の行と列にデバイスを分割します。
<code>layout</code> は、それぞれの引数で指定された列幅と行高で、マトリックス <code>mat</code> にあるのと同じ数の行と列にデバイスを分割します。
この関数は、プロットに凡例を追加するために使用することができます。  引数<code>x</code>と<code>y</code>の代わりに、関数<code>locator(1)</code>の呼び出しが使えることに注意してください。
様々な方法で与えられた座標を取り、対応する点を線分で結ぶ汎用関数。
様々な方法で与えられた座標を取り、対応する点を線分で結合する汎用関数。
(最初の)マウスボタンが押された時のグラフィックカーソルの位置を読み取る。
ある行列の列を別の行列の列に対してプロットする（1列の行列として扱われるベクトルであることが多い）。
ある行列の列を別の行列の列に対してプロットする (多くの場合、1列の行列として扱われる単なるベクトルである)。
ある行列の列を別の行列の列に対してプロットする(whichoftenは単なる1列行列として扱われるベクトルである)。
現在のグラフィックデバイスにモザイクをかける。
テキストは、現在の図形領域の4つの余白のうちの1つ、またはデバイス領域の外側の余白のうちの1つに書き込まれます。
散布図の行列が生成される。
散布図の行列が生成される。
例えば、<code>coplot</code> や <code>pairs</code> の引数として使用される、単純で便利な <code>panel</code> 関数の例。
<code>par</code>は、グラフィカル・パラメータの設定や問い合わせに使用することができます。パラメータは、<code>tag = value</code>形式で<code>par</code>の引数として指定するか、タグ付き値のリストとして渡すことによって設定することができます。
この関数は、x-y平面上の曲面の透視図を描画します。  <code>persp</code>は汎用関数です。
円グラフを描画する。
アクティブなグラフィックスウィンドウに軸やタイトルなどの装飾を持つ散布図を描画します。
アクティブなグラフィックスウィンドウで、軸やタイトルなどの装飾を持つ散布図を描く
典型的には、<code>aov()</code>によって分析されたデザインされた実験について、1つ以上の<code>因子</code>の単変量効果をプロットします。
区間<code>[from, to]</code>上の関数に対応する曲線を描画します。<code>curve</code>は、変数<code>xname<//code>、デフォルト<span class="samp">x</span>に式をプロットすることもできます。
この関数(<code>frame</code>は<code>plot.new</code>のエイリアスです)は、現在のプロット(もしあれば)を終了させ、新しいグラフィックフレームに進めます。  これは、すべての高レベルのプロット関数で使用され、また、複数の図領域が使用されているときにプロットをスキップするのにも便利です。
この関数は、グラフィックスウィンドウのワールド座標系を設定します。  この関数は、<code>plot.default</code> (<em><code>plot.new</code> の後</em>)のような高レベルの関数によって呼び出されます。
これは<em>点と線の基本的なプロットを行う内部関数です。  通常、より高レベルの関数を代わりに使用し、引数の説明についてはヘルプページを参照する必要があります。
<code>points</code> は、指定された座標に一連の点を描画する汎用関数です。  指定された文字は、座標を中心として描画されます。
<code>points</code> は、指定された座標に一連の点を描画する汎用関数です。  指定された文字が座標を中心に描画されます。
<code>polygon</code> は、頂点が <code>x</code> と <code>y</code> で与えられる多角形を描画します。
<code>path</code> は、頂点が <code>x</code> と <code>y</code> で与えられるパスを描画します。
<code>rasterImage</code> は与えられた位置とサイズのラスター画像を描画します。
<code>rect</code>は、与えられた座標、塗りつぶし、境界の色で矩形（または矩形のシーケンス）を描画します。
データの<em>rug</em>表現(1-d plot)をプロットに追加します。
<code>split.screen</code>は、カレントデバイスの中に、ある程度、別々のグラフィックデバイスとして扱うことができるいくつかの領域を定義します。  これは、1つのデバイスで複数のプロットを生成するのに便利です。  スクリーン自体も分割することができ、かなり複雑なプロットの配置を可能にする。

<code>screen</code>は描画するスクリーンを選択するのに使われる。

<code>erase.screen</code>は、背景色で塗りつぶされた1つの画面を消去するのに使われる。

<code>close.screen</code>は、指定されたスクリーン定義を削除する。
点のペア間に線分を引く。
<code>smoothScatter</code>は、(2次元)カーネル密度推定によって得られる、散布図の平滑化された色密度表現を生成します。
スパイン・プロットは、モザイク・プロットの特殊なケースであり、積み重ねられた（または強調された）棒グラフの一般化と見ることができます。同様に、スピノグラムはヒストグラムの拡張です。
<code>split.screen</code>は、現在のデバイスの中に、ある程度、別々のグラフィック・デバイスとして扱えるいくつかの領域を定義します。  これは、1つのデバイスで複数のプロットを生成するのに便利である。  スクリーン自体も分割することができ、かなり複雑なプロットの配置を可能にする。

<code>screen</code>は描画するスクリーンを選択するのに使われる。

<code>erase.screen</code>は、背景色で塗りつぶされた1つの画面を消去するのに使われる。

<code>close.screen</code>は、指定されたスクリーン定義を削除する。
多変量データセットのスタープロットまたはセグメント図を描画します。1つの場所で、'スパイダー'(または'レーダー')プロットも描画します。
<code>ststem</code>は、<code>x</code>の値の茎と葉のプロットを作成します。<code>scale</code>パラメータは、プロットのスケールを拡大するために使用することができます。  <code>scale = 2</code>の値は、プロットの長さをデフォルトの約2倍にします。
これらの関数は、与えられた文字列または数式<code>s[i]</code>の幅または高さを、<em>ユーザ</em>座標、<em>インチ</em>、または図の幅<code>par("fin")</code>の分数<code>par("fin")</code>として、現在の描画デバイス上でそれぞれ計算します。
<code>stripchart</code>は、与えられたデータの一次元散布図(または点描図)を作成します。  これらのプロットは、サンプルサイズが小さい場合に、<code>boxplot</code>の良い代替となります。
これらの関数は、与えられた文字列または数式<code>s[i]</code>の幅または高さを、<em>ユーザ</em>座標、<em>インチ</em>、または図の幅<code>par("fin")</code>に対する割合<code>par("fin")</code>で、現在の描画デバイス上でそれぞれ計算します。
複数の点は、複数の葉('花びら')を持つ'ひまわり'としてプロットされます。
この関数はプロット上にシンボルを描画します。  <em>circles</em>, <em>squares</em>, <em>rectangles</em>, <em>stars</em>, <em>thermometers</em>, <em>boxplots</em> の6つのシンボルのうちの1つを、指定したx座標とy座標に描画します。  相対的な大きさなど、シンボルの特定の側面は、追加のパラメータによってカスタマイズすることができます。
<code>text</code> は、ベクトル <code>labels</code> で指定された文字列を <code>x</code> と <code>y</code> で指定された座標に描画します。<code>y</code> は、座標の構築に <code>xy.coords(x, y)</code> が使用されているため、欠落している可能性があります。
<code>text</code> は、ベクトル <code>labels</code> で与えられた文字列を、<code>x</code> と <code>y</code> で与えられた座標に描画します。<code>y</code> は、<code>xy.coords(x, y)</code> が座標の構築に使用されているので、欠落しているかもしれません。
この関数は、プロットにラベルを追加するために使用できます。  その最初の4つの主要な引数は、ほとんどの高レベルのプロット関数の引数としても使用できます。  これらは<code>character</code>型か<code>expression</code>型でなければなりません。後者の場合、下付き文字や上付き文字、ギリシャ文字、分数など、多くの数学的記法が利用できます。
<code>xinch</code> と <code>yinch</code> は、引数として与えられたインチ数を、 グラフィックス関数でプロットするための正しい単位に変換します。  通常、これは、通常の座標が使用される場合、すなわち、<em>log</em>スケール（<code>par</code>の<code>log</code>引数を参照）が使用される場合にのみ意味を持ちます。


Xスプラインは、制御点を基準にして描かれる曲線です。
<code>xinch</code>と<code>yinch</code>は、引数として指定されたインチ数を、グラフィック関数で描画するための正しい単位に変換します。  通常、これは、通常の座標が使用される場合、すなわち、<em>log</em>スケール（<code>par</code>の<code>log</code>引数を参照）が使用される場合にのみ意味を持ちます。

<code>xyinch</code> は、同時に<code>xy</code>という数値の組に対しても同じことをします。
<code>xinch</code> と <code>yinch</code> は、引数として与えられた指定されたインチ数を、 グラフィックス関数でプロットするための正しい単位に変換します。  通常、これは、通常の座標が使用される場合、すなわち、<em>log</em>スケール（<code>par</code>の<code>log</code>引数を参照）が使用される場合にのみ意味を持ちます。

<code>xyinch<//code>は同時に<code>xy<//code>,数値のペアに対して同じことをする。
行列の乗算に類似した操作で2つのベクトルや行列を加算するのが便利なことがある。行列nXmとmYpの場合、nSpのi,j番目の要素の行列和＝iXm＋mYjのsum(over m)となる。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、些細な関数ですが、行列の下三角形を四捨五入して表示する便利な関数です。reflectは、因子分析または主成分分析の出力を、1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericは、カテゴリー/レベルであるdataframeの列を数値に変換します。
信頼性の内部一貫性の測定範囲は、<i>omega_hierchical</i>から<i>alpha</i>から<i>omega_total</i>までです。  この関数は2つの推定値を報告します：Cronbachの係数<i>alpha</i>とGuttmanの<i>lambda_6</i>です。  また、項目-全体の相関、項目が省略された場合の<i>alpha</i>、項目の平均と標準偏差も報告されます。
信頼性の内部一貫性の測定範囲は、<i>omega_hierchical</i>から<i>alpha</i>から<i>omega_total</i>までです。  この関数は2つの推定値を報告します：Cronbachの係数<i>alpha</i>とGuttmanの<i>lambda_6</i>です。  また、項目と全体の相関、項目が省略された場合の<i>alpha</i>、項目の平均と標準偏差も報告されます。
<code>setCor</code>を使用してデータまたは相関行列から回帰を行ったり、<code>link{mmediate}</code>を使用して媒介分析を行う場合、代替モデルを比較することが有用です。  これらは両方とも回帰モデルなので、適切な検定は分散分析です。  カイ2乗を用いた同様な検定は、因子分析モデルについても行うことができる。
多くの分野では，根底にある現象はたぶん連続的であるにもかかわらず，決定や結果はカテゴリー的である．  例えば、学生が大学院に合格するかしないか、卒業するかしないか。X線検査は、患者が癌であるか否かを診断する。   このような決定の結果は、通常、Valid Positives（有効な陽性）、Valid Negatives（有効な陰性）、False Positives（偽陽性）、False Negatives（偽陰性）とラベル付けされる。仮説検定では、偽陽性はタイプIのエラーとして知られ、偽陰性はタイプIIのエラーである。  これら4つのセルの関係は、決定ルールと結果の相関関係、および決定に必要な証拠のレベル（基準）に依存する。  信号検出理論と決定理論には、性能（accuracy = VP + VN）、感度（VP/(VP + FN)）、特異度（1 - FP）、d プライム（d'）、および応答動作特性曲線下面積（AUC）の多くの関連尺度がある。より一般的には、これらは2値データに基づく相関の例である。  <code>AUC</code>は、これらの質問のいくつかに対応します。  
Von Neumanら(1941)は、平均の漸進的なシフトを考慮に入れた変動の尺度として、連続差の平均二乗について議論した。これは、弾道学で誤差を研究するときや、情動を研究するときの気分の変動性や安定性を研究するときに適切である。ランダムなデータの場合、これは分散の2倍になりますが、順序が連続し、正の自己相関を持つデータの場合、これはずっと小さくなります。mssdは分散-自己相関の2倍なので、特定のラグの自己相関を見つけることも可能です。
Goldberg (2006)は、「トップ・ダウン」からの階層的な因子構造構成について説明した。  最初のアイデアは、あるレベルから次のレベルへの因子スコア相関によって組織化された1因子からnf因子までの連続した因子分析を行うことでした。  Waller (2007) は，スコアを求めずに成分についてこれを行う簡単な方法について議論した．  因子を階層的に組織化するために（Gorsuchからの）因子相関を使用すると，結果が多くの異なるレベルで組織化されるかもしれない．このアルゴリズムは，主成分（pca）または真の因子分析に適用できる．
Goldberg (2006) は，「トップ・ダウン」からの階層的な因子構造編成を説明した．  最初のアイデアは，あるレベルから次のレベルへの因子スコア相関によって組織化された1因子からnf因子までの連続した因子分析を行うことであった．  Waller (2007) は，スコアを求めずに成分についてこれを行う簡単な方法について議論した．  因子を階層的に組織化するために（Gorsuchからの）因子相関を使用すると，結果が多くの異なるレベルで組織化されるかもしれない．このアルゴリズムは，主成分（pca）または真の因子分析に適用できる．
Holzinger-Swineford (1937) は，一般因子と無相関グループ因子の2因子モデルを導入した．Holzingerのデータ・セットは、Joreskogによって例として使用された9 *9 行列と同様に、彼らの論文からのオリジナルの14 * 14 行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
<code>bestScales</code>は、特定の基準と最も相関のある項目/尺度から尺度を形成し、次に単位重み付けされた尺度を用いてホールドアウト標本で交差検証を行います。  これは、基本的なブートストラップ集計（バギング）手法またはK-foldクロス検証のいずれかを用いて、n.iter回繰り返されるかもしれません。したがって、この手法は<code>BISCUIT</code>（クロス検証され、単位重み付けされ、情報量が多く、透明性のあるベスト・アイテム・スケール）として知られています。  項目内容の辞書が与えられると、<code>bestScales<//code>は、基準相関によってソートし、項目内容を表示します。バギング（ブートストラップ集計）のオプションが含まれています。単位重み付けの代替は、基準とのゼロ次相関（交差検証）によって項目を重み付けすることです。この重み付きバージョンは、<code>BISCWIT</code>と呼ばれ、オプションの出力です。
<code>bestScales</code> は、特定の基準と最も相関のある項目/尺度から尺度を形成し、次に単位重み付けされた尺度を用いてホールドアウト標本でクロスバリデーションを行います。  これは、基本的なブートストラップ集計（バギング）技術またはK-foldクロス検証のいずれかを使用して、n.iter回繰り返されるかもしれません。したがって、この手法は<code>BISCUIT</code>（クロス検証され、単位重み付けされ、情報量が多く、透明性のあるベスト・アイテム・スケール）として知られています。  項目内容の辞書が与えられると、<code>bestScales<//code>は、基準相関によってソートし、項目内容を表示します。バギング（ブートストラップ集計）のオプションが含まれています。単位重み付けの代替は、基準とのゼロ次相関（交差検証）によって項目を重み付けすることです。この重み付きバージョンは<code>BISCWIT</code>と呼ばれ、オプションの出力です。
国際パーソナリティ項目プール（ipip.ori.org）から取られた25のパーソナリティ自己報告項目は、SAPA（Synthetic Aperture Personality Assessment）ウェブベースのパーソナリティ評価プロジェクトの一部として含まれている。  被験者2800人のデータは、尺度構成、因子分析、項目反応理論分析のための実証セットとしてここに含まれている。  さらに3つの人口統計学的変数（性別、学歴、年齢）も含まれている。このデータセットは非推奨であり、ユーザーは<code>bfi</code>を使うことが推奨される。
Synthetic Aperture Personality Assessment (SAPA)ウェブベースの性格評価プロジェクトの一環として、International Personality Item Pool (ipip.ori.org)から取られた25の性格自己報告項目が含まれている。  被験者2800人のデータは、尺度構成、因子分析、項目反応理論分析のための実証セットとしてここに含まれている。  さらに3つの人口統計学的変数（性別、学歴、年齢）も含まれている。このデータセットは非推奨であり、ユーザーは<code>bfi</code>を使うことが推奨されます。
例えば、2つのグループの年齢分布や学歴分布を表示する場合、それらを背中合わせにプロットするのが便利です。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotationへの適切な呼び出しによって実装されます。
bigCor は、変数を（size=size の）サブセットに分割し、すべてのサブセットの相関を求め、得られた行列を 1 つの大きな行列につなぎます。   cor と比較して速度が顕著に向上しています。  
biplot関数を<code>fa</code>、<code>fa.poly</code>、<code>principal</code>の出力に拡張します。因子スコアと因子負荷量を同じグラフにプロットします。  因子の数が2の場合、すべての因子の組がプロットされます。因子得点ヒストグラムは対角線上にプロットされます。入力は、<code>fa</code>、<code>principal</code>、または}code{linkfa.polyでscores=TRUEオプションを指定した結果のオブジェクトです。点は、他の基準に従って色付けされるかもしれません。
bifactor回転は、GPArotationパッケージのGPForthを呼び出して、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案するバリミン回転は、GPArotation への適切な呼び出しによって実装される。
四分木相関は、二変量正規性を仮定した2×2表から推定されるピアソン相関です。ポリコレ相関は、これを n x m 表に一般化します。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
N個の条件のすべてに同数のn人の被験者を無作為に割り当てることは、ブロック無作為化によって行うことができ、ブロック・サイズは実験条件の数である。独立変数の数と各IVの水準数が入力として指定される。出力はブロック無作為化計画である。
McDonald(1999)や項目応答理論の他の議論で使用されているデータセットの例では、法科大学院入学共通テスト（LSAT）の10項目（5項目×2セット）のデータ表が使用されています。  このデータセットには、元の表と、第1セット（図分類）と第2セット（討論）に対する1000人の被験者の回答が含まれている。
Rindskopf and Rose (1988) は、このデータ集合を使って確認的2次因子モデルを実証しています。  これは、階層構造と代替因子解を探索するための良い例のデータセットです。このデータセットには流動性知能と結晶性知能の測定値が含まれている。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframe列を数値に変換します。
John Schmid と John M. Leiman (1957)は、階層因子構造を二因子構造に変換する方法について論じています。Schmid.leiman は、対角上に共同体性を持つ 12 x 12 の相関行列です。これは減衰補正の効果を示すために使用できます。Chenら(2006)から2つのデータセットを追加しました。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換する。 r2cとcor2covは相関行列を共分散行列に変換する。d2tとt2dはコーエンのdをtに変換し、tをコーエンのdに変換する。
因子分析と主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとする。  別の構造として，変数が2次元空間の円の外周に一様に配置される円周構造がある．  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
因子分析の回転や主成分分析の解は、一般的に相関行列を単純構造として表現しようとする。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造がある。  このようなデータを作成するのは簡単で、影響やパーソナリティ構造の代替解を探索するのに有用である。
因子分析の回転や主成分分析の解は、一般的に相関行列を単純な構造として表現しようとする。  代替的な構造として魅力的なのは、変数が2次元空間の円の周囲に一様に配置された円周構造である。  このようなデータを作成するのは簡単で、影響やパーソナリティ構造の代替解を探索するのに有用である。
因子分析の回転や主成分分析の解は、一般的に相関行列を単純な構造として表現しようとする。  代替的な構造として魅力的なのは、変数が2次元空間の円の周囲に一様に配置された円周構造である。  このようなデータの生成は簡単であり、感情や性格の構造に関する代替解を探索するのに有用である。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最も適合する位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最も適合する位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
1s、0s、1sのn x c個のクラスタ定義行列（キー）、およびn x n個の相関行列、またはN x n個のデータ行列が与えられたとき、合成クラスタの相関を求めます。  キー行列は、手入力、クリップボードからのコピー（<code>read.clipboard</code>）、または<code>factor2cluster</code>や<code>make.keys</code>関数の出力として得ることができます。  <code>scoreItems</code>と同様の機能で、クラスタごとの項目相関も得られます。<code>scoreBy</code>は、<code>statsBy</code>を呼び出した後、個々の被験者に対してこれを行います。
<code>ICLUST</code>によって発見されたクラスタモデルは、元の相関行列にどの程度フィットしているでしょうか？  同様のアルゴリズム<code>factor.fit</code>が<code>VSS</code>にあります。この関数はICLUSTの内部的なものだが、より一般的な使い方もある。

一般に、クラスター・モデルは、複雑度1のVery Simple Structureモデルである。  つまり、すべての項目が1つの因子/クラスタだけを表すと仮定されます。クラスター適合は、このモデルが相関行列をどれだけよく再現するかの分析である。  クラスタ適合と因子適合という2つの適合の尺度が与えられます。  クラスター適合は、異なるクラスターを定義する変数が直交していると仮定します。  因子適合は、クラスター・モデルによって生成された負荷量を取り、すべてのクラスターに対するクラスター負荷量を求め、このやや複雑なモデルの適合度を測定する。  クラスタ負荷量は因子負荷量に似ていますが、同一ではないので、ここで見つかる因子適合と<code>factor.fit</code>で見つかる因子適合は似ているでしょう。   
n x n個の相関行列と、c個のクラスター上のn個の項目に対する-1,0,1個のクラスター重みのn x c個の行列が与えられたとき、各項目と各クラスターとの相関を求めます。  項目がクラスタの一部である場合、項目の重複を補正する。  <code>ICLUST</code>関数群の一部ですが、多くの項目分析の問題に役立ちます。
クラスター分析と因子分析は、より少ない数の（潜在）因子または（観察された）クラスターの観点から項目をグループ化するための手続きです。  クラスターのグラフィカルな表示は，一般にツリー構造を示すが，項目とクラスターの相関で表現することもできる．  

Cluster.plotは、クラスタ負荷量（例えば<code>ICLUST</code>から取得）または因子負荷量（例えば<code>fa</code>から取得）によって項目をプロットします。  クラスタ・メンバーシップは、前もって割り当てられてもよいし、各アイテムの最も高い（絶対的な）クラスタ・ローディングの観点から決定されてもよい。  

入力がクラス "kmeans "のオブジェクトの場合、クラスタ中心がプロットされる。
kmeansクラスタリング関数の出力は、クラスタメンバーシップのベクトルを生成します。  <code>score.items</code> と <code>cluster.cor</code> 関数はキーの行列を必要とします。

また、<code>ICLUST</code>解析の出力からキー行列を求めるために使用することもできる。  (<code>factor2cluster</code>関数を呼び出すことによって。
data.frameまたは行列が与えられたら、グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d統計量をr統計量に変換し、スチューデントのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
Cohenのカッパ (Cohen, 1960) および重み付きカッパ (Cohen, 1968) は，名義得点を使用する場合に2人の評定者の一致を見つけるために使用できる．  2人以上の評定者を使用する場合、ライトのカッパは単なる平均コーエン・カッパとなる。

weighted.κは（観察されたマッチの確率-期待されたマッチの確率）/（1-期待されたマッチの確率）である。  κは主対角線上のマッチだけを考慮する。  重み付きκは対角線外の要素も考慮する。
2つの行列の一致係数は、それぞれの値のクロス積を平方根で割ったものである。列がゼロ中心の場合、これは単なる相関である。列がスケール中立点を中心とする場合、これはコーエンのプロファイル相関である。距離の集合（街区、ユークリッド、ミンコフスキー）は、距離関数によって求めることができる。
医学や臨床心理学では、診断はカテゴリー化される傾向がある（誰かがうつ病かそうでないか、誰かが不安障害かそうでないか）。  これらの症状が併存することを併存性という。   診断カテゴリーによって、他の診断カテゴリーとの併存性の程度は異なる。  相関の観点からは、併存率は4重表の1つのセルにつけられた名前にすぎない。  したがって、別々の診断の確率と合同診断の確率を考慮することで、併存率を分析することが可能である。  これにより、ファイ相関、ユール相関、テトラコリック相関に必要な2×2の表が得られる。
因子分析や主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとする。  別の構造として，変数が2次元空間の円の外周に一様に配置される円周構造がある．  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
古典的テスト理論（CTT）は、すべてのテストが1つの因子と残差誤差で表現できる場合、4つ以上のテストは共属的に等価であると考える。  並列検定は，（通常2つの）検定が等しい因子負荷量を持つ特別なケースである．  タウ等価検定は，等しい因子負荷量を持つが，不均等な誤差を持つことがある．  共属検定は，因子負荷と誤差分散の両方で異なることがある．
2つの行列の一致係数は，それらの平方和の平方根で割ったそれぞれの値の積である．列がゼロ中心の場合，これは単なる相関である．列がスケール中立点を中心とする場合、これはコーエンのプロファイル相関である。距離の集合（街区、ユークリッド、ミンコフスキー）は、距離関数で求めることができる。
正規理論は相関の信頼区間を提供するが、これは個々の項目がMassively Missing at RandomであるSynthetic Aperality Assessment (SAPA)データでは特に問題となる。  ブートストラップ信頼区間は、Pearson相関、Spearman相関、Kendall相関、tetrachoric相関、polychoric相関、およびそれらの相関から作成された尺度について発見されます。相関行列と標本サイズが与えられると，正規理論による信頼区間が提供される．
相関行列は，構造を強調するために画像関数を用いてグラフィカルに表示することができる．  これは，明確な構造を持つ相関行列の構造を示すのに特に有用なツールである．  部分的には，因子分析や他の多変量解析技法を教えたり議論したりするためのグラフィックの教育的価値を意味する．
相関行列は，構造を強調するために画像関数を用いてグラフィカルに示すことができる．  これは、相関行列の構造を明確に示すのに特に有用なツールである。  部分的には，因子分析や他の多変量解析技法を教えたり議論したりするためのグラフィックの教育的価値を意図している．
因子分析は正定相関行列を必要とする。  残念ながら、欠損データの対削除や、<code>tetrachoric</code>または<code>polychoric</code>相関を使用する場合、すべての相関行列が正定値とは限りません。 cor.smoothは固有ベクトル（主成分）の平滑化を行います。  負の固有値は100 * eig.tolで置き換えられ，行列は再現され，cov2corを用いて強制的に相関行列に変換されます．
因子分析には，正定値相関行列が必要である．  残念ながら、欠損データのペアごとの削除や、<code>tetrachoric</code>または<code>polychoric</code>相関を使用する場合、すべての相関行列が正定値になるわけではありません。  負の固有値は100 * eig.tolで置き換えられ，行列は再現され，cov2corを用いて強制的に相関行列に変換されます．
RCoreのcov.wt関数はこの処理を行い、共分散行列または相関行列を返します。  cor.wt関数はサンプルサイズまたは標準誤差で重み付けを行い、デフォルトでは相関を返します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つまたは複数の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframe列を数値に変換します。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   r2c と cor2cov は相関行列を共分散行列に変換する。 d2t と t2d はコーエンの d を t に、t をコーエンの d に変換する。
相関(-1から1まで)を距離(0から2まで)に変換するマイナーなヘルパー関数。<i>d = √{(2(1-r))}</i>.
正規理論は、相関の信頼区間を提供しますが、これは、個々の項目がMassively Missing at RandomであるSynthetic Aperality Assessment (SAPA)データでは特に問題となります。  ブートストラップ信頼区間は、Pearson相関、Spearman相関、Kendall相関、tetrachoric相関、polychoric相関、およびそれらの相関から作成された尺度について発見されます。相関行列と標本サイズが与えられると，正規理論の信頼区間が提供される．
FIMLの共分散行列/相関行列を求めるために、lavaanパッケージの関数を利用します。  FIMLは、corの通常のペアワイズ削除オプションよりもはるかに遅いかもしれませんが、わずかに正確な推定値を提供します。
相関行列は、構造を強調するために image 関数を使用してグラフィカルに表示することができます。  これは、構造が明確な相関行列の構造を示すのに特に便利なツールです。  部分的には，因子分析や他の多変量解析技法を教えたり議論したりするためのグラフィックの教育的価値を意図している．
相関行列は，構造を強調するために画像関数を用いてグラフィカルに示すことができる．  これは、相関行列の構造を明確に示すのに特に有用なツールである。  部分的には、因子分析や他の多変量解析テクニックを教えたり議論したりするためのグラフィックの教育的価値を意味する。
cor関数は行列の相関を求めますが、確率値は報告しません。cor.testは相関を求めますが、一度に1組の変数の相関しか報告しません。corr.testはcorを使って完全データまたはペアワイズデータの相関を求め、サンプルサイズと確率値も報告します。対称行列の場合、生の確率が対角線の下に、多重比較で調整された相関が対角線の上に報告されます。x と y が異なる場合、デフォルトでは多重検定のために確率が調整される。corr.testとcorr.pの両方は、各相関について未加工の信頼区間と調整済み信頼区間を返す。
cor 関数は行列の相関を求めますが、確率の値は報告しません。cor.test は相関を求めますが、一度に1組の変数の相関のみを報告します。対称行列の場合、生の確率が対角線の下に、多重比較で調整された相関が対角線の上に報告されます。x と y が異なる場合、デフォルトでは多重検定のために確率が調整される。corr.testとcorr.pの両方は、各相関について未加工の信頼区間と調整された信頼区間を返す。
生の相関行列と信頼度のベクトルが与えられた場合、対角線上の減衰された相関を報告する。
Steiger (1980)は、相関行列の要素の2乗の合計、またはFisher z scoreに相当するものが、値が0であるという帰無仮説（すなわち、恒等行列の要素）の下ではカイ2乗として分布することを指摘しました。  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970) は，行列間の差の検定も検討した．
Bartlett (1951) は，Rが恒等行列であれば，-ln(det(R)*(N-1 - (2p+5)/6) がカイ2乗として分布することを提案した．  残差相関がすべてゼロであることを検定するのに有用である．Kaiser-Meyer-Olkin 検定とは対照的である．
Steiger (1980) は，相関行列の要素の2乗の合計，またはFisher z スコアに相当するものが，値が0（つまり，恒等行列の要素）であるという帰無仮説のもとで，カイ2乗として分布することを指摘した．  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970) は、行列間の差の検定も検討した。
Steiger (1980) は，相関行列の要素の2乗の合計，またはFisher z スコアに相当するものが，値が0であるという帰無仮説（すなわち，恒等行列の要素）のもとで，カイ2乗として分布することを指摘した．  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970) は、行列間の差の検定も検討した。
Steiger (1980) は，相関行列の要素の2乗の合計，またはFisher z スコアに相当するものが，値が0であるという帰無仮説（すなわち，恒等行列の要素）のもとで，カイ2乗として分布することを指摘した．  これは、1つの行列の相関がゼロと異なるかどうかを調べる場合や、2つの行列を比較する場合に特に有用である。Jennrich (1970)は、行列間の差の検定も検討した。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最も適合する位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
サーカディアンデータは24時間の位相で周期的である。これらの関数は、最もよくフィットする位相角（cosinor）、円平均、サーカディアンデータとの円相関、および円相関による線形を求める。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくとよい。  これは、SAPAタイプの分析を行うときに特に有用である。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられる。
相関行列または生データの行列またはデータフレームが与えられた場合、重回帰を求め、x変数の集合の関数としてy変数の集合を関連づけるパス図を描きます。  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求めます。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する、些細ですが便利な関数です。reflectは、因子分析または主成分分析の出力を、1つまたは複数の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframeの列を数値に変換します。
行動の力学（Atkinson and Birch, 1970, Revelle, 1986）のような動的動機づけモデルは、単純な微分（行列）方程式のペアとして再パラメータ化することができます（Revelle, 1986, 2008）。この関数は、CTAの動的側面をシミュレートする。  CTAモデルについては、Revelle and Condon (2015)で詳述されている。
行動の力学（Atkinson and Birch, 1970, Revelle, 1986）のような動的動機づけモデルは、単純な微分（行列）方程式のペアとして再パラメータ化することができる（Revelle, 1986, 2008）。この関数は、CTAの動的側面をシミュレートする。  CTAモデルについては、Revelle and Condon (2015)で詳しく議論されている。
data.frameまたは行列が与えられて、グループ化変数に依存する各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d 統計量を r 等価値に変換し，Student の t 統計量と関連する p 値を報告し，グループ化変数の両方の値の統計量を返す．  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループのセントロイド間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
データ集合を表現する多くの方法の中で，1つはグループ変数の各値での密度プロットで，もう1つは複数の変数のバイオリン・プロットである．  密度プロットは、効果量を示すために、異なるグループの密度を示します。バイオリン・プロットは、箱ひげ図に似ていますが、実際の分布を示します。中央値、25パーセンタイル線、75パーセンタイル線が表示に追加されます。グループ化変数が指定されると、violinByは各変数と各グループについてviolin plotを描画します。データポイントも描画されます。
Rには多くの要約統計量がありますが、この関数は古典的な心理測定における尺度構成や項目分析に最も役立つものを提供します。Rangeは、データ集合の最初のパス、コーディングエラーのチェックに最も役立ちます。  
グループ化変数による基本的な要約統計量をレポートする。  グルーピング変数が何らかの実験変数で、データをプロットするために集計する場合に便利です。  byと<code>describe</code>のラッパーです。
グループ化変数による基本的な要約統計量を報告する。  グルーピング変数が何らかの実験変数で、プロットのためにデータが集計される場合に有用である。  byと<code>describe</code>のラッパーです。
Rには多くの要約統計量がありますが、この関数は古典的な心理測定における尺度構成や項目分析に最も役立つものを提供します。Rangeは、データセットの最初のパスで、コーディングエラーをチェックするために最も有用です。  
この関数は、古典的な心理測定における尺度構成や項目分析に最も役立つものを提供します。Rangeは、データセットの最初のパスで、コーディングエラーをチェックするために最も有用である。  
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描くためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの機能の一部の代替として使用されます。
McDonaldは、検定の一般的な因子飽和度の推定値として係数ωを提案しています。  ωを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid Leiman変換を行い、ωを求めることです。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらにもう1つの方法は、WallerのSchmid-Leimanを直接行うことである。
2つの行列の合同係数は、それぞれの値の積を平方根で割ったものである。列がゼロ中心であれば、これは単なる相関である。列がスケール中立点を中心とする場合、これはコーエンのプロファイル相関である。距離関数により、距離の集合（街区、ユークリッド、ミンコフスキー）を求めることができる。
2つの正規分布上のxとyのカットポイントに基づいて4つの領域に分割された相関楕円のグラフィック。  これもレイアウト関数の使用例である。テトラコリックがどのように機能するかを示すために、2変量密度プロットを描く。
2つの正規分布上のxとyのカットポイントに基づいて4つの領域に分割された相関楕円のグラフィック。  これはレイアウト関数の使用例でもある。テトラコリックスの働きを示す2変量密度プロットを描く。
n個の異なる値を持つ変数xがあるとすると、各変数の存在(1)または非存在(0)を0/1にコード化したn個の新しいダミー・コード化変数を作成します。  典型的なアプリケーションは、大学の専攻のベクトルからダミー・コード化された大学の専攻を作成することであろう。グループごとにカテゴリを組み合わせることもできる。  デフォルトでは、xのNA値はNAとして返される（2017/10/20追記）
Dwyer (1937) は、因子拡張の手法を導入し、Thurstoneからの8つの認知変数を使用しました。  これは彼の論文で使用されたデータ集合の例です。
 eigen.loadingsは、固有値の平方根を掛けた固有ベクトルのより典型的なメトリックに変換します。   これにより、princompまたはeigenを使用した場合に、擬似的な因子負荷量を求めることができます。<br><code>principal</code>を使って主成分分析を行う場合は、このルーチンは必要ありません。
相関を教えるには、相関を反映するために平均の周りに楕円を描くのが便利です。  John Foxのcarパッケージの楕円関数のこのバリエーションがそうです。  入力は2つのベクトルか行列かdata.frameです。  後者の場合、変数の数が &gt;2であれば、楕円は<code>pairs.panel</code>関数で行われます。エリプスは既存のプロットに追加することもできます。ミンコフスキー関数は、一般化された楕円として含まれます。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013)が提案するバリミン回転は、GPArotationへの適切な呼び出しによって実装される。
平均と信頼区間をプロットするRの多くの関数の1つ。必要であれば、棒グラフを使用することもできます。  分布を要約するためにboxplotなどの関数と組み合わせることもできる。  平均と標準誤差は<code>describe</code>を使って生データから計算されます。あるいは、平均±1標準偏差のプロットを描くこともできる。
平均と信頼区間をプロットするRの多くの関数の1つです。  主に、複数の標本から再現される確率を示すためのデモンストレーションを目的としています。  分布を要約するためにboxplotなどの関数と組み合わせることもできる。  各グループの平均と標準誤差は、<code>describeBy</code>を使って計算されます。
平均と信頼区間をプロットするRの多くの関数の1つです。必要であれば、棒グラフを使用することもできます。  また、分布を要約するためにboxplotなどの関数と組み合わせることもできます。  平均と標準誤差は<code>describe</code>を使って生データから計算されます。あるいは、平均±1標準偏差のプロットを描くこともできます。
データの2つのベクトル（XとY）が与えられたら、平均をプロットし、XとYの両方向の標準誤差を示す。
<code>describe</code>、<code>describeBy</code>、<code>statsBy</code>、または<code>bestScales</code>のデータを使用して、異なるグループまたは変数のエラーバーを持つドット・チャートを見つけることができます。
行列またはデータフレーム、データが与えられた場合、グループ化変数に基づいて統計量を求め、グループ化変数の各値についてエラーバー付きのxおよびy平均をプロットします。  データが対になっている場合（例えば男女別）、すべての変数について2つのグループの平均とエラーバーをプロットする。
構造方程式モデリング(SEM)は、多変量構造を確認するための強力なツールで、lavaan、sem、またはOpenMxパッケージによってよく実行されます。SEMモデルは確認的であるため、特定のモデルを検定します。  一方、探索的構造方程式モデリング（ESEM）は、より探索的なアプローチをとります。  因子拡張を使用することで、ある変数集合（X）の因子を別の変数集合（Y）の変数空間に拡張することができます。この手法を用いて、通常のSEMと同じように、潜在変数の2つの集合の間の相関を推定することができます。  探索的因子分析（EFA）に基づくこのアプローチは、探索的構造方程式モデリングを行うための迅速で簡単なアプローチを提供します。  
構造方程式モデリング（SEM）は、多変量構造を確認するための強力なツールであり、lavaan、sem、またはOpenMxパッケージによってよく実行されます。SEMモデルは確認的であるため、特定のモデルを検定します。  一方、探索的構造方程式モデリング（ESEM）は、より探索的なアプローチをとります。  因子拡張を使用することで、ある変数集合（X）の因子を別の変数集合（Y）の変数空間に拡張することができます。この手法を用いて、通常のSEMと同じように、潜在変数の2つの集合の間の相関を推定することができます。  探索的因子分析（EFA）に基づくこのアプローチは、探索的構造方程式モデリングを行うための迅速で簡単なアプローチを提供します。  
因子分析または主成分分析の結果は、通常、各因子の主要負荷量の観点から解釈されます。  これらの構造は、負荷量の表として表現されるか、絶対値 &gt; いくつかのカット・ポイントを持つすべての負荷量がエッジ（パス）として表現されるグラフとして表現されます。<code>fa.diagram</code>は、様々な<code>diagram</code>関数を用いて図を描きます。<code>fa.graph</code>は、外部プロット用のドットコードを生成します。  <code>fa.rgraph</code>はRgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。<code>het.diagram</code>は、異なるレベルの因子/尺度解の「ヘテラーキー」図を描きます。
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、より良い方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は，n.iter &gt; 1でfaによって求められます．
因子負荷量の2つのセットが与えられた場合，それらの一致度（ベクトル余弦）を報告する．最初に報告したのはBurt (1937,1 1948)であるが、これは因子一致のタッカー指数としてよく知られている。Cohenのプロファイル類似度も見られることがある。
因子分析または主成分分析の結果は、通常、各因子の主要負荷量の観点から解釈される。  これらの構造は，負荷量の表として表現されるか，絶対値 &gt; いくつかのカット・ポイントを持つすべての負荷量がエッジ（パス）として表現されるグラフとして表現される．<code>fa.diagram</code>は、様々な<code>diagram</code>関数を用いて図を描きます。<code>fa.graph</code>は外部プロット用のドットコードを生成します。  <code>fa.rgraph</code>はRgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。<code>het.diagram</code>は、異なるレベルの因子/尺度解の "heterarchy "図を描きます。
Dwyer (1937) は、オリジナルの分析に含まれていない変数の因子負荷量を見つける手法を導入しました。  これは基本的に，因子スコアとの拡張変数の減衰されない相関を見つけることである．  因子信頼性を補正しない代替法が、Gorsuch (1997)によって提案されました。両方のオプションは、新しい変数への拡張を伴う探索的因子分析の応用です。また，因子空間での変数の有効性を見つけるのにも有用である．  
Dwyer (1937) は、オリジナルの分析に含まれていない変数の因子負荷量を見つける方法を紹介しました。  これは基本的に，因子スコアとの拡張変数の減衰されない相関を見つけることである．  因子信頼性を補正しない代替法が、Gorsuch (1997)によって提案されました。両方のオプションは、新しい変数への拡張を伴う探索的因子分析の応用です。また，因子空間での変数の有効性を見つけるのにも有用である．  
因子分析または主成分分析の結果は，通常，各因子の主要負荷量の観点から解釈される．  これらの構造は，負荷量の表として表現されるか，絶対値 &gt; いくつかのカット・ポイントを持つすべての負荷量がエッジ（パス）として表現されるグラフとして表現される．<code>fa.diagram</code>は、様々な<code>diagram</code>関数を用いて図を描きます。<code>fa.graph</code>は外部プロット用のドットコードを生成します。  <code>fa.rgraph</code>はRgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。<code>het.diagram</code>は、異なるレベルの因子/尺度解の "heterarchy "ダイアグラムを描きます。
 合理的、要因的、または経験的な手段によって尺度を構成する場合、互いに最も関連性の高い項目の内容（例えば、一連の項目の<code>fa.lookup<//code>の因子負荷量）や、ある特定の基準の集合（例えば、<code>bestScales<//code>）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準の相関によってソートし、項目内容を表示します。
因子分析解の中には、相関因子を生成し、それが因数分解されるものもあります。  解が1つの高次を持つ場合，ω関数が最も適切である．  しかし、複数の高次因子がある場合は、faMulti関数が低次因数分解を行い、その結果の相関行列を因数分解します。  マルチレベル因子ダイアグラムも表示されます。
因子分析解の中には、相関因子を生成し、それが因数分解されるものもあります。  解が1つの高次の場合は、ω関数が最も適切です。  しかし、複数の高次因子がある場合、faMulti関数は低次因数分解を行い、その結果の相関行列を因数分解します。  複数レベルの因子図も表示されます。
fa.sortは、faまたはprincipal関数からの出力を受け取り、各因子の負荷量をソートします。  項目は最大の負荷量の順に配置されます。  fa.organizeは、列または行を再編成することができます。
データ行列または相関行列の因子または成分の数を決定する1つの方法は、連続する固有値の「scree」プロットを調べることです。  プロットの鋭い切れ目が、抽出すべき成分や因子の適切な数を示唆する。  「並列 "分析は、観察されたデータの因子のscreeと、元のデータと同じサイズのランダムなデータ行列の因子のscreeを比較する代替手法である。これは、連続データ、2値データ、多値データについて、ピアソン相関、4値相関、多値相関を用いて行うことができる。
データ行列または相関行列の因子または成分の数を決定する1つの方法は、連続する固有値の "scree "プロットを調べることである。  プロットの鋭い切れ目が、抽出すべき成分や因子の適切な数を示唆する。  「並列 "分析は、観察されたデータの因子のscreeと、元のデータと同じサイズのランダムなデータ行列の因子のscreeを比較する代替手法である。これは、連続データ、2値データ、多値データに対して、ピアソン相関、4値相関、多値相関を用いて行うことができる。
クラスター分析と因子分析は、より少ない数の（潜在）因子または（観察された）クラスターの観点から項目をグループ化する手順である。  クラスターのグラフィカル・プレゼンテーションは，一般にツリー構造を示すが，項目ごとのクラスター相関で表現することもできる．  

Cluster.plotは、クラスタ負荷量（例えば<code>ICLUST</code>から取得）または因子負荷量（例えば<code>fa</code>から取得）によって項目をプロットします。  クラスタ・メンバーシップは、前もって割り当てられてもよいし、各項目について最も高い（絶対的な）クラスタ・ローディングの観点から決定されてもよい。  

入力が "kmeans "クラスのオブジェクトの場合、クラスタ中心がプロットされる。
6年が経過し、これらの非推奨関数の使用を止める時が来ました！  これらの古い関数のすべての機能を含む<code>fa</code>を参照してください。  
潜在変数探索的因子分析(EFA)を行う多くの方法の中で、より良い方法の1つは、最小残差(minres)解を見つけるために最小2乗法(OLS)を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は、n.iter &gt;1でfaによって求められます。
fa.randomは、profileRパッケージのwprifm関数にインスパイアされたもので、平均値の被験者間差を除去し、ipsatizedデータの正規探索的因子分析を行います。  機能的には、これは因数分解の前にデータの一般因子を除去します。残差データ行列の非正定値性を防ぐために、各変数に非常に少量のランダムノイズが加えられます。これは被験者間効果を除去した後にfaを呼び出すだけです。すべての入力パラメータと出力オブジェクトの詳細な説明については、<code>fa</code>のヘルプファイルをお読みください。
因子分析または主成分分析の結果は、通常、各因子の主要負荷量の観点から解釈されます。  これらの構造は、負荷量の表として表現されるか、絶対値 &gt; いくつかのカットポイントを持つすべての負荷量がエッジ（パス）として表現されるグラフとして表現されます。<code>fa.diagram</code>は、様々な<code>diagram</code>関数を用いて図を描きます。<code>fa.graph</code>は外部プロット用のドットコードを生成します。  <code>fa.rgraph</code>はRgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。<code>het.diagram</code>は、異なるレベルの因子/尺度解の「ヘテラーキー」図を描きます。
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、より良い方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は、n.iter &gt; 1でfaによって求められます。
fa.sortは、faまたはprincipal関数からの出力を受け取り、各因子の負荷量をソートします。  項目は最大の負荷量の順に配置されます。  fa.organizeでは、列や行を再編成することができます。
カイ2乗およびその他の適合度統計量は、相関行列に対する因子または成分モデルの適合度に基づいて求められます。  これらの統計量は、通常、最尤解に関連していますが、最小残差解（OLS）、主軸解、主成分解でも求めることができます。  主にこれらの関数内から呼び出されますが、factor.statsは単独で使用することもできます。要因の妥当性と有効性の測定は，Grice, 2001の論文に従う．
探索的因子分析と項目反応理論は、バイナリ・データの非常に異なるモデルのように見えますが、項目の困難さと項目の識別について同等のパラメータ推定を提供することができます。  2値項目または多値項目のデータ集合の4値相関または多値相関は，最小残差または最尤因子分析を用いて因子分析され，その結果の負荷量が項目識別パラメータに変換される．  項目の因子負荷と組み合わされた四分位相関/多分位相関からのタウ・パラメータは、項目の困難性を推定するために使用されるかもしれない。
データを2つのレベル（たとえば、個人といくつかのグループ化変数のセット）で調査する場合、基本的な記述統計量（グループごとの平均、sds、ns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルでの相関の行列を、グループ内の相関とグループ間の相関に分解する能力です。
潜在変数探索的因子分析（EFA）を行う多くの方法の中で、よりよい方法の1つは、最小残差（minres）解を見つけるために最小2乗法（OLS）を使用することです。これは、行儀の悪い行列であっても、最尤法に非常によく似た解を生成します。minresのバリエーションとして、重み付き最小2乗法（WLS）があります。おそらく最もオーソドックスな手法は、主軸（PAF）であろう。  相関行列の固有値分解が行われ，各変数の共分散性が最初のn因子によって推定される．これらの共同性が対角線上に入力され，sum(diag(r))が変化しなくなるまで，この手順が繰り返される．   さらにもう1つの推定手順は，最尤法である．お行儀のよい行列では，最尤因子分析（fa または factanal 関数のいずれか）がおそらく好ましい．  負荷量と因子間相関のブートストラップ信頼区間は，n.iter &gt; 1でfaによって求められます．
データ行列または相関に対する2つの因子分析またはpca解が与えられたとき，2つの解の類似性は何か．これは因子相関と因子一致によって見つけられるかもしれません。  因子相関は，因子重みと相関行列の行列積によって求められ，因子スコア相関がどうなるかの推定値である．  因子一致度（別名タッカー係数またはバート係数）は，因子負荷量のベクトルの余弦である．
因子負荷量の2つのセットが与えられたとき，それらの一致度（ベクトルの余弦）を報告する．最初に報告したのはBurt (1937,1 1948)であるが，これは因子一致のTucker 指数としてよく知られている．Cohenのプロファイル類似度も見られるかもしれない。
基本的な因子または主成分モデルは，相関行列または共分散行列が，因子負荷行列とその転置行列との積によって再現されるというものである．F'FまたはP'P。  適合度の1つの簡単な指標は、1-残差の2乗和/元の相関の2乗和です。この適合度指標は、<code>VSS</code>や<code>ICLUST</code>などで使われている。
6年後、これらの非推奨関数の使用をやめる時が来ました！  これらの古い関数のすべての機能を含む<code>fa</code>をご覧ください。  
基本的な因子または主成分モデルは、相関行列または共分散行列が、因子負荷行列とその転置行列との積によって再現されるというものです。  この再現行列を求めます。  <code>factor.fit</code>、<code>VSS</code>、<code>ICLUST</code>などで使われます。
6年経った今、これらの非推奨関数の使用を止める時が来た！  これらの古い関数のすべての機能を含む<code>fa</code>をご覧ください。  
クラスター分析と因子分析は、より少ない数の（潜在）因子または（観測された）クラスターの観点から項目をグループ化するための手続きです。  クラスターのグラフィカルな表現は、一般的にツリー構造を示しますが、クラスター間の項目相関で表現することもできます。  

Cluster.plotは、クラスタ負荷量（例えば<code>ICLUST</code>から取得）または因子負荷量（例えば<code>fa</code>から取得）によって項目をプロットします。  クラスタ・メンバーシップは、前もって割り当てられてもよいし、各アイテムの最も高い（絶対的な）クラスタ・ローディングの観点から決定されてもよい。  

入力がクラス "kmeans "のオブジェクトの場合、クラスタ中心がプロットされる。
基本的な因子または主成分モデルは，相関行列または共分散行列が，因子負荷行列とその転置行列との積によって再現されるというものである．  元の行列から再現行列を引いた残差を求めます。  <code>factor.fit</code>、<code>VSS</code>、<code>ICLUST</code>などで使用されます。
因子行列や成分行列が与えられると、特定の変数の組を任意に回転させるのに便利なことがあります。  これは、より強力な回転パッケージGPArotationを補足するもので、通常とは異なる回転を行う特定の要件に対応するものです。
因子分析の基本的な問題は、モデルが構造レベルで定義されているにもかかわらず、データレベルでは不確定であるということです。この因子不確定性の問題は，因子スコアを推定する代替方法につながるが，どれも理想的なものではない．  Grice (2001)に従うと、ここでは4つの異なる方法が利用可能である。
カイ2乗および他の適合度統計量は，相関行列への因子または成分モデルの適合に基づいて求められる．  これらの統計量は、通常、最尤解に関連しますが、最小残差（OLS）、主軸、主成分解でも求めることができます。  主にこれらの関数内から呼び出されますが、factor.statsは単独で使用することもできます。要因の妥当性と有効性の測定は，Grice, 2001の論文に従う．
6年後、これらの非推奨関数の使用をやめる時が来ました！  これらの古い関数のすべての機能を含む<code>fa</code>を参照してください。  
因子負荷行列または主成分負荷行列が与えられた場合、各項目を、その項目の最大の（符号付き）因子負荷に対応するクラスタに割り当てます。  本質的に、これはクラスタ定義への非常に単純な構造アプローチであり、ほとんどの人が実際に行っていることに対応します：各項目について最大の負荷量を強調し、残りを無視します。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、JennrichとBentler (2011)によって導入された回転を実装しています。promaxは、HendricksonとWhite (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、その名前で呼び出すのが簡単です。  Ertl (2013) が提案するバリミン回転は、GPArotation への適切な呼び出しによって実装されます。
因子回転アルゴリズムの汚い小さな秘密は、局所最小の問題である（Nguyen and Waller,2022）。  その論文のアイデアに従い、我々は複数のランダムな再スタートを許容し、そして大域的な最適解を返す。  <code>fa</code>関数の一部として使用されますが、独立した関数としても利用できます。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   r2c と cor2cov は相関行列を共分散行列に変換する。 d2t と t2d はコーエンの d を t に、t をコーエンの d に変換する。他の変換は <code>cohen.d</code> を参照。
r2dは相関を効果量(Cohenのd)に、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換する。 r2cとcor2covは相関行列を共分散行列に変換する。
lm などからの数式入力は、標準的な構文を使って、媒介項、2次項、部分項を含むように拡張することができます。これは、<code>setCor</code>と<code>mmediate</code>で使用されます。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する、些細ですが便利な関数です。reflectは、因子分析または主成分分析の出力を、1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframe列を数値に変換します。
r2dは相関を効果量（Cohenのd）に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換する。chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻す。r2cとcor2covは相関行列を共分散行列に変換する。
Garcia, Schmitt, Branscombe, and Ellemers (2010) は、認知された性差別が、差別に抗議するイングループメンバーに対する女性の反応に対する怒りや好感に与える影響について、129人の被験者のデータを報告している。このデータセットは、Hayes (2013 and 2018)による「抗議」データセットとしても使用されている。  これは、回帰における媒介と中庸の有用な例である。また，交互作用のプロットの例としても使用できる．
幾何平均は，非正規分布，すなわち，幾何分布を記述するのに有用である．
テストの信頼性の8つの代替推定は、Guttman (1945)によって議論された6つ、ten Berge and Zergers (1978)によって議論された4つ（<i>μ_0 ... μ_3）</i>、および<i>β</i>（最悪のスプリット・ハーフ、Revelle, 1979）、Bentler and Woodward (1980)によって議論されたglb（最大最小境界）、および<i>ω_h</i>と<i>ω_t</i>（McDonald, 1999; Zinbarg et al、2005).スプリットハーフの最大値と最小値はブルートフォースかサンプリングで見つける。
最大下限値は「教育テスト問題」を解決する。すなわち，テストの信頼性はどの程度か，という問題である（この問題については<code>guttman</code>を参照）．テストの信頼性には多くの推定値があるが（Guttman, 1945）、そのほとんどはテストの真の信頼性を過小評価している。

与えられた項目の共分散行列 C に対して、この関数は Rcsdp パッケージの csdp 関数を用いて合計得点の信頼性の最大下界を求める。
テストの信頼性の8つの代替推定値には、Guttman (1945) によって議論された6つ、ten Berge and Zergers (1978) によって議論された4つ (<i>μ_0 ... μ_3)</i> 、および<i>β</i> (the worst split half, Revelle, 1979)、Bentler and Woodward (1980) によって議論されたglb (greatest lowest bound)、および<i>ω_h</i>と<i>ω_t</i> (McDonald, 1999; Zinbarg et al...、2005).スプリットハーフの最大値と最小値は、総当たりまたはサンプリングによって求められる。
Gleser, Cronbach and Rajaratnam (1965) は，一般化可能性理論の導入の一部として，分散成分とその比率の推定について議論している．  これは彼らの "完全にマッチしたG研究のための例示データ "の適応である（表3）。  12人の患者が6つの症状について2人の判定者から評価される。  分散成分がANOVAから導出される．
Gorsuch (1997) は，古典的なDwyer (1937) 因子拡張手法の代替を提案します．  このデータ集合は、その論文から取られたものです。  correct=TRUE オプションの有無で<code>link{fa.extension}</code>を比較するのに便利です。  
テストの信頼性の8つの代替推定は、Guttman (1945)によって議論された6つ、ten Berge and Zergers (1978)によって議論された4つ（<i>μ_0 ... μ_3）</i>、および<i>β</i>（最悪の分割半分、Revelle, 1979）、Bentler and Woodward (1980)によって議論されたglb（最大最小境界）、および<i>ω_h</i>と<i>ω_t</i>（McDonald, 1999; Zinbarg et al、2005).スプリットハーフの最大値と最小値は、総当りかサンプリングで見つける。
Harman (1967)によって報告された5つの古典的なデータ集合は、Holzingerから取られた9つの心理（認知）変数とBurtから取られた8つの感情変数です。他の2つは、社会経済と政治のデータセットです。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されています。
Harman (1967)によって報告された5つの古典的なデータセットは、Holzingerから取られた9つの心理的（認知的）変数とBurtから取られた8つの感情的変数である。他の2つは、社会経済的および政治的データセットである。さらに、8つの身体的変数。  これらの5つはすべて、さまざまな因数分解アルゴリズムのテストとデモンストレーションに使用されている。
調和平均は、単に逆数の算術平均の逆数である。
data.frame、行列、テキストオブジェクトの最初と最後のn行を表示する簡単な方法。  <code>head</code> と <code>tail</code> または <code>View</code> を呼び出すだけです。
data.frame、行列、テキストオブジェクトの最初と最後のn行を表示する簡単な方法。  <code>head</code> と <code>tail</code> または <code>View</code> を呼び出すだけです。
因子分析または主成分分析の結果は、通常、各因子の主要な負荷量の観点から解釈されます。  これらの構造は、負荷量の表として表現されるか、絶対値 &gt; いくつかのカット・ポイントを持つすべての負荷量がエッジ（パス）として表現されるグラフとして表現されます。<code>fa.diagram</code>は、様々な<code>diagram</code>関数を用いて図を描きます。<code>fa.graph</code>は、外部プロット用のドットコードを生成します。  <code>fa.rgraph</code>はRgraphvizパッケージ（利用可能な場合）を使用してグラフを描画します。<code>het.diagram</code>は、異なるレベルの因子/尺度解の "heterarchy "ダイアグラムを描きます。
行列またはdata.frameを与えると、各変数のヒストグラムを「行列」形式で作成します。各プロットに正規適合と密度分布を含める。

行と列の数が指定されるか、計算される。
Holzinger-Swineford (1937) は，一般因子と相関のないグループ因子の2因子モデルを導入した．Holzingerのデータ集合は、彼らの論文のオリジナルの14 * 14 行列と、Joreskogが例として用いた9 * 9 行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
クラス内相関は、評定者の信頼性を研究する際に、関連性の尺度として使用される。  Shrout and Fleiss (1979) は、特定の実験デザインに依存する6つの異なる推定を概説している。すべてが実施され、信頼限界が与えられる。  lmerは欠損値を許す。
一般的なデータ削減手法は、ケース（被験者）をクラスタ化することである。あまり一般的ではありませんが、心理学研究で特に有用なのは、項目（変数）をクラスタ化することです。これは因子分析の代替と考えられ、より単純なモデルに基づきます。クラスター・モデルは、変数間の相関は、各項目が最大1つのクラスターに負荷することを反映し、それらのクラスターに負荷する項目は、そのクラスターへのそれぞれの負荷量の関数として相関し、異なるクラスターを定義する項目は、それぞれのクラスター負荷量とクラスター間相関の関数として相関するというものである。本質的に、クラスター・モデルは、複雑さ1の非常に単純な構造因子モデルである（<code>VSS</code>を参照）。

この関数は、iclust アルゴリズムを適用して項目を階層的にクラスタリングし、複合尺度を形成します。係数 alpha と beta が新しいクラスタで増加する場合，クラスタは結合される．

アルファ（平均分割半相関）とベータ（最悪の分割半相関）は、テストの信頼性と一般的な因子飽和の推定値です。  (マクドナルドの係数 <i>omega hierarchical</i> および <i>omega total</i> を推定する <code>omega</code> 関数も参照してください)
一般的なデータ削減テクニックは、ケース（被験者）をクラスタリングすることです。あまり一般的ではありませんが、心理学研究で特に有用なのは、項目（変数）をクラスタ化することです。これは、より単純なモデルに基づく因子分析の代替と考えることができる。クラスター・モデルは、変数間の相関は、各項目が最大1つのクラスターに負荷することを反映し、それらのクラスターに負荷する項目は、そのクラスターへのそれぞれの負荷量の関数として相関し、異なるクラスターを定義する項目は、それぞれのクラスター負荷量とクラスター間相関の関数として相関するというものである。本質的に、クラスター・モデルは、複雑さ1の非常に単純な構造因子モデルである（<code>VSS</code>を参照）。

この関数は、iclust アルゴリズムを適用して項目を階層的にクラスタリングし、複合尺度を形成します。係数 alpha と beta が新しいクラスタで増加する場合，クラスタは結合される．

アルファ（平均分割半相関）とベータ（最悪の分割半相関）は、テストの信頼性と一般的な因子飽和の推定値です。  (マクドナルド係数 <i>omega hierarchical</i> および <i>omega total</i> を推定する <code>omega</code> 関数も参照してください)。
<code>ICLUST</code>アルゴリズムの中枢。  <code>ICLUST</code>から呼び出される。
<code>ICLUST</code>によって決定されたクラスタ構造が与えられた場合、psychパッケージのグラフィック関数を用いてグラフィック構造図を作成する。 <code>ICLUST</code>の出力をより正確に記述するためのドットコードを作成するには、<code>ICLUST.graph</code>を用いる。Rgraphvizが正常にインストールされていれば、<code>ICLUST.rgraph</code>を使うこともできる。
<code>ICLUST</code>によって決定されたクラスタ構造が与えられたら、<code>ICLUST</code>出力を記述するドットコードを作成する。  ドットコードを使用するには、https://www.graphviz.org/ Graphvizか市販のビューア（OmniGraffleなど）を使用する。  この関数はRgraphvizを使用する<code>ICLUST.rgraph<//code>と類似している。
<code>ICLUST</code>によって決定されたクラスター構造が与えられた場合、Rgraphvizを使って直接rgraphicを作成する。 <code>ICLUST</code>出力をより正確に記述するドットコードを作成するには、<code>ICLUST.graph</code>を使う。  オプションとして、ドットコードも生成され、ファイルに保存される。ドットコードを使用するには、https://www.graphviz.org/ Graphviz または市販のビューア（OmniGraffleなど）を使用する。
クラスター分析または因子分析の負荷量行列が与えられたとき、各列の負荷量の（絶対）サイズによって項目をソートする。  ICLUST および SAPA 分析の一部として使用される。列は
クラスター分析または因子分析の負荷量行列が与えられた場合，各列の負荷量の（絶対）サイズによって項目を並べ替える．  ICLUSTおよびSAPA分析の一部として使用される。で列を並べ替える．
構造方程式モデリング（SEM）は、多変量構造を確認するための強力なツールであり、lavaan、sem、またはOpenMxパッケージによってよく実行されます。SEMモデルは確認的であるため、特定のモデルを検定します。  一方、探索的構造方程式モデリング（ESEM）は、より探索的なアプローチをとります。  因子拡張を使用することで、ある変数集合（X）の因子を別の変数集合（Y）の変数空間に拡張することができます。この手法を用いて、通常のSEMがそうであるように、潜在変数の2つの集合の間の相関を推定することができます。  探索的因子分析（EFA）に基づいて、このアプローチは、探索的構造方程式モデリングを行うための迅速で簡単なアプローチを提供します。  
限定された数の回答カテゴリ（たとえば、態度項目）を持つデータでは、各回答カテゴリを幅 w を持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の四分位値を線形補間することが有用です。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
限られた数の回答カテゴリー（例えば、態度項目）を持つデータでは、各回答カテゴリーを幅wを持つ範囲として扱い、中央値、四分位値、または中央値回答内の任意の分位値を線形補間することが有用である。   
項目反応理論では、個人の能力（θ）と項目の難易度（diff）パラメータを推定することで、項目に対する個人の反応をモデル化する。  これは、このモデル化手順を表現する初期の粗雑な試みです。よりよい手順は、<code>irt.fa</code>を使用することです。
項目反応理論では、個人の能力（θ）と項目の困難さ（diff）パラメータを推定することによって、項目に対する個人の反応をモデル化します。  これは、このモデル化手順を捕らえる初期の粗雑な試みです。よりよい手順は、<code>irt.fa<//code>を使用することです。
項目反応理論では、個人の能力（θ）と項目の困難さ（diff）パラメータを推定することによって、項目に対する個人の反応をモデル化します。  これは、このモデル化手順を捕らえる初期の粗雑な試みです。よりよい手順は、<code>irt.fa<//code>を使うことである。
非常に粗雑で予備的なIRTプログラムへのステップです。これらの2つの関数は、項目の難易度と識別パラメータを推定します。  よりよい手順は、<code>irt.fa<//code>またはltmパッケージを使用することである。
探索的因子分析と項目反応理論は、バイナリデータの非常に異なるモデルのように見えますが、項目困難度と項目識別の等価なパラメータ推定を提供することができます。  2値項目または多値項目のデータ集合の4値相関または多値相関は、最小残差または最尤因子分析を用いて因子分析され、その結果の負荷量は項目識別パラメータに変換される。  項目の因子負荷と組み合わされた四分位相関/多分位相関からのタウ・パラメータは、項目の困難さを推定するために使用されるかもしれない。
非常に粗雑で予備的なIRTプログラムへのステップ．これらの2つの関数は、項目の困難さと識別パラメータを推定します。  よりよい手順は、<code>irt.fa</code> または ltm パッケージを使うことである。
項目反応理論は、個人の能力(θ)と項目困難度(diff)パラメータを推定することにより、項目に対する個人の反応をモデル化する。  これは、このモデリング手順を理解するための初期の粗雑な試みです。よりよい手順は、<code>irt.fa</code>を使用することである。
能力テストを分析するとき、潜在特性の関数として、注意散漫の選択肢がどのように変化するかを考慮することが重要である。  簡単なグラフィカル・ソリューションは、複数の項目から発見された潜在特性の値に対して、回答の支持頻度をプロットすることです。良い項目は、潜在特性が増加するにつれて、ディストラクターの確率が減少し、キーとなる答えが増加するものです。
<code>irt.fa</code>は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論(IRT)のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code>は尺度のリストをスコア化します。
探索的因子分析と項目反応理論は、バイナリデータの非常に異なるモデルのように見えますが、項目の困難さと項目の識別について同等のパラメータ推定を提供することができます。  2値項目または多値項目のデータ集合の4値相関または多値相関は、最小残差または最尤因子分析を用いて因子分析され、その結果の負荷量は項目識別パラメータに変換されます。  項目の因子負荷と組み合わされた四分位相関/多分位相関からのタウパラメータは、項目の困難性を推定するために使用されるかもしれない。
<code>irt.fa</code>は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論(IRT)パラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見された因子と同じ数の得点が得られます。<code>scoreIrt.2pl</code> は尺度のリストをスコア化します。
<code>irt.fa</code> は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論 (IRT) のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見された因子と同じ数の得点が得られます。<code>scoreIrt.2pl</code>はスケールのリストをスコア化します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つまたは複数の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframe列を数値に変換します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericはカテゴリー/レベルであるdataframeの列を数値に変換します。
因子分析や主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
 合理的、要因的、または経験的な手段によって尺度を構成する場合、互いに最も関連性の高い項目の内容（例えば、一連の項目の<code>fa.lookup<//code>の因子負荷量）、またはある特定の基準の集合（例えば、<code>bestScales<//code>）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
因子分析と主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  代替構造として，変数が2次元空間の円の外周に一様に配置される円周構造がある．  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
尺度の妥当性は、尺度の項目数、平均相互相関、平均妥当性の関数として変化する。任意の特定の基準に対する尺度の有効性の漸近限界は、平均有効性を平均尺度内項目相関の平方根で割ったものです。  <code>predicted.validity</code>は、（keys.listで定義された）尺度の集合に対する予測有効性と、さまざまな基準に対する平均項目有効性を求めます。  

この関数は、尺度信頼度（<code>reliability</code>を使用）と平均項目妥当性（<code>item.validity</code>を使用）を求め（そして報告し）ます。
Kaiser (1958) は、因子負荷量を回転させる前に正規化し、回転後に非正規化することを提案しました。  GPArotationパッケージは（デフォルトでは）正規化しませんし、<code>fa</code>関数も正規化しません。さらに混乱を招くかもしれませんが、statsのvarimaxは正規化しますが、GPArotationのvarimaxは正規化しません。<code>kaiser</code>は正規化されていない解の出力を取り、正規化された解を報告します。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高い相関を持つ項目の内容（例えば、一連の項目の<code>fa.lookup<//code>の因子負荷量）、または特定の基準の集合（例えば、<code>bestScales<//code>）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは因子負荷または基準相関によってソートし、項目内容を表示します。
 <code>scoreItems</code>を使用して生データから、または<code>cluster.cor</code>を使用して相関行列から、複合尺度を形成して項目を採点する場合、以前はキー行列を作成する必要がありました。ほとんどのスコアリング関数は直接キーのリストを使用するので、これはもはや必要ありません。<code>make.keys</code>は単にキー行列を作るためのショートカットです。  キー行列は-1,0,1の nvar x nscales 行列で、各スケールのメンバーシップを定義します。項目は場所または名前で指定できます。
n個のアイテムが与えられた場合、最も類似したアイテムのペアまたはトリプレットから、n/2またはn/3のミニスケールまたはパーセルを作成します。  これらは、その後の尺度構築や多変量（因子など）分析の基礎として使用できる。
Henry Kaiser (1970) は、因子分析データ行列のサンプリング適正測定法（MSA）を導入した。Kaiser and Rice (1974) はそれを修正した。これは，元の相関の2乗と比較した「イメージ」行列の2乗要素の関数である．  全体のMSAと各項目の推定値が求められる。この指数は、カイザー・マイヤー・オルキン（KMO）指数として知られている。
data.frameまたは行列の各変数の歪度（skew）と尖度（kurtosis）を求めます。  e1071のスキューと尖度とは異なり、これはdata.frame/matrixの各変数または各列について異なるスキューを計算します。
構造方程式モデルのグラフィカルな表現は、半確定因子モデルや確認因子モデルを概念化するのにとても便利な方法です。x (xmodel) と y (ymodel) の測定モデル、および x と y (phi) を接続するパス・モデルが与えられている場合、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合は，x 変数または y 変数間の相関を示す．

さらに便利なことに、この関数はJohn Foxの<em>semパッケージ</em>やYves Rosseelの<em>lavaan</em>パッケージで直接実行するのに適したモデルを返します。    このオプションを直接使用するには、errors=TRUEを指定する必要があります。

入力は行列か、<code>fa</code>、factanal、または<em>GPArotation</em>のような回転パッケージからの出力として指定できます。

記号グラフの場合、入力行列は文字列か、文字列と数値ベクトルの混合になる。

オプションとして、Rgraphvizがインストールされていない場合、<code>structure.sem<//code>はsemモデルだけを作成し、グラフをスキップします。(この機能は、現在<code>structure.diagram</code>に含まれています)。

structure.diagramは、Rgraphvizを使用せずにダイアグラムを描画するので、おそらく好ましいオプションである。

<code>lavaan.diagram</code>はlavaanパッケージからcfaまたはsemの結果を描画します。cfa、sem、mimic型の出力についてテストされています。  <em>lavaan</em>から出力オブジェクトを受け取り、<code>structure.diagram</code>を呼び出します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を、1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリー/レベルであるdataframeの列を数値に変換します。
ロジスティック関数（1/(1+exp(-x)）とロジット関数（log(p/(1-p)）は、項目反応理論の基本です。  単なる1行関数ですが、デモやIRTモデルの描画を容易にするために、ここに含まれています。また、graded responseモデルのlogistic.grmも含まれています。
ロジスティック関数（1/(1+exp(-x)）とロジット関数（log(p/(1-p)）は、項目応答理論の基本です。  単なる1行関数ですが、デモやIRTモデルの描画を簡単にするために、ここに含まれています。また、graded responseモデルのlogistic.grmも含まれています。
ロジスティック関数（1/(1+exp(-x)）とロジット関数（log(p/(1-p)）は、項目応答理論の基本です。  単なる1行関数ですが、デモやIRTモデルの描画を簡単にするために、ここに含まれています。また、graded responseモデルのlogistic.grmも含まれています。
 合理的、要因的、または経験的な手段によって尺度を構成する場合、互いに最も高い相関を持つ項目の内容（例えば、一連の項目の<code>fa.lookup<//code>の因子負荷量）、またはある特定の基準の集合（例えば、<code>bestScales<//code>）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは因子負荷または基準相関によってソートし、項目内容を表示します。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高い相関を持つ項目（例えば、項目セットの<code>fa.lookup<//code>の因子負荷量）、またはある特定の基準セット（例えば、<code>bestScales<//code>）の内容を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは因子負荷または基準相関によってソートし、項目内容を表示します。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高い相関を持つ項目（例えば、項目セットの<code>fa.lookup<//code>の因子負荷量）、またはある特定の基準セット（例えば、<code>bestScales<//code>）の内容を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframe列を数値に変換します。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは些細な関数ですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。levels2numericとchar2numericは、カテゴリー/レベルであるdataframe列を数値に変換します。
2つの標本（例えば、男性と女性）の相関行列を報告する場合、1つの行列として表示するのが便利で、対角線より下の項目は一方の行列を表し、対角線より上の項目はもう一方の行列を表します。  また、相関行列を、適合した（因子など）モデルからの残差と比較するのも便利です。  
McDonald(1999)や項目応答理論に関する他の議論で使用されているデータセットの例では、Law School Admissions Test (LSAT)の10項目（5項目×2セット）のデータ表が使用されています。  このデータセットには、元の表と、第1セット（図分類）と第2セット（討論）に対する1000人の被験者の回答が含まれている。
McDonald(1999)が項目応答理論の他の議論と同様に使用したデータセットの例では、法科大学院入学試験(LSAT)の10項目(5項目の2セット)のデータ表を使用しています。  このデータセットには、元の表と、第1セット（図分類）と第2セット（討論）の1000人の被験者の回答が含まれています。
data.frameまたは行列が与えられたら，グループ化変数による各変数の標準化平均差（コーエンのd）と信頼区間を求めよ．  d 統計量を r 等価値に変換し、スチューデントの t 統計量と関連する p 値を報告し、グループ化変数の両方の値の統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
data.frameまたは行列が与えられている場合，グループ化変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めなさい．  d統計量をr統計量に変換し、Studentのt統計量と関連するp値を報告し、グループ化変数の両方の値に対する統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりの複数の尺度（たとえば，OVL, OVL2, など）が利用可能である．
古典的検定理論（CTT）は，すべての検定が1つの因子と残差誤差で表現できる場合，4つ以上の検定は共属的に等価であるとみなす．  並列検定は、（通常2つの）検定が等しい因子負荷量を持つ特別なケースである。  タウ等価検定は，等しい因子負荷量を持つが，不均等な誤差を持つことがある．  共属検定は，因子負荷と誤差分散の両方が異なることがある．
因子負荷量と因子相互相関の集合から母集団直交相関行列または階層相関行列を作成する．そして，この母集団からサイズ n の標本を抽出することができる．  標本データ、標本相関、または母集団相関のいずれかを返します。  これは、指導やデモンストレーションのためのサンプル・データ・セットを作成するために使用されます。
<code>irt.fa</code>は、二項項目または多項項目の四項相関または多項相関の因子分析を通して、項目反応理論(IRT)のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code>は尺度のリストを採点します。
 <code>scoreItems</code>を使用して生データから、または<code>cluster.cor</code>を使用して相関行列から、複合尺度を形成して項目を得点化する場合、以前はキー行列を作成する必要がありました。ほとんどのスコアリング関数は直接キーのリストを使用するので、これはもはや必要ありません。<code>make.keys</code>は単にキー行列を作るためのショートカットです。  キー行列は-1,0,1の nvar x nscales 行列で、各スケールのメンバーシップを定義します。項目は場所または名前で指定できます。
 <code>scoreItems</code>を使用して生データから、または<code>cluster.cor</code>を使用して相関行列から複合尺度を形成して項目をスコアリングする場合、以前はキー行列を作成する必要がありました。ほとんどのスコアリング関数は直接キーのリストを使用するので、これはもはや必要ありません。<code>make.keys</code>はキー行列を作成するための単なるショートカットです。  キー行列は-1,0,1の nvar x nscales 行列で、各スケールのメンバーシップを定義します。項目は場所または名前で指定できます。
特定の基準との多くの相関の強さを示す便利な方法は、マンハッタン・プロットです。  これは、あるキーとなる変数によって並べられた相関のプロットに過ぎない。  <code>bestScales</code>で使用される項目の基礎を理解するのに便利です。
data.frameまたは行列の各変数の歪度（skew）と尖度（kurtosis）を求めます。  e1071のskewとkurtosisとは異なり、これはdata.frame/matrixの各変数または各列に対して異なるskewを計算します。
相関行列または生データの行列またはデータフレームが与えられたとき、重回帰を求め、x変数の集合の関数としてy変数の集合を関連付けるパス図を描く。  共変量(z)の集合は、xとyの集合から分割することができる。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も見つける。
相関行列の構造を見るには，類似項目が一緒にグループ化されるように項目を整理することが有用である．そのようなグループ化の手法の1つが因子分析です。 mat.sortは、因子モデル（指定された場合）、またはその他の順序、あるいは第1因子への負荷量（指定されていない場合）によって項目を並べ替えます。
相関行列または生データの行列またはデータフレームが与えられたら、重回帰を求め、x 変数の集合の関数として y 変数の集合を関連付けるパス図を描きます。  共変量（z）の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求める。
相関行列または生データの行列またはデータ・フレームが与えられると，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描く．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も見つける。
相関行列の構造を見るには，類似項目が一緒にグループ化されるように項目を整理することが有用である．そのようなグループ化の手法の1つが因子分析です。 mat.sortは、因子モデル（指定された場合）、またはその他の順序、または第1因子への負荷量（指定されていない場合）によって項目を並べ替えます。
mat.sortは，（指定された場合）因子モデルによって，または順序によって，または（指定されていない場合）第1因子の負荷量によって項目を並べ替えます．間接効果の信頼区間をブートストラップする．  媒介モデルは，モデル中の特定の共変量の効果を明示する拡張回帰モデルにすぎない．モデレーションは、予測変数の乗算によって行われます。   この関数は、いくつかの典型的な問題タイプについて、基本的な媒介/修正分析を提供します。
媒介および緩和のパス・モデルでの予測変数の直接効果および間接効果を求めます。間接効果の信頼区間をブートストラップします。  媒介モデルは，モデル中の特定の共変量の効果を明示する拡張回帰モデルにすぎない．モデレーションは、予測変数の乗算によって行われます。   この関数は，いくつかの典型的な問題タイプについて基本的な媒介/修正分析を提供する．
相関を教えるためには，相関を反映するために平均のまわりに楕円を描くことが有用である．  John Foxのcarパッケージの楕円関数のこのバリエーションがそうです。  入力は2つのベクトルか行列かdata.frameである。  後者の場合、変数の数が &gt;2であれば、楕円は<code>pairs.panel</code>関数で行われます。エリプスは既存のプロットに追加することもできます。一般化された楕円としてミンコフスキー関数が含まれます。
mixedCorは、連続変数に対するピアソン相関、多値項目に対する<code>polychoric</code>s、2値項目に対する<code>tetrachoric</code>s、およびさまざまな混合変数に対する<code>polyserial</code>または<code>biserial</code>相関を求めます。結果は、完全な相関行列だけでなく、多項式相関と四項式相関の個別の相関行列と困難を含みます。
mixedCorは、連続変数に対するピアソン相関、多値項目に対する<code>polychoric</code>s、2値項目に対する<code>tetrachoric</code>s、およびさまざまな混合変数に対する<code>polyserial</code>または<code>biserial</code>相関を求めます。結果には、完全な相関行列、および多項相関と四項相関の個別の相関行列と困難さが含まれる。
マルチレベル・データの信頼性のさまざまな指標（たとえば、被験者内にネストされた時間にわたる項目）が、一般化可能性理論を用いて見つけられるかもしれません。  分散成分が抽出されたデータには、基本的な3元配置のアノバが適用されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットからロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について、時間オーバーのオブザベーションの複数の格子プロットが作成されます。
一般化可能性理論を用いて、マルチレベル・データの信頼性のさまざまな指標（たとえば、被験者内にネストされた経時的項目）が見つけられるかもしれません。  分散成分が抽出されたデータに、基本的な3元配置のアノバが適用されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットからロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について、時間オーバーのオブザベーションの複数の格子プロットが作成されます。
一般化可能性理論を用いて、マルチレベル・データの信頼性のさまざまな指標（たとえば、被験者内にネストされた経時的項目）が見つけられるかもしれません。  分散成分が抽出されたデータに、基本的な3元配置のアノバが適用されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットからロングフォーマットに変換するヘルパー関数です。  データをワイドからロングフォーマットに並べ替えることができ、複数の変数と複数の被験者について、時間オーバーのオブザベーションの複数の格子プロットが作成されます。
媒介および緩和のパス・モデルにおける予測変数の直接効果および間接効果を求めます。間接効果の信頼区間をブートストラップします。  媒介モデルは，モデル中の特定の共変量の効果を明示する拡張回帰モデルにすぎない．モデレーションは、予測変数の乗算によって行われます。   この関数は，いくつかの古典的な問題タイプについて，基本的な媒介/修正分析を提供する．
Von Neuman ら (1941) は，平均の漸進的なシフトを考慮に入れた変動の尺度として，連続差の平均2乗について議論した．これは、弾道学で誤差を研究するときや、情動を研究するときの気分の変動性や安定性を研究するときに適切である。ランダムなデータの場合、これは分散の2倍になりますが、順序が連続し、正の自己相関を持つデータの場合、これはずっと小さくなります。mssdは分散の2倍-自己相関なので、特定のラグの自己相関を見つけることも可能です。
パスモデルは、構造方程式モデルまたはクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描くためのプリミティブを提供します。  Rgraphvizの機能の一部の代替として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
行列またはdata.frameが与えられると、各変数のヒストグラムを「行列」形式で作成します。各プロットに正規適合と密度分布を含む。

行と列の数は指定することも、計算することもできる。
パスモデルは、構造方程式モデルやクラスタ分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
パスモデルは、構造方程式モデルやクラスター分析出力を記述するために使用されます。  これらの関数は、パスモデルを描画するためのプリミティブを提供します。  Rgraphvizの一部の機能の代用として使用されます。
一般化可能性理論（generalizability theory）を用いて、マルチレベルデータの信頼性の様々な指標（例えば、被験者内にネストされた経時的な項目）を見つけることができる。  基本的な3元配置のアノバがデータに適用され、そこから分散成分が抽出されます。入れ子デザインのランダム効果がlmeによって発見されます。    これらはいくつかの信頼性/一般化可能性係数に変換されます。  lmerを使用するためのlme4へのオプション呼び出しは、欠損データのあるアンバランスデザインに使用できます。 mlArrangeは、ワイドフォーマットからロングフォーマットに変換するヘルパー関数です。  データは、ワイド形式からロング形式に並べ替えることができ、複数の変数と複数の被験者について時間オーバーのオブザベーションの複数の格子プロットが作成されます。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、因子分析または主成分分析の出力を、1つまたは複数の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリー/レベルであるdataframe列を数値に変換します。
探索的因子分析で適切な因子の数を決定する方法は複数あります。Very Simple Structure (VSS)基準のルーチンでは、さまざまな複雑さの解を、さまざまな因子数で比較することができます。グラフィック出力は、さまざまな複雑さのレベルについて、「最適な」因子の数を示します。  Velicer MAP 基準もよい選択である。<code>nfactors</code>は、これらの代替推定値をいくつか見つけてプロットする。
McDonaldは、テストの一般的な因子飽和の推定値として係数ωを提案しています。  ωを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid Leiman変換を行い、それからωを求めることです。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、適切なsem/lavaanオブジェクトを変換してomegaを見つけます。  さらにもう1つの方法は、Wallerの直接Schmid-Leimanを行うことである。
階層因子構造は、変数間の相関を、それ自体が高次の因子で表現できる相関因子のより小さな集合で表現します。

このような構造に対する2つの代替解が、<code>omega</code>関数によって見つけられる。  相関因子解は，相関因子への効果を通して，より高いレベルの一般因子の効果を表現する．  もう1つの表現は，項目への直交残差グループ因子の効果と同様，元の変数への一般因子の直接効果を見つけるために，Schmid Leiman 変換を利用する．

omega.graphとomega.diagramは、両方の構造を描画します。  グラフは、グラフィックス・ウィンドウに直接描画されるか、（omega.graphを使用する場合）Graphvizの実装を使用してグラフィックスに変換するために、"dot "コマンドで表現されます。

Graphvizを使用することで、Rgraphvizの出力をクリーンアップすることができる。しかし、GraphvizとRgraphvizが使用できない場合は、omega.diagramを使用してください。  

他の構造図作成関数、<code>fa.diagram</code>と<code>structure.diagram</code>を参照。

さらに
階層的因子構造は，変数間の相関を，それ自体が高次の因子によって表現されうる，より小さな相関因子の集合の観点から表現する．

このような構造に対する2つの代替解が、<code>omega</code>関数によって見つけられる。  相関因子解は，相関因子への効果を通して，より高いレベルの一般因子の効果を表現する．  もう1つの表現は，項目への直交残差グループ因子の効果と同様，元の変数への一般因子の直接効果を見つけるために，Schmid Leiman 変換を利用する．

omega.graphとomega.diagramは、両方の構造を描画します。  グラフは、グラフィックス・ウィンドウに直接描画されるか、（omega.graphを使用する場合）Graphvizの実装を使用してグラフィックスに変換するために、"dot "コマンドで表現されます。

Graphvizを使用することで、Rgraphvizの出力をクリーンアップすることができる。しかし、GraphvizとRgraphvizが使用できない場合は、omega.diagramを使用してください。  

他の構造図作成関数、<code>fa.diagram</code>と<code>structure.diagram</code>を参照。

さらに
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は，元のデータ集合の因子分析を行い，因子を斜めに回転させ，Schmid Leiman 変換を行い，それからオメガを求めることである．この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、適切なsem/lavaanオブジェクトを変換してomegaを見つけます。  さらにもう1つの方法は、WallerのSchmid-Leimanを直接行うことである。
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid-Leiman 変換を行い、それからオメガを求めることである。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらに、WallerのSchmid-Leimanを直接実行する方法もある。
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid-Leiman 変換を行い、それからオメガを求めることである。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、omegaを見つけるために適切なsem/lavaanオブジェクトを変換します。  さらに、WallerのSchmid-Leimanを直接実行する方法もある。
McDonaldは、テストの一般的な因子飽和度の推定値として係数ωを提案している。  オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid-Leiman 変換を行い、それからオメガを求めることである。この関数は、McDonaldが提案したように、階層的因子分析（Jensenに従う）を用いてオメガを推定する。関連するオプションは、omegaを使用してモデルを定義し、semまたはlavaanパッケージを使用して確認的（2因子）分析を実行することです。  これは、omegaSemとomegaFromSemによって行われます。omegaFromSemは、適切なsem/lavaanオブジェクトを変換してomegaを見つけます。  さらにもう1つの方法は、Wallerの直接Schmid-Leimanを行うことである。
マハラノビス距離は<i>D^2 = (x-μ)' Σ^-1 (x-μ)</i>であり、<i>Σ</i>はx行列の共分散である。  D2は分布の異常値を検出する方法として使われる。  期待されるカイ2乗値と比較して大きな D2 値は，異常な応答パターンを示す．  statsのマハラノビス関数は欠損データを扱いません。
Peter Killeen (2005)が議論している実験的または相関的発見の再現確率は、正確な再現で同じ方向の効果を見つける確率である。  Psychological Scienceに投稿された論文については、p.repを報告する必要がある。

F、t、p、rはすべて効果の大きさの推定値である。  しかし、F、t、pも標本サイズの関数である。  効果の大きさ（d prime）は、セル内標準偏差と比較した平均値間の差、または相関係数として表現されることがある。  これらの関数はp、F、tをd primeとrに変換する。
Peter Killeen (2005)が議論している実験的または相関的発見の再現確率は、正確な再現を行った場合に同じ方 向の効果が見つかる確率である。  Psychological Scienceに投稿された論文については、p.repを報告する必要がある。

F、t、p、rはすべて効果の大きさの推定値である。  しかし、F、t、pも標本サイズの関数である。  効果の大きさ（d prime）は、セル内標準偏差と比較した平均値間の差、または相関係数として表現されることがある。  これらの関数はp、F、tをd primeとrに変換する。
Peter Killeen (2005)が議論している実験的または相関的発見の再現確率は、正確な再現を行った場合に同じ方 向の効果が見つかる確率である。  Psychological Scienceに投稿された論文については、p.repを報告する必要がある。

F、t、p、rはすべて効果の大きさの推定値である。  しかし、F、t、pも標本サイズの関数である。  効果の大きさ（d prime）は、セル内標準偏差と比較した平均値間の差、または相関係数として表現されることがある。  これらの関数はp、F、tをd primeとrに変換する。
Peter Killeen (2005)が議論している実験的または相関的発見の再現確率は、正確な再現を行った場合に同じ方 向の効果が見つかる確率である。  Psychological Scienceに投稿された論文については、p.repを報告する必要がある。

F、t、p、rはすべて効果の大きさの推定値である。  しかし、F、t、pも標本サイズの関数である。  効果の大きさ（d prime）は、セル内標準偏差と比較した平均値間の差、または相関係数として表現されることがある。  これらの関数はp、F、tをd primeとrに変換する。
   2つの（対または非対）相関の差を検定する。3つの変数 x, y, z があるとき、xy 間の相関は xz 間の相関と異なるか？  y と z が独立であれば、これは z 変換 rs の単純な t 検定である。  しかし、それらが従属であれば、もう少し複雑になります。
pairsのヘルプページから引用したpairs.panelは、行列の散布図（SPLOM）を示し、対角線の下に2変量散布図、対角線上にヒストグラム、対角線の上にピアソン相関を示します。小さなデータセットの記述統計に便利です。  lm=TRUEの場合、y×xとx×yの両方で線形回帰フィットが表示されます。ポイントは、グループ化変数によって異なる色で表示されます。  ロバスト・フィッティングは，lowess または loess 回帰を用いて行われる．要求があれば、lmまたはloessの信頼区間が描画されます。
cor(x, use= "pairwise")を行うとき、各対相関のケース数を知っておくと便利です。  これは、SAPAタイプの分析を行うときに特に便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられます。
cor(x, use= "pairwise")を実行するとき、各対相関のケース数を知っておくと便利です。  これは、特にSAPAタイプの分析を行うときに便利です。さらに重要なことは、いくつかの欠損ペアがある場合、インプットされた値を提供することで、さらなる分析が可能になることです。  これは、SAPAプロジェクトで使用されているMMCAR（Massively Missing Completely at Random）計画を使用する場合に便利です。  欠落している特定のペアは、pairwiseZeroで識別できる。  カウントの要約はpairwiseDescribeで与えられる。
n個の項目の集合が与えられた場合、最も類似した項目のペアまたはトリプレットのn/2またはn/3のミニスケールまたはパーセルを形成する。  これらは、その後の尺度構築や多変量（因子など）分析の基礎として使用することができる。
x集合からy集合の変数の効果を除去するための行列代数の簡単な応用．入力は、データ行列または相関行列のいずれかである。  xとyの変数は位置によって指定される。  x と y が指定されていない場合は、すべての変数の影響が他のすべての相関から除算される。  回帰モデルと結果を比較するときに便利な数式入力を使用してもよい。
固有値分解 固有値分解を行い、指定された成分数の固有値、負荷量、適合度を返す。  基本的には、相関行列または共分散行列のn個の主成分について主成分分析（PCA）を行うだけである。  残差相関も表示できる。2乗相関の削減の質は、残差相関と元の相関を比較することで報告される。princomp とは異なり、これは最良の n因子のサブセットだけを返します。固有ベクトルは，因子分析でより一般的な成分負荷量を生成するために，固有値の平方で再尺度化される．
度数の1 x 4ベクトルまたは2 x 2行列が与えられたとき、相関のファイ係数を求めます。  典型的な使用法は、2値予測変数から2値基準を予測する場合です。
2変量連続データが2分されるとどうなるかのあまりおもしろくないデモです。  基本的には、r、phi、polychorのデモです。  
structure.listはリスト入力をデザイン行列に変換します。phi.listは相関行列に対して同じことを行います。NULL値を持つ因子は0で埋められます。
phi 係数（2つの2値変数で計算されたピアソンr）、および限界度数（パーセンテージ）が与えられたとき、それに対応する4値相関の推定値は何ですか？

カウントの2×2の表が与えられる<br>。

ファイ係数は (a - (a+b)*(a+c))/sqrt((a+b)(a+c)(b+d)(c+c)) である。

この関数は指定されたマージンのセルエントリーを再現し、次にテトラコーラス関数を呼び出します。(これは元々John Foxのpolychor関数に基づいています。)phi2polyの名前は将来非推奨になります。
<code>Yule2tetra</code>と<code>Yule2phi</code>に置き換えられた非推奨関数のセットです。

いくつかの古い相関行列は、ファイ相関行列またはユール相関行列として報告されている。  つまり、相関は2×2の数表から求められたのである：<br>。

ユールQは(ad-bc)/(ad+bc)。<br> <br

限界頻度はa+b、c+d、a+c、b+d。

このような相関の正方行列、およびa + bのセルにある各変数の割合が与えられると、各相関を2×2の表に再変換し、対応する多項式相関を推定することが可能である（John Foxのpolychor関数を使用）。
ファイ係数（2つの2値変数で計算されたピアソンr）、および限界度数（パーセンテージ）が与えられたとき、それに対応する4値相関の推定値は何ですか？

カウントの2×2の表が与えられる<br>。

ファイ係数は (a - (a+b)*(a+c))/sqrt((a+b)(a+c)(b+d)(c+c)) である。

この関数は指定されたマージンのセルエントリーを再現し、次にテトラコーラス関数を呼び出します。(これは元々 John Fox の polychor 関数に基づいています。)phi2poly という名前は将来非推奨になるでしょう。
フルランク未満の行列が与えられた場合、従来の逆関数は失敗します。  擬似逆行列または一般化逆行列は, 特異値分解 d 行列の正値のみを使用することでこの問題を解決します.MASSのginv関数とpracmaのpinv関数の応用です。
複数のプロット関数を "psych "クラスのオブジェクト用に1つに統合したものです。  <code>fa</code>、<code>irt.fa</code>、<code>VSS</code>、<code>ICLUST</code>、<code>omega</code>、<code>factor.pa</code>、<code>principal</code>の結果をプロットするために使用できます。
クラス "psych "のオブジェクトに対して、いくつかのプロット関数を1つにまとめる。  これは、<code>fa</code>、<code>irt.fa</code>、<code>VSS</code>、<code>ICLUST</code>、<code>omega</code>、<code>factor.pa</code>、または<code>principal</code>の結果をプロットするために使用できます。
データ行列や相関行列の因子や成分の数を決定する1つの方法は、連続する固有値の "scree "プロットを調べることです。  プロットの鋭い切れ目が、抽出する成分や因子の適切な数を示唆する。  「並列 "分析は、観察されたデータの因子のscreeと、元のデータと同じサイズのランダムなデータ行列の因子のscreeを比較する代替手法である。これは連続データ、2値データ、多値データに対して、Pearson相関、4値相関、多値相関を用いて行うことができる。
クラス "psych "のオブジェクトに対して、複数のプロット関数を1つにまとめる。  これは、<code>fa</code>、<code>irt.fa</code>、<code>VSS</code>、<code>ICLUST</code>、<code>omega</code>、<code>factor.pa</code>、<code>principal</code>の結果をプロットするために使用できます。
Revelle and Condon, (2019) は、理論家だけでなく実務家にも役立つことを意図したチュートリアルで、信頼性の問題をレビューした。  単一の尺度の信頼性を推定するための関数（<code>alpha</code>や<code>omega</code>など）、スプリットハーフの信頼性<code>splitHalf</code>、テスト-リテスト信頼性<code>testRetest</code>やマルチレベル信頼性<code>mlr</code>を求めるための関数など、心理学には多くの関数がありますが、<code>reliability</code>関数はこれらの関数のいくつかを組み合わせて、複数の尺度についてこれらの推奨尺度を報告します。

RevelleとCondon（2019）から引用すると、「信頼性は、すべての科学における測定の基本的な問題である。おそらく心理学的測定は他の自然科学の測定よりも混乱しているため、心理学者は長い間信頼性の問題を研究してきた。   

"信頼性の問題は、観測された変数間の相関が、基礎となる構成要素間の関係の（減衰した）過小評価であること、ある人のスコアの観測された推定値が、その人の潜在的なスコアの偏った推定値であること、特定の測定値の周りの信頼区間を推定する方法を理解するための基本である。信頼性を推定する多くの方法と、これらの推定値を使用する方法を理解することで、個人をよりよく評価し、選択と予測技術を評価することができます。これは測定の専門家だけの問題ではなく、観察されたデータから理論的な推論を行いたいすべての人にとっての問題である。

"すべての項目が構成要素を正確に等しく測定している場合にのみ正しい1つの係数を報告することは、もはや受け入れられません。  研究者は、少なくとも2つの係数（例えば、omega_hとomega_t）を報告することが奨励され、そして、それぞれが行われる推論に対して適切である理由を議論する。  alphaを使うことの暗黙の仮定（すなわち、タウの等価性や一次元性）を正当化できない限り、alphaだけを報告することは推奨されない。"  ここでは、それが簡単にできるようにしている。

<code>alpha</code>と<code>omega</code>関数は単一の尺度に対する信頼性の推定値を求め、<code>scoreItems</code>と<code>scoreOverlap</code>は複数の尺度に対するアルファ値を求めますが、複数の尺度に対して<code>omega</code>と<code>splitHalf</code>を呼び出すと便利な場合があります。  <code>reliability</code>は(<code>scoreItems</code>に適した)キーリストを受け取り、階層的なオメガと合計のオメガ、そしてそれぞれの個別の尺度に対するスプリットハーフの信頼性を求めます。

<code>plot.reliability</code>は、<code>reliability</code>の出力を受け取り、アルファ値と同様にオメガの値とスプリットハーフの信頼性の分布を示すドットチャートとして表示します。
複数のプロット関数を "psych "クラスのオブジェクト用に1つに統合します。  これは、<code>fa</code>、<code>irt.fa</code>、<code>VSS</code>、<code>ICLUST</code>、<code>omega</code>、<code>factor.pa</code>、または<code>principal</code>の結果をプロットするために使用できます。
因子分析およびクラスター分析の出力は、通常、項目ごとの因子相関（負荷量）を示します。  因子負荷量の表は、しばしば負荷量の大きさによってソートされます。  この表示スタイルでは、他の、二次的な次元での負荷量のパターンに気づきにくい傾向があります。  極座標に変換することで、二次的な負荷量のパターンが見やすくなります。
四分位相関は、二変量正規性を仮定した2 x 2表から推測されるピアソン相関である。多項相関は，これを n x m 表に一般化する．項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
四分木相関は、二変量正規性を仮定した2×2の表から推定されるピアソン相関である。ポリコレ相関は、これを n x m 表に一般化したものです。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
四分木相関は、二変量正規性を仮定した2×2の表から推定されるピアソン相関である。ポリコレ相関は、これを n x m 表に一般化したものです。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
四分木相関は、二変量正規性を仮定した2×2の表から推定されるピアソン相関である。ポリコレ相関は、これを n x m 表に一般化したものです。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。この後の2つの入力はデータフレームまたは行列である。  mnormt パッケージが必要。
予測因子得点は，推定因子得点を求めるために使用される重み行列を使用し，予測成分は負荷量行列を使用する．スコアは，予測標本に関して標準化されるか，オリジナル・データに基づいて標準化される．bestScales モデルからの予測スコアは、元の標本からの統計量に基づきます。
尺度の有効性は、尺度の項目数、平均相互相関、平均有効性の関数として変化する。任意の特定の基準に対する尺度の有効性の漸近限界は、平均有効性を平均尺度内項目相関の平方根で割ったものです。  <code>predicted.validity</code>は、（keys.listで定義された）尺度の集合に対する予測有効性と、さまざまな基準に対する平均項目有効性を求めます。  

この関数は、尺度の信頼性（<code>reliability</code>を使用）と平均項目の妥当性（<code>item.validity</code>を使用）を求め（そして報告し）ます。
固有値分解を行い、指定された成分数の固有値、負荷量、適合度を返します。  基本的には、相関行列または共分散行列のn個の主成分について主成分分析（PCA）を行うだけです。  残差相関も表示できる。2乗相関の削減の質は、残差相関と元の相関を比較することで報告される。princomp とは異なり、これは最良の n因子のサブセットだけを返します。固有ベクトルは，因子分析でより一般的な成分負荷量を生成するために，固有値の平方で再尺度化される．
psychのほとんどの関数について、限定的な出力（print）またはやや詳細な出力（summary）を与える。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、JennrichとBentler (2011)によって導入された回転を実装しています。promaxは、HendricksonとWhite (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、その名前で呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。これは、些細なことですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは、因子分析または主成分分析の出力を、1つまたは複数の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は2つのdata.frameを（同じ長さの）相関させます。levels2numericとchar2numericはカテゴリ/レベルであるdataframeの列を数値に変換します。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、その名前で呼び出すのが簡単です。  Ertl (2013) が提案した varimin 回転は、GPArotation への適切な呼び出しによって実装されます。
psychパッケージの概要

psych パッケージはノースウェスタン大学で開発されたもので、パーソナリティや心理学 の研究に最も有用な関数を含んでいます。  いくつかの関数(例えば、<code>read.file</code>、<code>read.clipboard</code>、<code>describe</code>、<code>pairs.panel</code>、<code>error.bars</code>、<code>error.dots</code>)は、基本的なデータ入力や記述分析に便利です。すべての関数の一覧はhelp(package="psych")またはobjects("package:psych")を使用してください。 パッケージの一部として3つのビネットが含まれています。  intro vignette は psych のインストール方法を、overview vignette は多くのアプリケーションで psych を使用する例を示しています。  さらに、<a href="https://personality-project.org/r/">https://personality-project.org/r/</a> のウェブページで利用可能なチュートリアルが増えています。

付属パッケージ<code>psychTools</code>には、より大きなデータセットの例と、もう1つのビネットが含まれている。

心理測定アプリケーションには、最尤(fm="mle")、最小残差(fm="minres")、最小順位(fm=minrank)、主軸(fm="pa")、加重最小二乗(fm="wls")因子分析のルーチン(<code>fa</code>)や、階層的な因子構造を二因子解に変換するSchmid Leiman変換(<code>schmid</code>)の関数があります。主成分分析(<code>pca</code>)も利用できます。  回転は，GPArotation 関数の多く（例えば，oblimin，quartimin，varimax，geomin，...）を呼び出す機能と同様に，ターゲット行列への因子または成分変換には，標準的なPromax変換（<code>Promax</code>），クラスター・ターゲットへの変換，または任意の単純なターゲット行列への変換（<code>target.rot</code>）が含まれます．データ行列の因子数を決定するための関数には、Very Simple Structure (<code>VSS</code>) やMinimum Average Partial Correlation (<code>MAP</code>) があります。

因子分析の代替アプローチは、項目クラスター分析（<code>ICLUST</code>）である。この関数は、探索的尺度の構築に特に適しています。

様々な信頼性係数を求めるための関数が多数あります（Revelle and Condon, 2019参照）。これらには、伝統的な<code>alpha</code>（複数の尺度について見つかり、<code>scoreItems</code>、<code>score.multiple.choice</code>によってより有用な出力が得られます）、ベータ（<code>ICLUST</code>）、McDonaldのオメガ係数（<code>omega</code>、<code>omegaSem</code>、<code>omega.diagram</code>）、Guttmanの内部一貫性信頼性の6つの推定値（<code>guttman</code>）、およびShroutとFleissによって議論されたクラス内相関係数の6つの尺度（<code>ICC</code>）も利用可能です。  

マルチレベル分析は、<code>statsBy</code>と<code>multilevel.reliability</code>で行うことができる。

<code>scoreItems</code>および<code>score.multiple.choice</code>関数は、採点キーを指定することにより、二値項目、多値項目、多肢選択項目の集合から単一または複数の尺度を形成するために使用することができます。  <code>scoreOverlap</code>は、重複する項目のスケール間相関を修正し、階層構造や入れ子構造を調べることができるようにする。

<code>bestScales</code>は、単位加重または相関加重を使用して、特定の基準を（クロス検証後に）最もよく予測するスケールを形成することができます。この手順は、<code>BISCUIT</code>アルゴリズム（クロス検証され、単位重み付けされ、情報量が多く、透明性のあるベスト・アイテム・スケール）とも呼ばれ、より複雑な機械学習アルゴリズムのシンプルな代替手段です。

項目特性のより便利な記述のための追加関数には、1パラメータと2パラメータの項目反応尺度がある。  <code>tetrachoric</code>、<code>polychoric</code>、<code>irt.fa</code>関数は、項目機能の2パラメータ記述を見つけるために使用されます。<code>scoreIrt</code>、<code>scoreIrt.1pl</code> および <code>scoreIrt.2pl</code>は基本的なIRTベースのスコアリングを行います。

Synthetic Aperture Personality Assessment (SAPA <a href="https://www.sapa-project.org/">https://www.sapa-project.org/</a>) プロジェクトの一環として、多くの手順が開発された。  これらのルーチンは、生データを使用するのと同等の複合尺度の形成と分析を容易にしますが、クラスター内およびスケール間の項目相関を追加することによって行います。これらの関数には、因子負荷行列からクラスタを抽出したり(<code>factor2cluster</code>)、相関行列から合成的にクラスタを形成したり(<code>cluster.cor</code>)、相関行列から多重相関((<code>setCor</code>)や部分相関((<code>partial.r</code>)を求めたりするものがあります。

<code>setCor</code>と<code>mmediate</code>は、生データまたは相関行列から回帰分析と媒介分析を行いたいという要望に応えるものである。  生データが提供された場合、これらの関数はまた媒介分析を行うことができます。

特定の構造を持つシミュレーションデータを生成する関数には、<code>sim.circ</code>（circumplex構造用）、<code>sim.item</code>（一般構造用）、<code>sim.congeneric</code>（congeneric測定の特定のデモンストレーション用）があります。  関数<code>sim.congeneric</code>と<code>sim.hierarchical</code>は、特定の構造特性を持つデータセットを作成するために使用することができます。これらすべてのより一般的な形式は、一般的な構造モデルを生成するための<code>sim.structural</code>です。  これらの詳細については、ビネット（psych_for_sem）を参照してください。

様々な標準的な統計検定を適用する関数には、再現確率を検定するための<code>p.rep</code>とその変種、相関の信頼区間を検定するための<code>r.con</code>、単一、ペア、またはセットの相関を検定するための<code>r.test</code>があります。

気分の日内変動や概日変動を研究するためには、循環統計量を使用することが有用である。  循環平均（<code>circadian.mean</code>）、循環（位相）相関（<code>circadian.cor</code>）、線形変数と循環変数の相関（<code>circadian.linear.cor</code>）を求める関数は、固定周期（例えば、24時間）で取られた測定について、最も適合する位相角（<code>cosinor</code>）を求める関数を補足します。

パーソナリティとモチベーションの動的モデル（手がかり-傾向-行動モデル）は、（<code>cta</code>.

データ入力（<code>read.file</code>）とデータ操作（<code>cs</code>と<code>dfOrder</code>）を可能にする多くの便利なヘルパー関数がある、

パッケージの最新の開発バージョンは、常にPMCラボのリポジトリから<em>ソース</em>ファイルとしてダウンロード可能です：

install.packages("psych", repos = "https://personality-project.org/r/", type="source").

これはPCとMac用の最新バージョンを提供する。
lowerCorはx変数の相関を求め、lowerMatを使ってそれらを表示します。これは些細なことですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を、1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリー/レベルであるdataframeの列を数値に変換します。
data.frame、行列、テキストオブジェクトの最初と最後のn行を表示する簡単な方法。  <code>head</code> と <code>tail</code> または <code>View</code> を呼び出すだけです。
r2dは相関を効果量(Cohenのd)に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定の値に変換する。 r2cとcor2covは相関行列を共分散行列に変換する。d2tとt2dはコーエンのdをtに変換し、tをコーエンのdに変換する。
単一の相関、2つの独立した相関の差、1つの変数を共有する2つの従属相関の差（Williamsの検定）、または異なる変数を持つ2つの従属相関の差（Steigerの検定）の有意性を検定します。
r2dは相関を効果量(Cohenのd)に変換し、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定値に変換する。chi2rはカイ二乗をrに変換し、r2chiは元に戻す。r2cとcor2covは相関行列を共分散行列に変換する。
r2dは相関を効果量(Cohenのd)に、d2rはdをrに変換します。g2rはHedgeのgを相関に変換します。   t2rはt検定をrに変換し、r2tは相関をt検定の値に変換します。 chi2rはカイ二乗をrに変換し、r2chiはそれを元に戻します。 r2cとcor2covは相関行列を共分散行列に変換します。 d2tとt2dはコーエンのdをtに変換し、tをコーエンのdに変換します。
data.frameまたは行列が与えられた時、グループ化変数による各変数の標準化平均差（コーエンのd）と信頼区間を求める。  d統計量をr統計量に変換し、スチューデントのt統計量と関連するp値を報告し、グループ化変数の両方の値の統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
r2dは相関を効果量（Cohenのd）に変換し，d2rはdをrに変換する．   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ2乗をrに変換し、r2chiはそれを元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
レーダープロットとスパイダープロットは、多変量データを表示する多くの方法のうちの2つに過ぎません。  <code>レーダー</code>は、相関を0（r=-1に対応）から1（r=1に対応）までの長さのベクトルとしてプロットします。  ベクトルは円の周りに放射状に配置されます。スパイダープロットは、各ベクトルの端点同士を結ぶ。プロットは，変数が何らかの意味のある方法で編成されている場合に最も適切である．
応用設定では，予測変数とある基準との間の相関を見つけることが典型的である．  残念ながら，予測変数が被験者を選ぶために使用される場合，予測変数の範囲は著しく減少する．  これは，観察される相関が予測変数の全範囲で観察されるよりも小さいことを制限する．  この問題の補正は，Thorndike Case 2としてよく知られている．

Rを非制限相関、rを制限相関、Sを非制限標準偏差、sを制限標準偏差とすると、次のようになる。

R = (rS/s)/ sqrt(1-r^2 + r^2(S^2/s^2)).   

他のいくつかの制限のケースもThorndikeによって考慮され、<code>rangeCorrection</code>で実装されている。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。これは些細なことですが、行列の下三角を四捨五入して表示する便利な関数です。reflectは、因子分析または主成分分析の出力を、1つ以上の因子が反映されるように反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリー/レベルであるdataframeの列を数値に変換します。
Holzinger-Swineford (1937) は、一般因子と相関のないグループ因子の2因子モデルを導入した。Holzingerのデータセットは、Joreskogが例として使用した9 *9行列と同様に、彼らの論文からのオリジナルの14 * 14行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Revelle and Condon, (2019) は、理論家だけでなく実務家にも役立つことを意図したチュートリアルで、信頼性の問題をレビューしている。  単一の尺度の信頼性を推定する<code>alpha</code>や<code>omega</code>、スプリットハーフの信頼性<code>splitHalf</code>、テスト・リテスト信頼性<code>testRetest</code>やマルチレベルの信頼性<code>mlr</code>を求める<code>reliability</code>関数は、これらの関数のいくつかを組み合わせて、複数の尺度について推奨される尺度を報告します。

RevelleとCondon（2019）から引用すると、「信頼性は、すべての科学における測定の基本的な問題である。おそらく心理学的測定は他の自然科学の測定よりも混乱しているため、心理学者は長い間信頼性の問題を研究してきた。   

"信頼性の問題は、観測された変数間の相関が、基礎となる構成要素間の関係の（減衰した）過小評価であること、ある人のスコアの観測された推定値が、その人の潜在的なスコアの偏った推定値であること、特定の測定値の周りの信頼区間を推定する方法を理解するための基本である。信頼性を推定する多くの方法と、これらの推定値を使用する方法を理解することで、個人をよりよく評価し、選択と予測技術を評価することができます。これは測定の専門家だけの問題ではなく、観察されたデータから理論的な推論を行いたいすべての人にとっての問題である。

"すべての項目が構成要素を正確に等しく測定している場合にのみ正しい1つの係数を報告することは、もはや受け入れられません。  研究者は、少なくとも2つの係数（例えば、omega_hとomega_t）を報告することが奨励され、そして、それぞれが行われる推論に対して適切である理由を議論する。  alphaを使うことの暗黙の仮定（すなわち、タウの等価性と一次元性）を正当化できない限り、alphaだけを報告することは推奨されない。"  ここでは、それが簡単にできるようにしている。

<code>alpha</code>と<code>omega</code>関数は単一の尺度に対する信頼性の推定値を求め、<code>scoreItems</code>と<code>scoreOverlap</code>は複数の尺度に対するアルファ値を求めますが、複数の尺度に対して<code>omega</code>と<code>splitHalf</code>を呼び出すと便利な場合があります。  <code>reliability</code>は(<code>scoreItems</code>に適した)キーリストを受け取り、階層的なオメガと合計のオメガ、そしてそれぞれの個別の尺度に対するスプリットハーフの信頼性を求めます。

<code>plot.reliability</code>は、<code>reliability</code>の出力を受け取り、アルファと同様に両方のオメガの値とスプリットハーフの信頼性の分布を示すドットチャートとして表示します。
心理学者は、"IQ" (mean=100, sd=15)、"SAT/GRE" (mean=500, sd=100)、"ACT" (mean=18, sd=6)、"Tスコア" (mean=50, sd=10)、"Stanines" (mean=5, sd=2)のような変換された尺度でデータを報告することがよくあります。<code>rescale</code>関数は、データを標準スコアに変換し、指定された平均と標準偏差に再スケールします。
様々な心理関数の残差が抽出され、"きれいに "印刷されます。
さまざまな心理関数の残差が抽出され、"きれい "に印刷される。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらを得点する方向のリスト（k個のキーを持つkeys.list）が与えられたとき、各人と各尺度の合計得点または平均得点を求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は <code>make.keys</code> を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は検出されませんが、項目の統計量は報告されます。(<code>cluster.cor</code>と同様の機能)。<code>response.frequencies</code>は多項式または多肢選択式の項目の各回答カテゴリにおける項目の支持頻度を報告します。<code>scoreFast</code>と<code>scoreVeryFast</code>は得点の総和/平均を求めるだけで、信頼度を報告しない。  大規模なデータセットではより高速です。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらを採点する方向のリスト(k個のキーを持つkeys.list)が与えられた場合、各人と各尺度の合計スコアまたは平均スコアを求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は <code>make.keys</code> を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は検出されませんが、項目の統計量は報告されます。(<code>cluster.cor</code>と同様の機能)。<code>response.frequencies</code>は、多項式または多肢選択式の項目の各回答カテゴリにおける項目の支持頻度を報告します。<code>scoreFast</code>と<code>scoreVeryFast</code>は得点の総和/平均を求めるだけで、信頼度を報告しない。  大規模なデータセットではより高速です。
IRT関数の中には、すべての項目が同じ方向にコード化されている必要があるものがあります。  reverse.codeは、1と-1のキー・ベクトルに基づいて項目を反転させます。  反転された項目は、項目最大値＋項目最小値から差し引かれる。  これらは指定してもよいし、計算してもよい。
Von Neumanら(1941)は、平均の漸進的なシフトを考慮に入れた変動性の尺度として、連続差の平均二乗について議論した。これは、弾道学の誤差を研究するときや、情動を研究するときの気分の変動性や安定性を研究するときに適切である。ランダムなデータの場合、これは分散の2倍になりますが、順序が連続し、正の自己相関を持つデータの場合、これはずっと小さくなります。mssdは分散-自己相関の2倍に過ぎないので、特定のラグの自己相関を求めることも可能である。
SAT Verbal、SAT Quantitative、ACTの自己申告スコアは、Synthetic Aperture Personality Assessment (SAPA)のウェブベースの性格評価プロジェクトの一環として収集された。  年齢、性別、学歴も報告されている。700人の被験者のデータは、相関と分析のためのデモセットとしてここに含まれている。
選択肢の行列と尺度値のベクトルが与えられたとき、尺度値はどの程度選択肢を捉えているのだろうか？  つまり、モデルで与えられた残差の2乗の大きさと、選択値の2乗の大きさはどのくらい違うのでしょうか？
推定密度を持つXとYのヒストグラムに関連するX Y散布図を描きます。  グループごとの密度プロットや、グループごとの分布楕円も描きます。一部はレイアウトの使用のデモンストレーション。また、相関だけでなく、lowessの平滑度や線形モデルの傾きも含まれます。
XとYのヒストグラムと推定密度を伴うXY散布図を描きます。  グループごとの密度プロットや、グループごとの分布楕円も描きます。一部はレイアウトの使用のデモンストレーション。また、相関だけでなく、lowess平滑度や線形モデルの傾きも含まれます。
オメガを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、Schmid Leiman変換を行い、それからオメガを求めることです。以下はSchmid Leimanのコードである。  S-L変換は、因子またはPC解を取り、それを斜め解に変換し、斜め解を因数分解して高次の（g ）因子を見つけ、そしてグループ因子からg を残差化します。
John Schmid と John M. Leiman (1957) は，階層因子構造を2因子構造に変換する方法を議論している．Schmid.leiman は，対角上に共同体性を持つ 12 x 12 の相関行列です．これは減衰補正の効果を示すために使用できます。さらに2つのデータセットがChen et al.
John Schmid と John M. Leiman (1957)は、階層的因子構造を2因子構造に変換する方法について議論しています。Schmid.leiman は、対角上に共同体性を持つ 12 x 12 の相関行列です。これは減衰補正の効果を示すために使用できます。さらに2つのデータセットがChen et al.
m個の項目（-1, 0, 1）のk個のキーの行列またはdata.frameと、m個の項目とn人の項目のスコアの行列またはdata.frameが与えられたとき、各人と各尺度の合計スコアまたは平均スコアを求めなさい。  さらに、クロンバックのアルファ、平均r、尺度間相関、および項目と尺度の相関を報告せよ。  (<code>score.items</code>に取って代わられました)。
<code>irt.fa<//code>は二項項目または多項項目の四項相関または多項相関の因子分析により項目反応理論(IRT)のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code> は尺度のリストをスコア化します。
<code>irt.fa</code> は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論 (IRT) のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code> は尺度のリストをスコア化します。
<code>irt.fa</code> は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論 (IRT) のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code>は尺度のリストを得点化します。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらを得点化する方向のリスト(k個のキーを持つkeys.list)が与えられた場合、各人と各尺度の合計得点または平均得点を求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は <code>make.keys</code> を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は検出されませんが、項目の統計量は報告されます。(<code>cluster.cor</code>と同様の機能)。<code>response.frequencies</code>は、多項式または多肢選択式の項目の各回答カテゴリにおける項目の支持頻度を報告します。<code>scoreFast</code>と<code>scoreVeryFast</code>は得点の総和/平均を求めるだけで、信頼度を報告しない。  大規模なデータセットではより高速です。
score.multiple.choiceは採点キーとデータマトリックス(またはdata.frame)を受け取り、各参加者の合計または平均正解数を求めます。  テストの基本統計量（アルファ値、平均r、項目平均、項目-全体相関）も報告されます。
1s、0s、1sのn x c個のクラスタ定義行列（キー）、およびn x n個の相関行列、またはN x n個のデータ行列が与えられた場合、複合クラスタの相関を求めます。  キー行列は、手入力、クリップボードからのコピー（<code>read.clipboard</code>）、または<code>factor2cluster</code>や<code>make.keys</code>関数の出力として得ることができます。  <code>scoreItems</code>と同様の機能で、クラスタごとの項目相関も得られます。<code>scoreBy</code>は、<code>statsBy</code>を呼び出した後、個々の被験者に対してこれを行います。
n個の項目とN個のオブザベーションからなるdata.frameまたは行列と、それらを得点化する方向のリスト(k個のキーを持つkeys.list)が与えられた場合、各人と各尺度の合計得点または平均得点を求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は <code>make.keys</code> を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は検出されませんが、項目の統計量は報告されます。(<code>cluster.cor</code>と同様の機能)。<code>response.frequencies</code>は、多項式または多肢選択式の項目の各回答カテゴリにおける項目の支持頻度を報告します。<code>scoreFast</code>と<code>scoreVeryFast</code>は得点の総和/平均を求めるだけで、信頼度を報告しない。  大規模なデータセットに対してより高速に動作する。
<code>irt.fa<//code>は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論(IRT)のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code> は尺度のリストをスコア化します。
<code>irt.fa</code> は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論 (IRT) のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code> は尺度のリストをスコア化します。
<code>irt.fa</code> は二項項目または多項項目の四項相関または多項相関の因子分析を通して項目反応理論 (IRT) のパラメータを求めます。<code>scoreIrt<//code>はこれらの識別と位置のパラメータ推定値を用いて、IRTに基づく回答スコアを求めます。相関行列で発見されたのと同じ数の因子がスコア化されます。<code>scoreIrt.2pl</code>は尺度のリストを得点化します。
n個の項目とN個のオブザベーションのdata.frameまたは行列と、それらを得点化する方向のリスト(k個のキーを持つkeys.list)が与えられた場合、各人と各尺度の合計得点または平均得点を求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は <code>make.keys</code> を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は検出されませんが、項目の統計量は報告されます。(<code>cluster.cor</code>と同様の機能)。<code>response.frequencies</code>は、多項式または多肢選択式の項目の各回答カテゴリにおける項目の支持頻度を報告します。<code>scoreFast</code>と<code>scoreVeryFast</code>は得点の総和/平均を求めるだけで、信頼度を報告しない。  大規模なデータセットではより高速です。
1、0、1（キー）の n x c 個のクラスタ定義行列と n x n 個の相関行列、または N x n 個のデータ行列が与えられた場合、複合クラスタの相関を求めます。  キー行列は、手入力、クリップボードからのコピー（<code>read.clipboard</code>）、または<code>factor2cluster</code>や<code>make.keys</code>関数の出力として得ることができます。  <code>scoreItems</code>と同様の機能で、クラスタごとの項目相関も得られます。<code>scoreBy</code>は、<code>statsBy</code>を呼び出した後、個々の被験者に対してこれを行います。
n個の項目とN個のオブザベーションからなるdata.frameまたは行列と、それらを得点化する方向のリスト(k個のキーを持つkeys.list)が与えられた場合、各人と各尺度の合計得点または平均得点を求めます。  さらに，クロンバックのアルファ，ガットマンのラムダ6，平均r，尺度間相関，および項目と尺度の相関（生の相関と項目の重なりの補正）を報告する．  必要であれば、欠損値を項目の中央値または平均値に置き換える。項目のキーは1（得点する）、-1（逆得点する）、または0（得点しない）。キーが負の項目は逆得点されます。  以前のバージョンではキー行列を使用していましたが、現在では採点キーのリストを使用することが推奨されています。キーファイルを作成する便利な方法は <code>make.keys</code> を参照してください。  入力が正方行列の場合、入力は共分散行列または相関行列であるとみなされ、得点は検出されませんが、項目の統計量は報告されます。(<code>cluster.cor</code>と同様の機能)。<code>response.frequencies</code>は、多項式または多肢選択式の項目の各回答カテゴリにおける項目の支持頻度を報告します。<code>scoreFast</code>と<code>scoreVeryFast</code>は得点の総和/平均を求めるだけで、信頼度を報告しない。  大規模なデータセットではより高速になる。
<code>bestScales</code>または<code>setCor</code>からの項目重みは、重み付きスケールスコアを見つけるために使用されます。<code>scoreItems</code>で使用される単位重みとは対照的に、<code>scoreWtd</code>はスケールスコアを求めるためにデータに重みのセットを掛けます。  これらの重みは回帰（例えば、<code>lm</code>や<code>setCor</code>）から得られるか、<code>bestScales</code>からのゼロ次相関重みであるかもしれません。
Cattellのscree検定は、相関行列の成分や因子の数を検定する最も簡単な方法の1つです。ここでは、相関行列の固有値と因子分析の固有値をプロットします。
データ分析の面倒な部分は、NAや他の値に変換する必要があるミスコード・データの問題に対処することです。  scrubは、与えられたdata.frameや行列に対して、fromからto=toまでの列の値のうち、最小値の集合（ベクトル）より小さいもの、または最大値のベクトルより大きいものをすべてNAに設定します。また、すべての値=isvalueからnewvalueへの基本的なデータの再コード化にも使用できます。連続変数をより少ないカテゴリに再コード化することもできます。  Nan、-Inf、InfをNAに変換します。

where、isvalue、newvaluesの長さは一致するか、1でなければならない。
ベクトル、行列、または data.frame の標準偏差を求めます。  後者2つの場合は、各列の sd を返します。  sd 関数とは異なり、オブザベーションがない場合はエラーを投げるのではなく NA を返します。
 <code>scoreItems</code>を使用して生データから、または<code>cluster.cor</code>を使用して相関行列から、複合尺度を形成して項目を採点する場合、以前はキー行列を作成する必要がありました。ほとんどのスコアリング関数は直接キーのリストを使用するので、これはもはや必要ありません。<code>make.keys</code>は単にキー行列を作るためのショートカットです。  キー行列は-1,0,1の nvar x nscales 行列で、各スケールのメンバーシップを定義します。項目は、場所または名前で指定できます。
構造方程式モデルのグラフィカル・プレゼンテーションは，半確定因子モデルと確認因子モデルを概念化するのにとても便利な方法である．x (xmodel) と y (ymodel) の測定モデル、および x と y を結ぶパス・モデル (phi) が与えられている場合、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合は，x 変数または y 変数間の相関を示す．

さらに便利なことに、この関数はJohn Foxの<em>semパッケージ</em>やYves Rosseelの<em>lavaan</em>パッケージで直接実行するのに適したモデルを返します。    このオプションを直接使用するには、errors=TRUEを指定する必要があります。

入力は行列か、<code>fa</code>、factanal、または<em>GPArotation</em>のような回転パッケージからの出力として指定できます。

記号グラフの場合、入力行列は文字列か、文字列と数値ベクトルの混合になる。

オプションとして、Rgraphvizがインストールされていない場合、<code>structure.sem<//code>はsemモデルだけを作成し、グラフをスキップします。(この機能は現在<code>structure.diagram</code>に含まれています)。

structure.diagramは、Rgraphvizを使用せずにダイアグラムを描画するので、おそらく好ましいオプションである。

<code>lavaan.diagram</code>はlavaanパッケージからcfaまたはsemの結果を描画します。cfa、sem、mimic型の出力についてテストされています。  <em>lavaan</em>から出力オブジェクトを受け取り、<code>structure.diagram</code>を呼び出します。
構造方程式モデルのグラフィカルな表現は、semや確証的因子モデルを概念化するのにとても便利な方法です。x (xmodel) と y (ymodel) の測定モデル、および x と y (phi) を結ぶパス・モデルが与えられたら、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合は，x 変数または y 変数間の相関を示す．

さらに便利なことに、この関数はJohn Foxの<em>semパッケージ</em>やYves Rosseelの<em>lavaan</em>パッケージで直接実行するのに適したモデルを返します。    このオプションを直接使用するには、errors=TRUEを指定する必要があります。

入力は行列か、<code>fa</code>、factanal、または<em>GPArotation</em>のような回転パッケージからの出力として指定できます。

記号グラフの場合、入力行列は文字列か、文字列と数値ベクトルの混合になる。

オプションとして、Rgraphvizがインストールされていない場合、<code>structure.sem<//code>はsemモデルだけを作成し、グラフをスキップします。(この機能は、現在<code>structure.diagram</code>に含まれています)。

structure.diagramは、Rgraphvizを使用せずにダイアグラムを描画し、おそらく好ましいオプションです。

<code>lavaan.diagram</code>はlavaanパッケージからcfaまたはsemの結果を描画します。cfa、sem、mimic型の出力についてテストされています。  <em>lavaan</em>から出力オブジェクトを受け取り、<code>structure.diagram</code>を呼び出します。
相関行列または生データの行列またはデータフレームが与えられた場合、重回帰を求め、x変数の集合の関数としてy変数の集合を関連付けるパス図を描きます。  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求める。
相関行列または生データの行列またはデータ・フレームが与えられると，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描く．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合間の正準相関も求める。
相関行列または生データの行列またはデータ・フレームが与えられると，重回帰を求め，x 変数の集合の関数として y 変数の集合を関連づけるパス図を描く．  共変量(z)の集合は、xとyの集合から分割することができます。回帰図は自動的に含まれる．   モデルは，従来の数式形式でも，x 変数とy 変数の項でも指定できる．  生データを使用する場合は，乗法モデル（交互作用）および2次項を数式モードで指定できる．デフォルトでは、交互作用を求める前にデータをゼロ中心にすることができる。  予測変数集合(x)と基準集合(y)の間のCohenの集合相関も求めます。x と y の集合の間の正準相関も求めます。
 合理的、要因的、または経験的な手段によって尺度を構築する場合、互いに最も高く関係する項目の内容（例えば、項目集合の<code>fa.lookup<//code>の因子負荷量）、またはいくつかの特定の基準集合（例えば、<code>bestScales<//code>）を調べることが有用です。項目内容の辞書が与えられると、これらのルーチンは、因子負荷または基準相関によってソートし、項目内容を表示します。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は2つのdata.frameを（同じ長さの）相関させます。 levels2numericとchar2numericは、カテゴリー/レベルであるdataframeの列を数値に変換します。
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>は階層的な因子モデルを作成し、<code>sim.item</code>はより一般的な項目のシミュレーションを行い、<code>sim.minor</code>は主要因子とマイナー因子をシミュレーションし、<code>sim.omega</code>はomegaの様々な例をテストし、<code>sim.parallel</code>は因子の数を決定する様々な方法の効率を比較します。   その他のシミュレーション関数については、ヘルプページを参照してください：<code>sim.rasch</code>はシミュレーションされたraschデータを作成します。 <code>sim.irt</code>は<code>sim.npl</code> 1から4パラメータのロジスティックIRTまたは<code>sim.npn</code> 1〜4パラメタ正規IRT,<code>sim.poly</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npn</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
sim.anovaは、3つの独立変数(IV1, IV2, IV3)の計画行列を、任意の数の水準と各主効果および交互作用の効果量とともに生成します。  IVは連続またはカテゴリーで、線形または2次効果を持つことができます。単一の従属変数または複数の（被験者内の）従属変数のいずれかが、指定されたモデルに従って生成されます。反復測定は，指定された信頼性を持つタウ等価であると仮定される．
因子負荷量と因子相互相関の集合から母集団直交相関行列または階層相関行列を作成する．そして，この母集団からサイズ n の標本を抽出することができる．  標本データ，標本相関，母集団相関のいずれかを返す．  これは、指導やデモンストレーションのためのサンプル・データ・セットを作成するために使用されます。
因子分析と主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造がある。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
古典的テスト理論（CTT）は、すべてのテストが1つの因子と残差誤差で表現できる場合、4つ以上のテストが共属的に等価であると見なします。  並列検定は，（通常2つの）検定が等しい因子負荷量を持つ特別なケースである．  タウ等価検定は，等しい因子負荷量を持つが，不均等な誤差を持つことがある．  共属検定は，因子負荷と誤差分散の両方で異なるかもしれない．
構造方程式モデルは、相関または相関行列を測定（因子）モデルと構造（回帰）モデルに分解します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データを生成します。

x 変数の集合と y 変数の集合を別々に測定モデルを指定することもできます。  そして、それらは、2つの集合の間の相関構造を持つ1つのモデルに結合されます。

最後に、一般的なケースとして、母集団の相関行列が与えられ、その相関行列を（サンプリングのばらつきで）再現するデータを生成します。  <code>sim.correlation</code>を参照してください。
因子分析や主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>は階層的な因子モデルを作成し、<code>sim.item</code>はより一般的な項目のシミュレーションを行い、<code>sim.minor</code>は主要因子とマイナー因子をシミュレーションし、<code>sim.omega</code>はomegaの様々な例をテストし、<code>sim.parallel</code>は因子の数を決定する様々な方法の効率を比較します。   その他のシミュレーション関数については、ヘルプページを参照してください：<code>sim.rasch</code>はシミュレーションされたraschデータを作成します。 <code>sim.irt</code>は<code>sim.npl</code> 1から4パラメータのロジスティックIRTまたは<code>sim.npn</code> 1〜4パラメタ正規IRT,<code>sim.poly</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npn</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
因子負荷量と因子相互相関の集合から母集団直交相関行列または階層相関行列を作成する。そして，この母集団からサイズ n の標本を抽出することができる．  標本データ、標本相関、母集団相関のいずれかを返します。  これは、指導やデモンストレーション用のサンプル・データ・セットを作成するために使用されます。
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデルの作成、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
因子分析と主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>は階層的な因子モデルを作成し、<code>sim.item</code>はより一般的な項目のシミュレーションを行い、<code>sim.minor</code>は主要因子とマイナー因子をシミュレーションし、<code>sim.omega</code>はomegaの様々な例をテストし、<code>sim.parallel</code>は因子の数を決定する様々な方法の効率を比較します。   その他のシミュレーション関数については、ヘルプページを参照してください：<code>sim.rasch</code>はシミュレーションされたraschデータを作成します。 <code>sim.irt</code>は<code>sim.npl</code> 1から4パラメータのロジスティックIRTまたは<code>sim.npn</code> 1〜4パラメタ正規IRT,<code>sim.poly</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npn</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
マルチレベル・データは、オブザベーションがグループ内に入れ子になっているときに発生します。これは、時に理解しにくい相関構造を生み出すことがあります。これらの2つのシミュレーションは、グループ内の相関が、グループ平均間の相関を意味するものでも、グループ平均間の相関によって暗示されるものでもないことを実証することを可能にします。集計されたデータの相関は「生態学的相関」と呼ばれることがある。グループレベルの相関と個人レベルの相関が独立であることは、このような推論を問題にする。  個人内データは、sim.multiで様々な個人内構造が可能なようにシミュレートされています。  
多階層データは、オブザベーションがグループ内に入れ子になっているときに発生します。これは、時に理解しにくい相関構造を生み出すことがあります。これらの2つのシミュレーションは、グループ内の相関が、グループ平均間の相関を意味するものでも、グループ平均間の相関によって暗示されるものでもないことを示すことができます。集計されたデータの相関は「生態学的相関」と呼ばれることがある。グループレベルの相関と個人レベルの相関が独立であることは、このような推論を問題にする。  個人内データは、sim.multiで様々な個人内構造が可能なようにシミュレートされています。  
psychパッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>は階層的な因子モデルを作成し、<code>sim.item</code>はより一般的な項目のシミュレーションを行い、<code>sim.minor</code>は主要因子とマイナー因子をシミュレーションし、<code>sim.omega</code>はomegaの様々な例をテストし、<code>sim.parallel</code>は因子の数を決定する様々な方法の効率を比較します。   その他のシミュレーション関数については、ヘルプページを参照してください：<code>sim.rasch</code>はシミュレーションされたraschデータを作成します。 <code>sim.irt</code>は<code>sim.npl</code> 1から4パラメータのロジスティックIRTまたは<code>sim.npn</code> 1〜4パラメタ正規IRT,<code>sim.poly</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npn</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>は階層的な因子モデルを作成し、<code>sim.item</code>はより一般的な項目のシミュレーションを行い、<code>sim.minor</code>は主要因子とマイナー因子をシミュレーションし、<code>sim.omega</code>はomegaの様々な例をテストし、<code>sim.parallel</code>は因子の数を決定する様々な方法の効率を比較します。   その他のシミュレーション関数については、ヘルプページを参照してください：<code>sim.rasch</code>はシミュレーションされたraschデータを作成します。 <code>sim.irt</code>は<code>sim.npl</code> 1から4パラメータのロジスティックIRTまたは<code>sim.npn</code> 1〜4パラメタ正規IRT,<code>sim.poly</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npn</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目シミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目シミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim.simplex</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>による階層因子モデル、<code>sim.item</code> より一般的な項目のシミュレーション、<code>sim.minor</code> 大因子と小因子のシミュレーション、<code>sim.omega</code> omegaの様々な例をテストする、<code>sim.parallel</code> 因子の数を決定する様々な方法の効率を比較する、<code>sim.rasch</code> シミュレーションされたraschデータを作成する、<code>sim.irt</code>は<code>sim.npl</code> 1-4パラメータロジスティックIRTまたは<code>sim.npn</code> 1-4パラメータ正規IRTを呼び出して一般的な1-4パラメータIRTデータを作成する,<code>sim.poly</code>は<code>sim.poly.npn</code> 1-4パラメータ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別にドキュメント化されていますが、ヘルプ機能を使いやすくするためにここにリストアップしています。  より詳細なヘルプは各関数を参照してください。
psych パッケージの多くの関数は、特定の構造を持つシミュレーションデータを生成します。  これらの関数には、<code>sim</code>による因子シンプレックス、<code>sim.simplex</code>によるデータシンプレックス、<code>sim.circ</code>による円周構造、<code>sim.congeneric</code>による1因子共同モデル、<code>sim.dichot</code>による2値項目のシミュレート、<code>sim.hierarchical</code>は階層的な因子モデルを作成し、<code>sim.item</code>はより一般的な項目のシミュレーションを行い、<code>sim.minor</code>は主要因子とマイナー因子をシミュレーションし、<code>sim.omega</code>はomegaの様々な例をテストし、<code>sim.parallel</code>は因子の数を決定する様々な方法の効率を比較します。   その他のシミュレーション関数については、ヘルプページを参照してください：<code>sim.rasch</code>はシミュレーションされたraschデータを作成します。 <code>sim.irt</code>は<code>sim.npl</code> 1から4パラメータのロジスティックIRTまたは<code>sim.npn</code> 1〜4パラメタ正規IRT,<code>sim.poly</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npn</code> 1〜4パラメタ多値正規理論項目または<code>sim.poly.npl</code> 1-4パラメタ多項式ロジスティック項目、<code>sim.poly.ideal.npn</code> 1-4パラメタ多項式正規理論理想点モデルまたは<code>sim.poly.ideal.npl</code> 1-4パラメタ多項式ロジスティック理想点モデルを呼び出して理想点または展開モデルに従ったデータを作成する<code>sim.poly.ideal</code>があります。

<code>sim.structural</code>は構造モデルの一般的なシミュレーション、<code>sim.anova</code>はANOVAとlmのシミュレーション、<code>sim.VSS</code>はVSSのシミュレーションです。これらの関数のいくつかは個別に文書化されていますが、ヘルプ機能を使いやすくするためにここに列挙しました。  より詳細なヘルプは各関数を参照してください。
因子分析と主成分分析の解の回転は、通常、相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  単純構造と円周構造のデータの生成は簡単で、影響とパーソナリティ構造の代替解を探索するのに有用である。3次元（球形）データへの一般化は簡単である。
構造方程式モデルは、相関行列または相関行列を測定（因子）モデルと構造（回帰）モデルに分解します。sim.structuralは、測定と構造の特性が既知のデータセットを作成します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データを生成します。

x 変数の集合と y 変数の集合を別々に測定モデルを指定することもできます。  そして、それらは、2つの集合の間の相関構造を持つ1つのモデルに結合されます。

最後に、一般的なケースとして、母集団の相関行列が与えられ、その相関行列を（サンプリングのばらつきで）再現するデータを生成します。  <code>sim.correlation</code>を使用します。
構造方程式モデルは、相関行列または相関行列を測定（因子）モデルと構造（回帰）モデルに分解します。sim.structuralは、既知の測定特性と構造特性を持つデータセットを作成します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データを生成します。

x 変数の集合と y 変数の集合を別々に測定モデルを指定することもできます。  そして、それらは、2つの集合の間の相関構造を持つ1つのモデルに結合されます。

最後に、一般的なケースとして、母集団の相関行列が与えられ、その相関行列を（サンプリングのばらつきで）再現するデータを生成します。  <code>sim.correlation</code>。
シミュレーションは統計学や心理測定学で最も有用なテクニックの1つです。  ここでは、指定された数の因子からなる単純な構造の相関行列をシミュレーションします。  各項目は複雑度1であると仮定します。  別のシミュレーションについては、<code>circ.sim<//code>と<code>item.sim<//code>を参照してください。
構造方程式モデルは、相関行列または相関行列を測定（因子）モデルと構造（回帰）モデルに分解します。sim.structuralは、既知の測定特性と構造特性を持つデータセットを作成します。既知の特性を持つ母集団または標本の相関行列が生成されます。オプションで生データを生成します。

x 変数の集合と y 変数の集合を別々に測定モデルを指定することもできます。  そして、それらは、2つの集合の間の相関構造を持つ1つのモデルに結合されます。

最後に、一般的なケースとして、母集団の相関行列が与えられ、その相関行列を（サンプリングのばらつきで）再現するデータを生成します。  <code>sim.correlation</code>を参照してください。
因子分析や主成分分析の解の回転は、一般的に相関行列を単純な構造として表現しようとします。  別の構造として、変数が2次元空間の円の外周に一様に配置された円周構造があります。  これらのデータを作成するのは簡単で、影響や性格の構造に関する代替解を探索するのに便利である。
data.frameまたは行列の各変数のskewとkurtosisを求めます。  e1071のskewとkurtosisとは異なり、これはdata.frame/matrixの各変数または各列に対して異なるskewを計算します。
ある変数と行列内の残りの変数の2乗重相関は、変数の共同性の初期推定値として使用されることがあります。

SMCは、ガットマンのラムダ6<code>guttman</code>係数を用いて信頼性を推定する場合にも用いられる。

ここでR.invはRの逆数である。
レーダー・プロットとスパイダー・プロットは、多変量データを表示する多くの方法のうちの2つに過ぎません。  <code>レーダー</code>は、相関を0（r=-1に対応）から1（r=1に対応）までの長さのベクトルとしてプロットします。  ベクトルは円の周りに放射状に配置されます。スパイダープロットは、各ベクトルの端点を結ぶ。プロットは，変数が何らかの意味のある方法で編成されている場合に最も適切である．
テストの信頼性の8つの代替推定は，Guttman (1945)によって議論された6つ，ten Berge and Zergers (1978)によって議論された4つ（<i>μ_0 ... μ_3）</i>，<i>β</i>（the worst split half, Revelle, 1979），Bentler and Woodward (1980)によって議論されたglb（greatgest lowest bound），および<i>ω_h</i>と<i>ω_t</i>（McDonald, 1999; Zinbarg et al、2005).スプリットハーフの最大値と最小値は、総当たりまたはサンプリングによって見つけられる。
2つのレベル（たとえば、個人といくつかのグループ化変数のセット）でデータを調査する場合、基本的な記述統計量（平均、sds、グループごとのns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルの相関の行列を、グループ内の相関とグループ間の相関に分解する機能です。
2つのレベル（例えば、個人といくつかのグループ化変数のセット）でデータを調査する場合、基本的な記述統計量（平均、sds、グループごとのns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルの相関の行列を、グループ内の相関とグループ間の相関に分解する機能です。
2つのレベル（例えば、個人といくつかのグループ化変数のセット）でデータを調査する場合、基本的な記述統計量（平均、sds、グループごとのns、グループ内相関）だけでなく、グループ間の統計量（すべての記述統計量、全体的なグループ間相関）を見つけることが有用です。特に有用なのは、個人レベルの相関の行列を、グループ内の相関とグループ間の相関に分解する機能です。
構造方程式モデルのグラフィカル・プレゼンテーションは，半確定因子モデルと確証因子モデルを概念化するのに非常に有用な方法である．x (xmodel) と y (ymodel) の測定モデル、および x と y (phi) を接続するパス・モデルが与えられている場合、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合は，x 変数または y 変数間の相関を示す．

さらに便利なことに、この関数はJohn Foxの<em>semパッケージ</em>やYves Rosseelの<em>lavaan</em>パッケージで直接実行するのに適したモデルを返します。    このオプションを直接使用するには、errors=TRUEを指定する必要があります。

入力は行列か、<code>fa</code>、factanal、または<em>GPArotation</em>のような回転パッケージからの出力として指定できます。

記号グラフの場合、入力行列は文字列か、文字列と数値ベクトルの混合になる。

オプションとして、Rgraphvizがインストールされていない場合、<code>structure.sem<//code>はsemモデルだけを作成し、グラフをスキップします。(この機能は、現在<code>structure.diagram</code>に含まれています)。

structure.diagramは、Rgraphvizを使用せずにダイアグラムを描画し、おそらく好ましいオプションです。

<code>lavaan.diagram</code>はlavaanパッケージからcfaまたはsemの結果を描画します。cfa、sem、mimic型の出力についてテストされています。  <em>lavaan</em>から出力オブジェクトを受け取り、<code>structure.diagram</code>を呼び出します。
構造方程式モデルのグラフィカルな表現は、semや確証的因子モデルを概念化するのにとても便利な方法です。x (xmodel) と y (ymodel) の測定モデル、および x と y (phi) を結ぶパス・モデルが与えられたら、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合は，x 変数または y 変数間の相関を示す．

さらに便利なことに、この関数はJohn Foxの<em>semパッケージ</em>やYves Rosseelの<em>lavaan</em>パッケージで直接実行するのに適したモデルを返します。    このオプションを直接使用するには、errors=TRUEを指定する必要があります。

入力は行列か、<code>fa</code>、factanal、または<em>GPArotation</em>のような回転パッケージからの出力として指定できます。

記号グラフの場合、入力行列は文字列か、文字列と数値ベクトルの混合になる。

オプションとして、Rgraphvizがインストールされていない場合、<code>structure.sem<//code>はsemモデルだけを作成し、グラフをスキップします。(この機能は現在<code>structure.diagram</code>に含まれています)。

structure.diagramは、Rgraphvizを使用せずにダイアグラムを描画するので、おそらく好ましいオプションである。

<code>lavaan.diagram</code>はlavaanパッケージからcfaまたはsemの結果を描画します。cfa、sem、mimic型の出力についてテストされています。  <em>lavaan</em>から出力オブジェクトを受け取り、<code>structure.diagram</code>を呼び出します。
structure.listはリスト入力をデザイン行列に変換します。φ.listは相関行列に対して同じことを行います。NULL値を持つ因子は0で埋められます。
構造方程式モデルのグラフィック表示は、半確定因子モデルと確証因子モデルを概念化するのに非常に便利な方法です。x (xmodel)とy (ymodel)の測定モデル、およびxとyを結ぶパスモデル(phi)が与えられたら、グラフを描きます。  ymodel が指定されない場合，測定モデル (xmodel + phi) だけを描画する．Rx 行列または Ry 行列が指定された場合は，x 変数または y 変数間の相関を示す．

さらに便利なことに、この関数はJohn Foxの<em>semパッケージ</em>やYves Rosseelの<em>lavaan</em>パッケージで直接実行するのに適したモデルを返します。    このオプションを直接使用するには、errors=TRUEを指定する必要があります。

入力は行列か、<code>fa</code>、factanal、または<em>GPArotation</em>のような回転パッケージからの出力として指定できます。

記号グラフの場合、入力行列は文字列か、文字列と数値ベクトルの混合になる。

オプションとして、Rgraphvizがインストールされていない場合、<code>structure.sem<//code>はsemモデルだけを作成し、グラフをスキップします。(この機能は、現在<code>structure.diagram</code>に含まれています)。

structure.diagramは、Rgraphvizを使用せずにダイアグラムを描画し、おそらく好ましいオプションである。

<code>lavaan.diagram</code>はlavaanパッケージからcfaまたはsemの結果を描画します。cfa、sem、mimic型の出力についてテストされています。  <em>lavaan</em>から出力オブジェクトを受け取り、<code>structure.diagram</code>を呼び出します。
psychのほとんどの関数について、限定的な出力(print)か、やや詳細な出力(summary)を与えます。
行列nXmとjYkが与えられたとき、超対角線に沿った要素xとyを持つ次元(n+j)と(m+k)の超行列を形成する。構造方程式を考慮するときに便利である．  測定モデル x と y は，すべての変数のより大きな測定モデルに結合できる．  もし x か y のどちらかが行列のリストであれば，それらのすべての要素から再帰的にスーパー行列を形成します．superCor は，2つの行列と2つの要素の相互相関から行列を形成します．
行列 nXm, jYk が与えられたとき, (n+j), (m+k) 次元の超行列を 形成する.構造方程式を考慮するときに便利である．  測定モデル x と y は，すべての変数のより大きな測定モデルに結合できる．  もし x か y のどちらかが行列のリストであれば，それらのすべての要素から再帰的にスーパー行列を形成します．superCor は，2つの行列と2つの要素の相互相関から行列を形成します．
行列 nXm, jYk が与えられたとき, (n+j), (m+k) 次元の超行列を 形成する.構造方程式を考慮するときに便利である．  測定モデル x と y は，すべての変数のより大きな測定モデルに結合できる．  superCor は、2つの行列とその要素の相互相関から行列を作成します。
data.frameまたは行列が与えられた時、グループ変数による各変数の標準化平均差（Cohenのd）と信頼区間を求めます。  d 統計量を r 等価値に変換し、スチューデントの t 統計量と関連する p 値を報告し、グループ化変数の両方の値の統計量を返します。  すべての変数で定義された空間での2つのグループの中心間のマハラノビス距離も求めます。  一方のグループのCohen d（0からの差）の信頼区間も見つけられるかもしれない．分布の重なりのいくつかの尺度（OVL，OVL2など）が利用可能である．
r2dは相関を効果量（Cohenのd）に変換し，d2rはdをrに変換する．   t2rはt検定をrに変換し、r2tは相関をt検定値に変換します。chi2rはカイ二乗をrに変換し、r2chiは元に戻します。r2cとcor2covは相関行列を共分散行列に変換します。
過去のセットの中には、限られたビン数のカウントの要約表として報告されているものがあります。  これらの表を元の値を表すdata.frameに変換することは、教育的な目的に役立ちます。  (例えば、回帰を実証するために、身長 x 立方体の元のガルトンの表を変換する)。列名と行名は数値に変換できなければならない。
過去のセットの中には、限られた数のビンにおけるカウントの要約表として報告されているものもある。  これらの表を元の値を表すdata.frameに変換することは、教育的な目的に役立ちます。  (例えば、回帰を実証するために、身長 x 立方体の元のガルトンの表を変換する)。列名と行名は数値に変換できなければならない。
lowerCorはx変数の相関を求め、lowerMatを使用してそれらを表示します。これは些細な関数ですが、行列の下三角形を四捨五入して表示する便利な関数です。reflectは因子分析または主成分分析の出力を反映し、1つ以上の因子が反映されるようにします。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は、2つのdata.frame（同じ長さ）を相関させます。 levels2numericとchar2numericは、カテゴリカル/レベルであるdataframeの列を数値に変換します。
Nurit Tal-Or, Jonanathan Cohen, Yariv Tasfati, and Albert Gunther (2010) は、メディアが他者に及ぼす推定効果と態度の変化を調査しました。  このデータセットは研究2のもので、メディアの推定される影響がその後の行動に及ぼす影響を調べたものである。  これは、Hayes（2013）による媒介の例として、また媒介関数に使用されている。
Nurit Tal-Or, Jonanathan Cohen, Yariv Tasfati, and Albert Gunther (2010)は、他者に対するメディアの推定影響と態度の変化を調査した。  このデータセットは研究2のもので、メディアの推定される影響がその後の行動に及ぼす影響を調べたものである。  これは、Hayes (2013)による媒介の例として、またmediate関数に使用されている。
bifactor回転は、GPArotationパッケージのGPForthを呼び出して、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013)が提案したバリミン回転は、GPArotationへの適切な呼び出しによって実装されます。
テストの信頼性の8つの代替推定値には、Guttman (1945)によって議論された6つ、ten Berge and Zergers (1978)によって議論された4つ（<i>μ_0 ... μ_3）</i>、および<i>β</i>（最悪のスプリット・ハーフ、Revelle, 1979）、Bentler and Woodward (1980)によって議論されたglb（最大最小境界）、および<i>ω_h</i>と<i>ω_t</i>（McDonald, 1999; Zinbarg et al、2005).スプリットハーフの最大値と最小値は、総当りまたはサンプリングによって求められる。
lowerCorは、x変数の相関を求め、lowerMatを使用してそれらを表示します。lowerMatは、行列の下三角形を四捨五入して表示する些細な、しかし便利な関数です。reflectは、1つ以上の因子が反映されるように、因子分析または主成分分析の出力を反映します。(Requested by Alexander Weiss.)progressBar prints out ... as a calling routine (e.g., <code>tetrachoric</code>) works through a tored calculation. shannon finds the Shannon index (H) of diversity or of information. test.all tests all the examples in a package. best.items sort a factor matrix for absolute values and displays the expanded items names. fa.lookup returns sorted factor analysis output with item labels.<code>cor2</code>は2つのdata.frame（同じ長さ）の相関をとります。 levels2numericとchar2numericは、カテゴリー/レベルであるdataframeの列を数値に変換します。
 項目反応理論（Item Response Theory）は、潜在スコアを推定するための多くの代替方法を提供します。  ここでは、回答パターンに関連する潜在変数を推定する6つの異なる方法を比較します。もともとはscoreIrtのテストとして開発されたものであるが、おそらくデモンストレーションの目的にも有用であろう。  項目は<code>sim.irt</code>を使ってシミュレートされ、<code>factor.scores</code>から<code>irt.fa</code>、1PLと2PL、2PNの単純加重モデルを使って統計量を求め、因子スコアを用いて採点されます。結果は、2値の場合はMIRTとldmの推定値とほぼ完全に一致し、多値の場合はMIRTとほぼ完全に一致した。  (ldmの結果は多値の場合不安定で、<code>scoreIrt</code>やMIRTと一致することもあれば、かなり悪いこともある)。  
心理関数が基本的なテストデータセットで実行されることを確認するテスト
テストの2つのプレゼンテーションがあれば、項目間の信頼性と人の安定性と同様に、テスト・リテスト信頼性を求めるのは簡単です。  データの多階層構造を用いて、人、項目、時間、人 x 時間、人 x 項目、項目 x 時間の分散成分や残差分散を見つけるために、分散分解を行うことも可能です。これは、さまざまな一般化係数につながります。
四分位相関は、二変量正規性を仮定した2 x 2表から推測されるピアソン相関です。多項相関は、これを n x m 表に一般化します。項目反応理論を行うときや，正規理論を用いた共存統計量を相関に変換するときに特に重要である．入力は，セル度数の2 x 2 表，セル度数のベクトル，または2分値データ（4分値の場合）または数値データ（多分値の場合）の data.frameまたは行列である．双列相関は、連続変数(X)と順序付きカテゴリ変数（たとえば、項目応答）の間の推論された潜在相関である多列相関の特別なケースです。後の2つの入力はデータフレームまたは行列である。  mnormtパッケージが必要。
サーストンケースVスケーリングは、他のオブジェクトと比較したオブジェクトのスケーリングを可能にする。サーストンが考慮したケースの1つとして、ケースVは等分散と無相関分布を仮定している。
Holzinger-Swineford (1937) は、一般因子と無相関グループ因子の2因子モデルを導入した。Holzingerのデータセットは、Joreskogが例として使用した9 *9 行列と同様に、彼らの論文からのオリジナルの14 * 14 行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
Holzinger-Swineford (1937) は、一般因子と無相関群因子の2因子モデルを導入した。Holzingerのデータセットは、彼らの論文にあるオリジナルの14 * 14行列と、Joreskogが例として使用した9 * 9行列である。サーストン相関行列は、能力項目の相関の9 * 9 行列である。  Reiseのデータセットは、メンタルヘルス項目の16 * 16相関行列である。ベヒトルト（Bechtholdt）のデータセットは、いずれも能力検査の17 x 17の相関行列である。  
data.frame、行列、テキスト・オブジェクトの最初と最後のn行を表示する簡単な方法。  <code>head</code>と<code>tail</code>または<code>View</code>を呼び出すだけです。
サイコメトリクスの多くの数式に登場しないのであれば、コーディングする価値はほとんどありません。
Tucker and Lewis (1973) はML因子分析の信頼性係数を導入した。  彼らのデータ・セットは、Tucker (1958) によって以前に報告され、Thurstone and Thurstone (1941)から取られたものです。  この相関行列は710人の被験者に対する9×9の行列で、2つの能力の相関因子がある：単語の流暢さ」と「言語能力」である。
項目の集合が1つの潜在特性を測定しているかどうかを評価する方法はいろいろある。  <code>unidim</code>は、もう1つの方法です。  もしデータに1因子モデルが成り立つなら、因子分析分解Fは、FF'が対角線に沿った共分散性を持つ相関を再現することを意味します。この場合、適合度FF'は相関行列から一意性を除いたものと同じになるはずである。  これが高ければ高いほど，一次元性の証拠となる．多くの代替統計量が推定される．
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、その名前で呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、その名前で呼び出すのが簡単です。  Ertl (2013) が提案したバリミン回転は、GPArotation への適切な呼び出しによって実装される。
bifactor回転は、GPArotationパッケージのGPForthを呼び出すことで、Jennrich and Bentler (2011)によって導入された回転を実装しています。promaxは、Hendrickson and White (1964)によって導入された斜め回転関数で、statsパッケージのpromax関数で実装されています。  残念ながら、promaxは因子間相関を報告しません。  promaxはそうです。  TargetQ は、欠損（NA）または数値（たとえば、0, 1）の要素を持つターゲット回転を行います。  target.rot は、任意のターゲット行列に対する一般的なターゲット回転を行います。equamaxは、GPArotationを呼び出してequamax回転を行うことを容易にします。  Equamax は、GPArotation 内で特定のオプションとして利用可能ですが、equamax を使用すると、名前を付けて呼び出すのが簡単です。  Ertl (2013) が提案する varimin 回転は、GPArotation への適切な呼び出しによって実装される。
データ集合を記述する多くの方法の中で、1つはグループ化変数の各値の密度プロットであり、もう1つは複数変数のバイオリン・プロットです。  密度プロットは、効果量を示すために異なるグループの密度を示します。バイオリン・プロットは、箱ひげ図に似ていますが、実際の分布を示します。中央値、25パーセンタイル線、75パーセンタイル線が表示に追加されます。グループ化変数が指定されると、violinByは各変数と各グループについてviolin plotを描画します。データポイントも描画されます。
データ集合を表現する多くの方法の中で、1つはグループ化変数の各値の密度プロットであり、もう1つは複数の変数のバイオリン・プロットです。  密度プロットは、効果量を示すために、異なるグループの密度を示します。バイオリン・プロットは、箱ひげ図に似ていますが、実際の分布を示します。中央値、25パーセンタイル線、75パーセンタイル線が表示に追加されます。グループ化変数が指定されると、violinByは各変数と各グループについてviolin plotを描画します。データポイントも描画されるかもしれません。
探索的因子分析で適切な因子の数を決定する方法は複数あります。非常に単純な構造(VSS)基準のルーチンは、さまざまな複雑さの解と異なる因子数の解を比較することを可能にします。グラフィック出力は、さまざまな複雑さのレベルについて、「最適な」因子の数を示します。  Velicer MAP 基準もよい選択である。<code>nfactors</code>は、これらの代替推定値をいくつか見つけてプロットする。
探索的因子分析で適切な因子数を決定する方法は複数あります。非常に単純な構造(VSS)基準のルーチンにより、さまざまな複雑さの解や異なる因子数の解を比較することができます。グラフィック出力は、さまざまな複雑さのレベルについて、「最適な」因子の数を示します。  Velicer MAP 基準もよい選択である。<code>nfactors</code>は、これらの代替推定値をいくつか見つけてプロットする。
因子数のもう1つの有用なテストは、ランダム行列の固有値が実行列の固有値より大きい場合です。ここではランダムデータに対するVSS解を示す。より良い検定は、おそらく<code>fa.parallel</code>です。
最適な因子数を推定するための Very Simple Structure 基準 ( <code>VSS</code>) を、複雑さの増大と因子数の増加の関数としてプロットします。  
Cattellの scree 検定は、相関行列の成分または因子の数を検定する最も簡単な方法の1つである。ここでは、相関行列の固有値と因子分析の固有値をプロットします。
シミュレーションは、統計学や心理測定学で最も有用な手法の1つである。  ここでは、指定された数の因子からなる単純な構造の相関行列をシミュレートします。  各項目は複雑度1であると仮定する。  別のシミュレーションについては、<code>circ.sim<//code>と<code>item.sim<//code>を参照してください。
シミュレーションは統計学や心理測定に関する最も有用な手法の1つです。  ここでは、指定された数の因子からなる単純な構造の相関行列をシミュレーションします。  各項目は複雑度1であると仮定します。  別のシミュレーションについては、<code>circ.sim<//code>と<code>item.sim<//code>を参照してください。
John Schmid と John M. Leiman (1957) は、階層的因子構造を2因子構造に変換する方法を議論しています。Schmidには、12 x 12の相関行列の例があります。schmid.leimanは、対角上に共分散を持つ12 x 12の相関行列です。これは減衰補正の効果を示すために使用できます。さらに2つのデータセットがChen et al.
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は、Winsorizedスコアを求める。   上下のトリム値は、トリム分位点と1-トリム分位点の値が与えられる。  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
中心傾向のロバスト推定値の中には、トリム平均とウィンソライズ平均がある。  この関数は，ウィンソライズされた得点を求める．   上下のトリム値は，トリム分位点と1-トリム分位点の値が与えられる．  そして、平均、sds、分散が求められる。    
相関がグループ内相関とグループ間相関に分解され、これら2つの相関が独立であることを示す。  グループ間相関は生態学的相関と呼ばれることもあり、グループ内相関とグループ間相関への分解はマルチレベル・モデリングの基本概念である。  このデータ集合は、9つの変数間の合成相関を示し、4つのグループで16のケースを表現している。    
Cohen's kappa (Cohen, 1960)および重み付きκ (Cohen, 1968)は、名義得点を使用する場合、2人の評定者の一致を見つけるために使用できます。  ライトのカッパは，2人以上の評定者を使用する場合は，単なる平均コーエン・カッパである．

weighted.κは、（観察されたマッチの確率-予想されたマッチの確率）/（1-予想されたマッチの確率）である。  κは主対角線上のマッチだけを考慮する。  重み付きκは、対角線外の要素も考慮する。
関連性の多くの尺度の1つがユール係数である。  カウントの2×2の表が与えられる<br>。

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布とは無関係に単一性を引く係数」の1つであることを示している(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>ユールの連関係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばこれはDigbyのHである。  YuleBonettは2 x 2のケースでこれを実装し、YuleCorはデータ行列のケースでこれを実装する。
多くの関連性の尺度の1つがYule係数である。  カウントの2 x 2表が与えられた<br>場合

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布とは無関係に単一性を引く係数」の1つであることを示している(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>ユールの連関係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばこれはDigbyのHである。  YuleBonettは2 x 2のケースでこれを実装し、YuleCorはデータ行列のケースでこれを実装する。
多くの関連性の尺度の1つがYule係数である。  カウントの2 x 2表が与えられた<br>場合

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布に依存せずに単一性を引く係数」の1つであることを示した(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>Yuleの共働係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばこれはDigbyのHである。  YuleBonettは2 x 2の場合、YuleCorはデータ行列の場合にこれを実装する。
<code>Yule2tetra</code>と<code>Yule2phi</code>に置き換えられた非推奨関数のセット。

いくつかの古い相関行列は、ファイ相関行列またはユール相関行列として報告されている。  つまり、相関は2×2の計数表から求められたのである：<br>。

ユールQは(ad-bc)/(ad+bc)。<br> <br

限界頻度はa+b、c+d、a+c、b+d。

このような相関の正方行列と、a + bのセルにある各変数の割合が与えられれば、各相関を2×2の表に再変換し、対応する多項式相関を推定することが可能である（John Foxのpolychor関数を使用）。
関連性の多くの尺度の1つがユール係数である。  カウントの2×2表が与えられ<br

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布に依存せずに単一性を引く係数」の1つであることを示している(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>ユールの連関係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばDigbyのHである。彼らは、c=0.5 - (.5 * min(セル確率)^2がより一般的な係数であることを提案している。  YuleBonettは2 x 2の場合、YuleCorはデータ行列の場合にこれを実装する。
<code>Yule2tetra</code>と<code>Yule2phi</code>に置き換わった非推奨関数のセット。

いくつかの古い相関行列は、ファイ相関行列またはユール相関行列として報告されている。  つまり、相関は2×2の数表から求められたのである。

ユールQは(ad-bc)/(ad+bc)。<br> <br

限界頻度はa+b、c+d、a+c、b+d。

このような相関の正方行列と、a + bのセルにある各変数の割合が与えられれば、各相関を2×2の表に再変換し、対応する多項式相関を推定することが可能である（John Foxのpolychor関数を使用）。
関連性の多くの尺度の1つがユール係数である。  カウントの2×2表が与えられ<br

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布とは無関係に単一性を引く係数」の1つであることを示している(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>ユールの連関係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばこれはDigbyのHである。  YuleBonettは2 x 2のケースでこれを実装し、YuleCorはデータ行列のケースでこれを実装する。
多くの関連性の尺度の1つがYule係数である。  カウントの2 x 2表が与えられた<br>場合

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布に依存せずに単一性を引く係数」の1つであることを示した(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>Yuleの共働係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばDigbyのHである。彼らは、c=0.5 - (.5 * min(セル確率)^2がより一般的な係数であることを提案している。  YuleBonettは2 x 2のケースでこれを実装し、YuleCorはデータ行列のケースでこれを実装する。
多くの関連性の尺度の1つがYule係数である。  カウントの2 x 2表が与えられた<br>場合

ユールQは(ad - bc)/(ad+bc).<br>概念的には、これは、ペアになったオブザベーションの総数に対する、一致しているペアの数（ad）-不一致の数（bc）です。  Warren (2008) は，ユールのQが，「統計的独立性のもとではゼロ値を持ち，最大値は単一性を持ち，最小値は周辺分布に依存せずに単一性を引く係数」の1つであることを示した(p 787)．<br>ad/bcはオッズ比であり、Q = (OR-1)/(OR+1) <br>Yuleの共働係数は、Y = (sqrt(OR) - 1)/(sqrt(OR)+1)Yule.inv は、特定のQとマージン(a+b,c+d,a+c,b+d)のセルエントリを見つける。  これは、古い相関表をより従来の<code>phi</code>相関や<code>tetrachoric</code>相関に変換するのに便利です。<br>Yule2phiとYule2tetraは、マージンを設定したYule Qを、対応するphi相関やtetrachoric相関に変換します。

ボネットとプライスは、Q係数とY係数がともにORのべき乗（c）を上げる一般的な係数族の一部であることを示している。  c=1ならば、これはYuleのQであり、0.5ならばYuleのYであり、c=0.75ならばDigbyのHである。彼らは、c=0.5 - (.5 * min(セル確率)^2がより一般的な係数であることを提案している。  YuleBonettは2 x 2の場合、YuleCorはデータ行列の場合にこれを実装します。
関数 <code>acf</code> は、自己共分散または自己相関関数の推定値を計算します（デフォルトではプロットします）。  関数<code>pacf</code>は部分自己相関に使用される関数です。  関数<code>ccf</code>は2つの変量系列の相互相関または相互共分散を計算する。
自己相関関数に正確にフィットするAR過程を計算する。
<code>add.scope</code>と<code>drop.scope</code>は、項の階層性を尊重しながら、モデルに個別に追加または削除できる項を計算します。
引数<code>scope</code>に含まれる、モデルへの追加やモデルからの削除が可能なすべての項を計算し、それらのモデルを適合させ、適合度の変化を計算する。
与えられた表に対して、マージンを計算するために1つ以上の水準で拡張する分類因子を指定することができる。  例えば、1番目の次元の合計と平均、2番目の次元の中央値を計算することができる。  結果として得られる表は、1番目の次元に対して2つの追加レベル、2番目の次元に対して1つの追加レベルを持つことになる。  デフォルトは、表のマージン全体の合計である。  他の可能性は、マージンが計算される順序に依存する結果を与えるかもしれない。  このフラグは、関数から出力される印刷物に表示されます。
データを部分集合に分割し、それぞれについて要約統計量を計算し、その結果を便利な形式で返します。
データを部分集合に分割し、それぞれについて要約統計量を計算し、その結果を便利な形式で返します。
データを部分集合に分割し、それぞれについて要約統計量を計算し、その結果を簡便な形式で返す。
対数尤度値が得られる1つまたは複数の適合モデルオブジェクトについて、<i>-2*log-尤度 + k*npar</i> の式に従って赤池の「情報量基準」を計算する汎用関数、ここで <i>npar</i> は適合モデルのパラメータの数を表し，通常のAICでは<i>k = 2</i>， いわゆるBICまたはSBC（Schwarzのベイズ基準）では<i>k = log(n)</i> （<i>n</i> はオブザベーションの数）である．
式で指定された線形モデルのエイリアス（線形従属項）を見つける
1つまたは複数の適合モデルオブジェクトについて，分散分析（または偏差）表を計算する
スケールパラメータの差に関するAnsari-Bradleyの2標本検定を実行します
各層について<code>lm</code>を呼び出して分散分析モデルをフィットする。
与えられたデータ点を線形補間する点のリスト、または線形（または定数）補間を行う関数を返す。
与えられたデータ点を線形補間する点のリスト、または線形（または定数）補間を行う関数を返す。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータにフィットする。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータにフィットする。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータにフィットさせる。
AICによる複雑度をデフォルトで選択し、自己回帰時系列モデルを普通の最小2乗法でデータにフィットする。
AICによる複雑度をデフォルトで選択して、自己回帰時系列モデルをデータに当てはめる。
ARIMAモデルを一変量時系列にあてはめる。
ARIMAモデルからシミュレーションを行う
ARIMAモデルを一変量時系列にあてはめ、あてはめたモデルから予測する。
ここに挙げた関数や変数は、もはや<span style="font-family：color：<b>R</b></span>の一部ではなくなりました。
ARMA過程の理論的自己相関関数または偏自己相関関数を計算する。
ARMA過程を無限MA過程に変換する。
クラス <code>"dendrogram"</code>は、木のような構造を扱うための一般的な関数を提供します。  これは、階層クラスタリングや分類/回帰ツリーにおける同様の関数の置き換えとして意図されており、これらのすべてがツリーのプロットや切断に同じエンジンを使用できるようになっています。
この関数は，データ行列の行間の距離を計算するために指定された距離尺度を使用して計算された距離行列を計算し，返します．
汎用関数<code>formula</code>とそのメソッドは、他のオブジェクトに含まれる数式を抽出する機能を提供します。

<code>as.formula</code>はほとんど同じで、<code>object</code>がすでに<code>"formula"</code>を継承している場合、さらに属性を保持します。
他の階層クラスタリング関数からのオブジェクトを<code>"hclust"</code>クラスに変換します。
ベクトル<i>(x[1], ..., x[n])</i>と<i>(y[0], y[1], ..., y[n])</i>(1つ多い!)が与えられた場合、<code>stepfun(x, y, ...)<//code> は補間'ステップ'関数、例えば<code>fn</code>を返します。すなわち<i>fn(t) = c</i><i>[i]</i> (定数) for <i>t in ( x[i], x[i+1])</i> and at the abscissa values、(デフォルトでは)<code>right = FALSE</code> の場合, <i>fn(x[i]) = y[i]</i>, <code>right=TRUE</code>の場合, <i>fn(x[i]) = y[i-1]</i>, for<i>i=1, ... , n</i>.n</i>.

上記の定数 <i>c[i]</i> の値は'continuity' パラメータ <code>f</code> に依存します.デフォルトでは, <code>right = FALSE, f = 0</code>, <code>fn</code> は <em>cadlag</em> 関数, すなわち、一般に, <i>c[i]</i> は隣り合う <i>y</i> の値の間で補間される, <i>c[i] = (1-f)*y[i] + f*y[i+1]</i>.したがって、<code>f</code>の0以外の値では、<code>fn</code>は、左連続である(すなわち、定数ピースが右端を含む)<code>right = TRUE, f = 1</code>でない限り、両側から不連続になり得るので、もはやproperstep関数ではないかもしれません、定数はその右端を含む)。
関数<code>ts</code>は、時系列オブジェクトを作成するために使用されます。

<code>as.ts<//code>と<code>is.ts<//code>はオブジェクトを時系列に強制し、オブジェクトが時系列かどうかをテストする。
名前、式、数値、文字列は一方式に変換される。<code>object</code> が数式である場合、それは片面でなければならず、その場合、それは変更されずに返される。
<code>x[]</code>のサブセットは平均化され、各サブセットは同じ因子レベルを持つ観測から構成される。
<code>"tskernel"</code>クラスは、離散対称な正規化平滑化カーネルを表現するように設計されています。  これらのカーネルは、ベクトル、行列、または時系列オブジェクトを平滑化するために使用することができます。

これらのカーネルオブジェクトには、<code>print</code>、<code>plot</code>、<code>[</code>メソッドがあります。
各グループ(標本)の分散が同じであるという帰無値のバートレット検定を行います。
対数尤度値が得られる1つまたは複数の適合モデルオブジェクトについて、<i>-2*log-尤度 + k*npar</i> の式に従って赤池の「情報量基準」を計算する汎用関数、ここで <i>npar</i> は適合モデルのパラメータの数を表し，通常のAICでは<i>k = 2</i>， いわゆるBICまたはSBC（Schwarzのベイズ基準）では<i>k = log(n)</i> （<i>n</i> はオブザベーションの数）である．
ベルヌーイ実験における成功確率に関する単純な帰無仮説の厳密検定を実行する．
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
現在のグラフィック・デバイスにバイプロットを描画する。
与えられた時系列における独立性の帰無仮説を検証するためのBox-Pierce検定統計量またはLjung-Box検定統計量を計算します。  これらは「portmanteau」検定として知られることもあります。
<code>density</code>におけるガウスカーネルの帯域幅セレクタ。
<code>density</code>におけるガウスカーネルの帯域幅セレクタ.
<code>density</code> のガウスカーネルに対応する帯域幅セレクタ.
<code>density</code> のガウスカーネルに対応する帯域幅セレクタ.
<code>density</code>におけるガウスカーネルの帯域幅セレクタ。
因子に<code>"contrasts"</code>属性を設定します。
2つのデータ行列間の正準相関を計算します。
(欠損していない)大文字小文字の名前と(欠損していない)変数名を返す単純なユーティリティ。
関数 <code>acf</code> は、自己共分散または自己相関関数の推定値を計算します（デフォルトではプロットします）。  関数<code>pacf</code>は部分自己相関に使用される関数です。  関数<code>ccf</code>は2変量系列の相互相関または相互共分散を計算する。
<code>chisq.test</code>は、カイ2乗分割表検定と適合度検定を行う。
<em>主座標分析</em> (Gower, 1966)としても知られている。
<code>coef</code>は、モデリング関数が返すオブジェクトからモデル係数を抽出する汎用関数です。  <code>coefficients</code>はその<em>別名</em>です。
<code>coef</code> は、モデリング関数が返すオブジェクトからモデル係数を抽出する汎用関数です。  <code>coefficients</code> はこの関数の <em>alias</em> です。
どのケースが完全であるか、つまり欠損値がないかを示す論理ベクトルを返します。
適合したモデルの1つまたは複数のパラメータの信頼区間を計算します。  クラス<code>"lm"</code>を継承したオブジェクトには、デフォルトとメソッドがあります。
fittedmodelの1つまたは複数のパラメータの信頼区間を計算します。  クラス<code>"lm"</code>を継承するオブジェクトには、デフォルトとメソッドがあります。
fittedmodelの1つ以上のパラメータの信頼区間を計算します。  クラス<code>"lm"</code>を継承するオブジェクトには、デフォルトとメソッドがあります。
適応バリアアルゴリズムを用いて、線形不等式制約に従う関数を最小化します。
コントラストの行列を返します。
対比の行列を返します。
対比の行列を返します。
対比の行列を返せ
対比の行列を返します。
因子に関連する対比の設定と表示
因子に関連するコントラストを設定し、表示する。
高速フーリエ変換を使用して、2つのシーケンスのいくつかの種類の共進を計算する。
この一連の関数は、Belsley, Kuh and Welsch (1980)、Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができる。
階層的クラスタリングの cophenetic distances を計算します。
<code>var</code>, <code>cov</code>, <code>cor</code>は、<code>x</code>の分散と、<code>x</code>と<code>y</code>の共分散または相関を計算します。   <code>x</code> と <code>y</code> が行列の場合、<code>x</code> の列と <code>y</code> の列の間の共分散（または相関）が計算されます。

<code>cov2cor</code>は、共分散行列を対応する相関行列に<em>効率的に</em>スケーリングします。
Pearsonの積モーメント相関係数、Kendallの<i>tau</i>、Spearmanの<i>rho</i>のいずれかを用いて、対になった標本間の関連を検定する。
<code>var</code>, <code>cov</code>, <code>cor</code> は、<code>x</code> の分散と、<code>x</code> と <code>y</code> の共分散または相関を計算します。   <code>x</code> と <code>y</code> が行列の場合、<code>x</code> の列と <code>y</code> の列の間の共分散（または相関）が計算されます。

<code>cov2cor</code> 共分散行列を対応する相関行列に<em>効率的にスケーリングします。
重み付けされた共分散行列とデータの平均、そしてオプションとして（重み付けされた）相関行列の推定値を含むリストを返します。
<code>var</code>, <code>cov</code>, <code>cor</code> は、<code>x</code> の分散と、<code>x</code> と <code>y</code> の共分散または相関を計算します。   <code>x</code> と <code>y</code> が行列の場合、<code>x</code> の列と <code>y</code> の列の間の共分散（または相関）が計算されます。

<code>cov2cor</code> は共分散行列を対応する相関行列に<em>効率的に</em>スケーリングします。
この一連の関数は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
累積ピリオドグラムのプロット
<code>hclust</code>から得られるような木を、グループの数またはカットハイトを指定することにより、いくつかのグループに分割します。
<code>time</code> は、時系列がサンプリングされた時間のベクトルを作成します。

<code>cycle</code>は、各観測のサイクル内の位置を示す。

<code>frequency</code>は単位時間あたりのサンプル数を返し、<code>deltat</code>は観測の時間間隔を返す（<code>ts</code>を参照）。
単純な式の導関数を記号的、アルゴリズム的に計算する。
パラメータ<code>shape1</code>と<code>shape2</code>（およびオプションの非心パラメータ<code>ncp</code>）を持つベータ分布の密度、分布関数、分位関数、ランダム生成。
<code>size</code>と<code>prob</code>をパラメータとする二項分布の密度、分布関数、分位関数、ランダム生成。

これは慣例的に<code>size</code>試行における「成功」の数と解釈される。
位置パラメータ<code>location</code>およびスケールパラメータ<code>scale</code>を持つCauchy分布の密度、分布関数、分位関数およびランダム生成.
自由度<code>df</code>とオプションの非心パラメータ<code>ncp</code>を持つカイ2乗(<i>chi^2</i>)分布の密度、分布関数、分位関数、ランダム生成。
移動平均を使って、時系列を季節、トレンド、不規則成分に分解する。  加法的または乗法的な季節成分を扱う。
<code>delete.response</code>は、同じモデルの<code>terms</code>オブジェクトを返しますが、応答変数はありません。

<code>drop.terms</code>はモデルの右辺から変数を削除します。同じ機能を実行する <code>"[.terms"</code> メソッドもあります (<code>keep.response = TRUE</code>) 。

<code>reformulate</code> は文字ベクトルから数式を作成します。  <code>length(termlabels)&gt;1</code>の場合、その要素は<code>+</code>で連結されます。非構文的な名前(例えば、スペースや特殊文字を含む。<code>make.names</code>を参照)は、バックティックで保護されなければなりません(例を参照)。
<code>time</code>は、時系列がサンプリングされた時刻のベクトルを生成します。

<code>cycle</code>は、各観測のサイクル内の位置を示す。

<code>frequency</code>は単位時間あたりのサンプル数を返し、<code>deltat</code>は観測の時間間隔を返す（<code>ts</code>を参照）。
関数<code>FUN</code>を<code>dendrogram</code>の各ノードに再帰的に適用する。  <code>y &lt;- dendrapply(x, fn)</code> のとき、<code>y</code>は<code>x</code>と同じグラフ構造の添字であり、各ノードに対して<code>y.node[j] &lt;- FUN( x.node[j], ...)</code> (ここで<code>y.node[j]</code>はyのj番目のノードの(無効な!)表記である)。
(S3)汎用関数<code>density</code>はカーネル密度推定を行います。  デフォルトのメソッドは、与えられたカーネルとバンド幅で一変量オブザベーションを行います。
(S3)汎用関数 <code>density</code> は、カーネル密度推定を行います。  デフォルトのメソッドは、与えられたカーネルと一変量オブザベーションのバンド幅でこれを行います。
単純な式の導関数を、記号的およびアルゴリズム的に計算します。
単純な式の導関数を，記号的およびアルゴリズム的に計算します．
deviance関数は，適合モデルオブジェクトのdevianceを返します．
率<code>rate</code>（すなわち、平均<code>1/rate</code>）を持つ指数分布の密度、分布関数、分位関数、randomgeneration。
自由度<code>df1</code>と<code>df2</code>を持つF分布（およびオプションの非心パラメータ<code>ncp</code>）の密度、分布関数、分位関数、ランダム生成。
<code>"tskernel"</code> クラスは、離散対称な正規化平滑化カーネルを表現するように設計されています。  これらのカーネルは、ベクトル、行列、時系列オブジェクトを平滑化するために使用することができます。

これらのカーネルオブジェクトには、<code>print</code>, <code>plot</code>, <code>[</code>メソッドがあります。
フィットされたモデルオブジェクトから抽出された残差自由度を返します。
ジェネリック関数 <code>formula</code> とそのメソッドは、他のオブジェクトに含まれている式を抽出する機能を提供します。

<code>as.formula</code>はほとんど同じで、<code>object</code>がすでに<code>"formula"</code>を継承している場合、さらに属性を保持します。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するのに使用できます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
<code>shape</code>と<code>scale</code>をパラメータとするガンマ分布の密度、分布関数、分位関数、ランダム生成。
パラメータ<code>prob</code>を持つ幾何分布の密度・分布関数・分位点関数・ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成
遅延差分関数<code>diff</code>の逆関数を計算します。
この関数は，データ行列の行間の距離を計算するために指定された距離尺度を使用して計算された距離行列を計算し，返します．
対数正規分布の密度、分布関数、分位点関数、ランダム生成 (その対数の平均は <code>meanlog</code> に等しく、標準偏差は <code>sdlog</code> に等しい)
パラメータ<code>location</code>と<code>scale</code>を持つロジスティック分布の密度、分布関数、分位関数、ランダム生成。
多項分布乱数ベクトルの生成と多項確率の計算
<code>size</code>と<code>prob</code>をパラメータとする負の二項分布の密度、分布関数、分位関数、乱数生成
平均が<code>mean</code>で標準偏差が<code>sd</code>の正規分布の密度、分布関数、分位関数、ランダム生成
パラメータ<code>lambda</code>を持つポアソン分布の密度，分布関数，分位関数，ランダム生成．
<code>add.scope</code>と<code>drop.scope</code>は、項の階層性を尊重しながら、モデルに個別に追加したり、モデルから削除したりできる項を計算します。
<code>delete.response</code>は、同じモデルの<code>terms</code>オブジェクトを返しますが、レスポンス変数はありません。

<code>drop.terms</code>はモデルの右辺から変数を削除します。同じ機能を実行する <code>"[.terms"</code> メソッドもあります (<code>keep.response = TRUE</code>) 。

<code>reformulate</code> は文字ベクトルから数式を作成します。  <code>length(termlabels)&gt;1</code>の場合、その要素は<code>+</code>で連結されます。非構文的な名前(例えば、スペースや特殊文字を含む。<code>make.names</code>を参照)は、バックスティックで保護されなければなりません(例を参照)。<code>parse</code>できない<code>response</code>は、非推奨の警告とともに、互換性を保ちながら、今のところまだ動作します。
引数<code>scope</code>に含まれる、モデルに追加したりモデルから削除したりできるすべての単項を計算し、それらのモデルを適合させ、適合度の変化についてatableを計算します。
サイズ<code>n</code>の標本から得られるWilcoxon Signed Rank統計量の分布の密度、分布関数、分位関数、ランダム生成。
自由度<code>df</code>（およびオプションの非心パラメータ<code>ncp</code>）を持つt分布の密度、分布関数、分位関数、ランダム生成。
これは、コード化された変数ではなく、係数の元の水準で係数を抽出します。
これは、コード化された変数ではなく、係数の元の水準で係数を抽出します。
これらの関数は、<code>min</code>から<code>max</code>までの区間上の一様分布に関する情報を提供します。  <code>dunif</code>は密度を、<code>punif</code>は分布関数を、<code>qunif</code>は分位関数を、<code>runif</code>は乱数偏差を生成します。
パラメータ<code>shape</code>と<code>scale</code>を持つワイブル分布の密度、分布関数、分位関数、乱数生成。
それぞれサイズ<code>m</code>と<code>n</code>の標本から得られるWilcoxon順位和統計量の分布の密度、分布関数、分位関数、ランダム生成。
経験的累積分布関数を計算し、そのような "ecdf "オブジェクトをプロット、印刷、計算するためのいくつかのメソッドを提供します。
複数の層を持つ分散分析モデルにおける固定効果項の効率を計算します。
適合したモデル（通常は線形モデル）から（直交）効果を返す。これは汎用的な関数ですが、現在のところ<code>"lm"</code>クラスと<code>"glm"</code>クラスを継承したオブジェクト用のメソッドしか持っていません。
時系列<code>x</code>を低次元ユークリッド空間に埋め込みます。
最初と最後の観測が行われた時刻を抽出して符号化する。Sバージョン2との互換性のためにのみ提供される。
残差平方和と積の行列，または多変量線形モデルの推定分散行列を計算する関数．
新しい変数を、指定されたモデルの式の一部であったかのように評価する。  これにより、同じ<code>na.action</code>と<code>subset</code>引数が適用され、例えば、<code>sin(x)</code>を予測変数として使用するモデルに対して<code>x</code>を回復することができます。
適合したパラメトリック・モデルの(一般化された)赤池<b>A</b>n <b>I</b>情報<b>C</b>基準を計算する。
共分散行列の順序行列に対して最尤因子分析を行います。
<code>add.scope</code>と<code>drop.scope</code>は、項の階層性を尊重しながら、モデルに個別に追加したり、モデルから削除したりできる項を計算します。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
配列の離散フーリエ変換 (DFT) を高速アルゴリズム "Fast Fourier Transform" (FFT) で計算する。
一変量時系列または多変量時系列の各系列に線形フィルタリングを適用する
固定マージンを持つ分割表の行と列の独立性の帰無を検定するフィッシャーの正確検定を実行します。
<code>fitted</code>は、モデリング関数が返すオブジェクトからフィット値を抽出する汎用関数です。  <code>fitted.values<//code>はそのアナリアスです。

モデルフィッティング関数によって返されるすべてのオブジェクトクラスは、<code>fitted</code>メソッドを提供しなければなりません。  (ジェネリックは<code>fitted</code>であり、<code>fitted.values</code>ではないことに注意してください)。

メソッドは、<code>napredict</code>メソッドを使用して欠損値の欠落を補うことができます。  default と <code>nls</code> メソッドがそうです。
<code>fitted</code>は、モデリング関数によって返されたオブジェクトからフィット値を抽出する汎用関数です。  <code>fitted.values<//code>はそのアナリアスです。

モデルフィッティング関数によって返されるすべてのオブジェクトクラスは、<code>fitted</code>メソッドを提供しなければなりません。  (ジェネリックは<code>fitted</code>であり、<code>fitted.values</code>ではないことに注意してください)。

メソッドは、<code>napredict</code>メソッドを使用して欠損値の欠落を補うことができます。  デフォルトと <code>nls</code> メソッドがそうです。
Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum) を入力データに対して返します。
各グループ（サンプル）の分散が同じであるという帰無仮説のFligner-Killeen（中央値）検定を実行します。
ジェネリック関数<code>formula</code>とそのメソッドは、他のオブジェクトに含まれる数式を抽出する機能を提供します。

<code>as.formula</code>はほとんど同じで、<code>object</code>がすでに<code>"formula"</code>を継承している場合は、さらに属性を保持する。
<code>time</code> は、時系列がサンプリングされた時間のベクトルを作成します。

<code>cycle</code>は、各観測のサイクル内の位置を示す。

<code>frequency</code>は単位時間あたりのサンプル数を、<code>deltat</code>はオブザベーション間の時間間隔を返します（<code>ts</code>を参照）。
再現性のないブロック・データでフリードマン順位和検定を実行します。
フラットな'分割表を作成します。
ファミリーオブジェクトは、<code>glm<//code>などの関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
<code>model.frame</code>（汎用関数）とそのメソッドは、<code>formula</code>と任意の<code>...</code>引数を使用するために必要な変数を持つ<code>data.frame</code>を返します。
<code>update</code>は、モデルを更新し、(デフォルトでは)再フィットします。  これは、オブジェクトに格納された呼び出しを抽出し、呼び出しを更新し、(デフォルトでは)その呼び出しを評価することによって行われます。  データフレームが修正された場合など、1つの引数だけで<code>update<//code>を呼び出すと便利なことがあります。

<code>update()</code>や同様の関数における "呼び出しの抽出 "は、<code>getCall()</code>を使用します。<code>getCall()</code>は、単に<code>x$call</code>を取得するデフォルトメソッドを持つ(S3の)汎用関数です。

このため、<code>update()</code>は、新しいモデル・クラスに対して、自動的に、あるいはそのクラスのための単純な<code>getCall()</code>メソッドを提供することによって、（そのデフォルトメソッドによって）動作することがよくあります。
この関数は、非線形回帰モデルの初期パラメータ推定値を評価します。  <code>data</code> がパラメータ化されたデータフレームまたは<code>pframe</code>オブジェクトである場合、その<code>parameters</code>属性が返されます。そうでない場合、オブジェクトは、その<code>initial</code>属性が評価可能な<code>selfStart</code>オブジェクトへの呼び出しを含んでいるかどうかを調べます。
<code>glm<//code>は、線形予測変数の記号的記述と誤差分布の記述によって指定される一般化線形モデルの適合に使用されます。
通常、<code>glm.fit</code>によって内部的にのみ使用されますが、<code>control</code>引数を作成するために使用されることもあります。
<code>glm<//code>は、線形予測変数の記号的記述と誤差分布の記述によって指定される一般化線形モデルの適合に使用されます。
<code>tsp</code>は、<code>tsp</code>属性（または<code>NULL</code>）を返します。これは、Sバージョン2との互換性のために含まれています。<code>tsp&lt;-</code>は<code>tsp</code>属性を設定します。<code>hasTsp</code>は、<code>x</code>が<code>tsp</code>属性を持つことを保証します。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
非類似度の集合に関する階層クラスター分析とその分析手法。
ヒートマップは，左側と上側にデンドログラムを追加した擬似カラー画像（基本的には<code>image(t(x))</code>）である．  通常，デンドログラムによって課された制限の範囲内で，ある値（行または列の平均）の集合に従って行と列の並べ替えが実行される．
未知のパラメータは、予測誤差の2乗を最小化することによって決定されます。
この関数は、回帰フィットの品質をチェックするためのさまざまな診断に使用される基本量を提供する。
この一連の関数は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) などで議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するのに使うことができる。
有限または無限区間上の1変数の関数の適応求積法
因子の2元配置の組み合わせに対する応答の平均（または他の要約）をプロットし、可能な交互作用を説明する。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
は、<code>x</code>値の四分位範囲を計算します。
<span style="font-family：color：#666666;"><b>R</b></span>の数式表記では、切片がないモデルや予測変数がないモデルが可能です。<code>is.empty.model()</code>は、オブジェクトがemptyymodelを記述しているかどうかをチェックします。
クラス <code>"dendrogram"</code>は、木のような構造を扱うための一般的な関数を提供します。  これは、階層クラスタリングや分類/回帰ツリーにおける同様の関数の置き換えとして意図されており、これらのすべてがツリーのプロットや切断に同じエンジンを使用できるようになっています。
時系列オブジェクトを作成するために、関数<code>ts</code>が使用されます。

<code>as.ts<//code>と<code>is.ts<//code>はオブジェクトを時系列に強制し、オブジェクトが時系列かどうかをテストする。
ベクトル<i>(x[1], ..., x[n])</i>と<i>(y[0], y[1], ..., y[n])</i>(1つ多い!)が与えられると、<code>stepfun(x, y, ...)<//code> は補間'ステップ'関数、例えば<code>fn</code>を返す。すなわち<i>fn(t) = c</i><i>[i]</i> (定数) for <i>t in ( x[i], x[i+1])</i> and at the abscissa values、(デフォルトでは)<code>right = FALSE</code> の場合, <i>fn(x[i]) = y[i]</i>, <code>right=TRUE</code>の場合, <i>fn(x[i]) = y[i-1]</i>, for<i>i=1, ... , n</i>.n</i>.

上記の定数 <i>c[i]</i> の値は'continuity' パラメータ <code>f</code> に依存します.デフォルトでは, <code>right = FALSE, f = 0</code>, <code>fn</code> は <em>cadlag</em> 関数, すなわち、一般に, <i>c[i]</i> は隣り合う <i>y</i> の値の間で補間される, <i>c[i] = (1-f)*y[i] + f*y[i+1]</i>.したがって、<code>f</code>の0以外の値では、<code>fn</code>は、左連続である(すなわち、定数ピースが右端を含む)<code>right = TRUE, f = 1</code>でない限り、両側から不連続になり得るので、もはやproperstep関数ではないかもしれません、定数はその右端を含む)。
関数<code>ts</code>は、時系列オブジェクトを作成するために使用されます。

<code>as.ts<//code>と<code>is.ts<//code>はオブジェクトを時系列に強制し、オブジェクトが時系列かどうかをテストします。
<code>"tskernel"</code>クラスは、離散非対称な正規化平滑化カーネルを表現するように設計されています。  これらのカーネルは、ベクトル、行列、または時系列オブジェクトを平滑化するために使用できます。

これらのカーネルオブジェクトには、<code>print</code>, <code>plot</code>, <code>[</code>メソッドがあります。
等張（単調増加ノンパラメトリック）最小2乗回帰を計算します。
(ガウス)対数尤度を求めるために、または予測や平滑化のためにカルマンフィルタリングを使用します。
(ガウス)対数尤度を求めるために、または予測や平滑化のためにカルマンフィルタリングを使用します。
カルマンフィルタリングを使って、(ガウス)対数尤度を求める、または、予測や平滑化を行う。
カルマンフィルタリングを使って、(ガウス)対数尤度を求める。
<code>kernapply</code> は、入力シーケンスと特定のカーネルとの間の畳み込みを計算します。
<code>"tskernel"</code> クラスは、離散対称な正規化平滑化カーネルを表現するように設計されています。  これらのカーネルは、ベクトル、行列、時系列オブジェクトを平滑化するために使用することができます。

これらのカーネルオブジェクトには、<code>print</code>, <code>plot</code>, <code>[</code>メソッドがあります。
データ行列に対してk-meansクラスタリングを実行します。
ベクトル<i>(x[1], ..., x[n])</i>と<i>(y[0], y[1], ..., y[n])</i>(1つ多い!)が与えられた場合、<code>stepfun(x, y, ...)<//code> は補間'ステップ'関数、例えば<code>fn</code>を返す。すなわち<i>fn(t) = c</i><i>[i]</i> (定数) for <i>t in ( x[i], x[i+1])</i> and at the abscissa values、(デフォルトでは)<code>right = FALSE</code> の場合, <i>fn(x[i]) = y[i]</i>, <code>right=TRUE</code>の場合, <i>fn(x[i]) = y[i-1]</i>, for<i>i=1, ... , n</i>.n</i>.

上記の定数 <i>c[i]</i> の値は'continuity' パラメータ <code>f</code> に依存します.デフォルトでは, <code>right = FALSE, f = 0</code>, <code>fn</code> は <em>cadlag</em> 関数, すなわち、一般に, <i>c[i]</i> は隣り合う <i>y</i> の値の間で補間される, <i>c[i] = (1-f)*y[i] + f*y[i+1]</i>.したがって、<code>f</code>の0以外の値では、<code>fn</code>は、左連続である(すなわち、定数ピースが右端を含む)<code>right = TRUE, f = 1</code>でない限り、両側から不連続になり得るので、もはやproperstep関数ではないかもしれません、定数はその右端を含む)。
クラスカル・ワリス順位和検定を行う。
1標本または2標本のKolmogorov-Smirnov検定を実行します。
Nadaraya-Watsonカーネル回帰推定を実行します。
時系列のラグ付きバージョンを計算し、時間ベースバックを指定されたオブザベーション数だけシフトします。

<code>lag</code>は一般的な関数で、このページではそのデフォルトメソッドを説明します。
時系列をそれ自身のラグ付きバージョンに対してプロットします。自己相関がなくなっても「自己依存性」を可視化するのに役立ちます。
<em>探索的データ分析</em>で推奨されているように、ロバストに直線をフィットします。

現在のところデフォルト(<code>iter = 1</code>)では、最初の中央値-中央値直線は<em>反復されません</em>(参考文献にあるTukeyの "resistant line "とは異なります)。
<code>lm<//code>は線形モデルの適合に使用されます。回帰分析、単一層分散分析、共分散分析（<code>aov<//code>はこれらのより便利なインターフェイスを提供するかもしれませんが）を実行するために使用することができます。
これらは<code>lm</code>が線形モデルの適合に使用する基本的な計算エンジンです。  これらは、経験豊富なユーザでない限り、通常は直接使うべきでは<em>ありません</em>。  <code>.lm.fit()</code>は、最も内側のQRベースのCコードへの骨組みラッパーであり、<code>glm.fit</code>と<code>lsfit</code>は、より経験豊富なユーザであっても、同様にベースになっています。
この関数は、回帰適合の品質をチェックするためのさまざまな診断に使われる基本量を提供します。
これらは<code>lm</code>が線形モデルの適合に使用する基本的な計算エンジンです。  これらは、経験豊富なユーザでない限り、通常、直接使うべきではありません。  <code>.lm.fit()</code>は、最も内側のQRベースのCコードへの骨組みラッパーであり、<code>glm.fit</code>と<code>lsfit</code>は、より経験豊富なユーザにとっても同様にベースとなっています。
因子分析(または主成分分析)の負荷量を抽出または印刷する。
1つ以上の数値予測変数によって決定される多項式曲面を、局所フィットを用いてフィットする。
<code>loess</code>フィットの制御パラメータを設定する
<code>loess</code>によって計算された滑らかな曲線を散布図にプロットし、追加する。
この関数は汎用的であり、メソッド関数は特定のクラスのオブジェクトを扱うために書くことができます。  この関数のメソッドを持つクラスは以下の通りです：<code>"glm"</code>, <code>"lm"</code>, <code>"nls"</code> and <code>"Arima"</code>.  パッケージには、<a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>パッケージの<code>"fitdistr"</code>、<code>"negbin"</code>、<code>"polr"</code>、<a href="https://CRAN.R-project.org/package=nnet"><span class="pkg">nnet</span></a>、<code>"gls"</code>, <code>"gnls"</code>、<code>"lme"</code>などは<a href="https://CRAN.R-project.org/package=nlme"><span class="pkg">nlme</span></a> パッケージにあります。
<code>loglin</code>は、Iterative Proportional Fittingによって多次元分割表に対数線形モデルをフィットするために使用されます。
この関数は、局所重み付け多項式回帰を使用する<em>LOWESS</em>スムーザーの計算を実行します（参考文献を参照）。
回帰係数の標準誤差、t値、p値を含む基本統計量を計算します。
回帰係数の標準誤差、t値、p値を含む基本統計量を計算し、<code>print.it</code>が<code>TRUE</code>の場合はそれらを表示します。
モデルにおける<b><i>b></i></b>の最小二乗推定値

<p style="text-align: center;"><i>y = X b + e</i>.

が見つかる。
絶対値偏差の中央値、つまり中央値からの絶対値偏差の(lo-/hi-)中央値を計算し、(デフォルトでは)漸近正規整合性のための係数で調整する。
<code>x<//code>の全行とベクトル<i>mu</i> = <code>center<//code>の<i>Sigma</i> = <code>cov<//code>に対する二乗マハラノビス距離を返します.これは(ベクトル<code>x<//code>に対して)次のように定義されます。

<p style="text-align: center;"><i>D^2 = (x - μ)' Σ^-1 (x - μ)</i>.
この関数は、<code>glm()</code>の<code>family</code>関数と一緒に使われます。リンクの名前を与えると、リンク関数、逆リンク関数、導関数<i>dmu/deta</i>、ドメインチェック用の関数を返します。
(ガウス)対数尤度を求めたり、予測や平滑化のためにカルマンフィルタリングを使う。
<code>model.frame.default</code>が、(単変量)<code>poly</code>や<code>ns</code>のような項を持つモデルから予測するときに、正しい行列を作成するのを助けるユーティリティ。
多変量分散分析のためのクラス。
3元交互作用がないと仮定して、2つの名義変数が各層で条件付き独立であるというヌルについて、Cochran-Mantel-Haenszelカイ2乗検定を実行します。
Wishart分布の共分散行列（またはその変換行列）が、与えられた行列に比例するかどうかを検定します。
McNemarのカイ2乗検定を実行し、2次元分割表における行と列の対称性を検定します。
標本の中央値を計算する
標本の中央値を計算します
Tukeyの<em>メディアンポリッシュ</em>手順を使用して，加法モデル（2元分解）をフィットします．
<code>model.frame</code>にオプション引数として渡されたモデルフレームの応答、オフセット、サブセット、重み、その他の特別な成分を返します。
<code>model.frame</code>（汎用関数）とそのメソッドは、<code>formula</code>と任意の<code>...</code>引数を使用するために必要な変数を持つ<code>data.frame</code>を返します。
<code>model.frame</code>（汎用関数）とそのメソッドは、<code>formula</code>を使用するために必要な変数と、任意の<code>...</code>引数を持つ<code>data.frame</code>を返します。
<code>model.matrix</code>は、デザイン（またはモデル）行列を作成します。例えば、因子をダミー変数の集合に展開し（コントラストに依存します）、交互作用も同様に展開します。
<code>model.matrix</code>は、デザイン（またはモデル）行列を作成します。例えば、（対照によって）因子をダミー変数の集合に展開し、同様に交互作用を展開します。
<code>model.matrix</code>は、デザイン（またはモデル）行列を作成します。例えば、（contrastによって）因子をダミー変数の集合に展開し、同様に交互作用を展開します。
<code>model.frame</code>にオプション引数として渡されたモデルフレームのレスポンス、オフセット、サブセット、重み、その他の特別な構成要素を返します。
<code>model.frame</code>にオプション引数として渡されたモデルフレームの応答、オフセット、サブセット、重み、その他の特別な成分を返します。
モデルフィット、特に複雑な<code>aov</code>フィットの要約表を計算します。
<code>model.frame</code>のオプション引数として渡されたモデルフレームの応答、オフセット、サブセット、重み、その他の特別な成分を返します。
これらの関数は、時系列の季節（またはその他の）部分系列をプロットします。
スケールパラメータの差に関するMoodの2標本検定を実行します。
配列の離散フーリエ変換(DFT)を高速アルゴリズムである「高速フーリエ変換」(FFT)で計算する。
オブジェクトの作成に使用されたNAアクションに関する情報を抽出します。
時系列オブジェクトの中で、欠落していない値の最も長い連続したストレッチを見つける。  (同値の場合は、最初のストレッチ)。
<code>na.fail</code>は、欠落値を含んでいなければオブジェクトを返し、そうでなければエラーを通知します。<code>na.omit</code>は、不完全なケースを取り除いたオブジェクトを返します。
<code>na.omit</code>は、不完全なケースを取り除いたオブジェクトを返します。<code>na.pass</code>は、変更されていないオブジェクトを返します。
<code>na.omit</code>は、不完全なケースを取り除いたオブジェクトを返します。<code>na.pass</code>は、変更されていないオブジェクトを返します。
<code>na.fail</code>は、欠損値を含んでいなければオブジェクトを返し、そうでなければエラーを通知します。<code>na.omit</code>は、不完全なケースを取り除いたオブジェクトを返します。
残差と予測値を調整するために欠損値情報を使用する。
<code>na.action</code>の効果を報告するために欠損値情報を使用します。
残差と予測値を調整するために欠損値情報を使用する。
<code>nextn</code>は、<code>factors</code>に含まれる値の累乗の積として得られる、<code>n</code>以上の最小の整数を返す。

<code>nextn()</code>は、<code>fft</code>の引数をゼロパディングするのに適した長さを見つけるために使用されることを意図しています。
この関数は、ニュートン型アルゴリズムを用いて関数 <code>f</code> の最小化を行います。  詳細はリファレンスを参照してください。
PORTルーチンを使用した非制約およびボックス制約付き最適化。

歴史的互換性のため。
非線形モデルのパラメータの非線形（重み付き）最小二乗推定値を決定する。
<code>nls</code>非線形最小二乗法アルゴリズムの特性を設定できるようにする。
<code>b0 + b1*(1-exp(-exp(lrc) * x))</code>の形式で漸近回帰モデルを<code>xy<//code>データに当てはめます。これは、より複雑なモデルの開始推定値を決定する際のビルディングブロックとして使用できます。
逆線形補間を使用して、<code>xy</code>で表される関数が<code>yval</code>と等しくなる<code>x</code>値を近似します。
<code>xy</code> オブジェクトから、<code>y</code> 対 <code>x</code> のグラフの左側(すなわち、<code>x</code> の小さな値)の水平漸近線の最初の推測を提供します。  主に、自己開始非線形回帰モデルの<code>initial</code>関数内で使用されます。
<code>xy</code> オブジェクトからの <code>y</code> 対 <code>x</code> のグラフの右側(すなわち、<code>x</code> の大きな値)の水平漸近線の初期推測を提供する。  主に自己開始非線形回帰モデルの<code>initial</code>関数内で使用されます。
モデルの適合から「オブザベーション」の数を抽出します。  これは主にBIC（<code>AIC</code>を参照）を計算する際に使用されます。
<code>numericDeriv</code> は、式の勾配を数値的に評価します。
オフセットは、一般化線形モデルのような線形予測変数に追加される項であり、推定された係数ではなく既知の係数1を持つ。
正規分布からの2つ以上の標本が同じ平均を持つかどうかを検定する．  分散は必ずしも等しいとは仮定されない。
Nelder-Mead、準ニュートン、共役勾配アルゴリズムに基づく汎用最適化。ボックス制約付き最適化とシミュレーテッドアニーリングのオプションもあります。
Nelder-Mead、準ニュートン、共役勾配アルゴリズムに基づく汎用最適化。box-constrained最適化とシミュレーテッドアニーリングのオプションがあります。
関数<code>optimize</code>は、<code>lower</code>から<code>upper</code>までの区間で、最初の引数に対する関数<code>f</code>の最小値または最大値を探索する。

<code>optimise</code> は <code>optimize</code> のエイリアスです。
関数 <code>optimize</code> は、<code>lower</code> から <code>upper</code> までの区間で、最初の引数に対する関数 <code>f</code> の最小値または最大値を探索します。

<code>optimise</code> は <code>optimize</code> のエイリアスです。
これらの関数は、adendrogramの葉の順序(index)や<code>"label"</code>属性を返します。  これらのインデックスは、追加データの適切なコンポーネントにアクセスするために使用できます。
p値の集合が与えられた場合、いくつかのメソッドのいずれかを使用して調整されたp値を返します。
p値の集合が与えられた場合、いくつかの手法のうちの1つを用いて調整したp値を返します。
関数 <code>acf</code> は、自己共分散または自己相関関数の推定値を計算します（デフォルトではプロットします）。  関数<code>pacf</code>は部分自己相関に使用される関数です。  関数<code>ccf</code>は、2つの2変量系列の相互相関または相互共分散を計算します。
2つのベクトルを<code>"Pair"</code>クラスのオブジェクトに結合する。
多重検定の補正を伴う割合の組間の一対比較を計算します。
多重検定の補正を伴う群水準間の一対比較を計算する
多重検定の補正を伴う一対比較のp値の表を作成します。
多重検定の補正を伴う群間の一対比較の計算
<code>shape1</code>と<code>shape2</code>（およびオプションの非心パラメータ<code>ncp</code>）をパラメータとするベータ分布の密度、分布関数、分位関数、ランダム生成。
<code>size</code>と<code>prob</code>をパラメータとする二項分布の密度、分布関数、分位関数、ランダム生成。

これは慣習的に<code>size</code>試行における'成功'の数と解釈されている。
<code>pbirthday</code>は偶然の一致の確率を計算し、<code>qbirthday</code>は少なくとも指定された偶然の一致の確率を持つのに必要な観測の最小数を計算します。
位置パラメータ<code>location</code>とスケールパラメータ<code>scale</code>を持つCauchy分布の密度、分布関数、分位関数、ランダム生成。
自由度<code>df</code>とオプションの非心パラメータ<code>ncp</code>を持つカイ2乗(<i>chi^2</i>)分布の密度, 分布関数, 分位関数, ランダム生成.
率<code>rate</code>（すなわち、平均<code>1/rate</code>）を持つ指数分布の密度、分布関数、分位関数、ランダム生成。
自由度<code>df1</code>と<code>df2</code>のF分布（およびオプションの非心パラメータ<code>ncp</code>）の密度、分布関数、分位関数、ランダム生成
Gamma 分布の密度、分布関数、分位関数、ランダム生成（パラメータ <code>shape</code> と<code>scale</code>）。
パラメータ <code>prob</code> を持つ幾何分布の密度・分布関数・分位点関数・ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成。
ここに挙げた関数や変数は、もはや<span style="font-family：color：</b></span>の一部ではなくなりました。
対数が<code>meanlog</code>に等しく、標準偏差が<code>sdlog</code>に等しい対数正規分布の密度、分布関数、分位関数、ランダム生成。
パラメータ<code>location</code>と<code>scale</code>を持つロジスティック分布の密度、分布関数、分位関数、ランダム生成。
経験的累積分布関数を計算し、そのような "ecdf "オブジェクトをプロット、印刷、計算するためのいくつかのメソッドを提供します。
<code>"spec"</code>クラスのオブジェクトに対するプロットメソッド。  多変量時系列に対して、系列のマージナルスペクトルをプロットしたり、クロススペクトルのコヒーレンシーと位相のペアをプロットしたりします。
<code>"spec"</code>クラスのオブジェクトのプロットメソッド。  マルチバリアット時系列に対して、系列のマージナルスペクトル、またはクロススペクトルのコヒーレンシーと位相のペアをプロットします。
<code>stepfun</code>オブジェクト用の汎用<code>plot</code>メソッドと区分定数関数をプロットするユーティリティ。
クラス<code>"ts"</code>を継承するオブジェクトのためのプロット・メソッド。
<code>size</code>と<code>prob</code>をパラメータとする負の二項分布の密度、分布関数、分位関数、randomgeneration。
平均が<code>mean</code>で標準偏差が<code>sd</code>の正規分布の密度、分布関数、分位関数、ランダム生成。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
ポアソン分布の率パラメータに関する単純な帰無仮説、または2つの率パラメータ間の比に関する厳密検定を行います。
指定された点<code>x</code>の集合上の次数1から<code>次数</code>までの直交多項式を返すか評価します: これらは次数0の定数多項式にすべて直交します。
指定された点群<code>x</code>上の次数1から<code>次数</code>までの直交多項式を返すか評価します。
リンク関数<i>η = μ ^ λ</i>に基づいてリンクオブジェクトを作成します。
検定の検出力を計算するか、目標の検出力を得るためのパラメータを決定します。
割合の2標本検定の検出力を計算、または目標とする検出力を得るためにパラメータを決定します。
1標本または2標本のt検定の検出力を計算するか，または目標とする検出力を得るためのパラメータを決定する
<code>x</code>が単位根を持つという帰無仮説に対するPhillips-Perron 検定を定常対立仮説に対して計算します。
確率点列<code>(1:m - a)/(m + (1-a)-a)</code> を生成し、ここで<code>m</code>は、<code>length(n)==1</code>なら<code>n</code>、<code>length(n)</code>なら<code>length(n)</code>となります。
パラメータ<code>lambda</code>を持つポアソン分布の密度、分布関数、分位関数、ランダム生成。
射影追跡回帰モデルをフィットします。
与えられたデータ行列に対して主成分分析を行い、その結果をクラス <code>prcomp</code> のオブジェクトとして返します。
<code>predict</code>は、様々なモデル適合関数の結果から予測を行う汎用関数です。  この関数は、第1引数の<code>class</code>に依存する特定の<em>メソッド</em>を呼び出します。
フィットされた一般化線形モデルオブジェクトから予測値を取得し、オプションでそれらの予測値の標準誤差を推定します。
線形モデル・オブジェクトに基づく予測値。
与えられたモデル・オブジェクトに関連するプロットに使用されるオブジェクトを計算します。
<code>princomp</code> は、与えられた数値データ行列に対して主成分分析を行い、その結果をクラス<code>princomp</code>のオブジェクトとして返します。
<code>summary.lm</code>、<code>summary.glm</code>、<code>anova</code>のような、より高レベルの<code>print</code>メソッドで使用されるユーティリティ関数です。  目標は、多くの場合<code>x</code>だけを指定すればよいような、スマートなデフォルトを持つ柔軟なインタフェースを提供することである。
<code>fitted</code>で表される解の近傍での目的関数の振る舞いを調べる。

詳細はメソッド関数のドキュメントを参照。
<code>proj</code> は、線形モデルの項へのデータの射影を与える行列または行列のリストを返します。  これは、<code>aov</code>モデルに最もよく使用されます。
これらの関数は、因子分析におけるローディング行列を「回転」させる。
<code>prop.test<//code>は、いくつかのグループの割合（成功確率）が同じである、または、それらがある与えられた値と等しいという帰無値を検定するために使用することができます。
すなわち、対数オッズが<code>score</code>に比例して変化する局所的な選択肢に対して漸近的に最適な検定です。  デフォルトでは、<code>score<//code>が群数として選択されます。
サイズ<code>n</code>の標本から得られるWilcoxon Signed Rank統計量の分布の密度,分布関数,分位関数,ランダム生成.
自由度<code>df</code>（およびオプションの非心パラメータ<code>ncp</code>）を持つt分布の密度、分布関数、分位関数、ランダム生成。
<i>R</i>は標準正規標本の範囲、<i>df*s^2</i>は自由度<i>df</i>のchi-squaredとして独立に分布する、<i>studentized range, <i>R/s</i>の分布の関数は、<code>pchisq<//code>を参照してください。
これらの関数は、<code>min</code>から<code>max</code>までの区間における一様分布に関する情報を提供します。  <code>dunif</code>は密度を、<code>punif</code>は分布関数を、<code>qunif</code>は分位関数を、<code>runif</code>は乱数偏差を生成します。
パラメータ<code>shape</code>と<code>scale</code>を持つワイブル分布の密度、分布関数、分位関数、乱数生成。
それぞれサイズ<code>m</code>と<code>n</code>の標本から得られるWilcoxon順位和統計量の分布の密度、分布関数、分位関数、ランダム生成
パラメータ<code>shape1</code>と<code>shape2</code>（およびオプションの非心パラメータ<code>ncp</code>）を持つベータ分布の密度、分布関数、分位関数、ランダム生成。
<code>size</code>と<code>prob</code>をパラメータとする二項分布の密度、分布関数、分位関数、ランダム生成。

これは慣例的に<code>size</code>試行における'成功'の数として解釈される。
<code>pbirthday</code>は偶然の一致の確率を計算し、<code>qbirthday</code>は少なくとも指定された偶然の一致の確率を持つのに必要な観測の最小数を計算します。
位置パラメータ<code>location</code>とスケールパラメータ<code>scale</code>を持つCauchy分布の密度、分布関数、分位関数、ランダム生成。
自由度<code>df</code>とオプションの非心パラメータ<code>ncp</code>を持つカイ2乗(<i>chi^2</i>)分布の密度, 分布関数, 分位関数, ランダム生成.
率<code>rate</code>（すなわち、平均<code>1/rate</code>）を持つ指数分布の密度、分布関数、分位関数、ランダム生成。
自由度<code>df1</code>と<code>df2</code>のF分布（およびオプションの非心パラメータ<code>ncp</code>）の密度、分布関数、分位関数、ランダム生成
Gamma 分布の密度、分布関数、分位関数、ランダム生成（パラメータ <code>shape</code> と<code>scale</code>）。
パラメータ <code>prob</code> を持つ幾何分布の密度・分布関数・分位点関数・ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成
対数が平均で<code>meanlog</code>に等しく、標準偏差が<code>sdlog</code>に等しい対数正規分布の密度、分布関数、分位関数、ランダム生成
パラメータ<code>location</code>と<code>scale</code>を持つロジスティック分布の密度、分布関数、分位関数、ランダム生成。
負の二項分布の密度・分布関数・分位点関数・ランダム生成 (パラメータ<code>size</code>, <code>prob</code>)。
平均が<code>mean</code>で標準偏差が<code>sd</code>の正規分布の密度、分布関数、分位関数、ランダム生成
パラメータ <code>lambda</code> を持つポアソン分布の密度、分布関数、分位関数、およびランダム生成。
<code>qqnorm</code>は汎用の関数で、デフォルトでは<code>y</code>の値の正規QQプロットを生成します。<code>qqline</code>は、"理論的な"(デフォルトでは正規の)分位点-分位点プロットに、<code>probs</code>分位点(デフォルトでは第1分位点と第3分位点)を通る線を追加します。

<code>qqplot</code>は2つのデータセットのQQプロットを生成する。

<code>qqnorm</code>,<code>qqplot</code>,<code>qqline</code> の引数としてグラフィカルなパラメータを与えることができます。
<code>qqnorm</code>は汎用の関数で、デフォルトでは<code>y</code>の値の正規QQプロットを生成します。<code>qqline</code>は、"理論的な"、デフォルトでは正規の、<code>probs</code>四分位数、デフォルトでは第1四分位数と第3四分位数を通る四分位-四分位プロットに線を追加します。

<code>qqplot</code>は2つのデータセットのQQプロットを生成する。

<code>qqnorm</code>, <code>qqplot</code>, <code>qqline</code> の引数として、グラフィカルなパラメータを与えることができます。
<code>qqnorm</code>は汎用の関数で、デフォルトでは<code>y</code>の値の正規QQプロットを生成します。<code>qqline</code>は、"理論的な"、デフォルトでは正規の、<code>probs</code>四分位数、デフォルトでは第1四分位数と第3四分位数を通る四分位-四分位プロットに線を追加します。

<code>qqplot</code>は2つのデータセットのQQプロットを生成する。

<code>qqnorm</code>、<code>qqplot</code>、<code>qqline</code>の引数として、グラフパラメータを与えることができます。
サイズ<code>n</code>の標本から得られるWilcoxon Signed Rank統計量の分布の密度, 分布関数, 分位関数, ランダム生成.
自由度<code>df</code>（およびオプションの非心パラメータ<code>ncp</code>）を持つt分布の密度、分布関数、分位関数、ランダム生成。
<i>R</i>は標準正規標本の範囲、<i>df*s^2</i>は<i>df</i>自由度を持つカイ二乗として独立に分布する、<i>studentized range, <i>R/s</i>の分布の関数、<code>pchisq<//code>を参照してください。
複製されていないブロックデータでQuade検定を行います。
汎用関数<code>quantile</code>は、与えられた確率に対応する標本の分位を生成します。最小のオブザベーションは確率0に対応し、最大のオブザベーションは確率1に対応します。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
ファミリーオブジェクトは、<code>glm</code>のような関数で使用されるモデルの詳細を指定する便利な方法を提供します。  このようなモデル適合がどのように行われるかの詳細については、<code>glm<//code>のドキュメントを参照してください。
これらの関数は、<code>min</code>から<code>max</code>までの区間における一様分布に関する情報を提供します。  <code>dunif</code>は密度を与え、<code>punif</code>は分布関数を与え、<code>qunif</code>は分位関数を与え、<code>runif</code>は確率偏差を生成します。
パラメータ<code>shape</code>と<code>scale</code>を持つワイブル分布の密度、分布関数、分位関数、乱数生成。
それぞれ<code>m</code>と<code>n</code>の大きさの標本から得られるWilcoxon順位和統計量の分布の密度、分布関数、分位関数、ランダム生成。
Patefield'sgorithmを用いて、与えられたマージンを持つ2元表をランダムに生成する。
パラメータ <code>shape1</code> と <code>shape2</code> (およびオプションの非心パラメータ <code>ncp</code>) を持つベータ分布の密度、分布関数、分位関数、ランダム生成。
<code>size</code>と<code>prob</code>をパラメータとする二項分布の密度、分布関数、分位関数、ランダム生成。

これは慣例的に<code>size</code>試行における「成功」の数として解釈される。
位置パラメータ<code>location</code>およびスケールパラメータ<code>scale</code>を持つCauchy分布の密度、分布関数、分位関数およびランダム生成.
自由度<code>df</code>とオプションの非心パラメータ<code>ncp</code>を持つカイ2乗(<i>chi^2</i>)分布の密度、分布関数、分位関数、ランダム生成。
<code>ftable</code>と呼ばれる'平坦な'(分割表)表を読み書きできます。
デンドログラムの枝の周囲に、対応するクラスタを強調する矩形を描画。まずデンドログラムをあるレベルで切断し、次に選択された枝の周囲に矩形を描く。
<code>delete.response<//code>は、同じモデルの<code>terms<//code>オブジェクトを返しますが、レスポンス変数はありません。

<code>drop.terms</code>はモデルの右辺から変数を削除します。同じ機能を実行する <code>"[.terms"</code> メソッドもあります (<code>keep.response = TRUE</code>) 。

<code>reformulate</code> は文字ベクトルから数式を作成します。  <code>length(termlabels)&gt;1</code>の場合、その要素は<code>+</code>で連結されます。非構文的な名前(例えば、空白や特殊文字を含む。<code>make.names</code>を参照)は、バックティックで保護されなければなりません(例を参照)。<code>parse</code>できない<code>response</code>は、deprecationの警告とともに、互換性を保ちながら、今のところまだ動作します。
因子のレベルは、<code>ref</code>で指定されたレベルが最初になり、他のレベルが下に移動するように並び替えられます。これは、最初のレベルを参照とする<code>contr.treatment</code>対比に有用である。
<code>reorder</code>は汎用関数です。  <code>"default"</code>メソッドは、最初の引数をカテゴリー変数として扱い、2番目の変数（通常は数値）の値に基づいてそのレベルを並べ替えます。
式の各項の複製数のベクトルまたはリストを返します。
この関数は、データフレームを'wide'フォーマット（同じ行の別々の列に繰り返し測定がある）と'long'フォーマット（別々の行に繰り返し測定がある）の間で整形します。
<code>residuals</code>は、モデリング関数が返すオブジェクトからモデル残差を抽出する汎用関数です。

<code>resid</code>という省略形は、<code>residuals</code>の別名です。これは、ユーザーがオブジェクト・スロットを直接参照するのではなく、アクセサ関数を通してオブジェクト・コンポーネントにアクセスすることを奨励することを意図しています。

モデル・フィット関数によって返されるすべてのオブジェクト・クラスは、<code>residuals</code> メソッドを提供しなければならない。  (このメソッドは<span class="samp">residuals</span>のためのものであり、<span class="samp">resid</span>ではないことに注意してください)。

メソッドは、<code>naresid</code>メソッドを使用して、欠損値の欠落を補正することができます。  デフォルトでは、<code>nls</code>と<code>smooth.spline</code>メソッドが使用されます。
<code>residuals</code>は、モデリング関数が返すオブジェクトからモデルの残差を抽出する汎用関数です。

<code>resid</code>という省略形は、<code>residuals</code>の別名です。これは、ユーザーがオブジェクト・スロットを直接参照するのではなく、アクセサ関数を通してオブジェクト・コンポーネントにアクセスすることを奨励することを意図しています。

モデル・フィット関数によって返されるすべてのオブジェクト・クラスは、<code>residuals</code> メソッドを提供しなければならない。  (このメソッドは<span class="samp">residuals</span>のためのものであり、<span class="samp">resid</span>ではないことに注意してください)。

メソッドは、<code>naresid</code>メソッドを使用して、欠損値の欠落を補正することができます。  デフォルトでは、<code>nls</code>と<code>smooth.spline</code>メソッドが使用されます。
これらの関数はすべて、クラス<code>glm</code>または<code>summary.glm</code>オブジェクトの<code>メソッド</code>です。
これらの関数はすべて、クラス <code>"lm"</code> オブジェクトの <code>methods</code> です。
率<code>rate</code>（すなわち、平均<code>1/rate</code>）を持つ指数分布の密度、分布関数、分位関数、ランダム生成。
自由度<code>df1</code>と<code>df2</code>のF分布（およびオプションの非心パラメータ<code>ncp</code>）の密度、分布関数、分位関数、ランダム生成
Gamma 分布の密度、分布関数、分位関数、ランダム生成（パラメータ <code>shape</code> と<code>scale</code>）。
パラメータ <code>prob</code> を持つ幾何分布の密度・分布関数・分位点関数・ランダム生成
超幾何分布の密度、分布関数、分位関数、ランダム生成
対数が平均で<code>meanlog</code>に等しく、標準偏差が<code>sdlog</code>に等しい対数正規分布の密度、分布関数、分位関数、ランダム生成
パラメータ<code>location</code>と<code>scale</code>を持つロジスティック分布の密度、分布関数、分位関数、ランダム生成。
多項分布乱数ベクトルの生成と多項確率の計算
<code>size</code>と<code>prob</code>をパラメータとする負の二項分布の密度、分布関数、分位関数、乱数生成
平均が<code>mean</code>で標準偏差が<code>sd</code>の正規分布の密度、分布関数、分位点関数、ランダム生成
パラメータ <code>lambda</code> を持つポアソン分布の密度、分布関数、分位関数、ランダム生成
サイズ<code>n</code>の標本から得られるWilcoxon Signed Rank統計量の分布の密度、分布関数、分位関数およびランダム生成。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982) 等で議論されている線形モデルや一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するために使用することができます。
この関数群は、Belsley, Kuh and Welsch (1980), Cook and Weisberg (1982)等で議論されている線形および一般化線形モデルの回帰(leave-one-out deletion)診断のいくつかを計算するのに使用できます。
自由度<code>df</code>（およびオプションの非心パラメータ<code>ncp</code>）を持つt分布の密度、分布関数、分位関数、ランダム生成。
これらの関数は、<code>min</code>から<code>max</code>までの区間における一様分布に関する情報を提供します。  <code>dunif</code>は密度を、<code>punif</code>は分布関数を、<code>qunif</code>は分位関数を、<code>runif</code>は乱数偏差を生成します。
奇数スパンの実行中央値を計算します。  これは、可能な限り「最も頑健な」散布図の平滑化である。  効率化のために（そして歴史的な理由から）、同じ結果を与える2つの異なるアルゴリズムのどちらかを使用することができます。
密度、分布関数、分位関数、およびパラメータ<code>shape</code>と<code>scale</code>を持つワイブル分布のランダム生成。
それぞれ<code>m</code>と<code>n</code>の大きさの標本から得られるWilcoxon順位和統計量の分布の密度、分布関数、分位関数、ランダム生成。
<code>シグマ<//code>と<code>df<//code>をパラメータとするウィシャート分布に従って分布する<code>n<//code>個のランダム行列<i>W_p(Sigma, df)</i> を生成する。
散布図に<code>loess</code>で計算された滑らかな曲線をプロットして追加します。
<code>screeplot.default</code>は主成分の数に対する分散をプロットします。これは、クラス<code>"princomp"</code>と<code>"prcomp"</code>の<code>plot</code>メソッドでもあります。
この関数は、<code>x</code>の値の標準偏差を計算します。もし<code>na.rm</code>が<code>TRUE</code>ならば、計算を進める前に欠損値が取り除かれます。
1つ以上の対比の標準誤差を<code>aov</code>オブジェクトで返します。
<code>nls</code>などで使用する自己開始非線形モデルを構築する。  データから近似パラメータ値を計算する関数<code>initial</code>により、そのようなモデルは「自己開始」、すなわち、例えば、<code>nls()</code>で<code>start<//code>引数を必要としません。
これは、オブジェクトの名前を設定し、そのオブジェクトを返す便利な関数です。  この関数は、関数の定義の最後で、返されるオブジェクトを作成していて、名前を割り当てることができるように、名前を付けて格納したくないような場合に最も便利です。
シャピロ・ウィルク正規性検定を実行します。
誤差の推定標準偏差、"residual standard deviation" (例えば、<code>summary.lm()</code>の出力では、"residual standard error "という誤った名前もあります)を適合モデルから抽出します。

<code>sigma(.)</code>は、適合モデルから<em>推定</em>パラメータ、すなわち<i>sigma^</i>を抽出します。
適合したモデルオブジェクトに対応する分布から1つ以上の応答をシミュレートします。
Tukeyの平滑化、<em>3RS3R</em>、<em>3RSS</em>、<em>3R</em>など。
与えられたデータに三次平滑化スプラインをフィットします。
ベクトル<code>y</code>の端点を平滑化します。(奇数スパンの)、
これは、<code>sortedXyData</code>オブジェクトクラスのコンストラクタ関数です。  これらのオブジェクトは、ほとんどの場合、<code>selfStart</code>クラスの<code>initial</code>関数で使用されます。
ARモデルを<code>x</code>にフィットし(または既存のフィットを使用し)、フィットされたモデルのスペクトル密度を計算(デフォルトではプロット)します。
<code>spec.pgram</code>は、高速フーリエ変換を用いてピリオドグラムを計算し、オプションとして、一連の修正Daniellスムーサー(終了値に半分の重みを与える移動平均)を用いて結果を平滑化します。
時系列にcosine-bell taperを適用する。
<code>spectrum</code>関数は、時系列のスペクトル密度を推定します。
与えられたデータ点に対して3次（またはエルミート）スプライン補間を行い、補間によって得られた点のリストか、補間を行う<em>関数</em>を返す。
与えられたデータ点に対して3次（またはエルミート）スプライン補間を行い、 補間によって得られた点のリストか、補間を行う<em>関数</em>を返します。
与えられたデータ点の3次（またはエルミート）スプライン補間を行い、補間によって得られた点のリストか、補間を実行する<em>関数</em>を返します。
この<code>selfStart</code>モデルは、漸近回帰関数とその勾配を評価します。  また、<code>initial</code>属性があり、与えられたデータ集合に対してパラメータ<code>Asym</code>, <code>R0</code>,<code>lrc</code>の初期推定値を評価します。

<code>SSweibull()</code>は、この漸近モデルを追加パラメータで一般化することに注意してください。
この<code>selfStart</code>モデルは、漸近回帰関数の代替パラメータ化とそれらのパラメータに関する勾配を評価します。これは、パラメータ<code>Asym</code>, <code>lrc</code>, <code>c0</code>の初期推定値を作成する<code>initial</code>属性を持ちます。
この<code>selfStart</code>モデルは、原点とその勾配を通る漸近回帰関数を評価します。  これは、<code>initial</code>属性を持ち、与えられたデータ集合のパラメータ<code>Asym</code>と<code>lrc</code>の初期推定値を評価します。
この<code>selfStart</code>モデルは、二重指数モデル関数とその勾配を評価します。  パラメータ <code>A1</code>, <code>lrc1</code>, <code>A2</code>, <code>lrc2</code> の初期推定値を作成する <code>initial</code> 属性を持ちます。
残差の平方和と積の行列、または多変量線形モデルの推定分散行列を計算する関数。
この<code>selfStart<//code>モデルは、一次コンパートメント関数とその勾配を評価します。  パラメータ<code>lKe</code>, <code>lKa</code>,<code>lCl</code>の初期推定値を作成する<code>initial</code>属性を持ちます。
この<code>selfStart</code>モデルは、4パラメータのロジスティック関数とその勾配を評価します。  これは、与えられたデータ集合のパラメータ<code>A</code>, <code>B</code>, <code>xmid</code>, <code>scal</code>の初期推定値を計算する<code>initial</code>属性を持ちます。
この<code>selfStart</code>モデルは、Gompertz成長モデルとその勾配を評価します。  パラメータ <code>Asym</code>, <code>b2</code>, <code>b3</code> の初期推定値を作成する <code>initial</code> 属性を持ちます。
この<code>selfStart</code>モデルは、ロジスティック関数とその勾配を評価します。  パラメータ<code>Asym</code>,<code>xmid</code>,<code>scal</code>の初期推定値を作成する<code>initial</code>属性を持ちます。   <span style="font-family：color：<span style="font: Courier New; color: #666666;"><b>R</b></span> 3.4.2 以前では、<code>min(input)</code> がちょうど 0 のとき、そのinit 関数は失敗しました。
この<code>selfStart</code>モデルはMichaelis-Mentenモデルとその勾配を評価します。  パラメータ<code>Vm</code>と<code>K</code>の初期推定値を評価する<code>initial</code>属性を持ちます。
この<code>selfStart</code>モデルは、成長曲線データとその勾配についてワイブルモデルを評価します。  <code>initial</code> 属性があり、与えられたデータ集合についてパラメータ <code>Asym</code>、<code>Drop</code>、<code>lrc</code>、<code>pwr</code> の初期推定値を評価します。
最初と最後の観測が行われた時刻を抽出し、符号化する。Sバージョン2との互換性のためにのみ提供されています。
これは、<code>anova(..., test != NULL)</code>の<code>lm</code>と<code>glm</code>メソッドで使用されるユーティリティ関数であり、一般ユーザは使用すべきではありません。
AICによって数式ベースのモデルを選択する。
ベクトル<i>(x[1], ..., x[n])</i>と<i>(y[0], y[1], ..., y[n])</i>(1つ多い!)が与えられた場合、<code>stepfun(x, y, ...)</code>は補間'ステップ'関数、例えば<code>fn</code>を返す。すなわち<i>fn(t) = c</i><i>[i]</i> (定数) for <i>t in ( x[i], x[i+1])</i> and at the abscissa values、(デフォルトでは)<code>right = FALSE</code> の場合, <i>fn(x[i]) = y[i]</i>, <code>right=TRUE</code>の場合, <i>fn(x[i]) = y[i-1]</i>, for<i>i=1, ... , n</i>.n</i>.

上記の定数 <i>c[i]</i> の値は'continuity' パラメータ <code>f</code> に依存します.デフォルトでは, <code>right = FALSE, f = 0</code>, <code>fn</code> は <em>cadlag</em> 関数, すなわち、一般に, <i>c[i]</i> は隣り合う <i>y</i> の値の間で補間される, <i>c[i] = (1-f)*y[i] + f*y[i+1]</i>.したがって、<code>f</code>の0以外の値では、<code>fn</code>は、左連続である(すなわち、定数ピースが右端を含む)<code>right = TRUE, f = 1</code>でない限り、両側から不連続になり得るので、もはやproperstep関数ではないかもしれません、定数は右終点を含む)。
時系列を、<code>loess</code>を用いて、季節成分、トレンド成分、不規則成分に分解する。
最尤法による時系列の構造モデルのあてはめ
分散分析モデルを要約する。
これらの関数はすべて、クラス<code>glm</code>または<code>summary.glm</code>オブジェクトの<code>メソッド</code>です。
<code>"lm"</code>クラスの<code>summary</code>メソッド。
クラス <code>"manova"</code> の <code>summary</code> メソッド。
ベクトル<i>(x[1], ..., x[n])</i>と<i>(y[0], y[1], ..., y[n])</i>(1つ多い!)が与えられたとき、<code>stepfun(x, y, ...)<//code> は補間'ステップ'関数、例えば<code>fn</code>を返します。すなわち<i>fn(t) = c</i><i>[i]</i> (定数) for <i>t in ( x[i], x[i+1])</i> and at the abscissa values、(デフォルトでは)<code>right = FALSE</code> の場合, <i>fn(x[i]) = y[i]</i>, <code>right=TRUE</code>の場合, <i>fn(x[i]) = y[i-1]</i>, for<i>i=1, ... , n</i>.n</i>.

上記の定数 <i>c[i]</i> の値は'continuity' パラメータ <code>f</code> に依存します.デフォルトでは, <code>right = FALSE, f = 0</code>, <code>fn</code> は <em>cadlag</em> 関数, すなわち、一般に, <i>c[i]</i> は隣り合う <i>y</i> の値の間で補間される, <i>c[i] = (1-f)*y[i] + f*y[i+1]</i>.したがって、<code>f</code>の0以外の値では、<code>fn</code>は、左連続である(すなわち、定数ピースが右端を含む)<code>right = TRUE, f = 1</code>でない限り、両側から不連続になり得るので、もはやproperstep関数ではないかもしれません、定数はその右端を含む)。
(x,y)の値をFriedmanの'super smoother'によって滑らかにする。
与えられた数値または論理ベクトルまたは配列を記号化します。相関行列、疎行列、論理行列などの構造化行列の可視化に特に役立ちます。
データのベクトルに対して1標本および2標本のt検定を行う。
予測変数に対する回帰項をプロットし、オプションで標準誤差と部分残差を追加します。
関数<code>terms</code>は、様々な種類の<span style="font-family：color：<span style="font-family: Courier New, Courier;"><b>R</b></span> データ・オブジェクトから <em>terms</em> オブジェクトを抽出することができます。
この関数は、数式とオプションの引数を受け取り、termsオブジェクトを構築します。この項オブジェクトは、<code>model.matrix</code>を構築するために使用されます。
<code>time</code>は、時系列がサンプリングされた時刻のベクトルを作成します。

<code>cycle</code>は、各観測のサイクル内の位置を示す。

<code>frequency</code> は単位時間あたりのサンプル数を返し、<code>deltat</code> はオブザベーション間の時間間隔を返します（<code>ts</code> を参照）。
その最初の行が与えられると、対称トープリッツ行列を形成します。
関数 <code>ts</code> は時系列オブジェクトを作成するために使用されます。

<code>as.ts<//code>と<code>is.ts<//code>はオブジェクトを時系列に強制し、オブジェクトが時系列かどうかをテストする。
共通の周波数を持つ時系列を結合する。<code>ts.union</code>は、<code>NA</code>で全時系列をパディングし、<code>ts.intersect</code>は、全時系列がカバーする時間に制限します。
複数の時系列を共通のプロット上にプロットする。<code>plot.ts<//code>とは異なり、時系列は異なる時間ベースを持つことができますが、同じ頻度を持つ必要があります。
共通の頻度を持つ時系列を結合する。<code>ts.union</code>は、<code>NA</code>で全時間をパッドし、<code>ts.intersect</code>は、全系列でカバーされる時間に制限します。
時系列診断をプロットする汎用関数。
<code>tsp</code>は、<code>tsp</code>属性（または<code>NULL</code>）を返します。Sバージョン2との互換性のために含まれています。<code>tsp&lt;-</code>は<code>tsp</code>属性を設定します。<code>hasTsp</code>は、<code>x</code>が<code>tsp</code>属性を持つことを保証します。
<code>tsp</code> は <code>tsp</code> 属性 (または <code>NULL</code>) を返します。これは S バージョン 2 との互換性のために含まれています。<code>tsp&lt;-</code>は<code>tsp</code>属性を設定します。<code>hasTsp</code>は、<code>x</code>が<code>tsp</code>属性を持つことを保証します。
astate-spaceモデルにより、一変量時系列に対して固定区間平滑化を行います。  固定区間平滑化は、観測された系列全体に基づいて、各時点での状態の最良の推定を行います。
指定されたfamily-wis-eprobability of coverageを持つ因子のレベルのthemeans間の差に関する信頼区間の集合を作成する。  区間は，Studentizedrange 統計量， Tukeyの'Honest Significant Difference'法に基づく．
関数 <code>uniroot</code> は、最初の引数に関して、関数 <code>f</code> の根（つまりゼロ）を <code>lower</code> から <code>upper</code> までの区間で探索します。

<code>extendInt</code>を<code>"no"</code>でない文字列に設定すると、<code>sign(f(x))</code>が区間の端点で要求を満たさない場合に、正しい<code>interval = c(lower,upper)</code>を検索することを意味します。
<code>update</code>は、モデルを更新し、(デフォルトでは)再フィットします。  これは、オブジェクトに格納された呼び出しを抽出し、呼び出しを更新し、(デフォルトでは)その呼び出しを評価することによって行われます。  データフレームが修正された場合など、1つの引数だけで<code>update<//code>を呼び出すと便利なことがあります。

<code>update()</code>や同様の関数における "呼び出しの抽出 "は、<code>getCall()</code>を使用します。<code>getCall()</code>は、単に<code>x$call</code>を取得するデフォルトメソッドを持つ(S3の)汎用関数です。

このため、<code>update()</code>は、新しいモデルクラスに対して（デフォルトメソッドによって）自動的に、あるいはそのクラス用の単純な<code>getCall()</code>メソッドを提供することによって、しばしば動作します。
<code>update</code>はモデルを更新し、(デフォルトでは)再フィットします。  これは、オブジェクトに格納されているコールを抽出し、コールを更新し、(デフォルトでは)そのコールを評価することによって行われます。  データフレームが修正された場合など、1つの引数だけで<code>update<//code>を呼び出すと便利なことがあります。

<code>update()</code>や同様の関数における "呼び出しの抽出 "は、<code>getCall()</code>を使用します。<code>getCall()</code>は、単に<code>x$call</code>を取得するデフォルトメソッドを持つ(S3の)汎用関数です。

このため、<code>update()</code>は、新しいモデルクラスに対して、自動的に、あるいはそのクラスのための単純な<code>getCall()</code>メソッドを提供することによって、（そのデフォルトメソッドによって）動作することがよくあります。
<code>update.formula</code>は、モデルの式を更新するために使用されます。これは通常、項の追加や削除を含みますが、更新はより一般的なものである場合もあります。
<code>var</code>, <code>cov</code>, <code>cor</code>は、<code>x</code>の分散と、<code>x</code>と<code>y</code>の共分散または相関を計算します。   <code>x</code> と <code>y</code> が行列の場合、<code>x</code> の列と <code>y</code> の列の間の共分散（または相関）が計算されます。

<code>cov2cor</code> 共分散行列を対応する相関行列に<em>効率的に</em>スケーリングします。
正規母集団から得られた2つの標本の分散を比較するF検定を行う。
シンプルなユーティリティは、(欠損していない)ケース名と(欠損していない)変数名を返します。
これらの関数は、因子分析における負荷行列を「回転」させる。
mainパラメータ分散共分散行列関数は、適合したモデルオブジェクトの主要パラメータの分散共分散行列を返します。  モデルの「主」パラメータは、<code>coef</code> が返すパラメータに対応し、通常、厄介なスケールパラメータ(<code>sigma</code>)を含みません。
重み付き平均の計算
線形モデルのフィットから重み付き残差を計算。
<code>weights</code>は、モデリング関数が返すオブジェクトからフィットの重みを抽出する汎用関数です。

メソッドは、<code>napredict</code>メソッドを利用して欠損値の欠落を補うことができます。  デフォルトのメソッドはこれを行います。
後者は 'Mann-Whitney' 検定としても知られています。
<code>window</code> は、時間 <code>start</code> と <code>end</code> の間に観測されたオブジェクト <code>x</code> のサブセットを抽出する汎用関数です。もし周波数が指定された場合、系列は新しい周波数で再サンプリングされます。
<code>window</code> は、時間 <code>start</code> と <code>end</code> の間に観測されたオブジェクト <code>x</code> のサブセットを抽出する汎用関数です。頻度が指定された場合、系列は新しい頻度で再サンプリングされる。
フラット'（分割表）、別名<code>ftable</code>の読み込み、書き込み、強制。
通常データフレームに含まれる分類横断因子から分割表（オプションでスパース行列）を作成します。
