x
gctorture(TRUE)を呼び出すと、メモリ・マネージャはすべてのアロケーションで強制的にフルGCを行うように指示する。gctorture2はより洗練されたインターフェイスを提供し、GCトレートの開始を延期することができ、また、ステップ・アロケーションごとにのみGCを実行するオプションも提供する。gctorture2の3番目の引数は、Rが厳密な書き込みバリアが有効になって設定されている場合にのみ使用される。  この場合、すべてのガベージ・コレクションはフル・コレクションとなり、メモリ管理は空きノードをマークし、空きノードが使用されたときにエラーを知らせる多くの状況でのチェックを有効にする。  これは、Cコードで保護されていない値を分離するのに非常に役立ちます。  アノードがフリーになって再割り当てされた場合は検出されません。  inhibit_releaseargument を使えば、このような再割り当てを防ぐことができる。  gctorture2は、Rセッションの開始時に環境変数経由で呼び出すこともできる。  R_GCTORTUREはstep引数に対応し、R_GCTORTURE_WAITはwaitに、R_GCTORTURE_INHIBIT_RELEASEはreleaseを抑制します。
gctorture(TRUE)を呼び出すと、メモリ・マネージャはすべての割り当てに対して完全なGCを実行するように指示します。gctorture2は、GC拷問の開始を延期することを可能にする、より洗練されたインタフェースを提供し、また、ステップ割り当てごとにのみGCを実行するオプションも与えます。  この場合、すべてのガベージ・コレクションはフル・コレクションとなり、メモリ管理は空きノードをマークし、空きノードが使用されたときにエラーを知らせる多くの状況でのチェックを有効にする。  これは、Cコードで保護されていない値を分離するのに非常に役立ちます。  アノードがフリーになって再割り当てされた場合は検出されません。  inhibit_releaseargument を使えば、このような再割り当てを防ぐことができる。  gctorture2は、Rセッションの開始時に環境変数経由で呼び出すこともできる。  R_GCTORTUREはstep引数に対応し、R_GCTORTURE_WAITはwaitに、R_GCTORTURE_INHIBIT_RELEASEは抑制_releaseに対応する。
pos引数は、オブジェクトを検索する環境を、正の整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frametを使用することを含む）として、いくつかの方法で指定することができます。  デフォルトの-1は、toget呼び出しの現在の環境を示す。envir引数は、環境を指定する別の方法です。これらの関数は、指定された環境において、それぞれの名前xに値が束縛されているかどうかを調べます。  inheritsがTRUEであり、指定された環境内でxに値が見つからない場合、xという名前に出会うまでその環境を囲むフレームが検索されます。  modeが指定された場合、その型のオブジェクトのみが探索されます。ここでのmodeは、typeofとmodeの意味が混在しています：「mgetの場合、modeとifnotfoundの値は、xと同じ長さか、長さ1でなければならない。  引数ifnotfoundは、要求された項目が見つからなかった場合に使用する値か、項目が見つからなかった場合に呼び出される引数1つの関数を含むリストでなければならない。  dynGet()はやや実験的なもので、他の関数の内部で使用されます。これは、呼び出し側、つまり関数のsys.frame()内でオブジェクトを探します。  注意して使用してください。
where引数は、いくつかの方法でオブジェクトを探す環境を指定することができます：整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frameを使用することを含む）として。  envir引数は環境を指定する別の方法ですが、主に互換性のために存在します。この関数は、名前xが指定された環境でそれにバインドされた値を持っているかどうかを調べます。  inheritsがTRUEで、指定された環境でxに値が見つからない場合、xという名前に出会うまで、環境の閉じたフレームが検索されます。  modeが指定された場合、その型のオブジェクトのみが探索されます。modeは "numeric "コレクションと "function "コレクション(modeを参照)のいずれかを指定することができます。  (これは、コレクションのメンバが指定されている場合でも同じで、例えばmode = "special "であれば、あらゆる型の関数を求めることになる)。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  GUIコンソールを含む組み込みアプリケーションでは、これは信頼できないかもしれない。
NA
NA
stdin()、stdout()、stderr() は、それぞれコンソールの入力、出力、エラーに対応する標準接続である (ファイルストリームとは限らない)。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれません。
これは、R内部によって登録され処理された後の登録情報を取ります。  このクラスにはprintメソッドがあり、ルーチンを登録した型のみを表示します。
これは、登録され、R内部によって処理された後の登録情報を取ります。  つまり、拡張情報を使用します。登録されたルーチンを持つ型のみを表示するクラス用のprintメソッドがあります。
これは、登録され、R内部によって処理された後の登録情報を取ります。  つまり、拡張情報を使用します。クラス用のprintメソッドがあり、登録されたルーチンを持つ型のみを表示します。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルト・メソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち高い方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnames は適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が結果として返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するとエラーになります。
エラーの動作は、実行中のコード内で確立されたエラー・ハンドラと、options(error=) によって設定された現在のデフォルトのエラー・ハンドラによって制御されます。  エラーはまず、ingsignalCondition() を使用するかのようにシグナルされます。  ハンドラがない場合、またはすべてのハンドラが返された場合、エラー・メッセージが出力され（options("show.error.messages")がtrueの場合）、デフォルトのエラー・ハンドラが使用されます。  対話的な使用におけるデフォルトの動作(NULLerrorハンドラ)は、トップ・レベルのプロンプトまたはトップ・レベルのブラウザに戻ることであり、非対話的な使用では、(効果的に)q("no", status = 1, runLast = FALSE)を呼び出すことである。デフォルト・ハンドラは、エラー・メッセージをバッファに格納する。  エラーは、getOption("warning.length")文字数（デフォルト1000）に切り詰められます。条件オブジェクトが提供された場合、それは唯一の引数でなければならず、それ以上の引数は警告とともに無視されます。
getExportedValueは、名前空間nsでエクスポートされた変数名の値を返します。getNamespaceは、名前空間名を表す環境を返します。  getNamespaceExportsは、nsによってエクスポートされた名前の文字ベクトルを返します。getNamespaceImportsは、名前空間nsによって使用されたインポートの表現を返します。  getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
setHook は、システム（またはユーザ）関数から呼び出される関数のリストであるフックをユーザが登録するための一般的なメカニズムを提供します。  フックを完全に削除するには、setHook(hookName, NULL, "replace")を呼び出します。Rパッケージがライブラリによってアタッチされるか、その他の方法でロードされると、初期化コードを呼び出すことができます。  初期化中に呼び出されるパッケージ・フック関数の説明については、.onLoadを参照してください。  ユーザは、setHook()で提供されるフックを使って独自の初期化コードを追加することができます。この関数は、atry呼び出しの内部でfunname(pkgname, pkgpath)として呼び出されます。  すべてのフックが定義され、パッケージがアタッチされている場合、初期化イベントの順序は次のようになる：パッケージ・ネームスペースがロードされる。パッケージの.onLoad関数が実行される。S4メソッドのディスパッチがオンの場合、setLoadActionで設定されたアクションが実行されます。名前空間がシールされる。ユーザーの "onLoad "フックが実行される。パッケージが検索パスに追加される。パッケージの .onAttach 関数が実行されます。パッケージ環境が封印される。ユーザーの "attach "フックが実行される。パッケージがデタッチされ、その名前空間がアンロードされると、同様のシーケンス（ただし逆）が実行される：ユーザーの "detach "フックが実行される。パッケージの.Last.lib関数が実行される。パッケージが検索パスから削除される。ユーザーの「onUnload」フックが実行される。パッケージの .onUnload 関数が実行される。パッケージの名前空間がアンロードされます。Rセッションが終了しても、パッケージは削除されず、名前空間もアンロードされないので、対応するフックは実行されないことに注意してください。また、ユーザー・フックの中には、パッケージが検索パスにない状態で実行されるものがあるので、そのようなフックでは、パッケージ内のオブジェクトを、例のようにダブル（またはトリプル）コロン演算子を使って参照する必要があることにも注意してください。複数のフックが追加された場合、通常は getHook で示された順番で実行されますが、 "detach" と "onUnload" は逆の順番で実行されます。
これは、DLLを管理する内部テーブルに問い合わせます。
getExportedValueは、名前空間ns.getNamespaceでエクスポートされた変数名の値を返します。  getNamespaceExports は、ns によってエクスポートされた名前の文字ベクトルを返します。getNamespaceImports は、名前空間 ns によって使用されたインポートの表現を返します。  getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
getExportedValue は、名前空間 ns.getNamespace 内のエクスポートされた変数名の値を返します。  getNamespaceExports は、ns によってエクスポートされた名前の文字ベクトルを返します。getNamespaceImports は、名前空間 ns によって使用されたインポートの表現を返します。  getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
getExportedValue は、名前空間 ns.getNamespace 内のエクスポートされた変数名の値を返します。  getNamespaceExports は、ns によってエクスポートされた名前の文字ベクトルを返します。getNamespaceImports は、名前空間 ns によって使用されたインポートの表現を返します。  getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
packageHasNamespaceは、パッケージが名前空間を持っているかどうかを示すのではなく（現在はすべて持っています）、むしろ'NAMESPACE'ファイルを持っているかどうかを示します。  しかし、それを使うことを意図しているわけではありません。
getExportedValueはnamespace ns.getNamespaceでエクスポートされた変数名の値を返します。  getNamespaceExportsは、nsによってエクスポートされた名前の文字ベクトルを返します。getNamespaceImportsは、名前空間nsによって使用されたインポートの表現を返します。  getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
getExportedValue は、名前空間 ns.getNamespace 内のエクスポートされた変数名の値を返します。  getNamespaceExports は、ns によってエクスポートされた名前の文字ベクトルを返します。getNamespaceImports は、名前空間 ns によって使用されたインポートの表現を返します。  getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
getExportedValue は、名前空間 ns.getNamespace 内のエクスポートされた変数名の値を返します。  getNamespaceExports は、ns によってエクスポートされた名前の文字ベクトルを返します。getNamespaceImports は、名前空間 ns によって使用されたインポートの表現を返します。  getNamespaceName と getNamespaceVersion は、名前空間 ns の名前とバージョンを返します。getNamespaceUsers は、名前空間 ns をインポートする名前空間の名前の文字ベクトルを返します。
シンボルが含まれている DLL によって明示的に登録されている場合は、引数の数と呼び出されるイン ターフェースに関する情報が返されます。そうでない場合は、汎用ネイティブ・シンボル・オブジェクトが返されます。
引数なしで options() を呼び出すと、オプションの現在の値を含むリストが返されます。  以下のすべてのオプションが初期設定されているわけではないことに注意してください。  単一のオプションの値にアクセスするには、長さ1のリストであるoptions("width")ではなく、例えばgetOption("width")を使うべきである。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
srcfile 関数は、ソース・コード・ファイルの名前とディレクトリ、およびタイムスタンプを含む srcfile クラスのオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
NA
domain が NULL または "" で、gettext または ngettext がパッケージ pkg の名前空間の関数から呼び出された場合、 domain は "R-pkg" に設定されます。  適切なドメインが見つかった場合、各文字列は翻訳され、現在の言語への翻訳が見つかればそれに置き換えられる。  メッセージの翻訳に使用される言語は、OSのデフォルトやRの起動時のロケール設定（Sys.getlocale()参照）、特にLANGUAGE環境変数によって決定される。通常、パッケージpkgのRの警告/エラーメッセージのドメインは "R-pkg "であり、Cレベルのメッセージのドメインは "pkg "です。  このようなメッセージの翻訳は、言語によって非常に特殊なルールがあります: GNU Gettextマニュアルを参照してください。  文字列には、insprintfで使用される%dのインスタンスが1つ含まれます。  bindtextdomainは、同じ名前のC関数のラッパーである。  dirnameがanon-NULLの場合、メッセー ジカタログを探す場所を指定します：domain = NULLの場合、現在の場所を返します。
sprintfはシステムのsprintf C-library関数のラッパーです。  gettextfは、C-stylestring書式を提供する便宜関数であり、書式文字列の翻訳が可能です。引数（fmtを含む）は、可能であれば、最長の長さまで何度でも再利用され、並列に書式設定が行われます。  長さゼロの引数は許され、長さゼロの結果を与える。  すべての引数は、未使用であっても評価される。したがって、いくつかの型（例えば "symbol "や "language"、seetypeof）は許可されない。fmtresultで未使用の引数は警告となる。(引数を "スキップ "するには、%.0sという書式を使うことができる。)以下は、KernighanとRitchie(参考文献参照)から抽象化したものである。文字列fmtは、出力文字列に渡される通常の文字と、...を通して提供される 引数に対して操作される変換指定を含んでいる。  許容される変換指定は、a%で始まり、集合aAdifeEgGosxX%中の文字の1つで終わる。  これらの文字は以下の型を示す：整数値、oは8進数、xとXは16進数（a-fはコードと同じ大文字小文字を使用）。  正確に整数値を持つ数値変数は整数に強制される。  倍精度値は、"[-]mmm.ddd "という形式の "固定小数点 "10進数表記になります。  小数点以下の桁数（"d"）は精度によって指定されます：デフォルトは6です。  非定数値は，NA，NaN，または（おそらく符号の後に続く）Inf.倍精度値に変換される。倍精度値は，[-]m.ddde[+-]xxまたは[-]m.dddE[+-]xxの形式の「指数」10進表記で，指数が-4より小さいか精度と等しいより大きい場合は%eまたは%E形式で，そうでない場合は%f形式で表示される。(精度(デフォルト6)は、ここでは有効桁数を指定し、%f、%eでは小数点以下の桁数を指定する。)倍精度値、[-]0xh.hhhp[+-]dの形の2進表記。  小数点以下の16進数桁数は精度によって指定されます。デフォルトは、内部2進数表現を正確に表すのに十分な桁数です。  定数でない値は、NA、NaN、または（おそらく符号の後に続く）Infに変換されます。  フォーマット%aはx、p、16進数値に小文字を使用し、フォーマット%Aは大文字を使用する。これはC99の機能であるため、すべてのプラットフォームでサポートされるべきである。  ほとんどのシステムは末尾のゼロを抑制するが、そうでないものもある。  よく書かれたプラットフォームでは、通常の数値の場合、小数点の前に先頭の1があり、さらに（デフォルトでは）10進数13桁、つまり53ビットがある。  非正規化（別名「サブノーマル」）された数値の扱いは、プラットフォームに大きく依存する。  文字NAは "NA "に変換される。リテラル%（この場合、以下に示す余分なフォーマット文字はどれも許可されない）。sを持つ非文字引数に対してはas.characterによる変換が使用され、f, e, E, g, Gを持つ非倍数引数に対してはas.doubleによる変換が使用される。  もしlength(fmt) > 1であれば、全ての要素は同じ型の引数を予期しなければならない。さらに、最初の% と変換の終了文字の間には、どのような順序であっても、次のようなものがある。文字については、あるプラットフォームではゼロパッドされ、他のプラットフォームでは無視される。数値の「代替出力」を指定し、そのタイプに応じた動作をする。  e、e、f、g、Gの場合、出力には常に小数点が付きます。forとGの場合、末尾のゼロは削除されません。さらに、% の直後に1$から99$を付けて、番号の付いた引数を参照することができます。  この場合、すべての書式に番号が振られているのがベストです。番号が振られていない書式は、引数を順番に処理します。  この表記法では、引数を複数回使用することができます。その場合、引数は同じ型（整数、ダブル、文字）として使用されなければなりません。フィールド幅または精度（両方は不可）はアスタリスク*で示すことができます。  負のフィールド幅は，'-'フラグの後に正のフィールド幅が続くものとして扱われる。  負の精度は、精度が省略されたものとして扱われる。  s変換のフィールド幅と精度は、C標準に記述されているように、文字ではなくバイトとして 解釈されます。R数値ベクトルに使用されるCの倍数は符号付きゼロを持ち、sprintfは -0、-0.000 ...として出力します。
エンコーディングがマークされたファイル・パスがどのように解釈されるかについては、ファイルを参照のこと。
NA
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みを有効にしている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出さないでください。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピー・セマンティクスがあるため、注意が必要です。
fixed=TRUE：完全マッチングを使用する。perl=TRUE：Perlスタイルの正規表現を使用する。fixed=FALSE, perl=FALSE：POSIX1003を使用する。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対し、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでない場合はNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。 これらの関数は、それぞれ3つのモードのうちの1つで動作します: fixed = TRUE: 完全一致を使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対し、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでなければNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。 これらの関数は、それぞれ3つのモードのいずれかで動作します: fixed = TRUE: 完全一致を使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対して、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでなければNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。 これらの関数は、それぞれ3つのモードのうちの1つで動作します: fixed = TRUE: 完全一致を使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対して、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでない場合はNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
grep とは異なり、生のベクトル x 内にマッチするパターンを探します。例えば、空の文字列にマッチするパターンは本質的に無限大であるため、予期せぬ結果につながる可能性があります。引数invertは、マッチの補集合を返すように要求していると解釈されますが、これはvalue = TRUEの場合にのみ意味があります。  引数offsetは、補数ではなく、検索の開始位置を決定する。  invert = TRUEでall = TRUEを指定すると、先頭と末尾の空文字列を含むパターンで区切られた部分にxが分割されることに注意してください（この場合、"^"や"$"を使った正規表現を使用すると、直感的な結果が得られない可能性があります）。fixed = TRUEでvalue = TRUEといった引数の組み合わせもサポートされていますが、あまり意味がありません。
この関数は、同じ値が隣接するように要素を部分的にソートします。NAの値は最後に来る。  これは最善であることが保証されているので、同値は保持され、データがすでにグループ化/ソートされている場合は、グループ化は変更されません。  これは集計に便利で、特に文字ベクトルに対して高速である。裏では、"基数 "順序法が使用され、同じ注意事項が適用される。実数値は、数値の不正確さを考慮して少し丸められます。orderと同様に、クラス化されたRオブジェクトでは、グループ化はxtfrmの結果に基づいて行われます。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。これらの関数は、それぞれ3つのモードのうちの1つで動作します: fixed = TRUE: 完全マッチングを使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対し、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでなければNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
conがopenの場合、変更された接続がオープンされます。  gzip マジックヘッダを提供しない接続からの読み込みは、allowNonCompressed が true の場合は元の接続からの読み込みと同じになり、そうでない場合はエラーになります。圧縮された出力には NUL バイトが埋め込まれるので、con は open = "w" でオープンされた textConnection であることは許されません。  書き込み可能な rawConnection を使用して、データを変数に圧縮します。元の接続は使用不可となり、その接続を指 すオブジェクトはすべて、変更後の接続を指すようになります。  このため、新しい接続は明示的に閉じる必要があります。
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができます。fileの記述は、オープンするファイルへのパス（チルダ展開が行われる場合）、完全なURL（url呼び出しと同じ場合）、""（デフォルト）、または "clipboard"（「クリップボード」のセクションを参照）です。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つ代わりに）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
関数Iには主に2つの使い方がある。関数data.frameにおいて。  Iは、データ・フレームに追加されるオブジェクトや、as.data.frameによってデータ・フレームに変換されるオブジェクトを保護するためにも使用できます。  クラス "AsIs "は、for [, as.data.frame,printとformatを含むいくつかの独自のメソッドを持っています。関数式では。  そこでは、"+", "-", "*", "^"といった演算子を数式演算子として解釈することを禁止するために使用されます。  これはterms.formulaでは記号として解釈される。
エンコーディングの名前と利用可能なエンコーディングはプラットフォームに依存する。  ほとんどのプラットフォームでは、iconvlistがサポートされているエンコーディングのアルファベット順のリストを提供します。  他のプラットフォームでは、iconv(5)のマニュアルページか、マニュアルページの他の場所に情報がある（ただし、システムコマンドiconvは、Rが呼び出すC関数と同じエンコーディングのセットをサポートしていない可能性があることに注意）。  ほとんどのバージョンのiconvでは、変換先のエンコーディングに//TRANSLITを付加することで、音訳が可能になります。iconvの実装は一般的に妥当性チェックをあまり行わないので、 encoding fromが無効な入力を誤って変換してしまうことがよくあることに注意してください。
エンコーディングの名前と使用可能なエンコーディングはプラットフォームに依存します。  ほとんどのプラットフォームでは、iconvlistがサポートされているエンコーディングのアルファベット順のリストを提供します。  他のプラットフォームでは、iconv(5)のマニュアルページか、マニュアルページの他の場所に情報がある（ただし、システムコマンドiconvは、Rが呼び出すC関数と同じエンコーディングのセットをサポートしていない可能性があることに注意）。  ほとんどのバージョンのiconvでは、変換先のエンコーディングに//TRANSLITを付加することで、音訳が可能になります。iconvの実装は一般的に妥当性チェックをあまり行わないので、encoding fromが無効な入力を誤変換することが多いことに注意してください。
オプションとして、RはICU(http://site.icu-project.org)によって文字列を照合するように構築することができる。  そのようなシステムでは、icuSetCollateを使用して、照合順序を調整することができる。その他のビルドでは、この関数を呼び出しても何もせず、警告が表示される。  upper"、"lower"、または "default"。大文字と小文字のどちらを先に並べ替えるかを指定する。  デフォルトは通常小文字優先だが、すべての言語ではそうではない（例えばデンマーク語のデフォルト設定ではそうではない）。可変」文字（主に句読点と記号）の扱いを制御する。  可能な値は、"primary"、"secondary"、"tertiary"（デフォルト）、"quaternary"、"identical"。フランス語ロケールでは、アクセント記号が照合順序に与える影響は右から左へ向かうが、他のほとんどのロケールでは左から右へ向かう。  指定可能な値は "on"、"off"、"default"。  指定可能な値は "on "と "off"（デフォルト）。  これは合成文字の照合に影響する。2次と3次の間に追加されるレベルで、日本語のかな文字の大小を区別するために使用される。可能な値は "on" と "off"(デフォルト)。可能な値は "on" (ひらがなを4次レベルで最初にソートする) と "off" 。照合順序を詳しく理解し、専門的な要件がある人以外には、最初の3つのみに関心があると思われる。ICUは照合に使用されない。代わりにOSの照合サービスが使用される。ICUは照合に使用されない。代わりにC関数のstrcmpが使用され、(符号なし)数値順でバイトごとにソートされる。  環境変数R_ICU_LOCALEが空でない値に設定されている場合、 環境変数LC_ALLが'C'に設定されていない限り(または未設定だがLC_COLLATEが'C'に設定されている場合)、 OSに問い合わせるのではなく、その値が使用される。「ルート」照合順序: https://www.unicode.org/reports/tr35/tr35-collation.html#Root_Collation.For。 「本当の」ICUロケールの仕様: http://userguide.icu-project.org/locale。  ICUは、ロケールがサポートされていないことを報告せず、ICUが考える「最適な」ロケール(これはむしろ異なる可能性があり、icuGetCollate("actual")によって報告される。）  ほとんどの英語ロケールは "root "に戻る。"en_GB "などは有効なロケールだが（少なくともいくつかのプラットフォームでは）、照合順序に関する特別な規則は含まれていないからである。  case_level="on"、strength="primary "でアクセント記号の違いを無視し、 alternate_handling="shifted "でスペース文字と句読点を無視する。  ロケールに値を指定してこの関数を呼び出すと、locale = "none "で再度呼び出すまでICUが使用される。  ICUは、Sys.setlocaleがLC_ALLまたはLC_COLLATEに "C "を指定して呼び出されると、R_ICU_LOCALEが設定されていても使用されない。ICUは、異なる照合順序を設定するためにSys.setlocaleが呼び出されると、R_ICU_LOCALEに従って再び使用される。環境変数LC_ALL（またはLC_COLLATE）がR_ICU_LOCALEよりも優先されるのは、それらが'C'に設定されている場合だけである。  照合順序を設定する他の方法との相互作用があるため、R_ICU_LOCALEは、必要な場合にのみ注意して使用すべきである。localeが指定された場合、すべてのカスタマイズはロケールのデフォルトにリセットされる：Sys.setlocaleによってOS照合順序ロケート・カテゴリが変更された場合、照合順序エンジンはリセットされる。
オプションとして、RはICU(http://site.icu-project.org)によって文字列を照合するように構築することができる。  そのようなシステムでは、icuSetCollateを使用して、照合順序を調整することができる。その他のビルドでは、この関数を呼び出しても何もせず、警告が表示される。  upper"、"lower"、または "default"。大文字と小文字のどちらを先に並べ替えるかを指定する。  デフォルトは通常小文字優先だが、すべての言語ではそうではない（例えばデンマーク語のデフォルト設定ではそうではない）。可変」文字（主に句読点と記号）の扱いを制御する。  可能な値は、"primary"、"secondary"、"tertiary"（デフォルト）、"quaternary"、"identical"。フランス語ロケールでは、アクセント記号が照合順序に与える影響は右から左へ向かうが、他のほとんどのロケールでは左から右へ向かう。  指定可能な値は "on"、"off"、"default"。  指定可能な値は "on "と "off"（デフォルト）。  これは合成文字の照合に影響する。2次と3次の間に追加されるレベルで、日本語のかな文字の大小を区別するために使用される。可能な値は "on" と "off"(デフォルト)。可能な値は "on" (ひらがなを4次レベルで最初にソートする) と "off" 。照合順序を詳しく理解し、専門的な要件がある人以外は、最初の3つのみに関心があると思われる。ICUは照合に使用されない。代わりにOSの照合サービスが使用される。ICUは照合に使用されない。代わりにC関数のstrcmpが使用され、(符号なし)数値順でバイトごとにソートされる。  環境変数R_ICU_LOCALEが空でない値に設定されている場合、 環境変数LC_ALLが'C'に設定されていない限り(または未設定だがLC_COLLATEが'C'に設定されている場合)、 OSに問い合わせるのではなく、その値が使用される。「ルート」照合順序: https://www.unicode.org/reports/tr35/tr35-collation.html#Root_Collation.For。 「本当の」ICUロケールの仕様はhttp://userguide.icu-project.org/locale。  ICUはロケールがサポートされていないことを報告せず、ICUが考える「最適な」ロケール(これはむしろ異なる可能性があり、icuGetCollate("actual")によって報告される。）  ほとんどの英語ロケールは "root "に戻る。"en_GB "などは有効なロケールだが（少なくともいくつかのプラットフォームでは）、照合順序に関する特別な規則は含まれていないからである。  case_level="on"、strength="primary "でアクセント記号の違いを無視し、 alternate_handling="shifted "でスペース文字と句読点を無視する。  ロケールに値を指定してこの関数を呼び出すと、locale = "none "で再度呼び出すまでICUが使用される。  ICUは、Sys.setlocaleがLC_ALLまたはLC_COLLATEに "C "を指定して呼び出されると、R_ICU_LOCALEが設定されていても使用されない。ICUは、異なる照合順序を設定するためにSys.setlocaleが呼び出されると、R_ICU_LOCALEに従って再び使用される。環境変数LC_ALL（またはLC_COLLATE）がR_ICU_LOCALEよりも優先されるのは、それらが'C'に設定されている場合だけである。  照合順序を設定する他の方法との相互作用があるため、R_ICU_LOCALEは、必要な場合にのみ注意して使用すべきである。localeが指定された場合、すべてのカスタマイズは、ロケールのデフォルトにリセットされる。
if文やwhile文、また&&や||を使用する論理式で完全に等しいかどうかをテストするには、identicalを呼び出します。  このような場面では、==や!=などの比較演算子を使用することが多い。  これは自然に見えますが、Rでこれらの演算子が行うように設計されているものではありません。  xとyが長さ1であることを期待したが、片方がそうでなかった場合、FALSEは返されない。  同様に、引数の一方がNAの場合、結果もNAとなる。  いずれの場合も、if(x == y)...という式は期待通りには動作しない。all.equal関数もこの方法で等式をテストするために使われることがあるが、意図するところは異なる。  エラーは発生しないはずである。  identicalを停止させる唯一の方法として知られているのは、Cレベルで無効なポインタを持ち、メモリ・フォールトを発生させることである。  2つの大きな複雑なオブジェクトについて等式をチェックする場合、オブジェクトが同一であるか、ほぼ同一であっても、完全に独立したコピーである場合には、時間がかかることがある。  しかし、ほとんどのアプリケーションでは、計算コストは無視できるはずである。デフォルトのようにsingle.NAがtrueの場合、identicalはNaNをNA_real_とは異なると見なすが、すべてのNaNは等しい（同じ型のすべてのNAは等しい）。文字列は、異なるマークされたエンコーディングであるが、UTF-8に変換されたときに一致する場合、同一とみなされる。attribute.as.setがtrue（デフォルト）の場合、属性の比較は集合として行われます（ベクトルではないため、順序はテストされません）。ignore.bytecodeがtrue（デフォルト）の場合、関数のコンパイル済みバイトコード（cmpfunを参照）は比較では無視されます。  ignore.bytecodeがtrueの場合（デフォルト）、関数のコンパイル済みバイトコード（cmpfunを参照）は比較の際に無視されます。  異なるタイムゾーンの異なる時刻が同じ時刻を表す可能性があるだけでなく、タイムゾーンには複数の名前があり、構成要素のいくつかは省略可能です。 identical(x, y, FALSE, FALSE, FALSE, FALSE)は、厳密に等しいかどうかをテストしないことに注意してください。
NA
breakはfor、while、repeatループから抜け出し、制御はループの最内周の外側の最初の文に移る。  breakもnextも、入れ子になったループの一番内側だけに適用される。よくある間違いだが、ステートメントを中括弧（{ .. }）で囲むのを忘れることがある、特に、キーボードやソースからif...else構文を入力する際の構文エラーを避けるために、}とelseの間に改行を入れるべきではありません。そのため、防御的プログラミングの（やや極端な）姿勢の1つとして、if句などには常に中括弧を使用することが挙げられます。  seqの長さがゼロの場合、ループ本体はスキップされる。そうでなければ、変数varにseqの各要素の値が順番に代入される。ループ本体内でvarに代入することもできるが、次の繰り返しには影響しない。  ループが終了しても、varは最新の値を含む変数として残る。
yesまたはnoが短すぎる場合、それらの要素はリサイクルされます。yesはtestのいずれかの要素がtrueである場合にのみ評価され、noも同様に評価されます。
複素数ベクトルはcomplexで作成できます。  ベクトルは、長さ、実部と虚部、またはモジュラスと引数で指定できます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、つまり実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られませんが、実数部または虚数部がNaNの複素数は得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列の乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義されており、 solve, eigen, svdも定義されている。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。 NA_complex_と上記を参照)、またはプラスマイナス無限大になる。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではありません(現在はすべて持っています)。むしろ'NAMESPACE'ファイルを持っているかどうかを示します。  しかし、そのような使い方は想定されていません。
saveRDSとreadRDSは、1つのRobjectを接続先（通常はファイル）に保存し、そのオブジェクトをリストアする手段を提供します。  これは、1つまたは複数の名前付きオブジェクトを環境に保存したりリストアしたりするsaveやloadとは異なります。  関数serializeとunserializは、シリアライズに対する少し低レベルのインターフェイスを提供します：serializeによって接続にシリアライズされたオブジェクトは、readRDSによって読み戻すことができます。save(compress=FALSE)がfileを使用する場合を除き、fileがファイル名の場合、それはgzfileによって開かれます。  圧縮は、ファイルがファイル名のときにオープンされた接続によって処理されるため、接続によって処理される場合は、ファイルが接続のときにのみ可能です。  接続が提供された場合、それはまだオープンされていなければ、関数の時間の間、（バイナリモードで）オープンされます：すでにオープンされている場合、それはsaveRDS（ascii = FALSE）または非ASCII保存を読み取るためにバイナリモードでなければなりません。
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明します。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトは、オブジェクトが継承するクラスの名前を与える文字ベクトルであるclass属性を持っています（関数oldClassおよびoldClass<-は、この属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性の設定と同様に、class属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトであれば is を使用して、what で指定された class(es) のオブジェクトであるかどうかを調べます。
整数ベクトルが存在するのは、それを期待するCやFortranコードにデータを渡せるようにするためであり、（小さな）整数データを正確かつコンパクトに表現できるようにするためです。現在のRの実装では、整数ベクトルには32ビット整数を使うので、表現可能な整数の範囲は約±2*10^9に制限されることに注意してください。
NA
対話型Rセッションとは、対話する人間のオペレータがいることを前提としたセッションのことで、例えばRは間違った入力に対する訂正を促したり、次に何をするか、次のプロットに移ってもよいかどうかを尋ねたりすることができる。  Rが(WindowsのRterm.exeを経由して)ターミナルで実行される場合、'stdin'が(擬似)ターミナルに接続されていれば対話的であるとみなし、'stdin'がファイルやパイプにリダイレクトされていれば対話的ではないとみなす。  コマンドラインオプション--interactive (Unix)および--ess (Windows, Rterm.exe)は、このデフォルトの仮定を上書きする。(Unixのようなものでは、readlineコマンドラインエディタを使用するかどうかは--interactiveでは上書きされない。)Rの組み込みの使用では、セッションを対話型にするかどうかを設定できる。内部的には、セッションが対話型であるかどうかによって、seestopやoptions("showWarnCalls")など、いくつかのエラーの処理方法や報告方法が決まる。  save、--no-save、--vanillaのいずれかが必要かどうか、およびRがワークスペースを保存するかどうかを尋ねるかどうか。必要なときに起動されるデフォルトのグラフィック・デバイスの選択、およびdev.new: options("device")を参照。
union,intersect,setdiff,setequalのそれぞれは、引数の重複する値を捨て、as.vectorを引数に適用します（特に文字ベクトルにはcoerce係数を適用します）。
numToBits(.)とpackBits(., type="double")は互いに逆関数であることに注意してください。
intToUtf8はデフォルトではサロゲートペアを扱いません: サロゲート範囲内の入力はNAにマップされます。  UTF-16のバイトストリームが2バイト整数として(正しいバイト順で)読み込まれた場合に発生する可能性があります。この場合、allow_surrogate_pairs = TRUEで(一致しないサロゲート値はNAとして扱われたまま)解釈しようとします。
inverse.rle()はrle()の逆関数で、runからxを再構成する。
この関数は、代入可能な値を返すが、代入されていない場合は表示されない関数を使用したい場合に便利である。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、および.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。
Rの配列は1次元、2次元、またはそれ以上の次元を持つことができます。  2次元配列は行列と同じものです。1次元配列はしばしばベクトルのように見えますが、関数によっては異なって扱われることがあります。dim "属性は、非負の値を含む長さ1以上の整数ベクトルで、値の積は配列の長さと一致しなければなりません。is.arrayはプリミティブ関数です。リスト配列の場合、printメソッドはinteger,7という型と長さを示す形式で、長さが1でないエントリを表示します。
is.atomicは、アトミック型（"logical"、"integer"、"numeric"、"complex"、"character"、"raw"）とNULLに対して真である。  例外は、アトミック型、NULL、シンボル（as.nameで与えられる）、スロットを持つS4オブジェクト、外部ポインタ、そしてRからはほとんど見えないが、弱い参照とバイトコード（typeofを参照）である。アトミック型を「アトミック・ベクトル」と呼ぶのが一般的だが、is.vectorはさらに制限を課していることに注意：オブジェクトはアトミックになりうるが、（その意味では）ベクトルにはなりえない。
は評価されない関数呼び出し、つまり与えられた引数に名前付き関数を適用した評価されない式を返します（nameは呼び出される関数名を示す文字列でなければなりません）。  呼び出しは評価されないが、引数...は評価されることに注意。callはプリミティブであるため、最初の引数はnameとみなされ、残りの引数は構築された呼び出しの引数とみなされる。  is.call(x)は、typeof(x) == "language "と厳密に等価であることに注意してください。is.language()は、呼び出しに対しても真です（ただし、is.call()が偽の場合は、シンボルと式に対しても真です）。as.call(<string>)を使おうと思ったら、parse(text=*)の効率的なバージョンであるstr2lang(*)を使うことを検討してください。call()とas.call()は、適用可能であれば、これらのparse()ベースのアプローチよりもはるかに好ましいことに注意してください。
as.characterとis.characterは一般的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。as.characterは実数と複素数を有効数字15桁で表します（技術的には、コンパイラがISO C定数DBL_DIGを設定したもので、C99標準に従ってIEC60559算術演算をサポートするマシンでは15になります）。  これは、結果のすべての桁が信頼できる（表現エラーの結果ではない）ことを保証しますが、文字に変換して数値に戻すと数値が変わる可能性があることを意味します。  可能な限りの精度で数値を文字に変換したい場合は、formatを使用してください。
複素数ベクトルはcomplexで作成できます。  ベクトルは、その長さ、実数部と虚数部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、つまり実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られず、実数部または虚数部がNaNの複素数が得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列の乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義されており、solve, eigen, svdも同様である。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。上記のNA_complex_を参照)、またはプラスマイナス無限大になる。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  リストが与えられると、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
double は、指定された長さの倍精度ベクトルを作成する。  これは numeric.as.double と同じで、汎用関数です。  as.numericと同じです。  is.doubleはdouble型のテストです。Rには単精度データ型がありません。  すべての実数は倍精度形式で格納されます。  関数as.singleとsingleは、as.doubleとdoubleと同じですが、Cと.Fortranインタフェースで使用される属性Csingleを設定します。
is.element(x,y)はx %in%yと同じです。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には変わったコピーのセマンティクスがあるため、注意が必要です。
ここでの "Expression "は、口語的な意味、つまり数学的な式の意味で使われているのではありません。  expression "モードのオブジェクトはリストであるため、[, [[ や $ で置換することができます。  expressionとis.expressionはプリミティブ関数です。expressionは「特殊」で、引数を評価しません。
as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。ベクトルのエンコーディングは次のように行われます。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、レベルが要素のレベル集合に出現する順序で、要素のレベル集合の和を持つ因子となる（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味する）。
is.finiteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が有限（すなわち、NA、NaN、Inf、-Infのいずれかの値でない）ならばTRUEであり、そうでなければFALSEである。  is.infiniteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が無限大（すなわち、Infまたは-Infのいずれかに等しい）の場合に真（TRUE）となり、それ以外の場合に偽（FALSE）となる。  複素数は実数部または虚数部のどちらかがis.nanであれば無限大である。  NaNにtestequalityを与えたり、同一の値を使ったりしてはならない。  これらのうちの1つは、数値の欠損値NAに使用され、is.nanはその値に対して偽となる。  複素数は、実数部または虚数部のいずれかがNaNでNAでない場合、NaNとみなされる。論理ベクトル、整数ベクトル、生ベクトルのすべての要素は、NaNではないとみなされる。デフォルトのメソッドは、文字ベクトルとローベクトルを受け付け、すべてのエントリに対してFALSEを返します。Rバージョン2.14.0以前では、すべての入力を受け付け、数値以外のほとんどの値に対してFALSEを返していました。原子ベクトルでない場合はエラーとして通知されるようになりました。
is.primitive(x)はxがプリミティブ関数かどうか、つまりtypeof(x)が "builtin "か "special "かをテストします。
is.finiteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が有限（すなわち、NA、NaN、Inf、-Infのいずれかの値ではない）ならばTRUEであり、そうでなければFALSEである。  is.infiniteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が無限大（すなわち、Infまたは-Infのいずれかに等しい）の場合に真（TRUE）となり、それ以外の場合に偽（FALSE）となる。  複素数は実数部または虚数部のどちらかがis.nanであれば無限大である。  NaNにtestequalityを与えたり、同一の値を使ったりしてはならない。  これらのうちの1つは、数値の欠損値NAに使用され、is.nanはその値に対して偽となる。  複素数は、実数部または虚数部のいずれかがNaNでNAでない場合、NaNとみなされる。論理ベクトル、整数ベクトル、生ベクトルのすべての要素は、NaNではないとみなされる。デフォルトのメソッドは、文字ベクトルとローベクトルを受け付け、すべてのエントリに対してFALSEを返します。Rバージョン2.14.0以前では、すべての入力を受け付け、数値以外のほとんどの値に対してFALSEを返していました。原子ベクトルでない場合はエラーとして通知されるようになりました。
整数ベクトルは、それを期待するCやFortranコードにデータを渡せるように、また、（小さな）整数データを正確かつコンパクトに表現できるように存在します。現在のRの実装では、整数ベクトルには32ビット整数を使用しているため、表現可能な整数の範囲は約±2*10^9に制限されていることに注意してください。
NA
LISPのような）伝統的なドット付きペアリストは使用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として使用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます。他のタイプの引数の戻り値は文書化されていません。list、is.list、is.pairlistは基本関数です。
dyn.loadがロードするオブジェクトは、macOSを除くすべてのプラットフォームで「dynamicallyloadable libraries」（「DLL」と略される）と呼ばれる。  Unix系では「dynamicshared objects」（略称「DSO」）、または「shared objects」とも呼ばれる。  (POSIX標準では'実行可能オブジェクトファイル'を使用していますが、他の誰も使用していません。)適切なDLLを作成しインストールする方法については、'参照'および'R拡張の作成'および'Rのインストールと管理'マニュアルを参照してください。  これらの引数は、ユーザーが個々のライブラリのロード・プロセスをより詳細に制御できるようにするために用意されています。  一般的には、デフォルト値が適切であり、正当な理由があり、その意味を理解している場合にのみオーバーライドする必要があります。ローカル引数では、アタッチされるDLL内のシンボルを他のDLLから見えるようにするかどうかを制御できます。  シンボルを独自の名前空間に保持することは良い習慣ですが、関連する「章」をまたいでシンボルを共有する機能は、多くの場合に有用です。  さらに、プラットフォームやオペレーティング・システムのバージョンによっては、すべてのシンボルを正常に解決するために、シンボルをグローバルにロードしなければならないライブラリもあります。now引数をFALSEとして遅延ロードを使用すると、副作用が発生する可能性があるので注意が必要です。  シンボルが見つからないルーチンが呼び出された場合、プロセスは即座に終了する。  意図された使用法は、ライブラリ開発者がすべてのシンボルが実際に解決されていることを確認するためにTRUEを指定して呼び出すことと、一般ユーザーがFALSEを指定して呼び出すことです。  グローバル・テーブルに追加されたシンボルは、アプリケーションの他のすべての要素で使用できるため、2つの異なるDLL間で共有することができる。  これは微妙なバグの原因になる。  サポートされていないオプションが使われたときに警告メッセージが出るようにすることもできる。  これは、options関数でverboseまたはwarnオプションのいずれかを0以外に設定することで可能です。これらの追加引数については、http://www.stat.ucdavis.edu/~duncan/R/dynload/に短い説明とサンプルコードがあります。
TRUEとFALSEはR言語の論理定数を示す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  TRUEは1Lに、FALSEは0Lに、NAはNA_integer_にマッピングされる。
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとする。  もしどちらも与えられない場合，1列の行列が返される．もし data の要素が少なすぎて行列を埋められない場合， data の要素は再利用される．  データの長さが0の場合，アトミックベクトルの場合は適切な型のNA（生のベクトルの場合は0）が使用され，リストの場合はNULLが使用されます．is.matrixは，xがベクトルで長さ2の "dim "属性を持つ場合にTRUEを返し，そうでない場合はFALSEを返します．  この関数は汎用的であり、特定のクラスのオブジェクトを扱うメソッドを書くことができます。  データフレーム用のメソッドは、atomic列と(numeric/logical/complex)以外の列しかない場合は文字行列を返し、それ以外の文字列にはas.vectortを適用して因子と書式を指定します、as.matrixのデフォルトメソッドはas.vector(x)を呼び出すので、例えば因子を文字ベクトルに強制します。is.matrixはプリミティブな関数です。行列のprintメソッドは、各要素の名前またはインデックスを矩形にレイアウトします。  リスト行列の場合，長さが1でないエントリは，型と長さを示す integer,7 の形式で表示される．
文字型のNAは、文字列 "NA "とは異なる。  is.na<-.is.naとanyNAは汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。na<-は、より安全な欠測の設定方法を提供するかもしれません。例えば、因子の場合は異なる動作をします。NAを使用した数値計算は通常NAになります。  しかし、これは保証されたものではなく、将来のCPUやコンパイラは異なる動作をするかもしれません。動的バイナリ変換もこの動作に影響を与える可能性があります(valgrindでは、NaNが関与していなくてもNAを使用した計算がNaNになる可能性があります)。論理計算では、NAは欠損したTRUE/FALSE値として扱われるため、式がNAオペランドに依存しない場合、TRUEまたはFALSEを返す可能性があります。anyNAのデフォルトメソッドは、aclassとNULLを持たないアトミックベクトルを扱います。  any(is.na(x))は、クラスを持つオブジェクトや、recursive = FALSEのリストやペアリストに対して呼び出されます。
文字型のNAは文字列 "NA "とは異なる。  is.naとanyNAは汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。na<-は、より安全な欠測の設定方法を提供するかもしれません。例えば、因子の場合は異なる動作をします。NAを使用した数値計算は通常NAになります。  しかし、これは保証されたものではなく、将来のCPUやコンパイラは異なる動作をするかもしれません。動的バイナリ変換もこの動作に影響を与える可能性があります(valgrindでは、NaNが関与していなくてもNAを使用した計算がNaNになる可能性があります)。論理計算では、NAは欠損したTRUE/FALSE値として扱われるため、式がNAオペランドに依存しない場合、TRUEまたはFALSEを返す可能性があります。anyNAのデフォルトメソッドは、aclassとNULLを持たないアトミックベクトルを扱います。  any(is.na(x))は、クラスを持つオブジェクト、および recursive = FALSE のリストとペアリストに対して呼び出されます。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(例えば、パッケージの'DESCRIPTION'ファイルでは)、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
文字型のNAは文字列 "NA "とは異なる。  is.na<-.is.naとanyNAは汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。na<-は、より安全な欠測の設定方法を提供するかもしれません。例えば、因子の場合は異なる動作をします。NAを使用した数値計算は通常NAになります。  しかし、これは保証されたものではなく、将来のCPUやコンパイラは異なる動作をするかもしれません。動的バイナリ変換もこの動作に影響を与える可能性があります(valgrindでは、NaNが関与していなくてもNAを使用した計算がNaNになる可能性があります)。論理計算では、NAは欠損したTRUE/FALSE値として扱われるため、式がNAオペランドに依存しない場合、TRUEまたはFALSEを返す可能性があります。anyNAのデフォルトメソッドは、aclassとNULLを持たないアトミックベクトルを扱います。  any(is.na(x))は、クラスを持つオブジェクトや、recursive = FALSEのリストやペアリストに対して呼び出されます。
文字型のNAは文字列 "NA "とは異なる。  is.naとanyNAは汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。na<-は、より安全な欠測の設定方法を提供するかもしれません。例えば、因子の場合は異なる動作をします。NAを使用した数値計算は通常NAになります。  しかし、これは保証されたものではなく、将来のCPUやコンパイラは異なる動作をするかもしれません。動的バイナリ変換もこの動作に影響を与える可能性があります(valgrindでは、NaNが関与していなくてもNAを使用した計算がNaNになる可能性があります)。論理計算では、NAは欠損したTRUE/FALSE値として扱われるため、式がNAオペランドに依存しない場合、TRUEまたはFALSEを返す可能性があります。anyNAのデフォルトメソッドは、aclassとNULLを持たないアトミックベクトルを扱います。  any(is.na(x))は、クラスを持つオブジェクト、および recursive = FALSE のリストとペアリストに対して呼び出されます。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は要素のレベル集合の和をレベルとする因子になり、レベルが要素のレベル集合に出現する順番になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合になることを意味します）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷が可能な表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
as.nameは、まず引数を内部的に文字ベクトルに強制します（そのため、as.character用のメソッドは使用されません）。  as.nameはas.vector(x, "symbol")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。
is.finiteはxと同じ長さのベクトルを返し、そのj番目の要素はx[j]が有限であれば（すなわち、NA、NaN、Inf、Infのいずれでもなければ）TRUEとなり、そうでなければFALSEとなります。  is.infiniteは、xと同じ長さのベクトルを返し、そのj番目の要素は、x[j]が無限大（すなわち、Infまたは-Infのいずれかに等しい）の場合に真（TRUE）となり、それ以外の場合に偽（FALSE）となる。  複素数は実数部または虚数部のどちらかがis.nanであれば無限大である。  NaNにtestequalityを与えたり、同一の値を使ったりしてはならない。  これらのうちの1つは、数値の欠損値NAに使用され、is.nanはその値に対して偽となる。  複素数は、実数部または虚数部のいずれかがNaNであり、NAでない場合、NaNとみなされる。デフォルトのメソッドは、文字ベクトルとローベクトルを受け付け、すべてのエントリに対してFALSEを返します。Rバージョン2.14.0以前では、すべての入力を受け付け、数値以外のほとんどの値に対してFALSEを返していました。原子ベクトルでない場合はエラーとして通知されるようになりました。
NULLをインデックス化する（Extractを参照）ことは、構文的に合法な方法であれば何でも可能です。  NULLを持つオブジェクトは置換演算子で変更することができ、右辺の型に強制されます。NULLは空のペアリストとしても使用されます。値NULLを持つオブジェクトは、NULLオブジェクトが1つしかないため、属性を持つことができません。属性を割り当てようとすると、エラー(attr)になるか、オブジェクトが属性を持つ空のリストに昇格します(属性と構造体)。
as.numericは汎用関数ですが、S3のメソッドはas.double用に書かなければなりません。  これはas.doubleと同じです。is.numericは内部汎用プリミティブ関数です：オブジェクトの特定のクラスを処理するメソッドを書くことができます。  is.doubleとは異なります。  因数はデフォルト・メソッドで処理され、"Date"、"POSIXt"、"difftime "クラス用のメソッドがあります（これらは全てfalseを返します）。  is.numericのメソッドは、そのクラスの基本型がdoubleまたはintegerであり、値が数値として合理的に見なされる場合（例えば、その値に対する算術演算が理にかなっており、比較は基本型で行われるべき）にのみtrueを返すべきです。
数値型は1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷が可能な表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
as.numericは汎用関数ですが、S3のメソッドはas.double用に書かなければなりません。  これはas.doubleと同じです。is.numericは内部汎用プリミティブ関数です：オブジェクトの特定のクラスを処理するメソッドを書くことができます。  is.doubleとは異なります。  因子はデフォルト・メソッドで処理され、"Date"、"POSIXt"、"difftime "クラス用のメソッドがあります（これらは全てfalseを返します）。  is.numericのメソッドは、そのクラスの基本型がdoubleまたはintegerであり、値が数値として合理的に見なされる場合（例えば、その値に対する算術演算が理にかなっており、比較は基本型で行われるべき）にのみtrueを返すべきです。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  units="auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる可能な最大の単位（"weeks "を除く）が選択されます。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
as.numericは汎用関数ですが、S3のメソッドはas.double用に記述する必要があります。  これはas.doubleと同じです。is.numericは内部汎用プリミティブ関数です：オブジェクトの特定のクラスを処理するメソッドを書くことができます。  is.doubleとは異なります。  因子はデフォルト・メソッドで処理され、"Date"、"POSIXt"、"difftime "クラス用のメソッドがあります（これらは全てfalseを返します）。  is.numericのメソッドは、そのクラスの基本型がdoubleまたはintegerであり、値が数値として合理的に見なされる場合（例えば、その値に対する算術演算が理にかなっており、比較は基本型で行われるべき）にのみtrueを返すべきです。
NA
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数は2つのクラスを全く異なるものとして扱います。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は要素のレベル集合の和をレベルとする因子になり、レベルが要素のレベル集合に出現する順番になる（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合になることを意味する）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
LISPのような）伝統的なドット付きペア・リストは使用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として使用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます。他のタイプの引数の戻り値は文書化されていません。list、is.list、is.pairlistはプリミティブ関数です。
is.primitive(x)は、xがプリミティブ関数かどうか、つまりtypeof(x)が "builtin "か "special "かをテストする。
QR分解は多くの統計的手法で重要な役割を果たしている。  QR分解は多くの統計的手法で重要な役割を果たします。特に、与えられた行列 ㊟とベクトル㊟に対して方程式㊟=㊟を解くのに使われます。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q}行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に制限されます。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートしています。
S-PLUS8.0より前のRとS方言の両方で実行可能なコードにするには、is.Rを定義するか、if (exists("is.R") && is.function(is.R) && is.R())として使用しなければなりません。
raw型は生のバイトを保持するためのものです。  バイトのシーケンスを抽出したり、要素を置き換えたりすることができます（ただし、生のベクトルの要素によってのみ）。  関係演算子(バイト表現の数値順序を使用した比較を参照)は、ビット単位の解釈を持つ論理演算子(論理を参照)と同様に動作します。  rawへの強制は、入力値を小さい（10進）整数を表すものとして扱うので、入力はまず整数に強制され、[0 ... 255]の範囲外かNAの値は0（ヌルバイト）に設定される。as.rawとis.rawはプリミティブ関数である。
is.atomicは、atomic型（"logical"、"integer"、"numeric"、"complex"、"character"、"raw"）とNULLに対して真となる。  例外は、アトミック型、NULL、シンボル（as.nameで与えられる）、スロットを持つS4オブジェクト、外部ポインタ、Rからはほとんど見えないが弱い参照とバイトコード（typeofを参照）である。アトミック型を「アトミック・ベクトル」と呼ぶのが一般的だが、is.vectorはさらに制限を課していることに注意：オブジェクトはアトミックであるが、（その意味では）ベクトルではない。
NA
as.nameはまず引数を内部的に文字ベクトルに強制します（そのためas.character用のメソッドは使用されません）。  as.nameはas.vector(x, "symbol")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname名'が計算されます。  ...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、（以前はNAcountに含まれていた）除外された値をカウントしないように注意されています。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
is.unsortedは汎用的で、特定のクラスのオブジェクトを扱うメソッドを書くことができます。
mode="any "の場合、is.vectorはアトミックなモードであるリストと式に対してTRUEを返す。  (一方、as.vectorは、atomicモードの結果（ただし、"list "モードや "expression "モードの結果は除く）に対して、nameを含むすべての属性を除去する。is.vectorはFALSEを返し、as.vectorはmode = "any "の場合、因子を文字ベクトルに変換する。
ここでは、いわゆる "S3 "クラス（とメソッド）について説明する。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトは、オブジェクトが継承するクラスの名前を与える文字ベクトルであるクラス属性を持っています（関数oldClassおよびoldClass<-は、この属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性設定と同様にclass属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトであれば is を使用し、そうでなければ、class(x) のすべての要素が what に含まれていれば TRUE を返します。inherits と isa 以外はすべてプリミティブ関数です。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれません。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在はすべて持っています)。  しかし、そのような使い方は想定されていません。
デバッグ用のフラグが付けられた関数に入ると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  デバッグ・プロンプトでは、コマンドまたはR式を入力することができ、その後に改行が続きます。  別の関数の内部で定義されている関数をデバッグするには、その定義の最後までシングルステップで進み、その関数の名前に対してdebugを呼び出します。デバッグの使用は永続的で、デバッグがオフにされない限り、デバッガはすべての呼び出しで入力されます（関数が削除され、置き換えられた場合、デバッグ状態は保存されないことに注意してください）。明示的なシグネチャでS4メソッドをデバッグするには、シグネチャを使用します。シグネチャを指定すると、デバッグ対象のメソッドを示す。この場合のデバッグは、デバッグ・ビットではなくトレース・マシンを使用するため、若干異なる実装になっていることに注意してください。そのため、テキストと条件を非NULLシグネチャと組み合わせて指定することはできません。isdebuggedは、a)シグネチャがNULLでクロージャfunがデバッグされた場合、またはb)シグネチャがNULLでなく、funがS4ジェネリックで、そのシグネチャのfunのメソッドがデバッグされた場合にTRUEを返します。バイトコンパイルされた関数のデバッグが有効になっている場合、デバッグが無効になるまで、その関数の解釈されたバージョンが使用されます。
と&&は論理ANDを、｜と｜｜は論理ORを示します。  短縮形は、算術演算子とほぼ同じ方法で要素間の比較を行います。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、ゼロは偽、ゼロ以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (ディスパッチの計算方法についてはOpsを参照してください。)NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
最初の11の関数は接続を作成します。  デフォルトでは、接続はオープンされません（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することでオープンされる可能性があります。fileの記述は、オープンするファイルへのパス（チルダ展開が行われる場合）、完全なURL（urlを呼び出すのと同じ場合）、または""（デフォルト）、または "clipboard"（「クリップボード」のセクションを参照）です。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つ代わりに）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在ではすべてのパッケージが持っています)。  しかし、そのような使い方は想定されていません。
loadNamespace関数とattachNamespace関数は通常、libraryを使用してネームスペースと必要なインポートをロードするときに暗黙的に呼び出されます。  loadNamespaceは指定された名前空間をロードし、内部データベースに登録します。  指定された名前空間がすでにロードされているときに、その名前空間をロードするように要求しても、何の効果もありません。  引数は、libraryへの対応する引数と同じ意味を持っています。libraryのヘルプ・ページでは、特定のインストール済みパッケージがどのように選択されるかの詳細が説明されています。  ロード後、loadNamespaceは.onLoadという名前のフック関数を名前空間の内部変数として探します（これはエクスポートされるべきではありません）。  loadNamespaceは読み込んだ名前空間を検索パスにアタッチしません。attachNamespaceを使用すると、名前空間のエクスポートされた値を含むフレームを検索パスにアタッチできます（ただし、これはほとんどの場合ライブラリ経由で実行されます）。  isNamespaceLoaded(pkg)はpkg %in%loadedNamespaces()と同等ですが、pkg %in%loadedNamespaces()よりも効率的です。unloadNamespaceを使用すると、名前空間を強制的にアンロードすることができます。  名前空間がアタッチされている場合、最初にその名前空間がデタッチされ、それによって、名前空間に.onDetach関数または.Last.lib関数がエクスポートされている場合はその関数が実行されます。  名前空間が他のロードされた名前空間によってインポートされた場合、エラーがシグナルされ、名前空間はアンロードされない。  定義されている場合、内部レジストリから名前空間を削除する前にフック関数.onUnloadが実行されます。名前空間のアンロードと再ロードに関するいくつかの問題については、detachのヘルプのコメントを参照してください。
ISOdatetimeとISOdateはstrptimeの便利なラッパーで、デフォルトとISOdateがタイムゾーンとしてUTCを設定する点だけが異なります。  これらはstrptimeを使用するため、0:9999の範囲の年だけが受け付けられます。
ISOdatetimeとISOdateはstrptimeの便利なラッパーで、デフォルトとISOdateがタイムゾーンとしてUTCを設定する点だけが異なります。  これらはstrptimeを使用するため、0:9999の範囲の年だけが使用可能です。
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートで不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
isS4はmethodspackageに依存しないので、特にそのパッケージを要求する必要性を検出するために使用することができることに注意してください。asS3は、オブジェクトを暗黙のS3クラスの有効なオブジェクトに変換しようとするかどうかを制御するためにcompleteの値を使用します。  completeがTRUEである場合、S3クラスを拡張するS4クラスからのオブジェクトは、対応するS3クラスを持つS3オブジェクトに変換されます（S3Partを参照）。  これには、擬似クラスである array と matrix を拡張したクラスも含まれます。このようなオブジェクトの class 属性は NULL に設定されます。
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します: 現在のところ、(おそらくgz圧縮された)ファイル接続のみがサポートしています。  可能な値は、64ビットビルドや一部の32ビットビルドでは、Rintegerで表現可能な最大の数値を超える可能性があることに注意してください。ファイル接続は、書き込み/追加の両方でオープンすることができます。  どちらのシークを参照するかは、rw引数で設定できる。デフォルトは、最後に使用されたモード（読み込みまたは書き込み）である。  ほとんどのファイルは読み書きのためだけにオープンされているので、デフォルトはその状態である。  読み書きの初期位置は常にファイルの先頭である。書き込みの初期位置は、"r+"モードと "r+b "モードではファイルの先頭であり、そうでなければファイルの末尾である。  プラットフォームによっては、追記モードではファイルの末尾にしか書き込めないものもある。  (アペンドモードでオープンされたファイルの報告される書き込み位置は、 通常、ファイルが書き込まれるまで信頼できない。)gzfile接続は、いくつかの制限付きでシークをサポートしており、 展開されたファイルのファイル位置を使用する。  seekがwhereの非NA値で呼び出された場合、テキストモード接続でのプッシュバックはすべて破棄される。  これはファイル接続でのみ動作し、すべてのプラットフォームで実装されているわけではありません: 他のプラットフォーム(Windowsを含む)では、大きな(> 2Gb)ファイルでは動作しません。
行列法はデフォルトでeigenの内部で使用され、all.equalを使用して丸め誤差までの行列の対称性をテストします。  行列mは、そのrownamesとcolnamesが同一である場合にのみ対称であることに注意。  unname(m)の使用を検討すること。
行列の対称性を丸め誤差まで検定するためにall.equalがデフォルトで使用されます。  行列mは、そのrownamesとcolnamesが同じ場合にのみ対称であることに注意。  unname(m)の使用を検討すること。
と&&は論理ANDを、｜と｜｜は論理ORを示す。  短縮形は、算術演算子とほぼ同じ方法で要素間の比較を行う。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、ゼロは偽、ゼロ以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については「構文」を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
結果はrとすると、r <- x + runif(n, -a, a)ここで、n <- length(x)、aは量引数（指定された場合）である。追加される量aは、正の引数amountとして提供されるか、または以下のようにzから計算されます: amount == 0の場合、a <- factor * z/50 (Sと同じ)を設定します.amountがNULL (デフォルト)の場合、a <- factor * d/5を設定します。dは、隣接する一意な(ファズを除いた)x値間の最小の差です。
NA
NA
NA
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition 数は安価な近似によって推定される。  しかし、厳密な計算(svd経由)も十分に速い。1ノルム条件数とInfノルム条件数は、計算するのがずっと速いことに注意し、rcond()は、標準的なLAPACKルーチンを使って、複雑な行列に対してもこれらの逆条件数を計算する。kappa()とrcond()は、全く同じ機能の異なるインターフェースです。 kappa_triは、kappa.qrとkappa.defaultによって呼ばれる内部関数です。
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition 数は安価な近似によって推定される。  1-とInf-ノルム条件数は、計算するのがずっと速いことに注意し、rcond()は、標準的なLAPACKルーチンを使って、複雑な行列に対しても、これらの逆条件数を計算する。kappa()とrcond()は、全く同じ機能の異なるインターフェースです。 kappa_triは、kappa.qrとkappa.defaultによって呼ばれる内部関数です。
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition 数は安価な近似によって推定される。  1-とInf-ノルム条件数は、計算するのがずっと速いことに注意し、rcond()は、標準的なLAPACKルーチンを使って、複雑な行列に対しても、これらの逆条件数を計算する。kappa()とrcond()は、全く同じ機能の異なるインターフェースです。 kappa_triは、kappa.qrとkappa.defaultによって呼ばれる内部関数です。
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition 数は安価な近似によって推定される。  1-とInf-ノルム条件数は、計算するのがずっと速いことに注意し、rcond()は、標準的なLAPACKルーチンを使って、複雑な行列に対しても、これらの逆条件数を計算する。kappaとrcondは、全く同じ機能を持つ異なるインターフェースです。kappa_triは、kappa.qrとkappa.defaultから呼び出される内部関数です。
X と Y が同じ次元数を持たない場合、小さい方の配列はサイズ1の次元でパディングされる。  x%はクロネッカーの別名である（FUNは "*"に固定されている）。
Latin-1ロケール」には、Windowsコードページ1252のようなスーパーセット（印字可能文字用）は含まれますが、Latin-9（ISO 8859-15）は含まれません。Windowsの場合（コードページとsystem.codepageコンポーネントが追加で含まれる）、一般的なコードページは、1252（西ヨーロッパ）、1250（中央ヨーロッパ）、1251（キリル文字）、1253（ギリシャ語）、1254（トルコ語）、1255（ヘブライ語）、1256（アラビア語）、1257（バルト語）、1258（ベトナム語）、874（タイ語）、932（日本語）、936（簡体字中国語）、949（韓国語）、950（繁体字中国語）です。  コードページ28605はLatin-9で、65001はUTF-8です（サポートされている場合）。  RはCロケールを許可せず、デフォルトのコードページとして1252を使用する。
NA
NA
特異値分解は、多くの統計手法において重要な役割を果たす。svdとLa.svdは、返り値が異なる2つのインターフェイスを提供する。基礎となるLAPACKコードからうまくいかない結果は、正のエラーコード(多くの場合1)を与えるエラーとなる：これらはFORTRANコードの詳細な研究によって解釈することができるが、アルゴリズムが収束に失敗したことを意味する。
NA
NA
FUNはmatch.funの呼び出しによって見つけられ、通常、関数又はシンボル（例えば、バッククォートされた名前）として指定される、もし後者がアトミックベクトルであれば、FUNは常にXと同じ型の長さ1のベクトルを渡される。  汎用的なコードでは、...を通過させる場合、最初の2つの引数にXとFUNという名前を付けるのが良い方法である。これにより、FUNへの部分一致を避けることができ、XまたはFUNという名前の引数が...を通過した場合、賢明なエラーメッセージが表示されるようになる。  共通の長さが 1 の場合、結果はベクトルになり、1 より大きい場合は X の各要素に対応する列を持つ行列になります。  この関数は、FUNの全ての値がFUN.VALUEと互換性があり、長さと型が同じでなければならないことをチェックします(型は、logical< integer < double < complexの順序で上位の型に昇格することはできますが、降格することはできません)。S4クラスのユーザは、lapplyとvapplyにリストを渡す必要があります: 内部的な強制は、基本名前空間内のas.listによって行われ、ユーザによって定義されるものではありません(例えば、基本関数にS4methodsを設定することによって)。
lazyLoad関数はパッケージ・ローダーがデータベースからパッケージのコードをロードするために呼び出される主力関数です。  データベースは'filebase.rdb'(オブジェクト)と'filebase.rdx'(インデックス)の2つのバイナリファイルから構成されます。オブジェクト自体はenvirにロードされるのではなく、最初のアクセス時にデータベースからオブジェクトをロードする約束が作成されます(delayedAssign参照)。  (delayedAssignを参照してください。)関数lazyLoadDBexecはコア実装を含み、処理されたヘルプファイルデータをロードするメカニズムでも使用されます。
lazyLoad関数はパッケージローダがデータベースからパッケージのコードをロードするために呼び出される主力関数です。  データベースは'filebase.rdb'(オブジェクト)と'filebase.rdx'(インデックス)の2つのバイナリファイルから構成されます。オブジェクト自体はenvirにロードされるのではなく、最初のアクセス時にデータベースからオブジェクトをロードする約束が作成されます(delayedAssign参照)。  (delayedAssignを参照してください。)関数lazyLoadDBexecはコア実装を含んでおり、処理されたヘルプファイルデータをロードする機構でも使用されます。
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、実質的に[と[[ 演算子と同等です。  これは、デフォルト・メソッドをオブジェクトに適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  getRequiredPackages2は、Dependsフィールドで言及されたすべてのパッケージをアタッチします。  .getRequiredPackagesは、'DESCRIPTION'ファイルを使用した.getRequiredPackages2のラッパーです。.isMethodsDispatchOn()関数は、S4メソッドディスパッチが(通常はパッケージメソッドをロードすることによって)評価器でオンになっている場合にTRUEを返します。  sys.save.imageはq()とそのGUIアナログから呼び出されるシステム関数です。sys.load.imageはスタートアップ・コードから呼び出されます。これらの関数は直接呼び出されるべきではなく、変更される可能性があります。  .set_row_names(n)は、attr(<a data frame>, "row.names")に代入される、長さnの自動的な行名を生成します。  .row_names_infoは、データフレームの行名の内部形式に関する情報を与えます。どのような情報かについては、引数の型を参照してください。.GenericArgsEnvと.ArgsEnvは、プリミティブがクロージャであった場合の引数リストを持つクロージャを含む環境です。  内部S3ジェネリックである全てのプリミティブは.GenericArgsEnvの対応するメンバーを持っており、残りの非言語要素プリミティブは.ArgsEnvに対応しています。  詳細は'R Internals'マニュアルを参照してください。  これらはargsとprint.defaultとQC関数codocとcheckS3methodsで使用されます。.findPackageEnvはunserializeコードで呼び出され、可能であれば保存された環境を設定します。.TAOCP1997initは "Knuth-TAOCP "RNGの初期化コードです。.gtと.gtnはrankとisからのコールバックです。.primTraceと.primUntraceは、それぞれtraceとuntraceの基礎となるプリミティブ関数です。.Date、.POSIXct、.POSIXlt、.difftimeは、クラスジェネレーターです。.cache_classは、S3メソッドディスパッチで使用するために、S4クラスの継承をキャッシュします。  .popathは起動時に生成される変数で、使用中の翻訳パッケージがどこにあるかを記録します。.detachは、他のRパッケージで使用するためのdetachの「ベアボーン」バージョンです。.maskedMsgは、警告メッセージを生成するために、attach()とlibrary()の両方から呼び出されるユーティリティです。.C_および.F_で始まるオブジェクトは、登録されたCおよびFortranエントリ・ポイントへの参照です。Windowsのみ:.fixupGFortranStdoutおよび.fixupGFortranStderrは、systemおよびsystem2経由で外部コードを実行する際に、gfortranの標準出力および標準エラー・ユニットを有効にするヘルパー関数です。デフォルトでは、これらのユニットは、RGui内部で実行されている場合、Windowsプロファイルによって無効になっています。
正式な定義は、integral_0^1 t^(a-1) (1-t)^(b-1) dt(AbramowitzとStegunの6.2.1節、258ページ)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lgamma関数、digamma関数、trigamma関数は内部ジェネリック・プリミティブ関数です：メソッドは個別に定義することもできますし、Mathグループのジェネリック関数を使用して定義することもできます。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lγ関数、digamma関数、trigamma関数は内部ジェネリック・プリミティブ関数です：メソッドは個別に定義することもできますし、Mathグループジェネリックを介して定義することもできます。
length<-には "factor "メソッドがあります。この置換形式はベクトルの長さをリセットするために使用できます。  ベクトルが短くなると、余分な値は捨てられ、ベクトルが長くなると、新しい長さにNA（生のベクトルではnul）でパディングされます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
length<-には "factor "メソッドがあり、この置換形式はベクトルの長さをリセットするのに使うことができる。  ベクトルが短くなると、余分な値は捨てられ、ベクトルが長くなると、新しい長さにNA（生のベクトルではnul）でパディングされます。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  端数日は印刷時に無視されます。  methods(クラス = "Date")を参照してください。多くのメソッドの中から、いくつかのメソッドについては個別にドキュメント化されています。
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
length<-には "factor "メソッドがあります。この置換形式はベクトルの長さをリセットするために使用できます。  ベクトルが短くなると、余分な値は捨てられ、ベクトルが長くなると、新しい長さにNA（生のベクトルではnul）でパディングされます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからの秒単位のオフセット。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
この関数はxをループし、xの各要素の長さを含む互換性のあるベクトルを返す。事実上、length(x[[i]])はすべてのiに対して呼び出されるので、lengthに関するメソッドはすべて考慮される。
LETTERS：ローマ字の大文字26文字、letters：ローマ字の小文字26文字、month.abb：英語の月名の3文字の省略形、month.name：1年の月の英語名、π：円の円周と直径の比。
LETTERS：ローマ字の大文字26文字、letters：ローマ字の小文字26文字、month.abb：英語の月名の3文字の省略形、month.name：年の月の英語名、π：円の円周とその直径の比。
抽出形式も置換形式も汎用的であり、新しいメソッドを書くことができます。  因子の置換メソッドでは、valueにNAを指定すると、そのレベルはレベルから削除され、そのレベルを持つ要素はNAで置換されます。因子の場合、レベルvialevels(x) <- valueを置換することは、attr(x, "levels") <- valueと同じではありません（そして、attr(x, "levels") <- valueの方が好ましい）。
抽出と置換の両形式は汎用的であり、新しいメソッドを書くことができる。  因子の置換メソッドでは、valueにNAを指定すると、そのレベルはレベルから削除され、そのレベルを持つ要素はNAで置き換えられます。因子の場合、レベルvialevels(x) <- valueを置き換えることは、attr(x, "levels") <- valueと同じではありません(そして、attr(x, "levels") <- valueの方が好ましい)。
抽出と置換の両形式は汎用的であり、新しいメソッドを書くことができる。  因子の置換メソッドでは、valueにNAを指定すると、そのレベルはレベルから削除され、そのレベルを持つ要素はNAで置き換えられます。因子の場合、レベルvialevels(x) <- valueを置き換えることは、attr(x, "levels") <- valueと同じではありません(そして、attr(x, "levels") <- valueの方が好ましい)。
抽出と置換の両形式は汎用的であり、新しいメソッドを書くことができる。  因子の置換メソッドでは、valueにNAを指定すると、そのレベルはレベルから取り除かれ、そのレベルを持つ要素はNAで置き換えられます。因子の場合、レベルを置き換えるvialevels(x) <- valueは、attr(x, "levels") <- valueと同じではありません(そして、attr(x, "levels") <- valueよりも優先されます)。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lgamma関数、digamma関数、trigamma関数は、内部ジェネリックプリミティブ関数です：メソッドは、個別に定義することも、Mathグループジェネリックを介して定義することもできます。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lγ関数、digamma関数、trigamm関数は、内部ジェネリック・プリミティブ関数です：メソッドは、個別に定義することも、Mathグループジェネリックを介して定義することもできます。
NA
library(package)とrequire(package)はどちらもpackageという名前のパッケージの名前空間をロードし、これらのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合は（デフォルトのlibrary()のようにエラーではなく）FALSEを返し、警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locのデフォルト値(NULL)とともに使用すると、ライブラリよりも先に付属パッケージが検索されます。
これらの関数が扱うオブジェクトの種類については、dyn.loadを参照してください。library.dynamは、コマンドラインではなくパッケージ内部で使用するように設計されています。  library.dynam.unloadは、.onUnloadで使用するように設計されています。これは、DLLをアンロードし、.dynLibs()の値を更新します。dynLibsは、(library.dynamを使用して)パッケージによって現在ロードされているDLLを(引数なしで)取得または設定するために使用されます。
これらの関数が扱うオブジェクトの種類については、dyn.loadを参照してください。library.dynamは、コマンドラインではなくパッケージ内部で使用するように設計されており、実際には.onLoad内部でのみ使用する必要があります。  library.dynam.unloadは、.onUnloadで使用するように設計されています。これは、DLLをアンロードし、.dynLibs()の値を更新します。dynLibsは、(library.dynamを使用して)パッケージによって現在ロードされているDLLの取得(引数なし)または設定に使用されます。
Rは、GNU GENERAL PUBLIC LICENSE（バージョン2、1991年6月またはバージョン3、2007年6月）の条項に従って配布されています。  バージョン2のライセンスのコピーは'R_HOME/doc/COPYING'ファイルにあり、RShowDoc("COPYING")で見ることができます。  バージョン3のライセンスはRShowDoc("GPL-3")で表示できます。少数のファイル(APIヘッダーファイルの一部)はLESSER GNU GENERAL PUBLIC LICENSE、バージョン2.1以降で配布されています。  このライセンスのコピーは'$R_SHARE_DIR/licenses/LGPL-2.1'にあり、RShowDoc("LGPL-2.1")で見ることができます。  バージョン3のライセンスはRShowDoc("LGPL-3")で表示できます。
RはGNU GENERAL PUBLIC LICENSE第2版（1991年6月）または第3版（2007年6月）の条件で配布されています。  バージョン2のライセンスのコピーは 'R_HOME/doc/COPYING' ファイルにあり、RShowDoc("COPYING") で見ることができます。  バージョン3のライセンスはRShowDoc("GPL-3")で表示できます。少数のファイル(APIヘッダーファイルの一部)はLESSER GNU GENERAL PUBLIC LICENSE、バージョン2.1以降で配布されています。  このライセンスのコピーは'$R_SHARE_DIR/licenses/LGPL-2.1'にあり、RShowDoc("LGPL-2.1")で見ることができます。  バージョン3のライセンスはRShowDoc("LGPL-3")で表示できます。
LISPのような伝統的なドット付きペア・リストも利用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として利用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
NA
NA
すべてのリスト要素は（同じ長さに複製される可能性を除けば）「そのまま」取られることに注意。
環境は一意に命名されたエントリを持つ必要がありますが、命名されたリストはその必要はありません：リストに重複した名前がある場合、その名前を持つ最後の要素が使用されます。  名前が空だとエラーになります。
loadは、現在または以前のフォーマットで保存されたRオブジェクトをロードすることができます。  圧縮ファイル(saveを参照)をファイルから直接読み込むことも、適切な接続(urlへの呼び出しを含む)から読み込むこともできる。  gzfile orgzcon接続以外の接続は、圧縮保存を扱えるようにgzconでラップされます: この場合、接続は変更された状態(特にバイナリのみ)になり、明示的に閉じる必要があることに注意してください(ガベージは収集されません).現在のフォーマット(R 1.4.0から使用)で保存されたRオブジェクトのみが、接続から読み込むことができます。  マジックナンバー1971:1977はR <0.99.0のもので、RD[ABX]1はR 0.99.0からR 1.3.1のものです。  verbose引数は主にデバッグ用です。  これが TRUE の場合、ファイルからオブジェクトがロードされると、その名前がコンソールに表示される。  verboseを1以上の整数値に設定すると、個々のオブジェクトの属性やその他の部分に対応する名前も表示されます。  そのようなオブジェクトは、名前空間が利用できない場合でもロードすることができます。  警告は、そのような参照を持つ最初のオブジェクトを識別します（ただし、複数存在する可能性もあります）。
関数loadNamespaceとattachNamespaceは、通常、libraryを使用して名前空間と必要なインポートをロードするときに暗黙的に呼び出されます。  loadNamespaceは、指定された名前空間をロードし、内部データベースに登録します。  指定された名前空間がすでにロードされているときに、その名前空間をロードするように要求しても、何の効果もありません。  引数は、libraryへの対応する引数と同じ意味を持っています。libraryのヘルプ・ページでは、特定のインストール済みパッケージがどのように選択されるかの詳細が説明されています。  ロード後、loadNamespaceは.onLoadという名前のフック関数を名前空間の内部変数として探します（これはエクスポートされるべきではありません）。  loadNamespaceは読み込んだ名前空間を検索パスにアタッチしません。attachNamespaceを使用すると、名前空間のエクスポートされた値を含むフレームを検索パスにアタッチできます（ただし、これはほとんどの場合ライブラリ経由で実行されます）。  isNamespaceLoaded(pkg)はpkg %in%loadedNamespaces()と同等ですが、pkg %in%loadedNamespaces()よりも効率的です。unloadNamespaceを使用すると、名前空間を強制的にアンロードすることができます。  名前空間がアタッチされている場合、最初にその名前空間がデタッチされ、それによって、名前空間に.onDetach関数または.Last.lib関数がエクスポートされている場合はその関数が実行されます。  名前空間が他のロードされた名前空間によってインポートされた場合、エラーがシグナルされ、名前空間はアンロードされない。  定義されている場合、内部レジストリから名前空間を削除する前にフック関数.onUnloadが実行されます。名前空間のアンロードと再ロードに関するいくつかの問題については、detachのヘルプのコメントを参照してください。
packageHasNamespaceは、パッケージが名前空間を持っているかどうかを示すものではありません（現在ではすべてそうなっています）。  しかし、そのような使い方は想定されていません。
loadNamespace関数とattachNamespace関数は通常、libraryを使用してネームスペースと必要なインポートをロードするときに暗黙的に呼び出されます。  loadNamespaceは指定された名前空間をロードし、内部データベースに登録します。  指定された名前空間がすでにロードされているときに、その名前空間をロードするように要求しても、何の効果もありません。  引数は、libraryへの対応する引数と同じ意味を持っています。libraryのヘルプ・ページでは、特定のインストール済みパッケージがどのように選択されるかの詳細が説明されています。  ロード後、loadNamespaceは.onLoadという名前のフック関数を名前空間の内部変数として探します（これはエクスポートされるべきではありません）。  loadNamespaceは読み込んだ名前空間を検索パスにアタッチしません。attachNamespaceを使用すると、名前空間のエクスポートされた値を含むフレームを検索パスにアタッチできます（ただし、これはほとんどの場合ライブラリ経由で実行されます）。  isNamespaceLoaded(pkg)はpkg %in%loadedNamespaces()と同等ですが、pkg %in%loadedNamespaces()よりも効率的です。unloadNamespaceを使用すると、名前空間を強制的にアンロードすることができます。  名前空間がアタッチされている場合、最初にその名前空間がデタッチされ、それによって、名前空間に.onDetach関数または.Last.lib関数がエクスポートされている場合はその関数が実行されます。  名前空間が他のロードされた名前空間によってインポートされた場合、エラーがシグナルされ、名前空間はアンロードされない。  定義されている場合、内部レジストリから名前空間を削除する前にフック関数.onUnloadが実行されます。名前空間のアンロードと再ロードに関するいくつかの問題については、detachのヘルプのコメントを参照してください。
envirが指定されていない場合、デフォルトはparent.frame()(evalへの呼び出しが行われた環境)です。評価されるオブジェクトは、call orexpressionまたはname型(nameが現在のスコープで検索され、そのバインディングが評価される場合)、promise型、またはvector、function、environment(変更されずに返される)などの基本的な型のいずれかになります。evalq形式はeval(quote(expr), ...)と等価です。evalは最初の引数を現在のスコープで評価してから評価器に渡します。evalqはこれを回避します。eval.parent(expr, n)はval(expr, parent.frame(n))の省略形です。envirがリスト（データフレームなど）またはペアリストの場合、一時的な環境にコピーされ（囲み付き）、一時的な環境が評価に使用されます。  envirがNULLの場合、空リストとして解釈され、envirに値が見つからず、ルックアップは直接enclosに行きます。  evalqと同等であるが、デフォルトの引数は空の環境を新たに生成する。  これは、無名再帰関数を作成したり、環境内で定義された変数は外部からは見えないので、一種の限定名前空間機能として便利です。
環境をロックすることで、環境からの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時には保持されませんが、.onLoadで作成することができます。
環境をロックすることで、環境からの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時に保存されませんが、.onLoadで作成することができます。
log10とlog2は便利なラッパーに過ぎませんが、OSでサポートされている場合、10進数と2進数のlogは（logで計算してもラッパーで計算しても）より効率的かつ正確に計算されます。logbは、Sとの互換性のためにlogのラッパーです。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされます。
log10とlog2は便利なラッパーに過ぎませんが、OSでサポートされている場合、10進数と2進数のlogは（logまたはラッパーのどちらで計算しても）より効率的かつ正確に計算されます。logbは、Sとの互換性のためにlogのラッパーです。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされます。
log10とlog2は便利なラッパーに過ぎませんが、OSでサポートされている場合、10進数と2進数のlogは（logまたはラッパーのどちらで計算しても）より効率的かつ正確に計算されます。logbは、Sとの互換性のためにlogのラッパーです。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされます。
log10とlog2は便利なラッパーに過ぎませんが、OSでサポートされている場合、10進数と2進数のlogは（logまたはラッパーのどちらで計算しても）より効率的かつ正確に計算されます。logbは、Sとの互換性のためにlogのラッパーです。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされます。
log10とlog2は便利なラッパーに過ぎませんが、OSでサポートされている場合、10進数と2進数のlogは（logまたはラッパーのどちらで計算しても）より効率的かつ正確に計算されます。logbは、Sとの互換性のためにlogのラッパーである。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされる。
TRUEとFALSEはR言語の論理定数を示す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  論理ベクトルは、数値が必要なコンテキストでは整数ベクトルに強制され、TRUEは1Lに、FALSEは0Lに、NAはNA_integer_にマッピングされる。
NA
name引数では、オブジェクト名が取得される環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または明示的な環境（現在アクティブな関数呼び出しにアクセスするためのingsys.frameの使用を含む）のいずれかの形式で指定できます。デフォルトでは、lsまたはobjectsの呼び出し時の環境が使用されます。sorted=TRUEの場合の文字列の順序はロケールに依存することに注意してください。  sorted = FALSEの場合の文字列の順序は、環境がハッシュ化されているかどうかや、オブジェクトの挿入順序などに応じて任意です。
構文上有効な名前は、文字、数字、ドットまたは下線文字で構成され、文字またはドットで始まり、その後に数字が続かないものです。  文字の定義は現在のロケールに依存するが、数字とみなされるのはASCII数字のみである。  欠損値は "NA "に変換される。  Rキーワードに一致する名前には、ドットが付加される。  重複する値はmake.uniqueによって変更される。
make.uniqueが使用するアルゴリズムは、make.unique(c(A, B)) == make.unique(c(make.unique(A), B))という特性を持っています。言い換えれば、ベクトルに一度に1つの文字列を追加し、そのたびに一意にすることができます。
関数lockEnvironmentは、そのenvironment引数をロックします。environmentをロックすることで、environmentからの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時に保存されませんが、.onLoadで作成することができます。
initが与えられると、Reduceは論理的にそれをxの開始点（左から右に進む場合）または終了点にそれぞれ追加する。この拡張される可能性のあるベクトルvがn > 1個の要素を持つ場合、Reduceはvの要素に左から右、または右から左にそれぞれfを連続して適用する。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  現在の実装は、安定性とスケーラビリティを確保するために非再帰的である。  duceはfold（Haskellなど）やaccumulate（C++標準テンプレート・ライブラリなど）としても知られている。  Filterは単項述語関数fをxの要素に適用し、必要であれば論理に強制し、これが真を返すxの部分集合を返します。  可能性のあるNA値は、現在のところ常に偽とみなされることに注意してください。  FindとPositionはそれぞれCommon Lispのfind-ifとposition-ifに倣ったものです。  述語関数がtrueを与える要素がある場合、rightがfalse（デフォルト）かtrueかによって、そのような要素の最初か最後、またはその位置がそれぞれ返されます。  そのような要素がない場合は、nomatchで指定された値が返されます。  Mapはmapplyの単純なラッパーであり、結果を単純化するようなことはしていません。  NegateはCommon Lispの補語に相当する。  (述語)関数fが与えられると、fが返す関数の論理否定を返す関数を作成する。
mapplyは、...の値（長さが0でない限り、最も長い値の長さに再循環される）に対してFUNを呼び出し、その後にMoreArgsで与えられた引数を続ける。  呼び出しの中の引数は、...またはMoreArgsに名前がつけられている場合、名前がつけられる。...の引数（またはドットの構成要素）については、クラス特有のサブセット（[]など）と長さメソッドが、適用可能な場合に使用される。
NA
NA
NA
in%は現在"%in%"として定義されています。" <- function(x, table) match(x, table, nomatch = 0) > 0因子、生のベクトル、リストは文字ベクトルに変換され、xとtableはマッチングの前に共通の型(Rの順序では、論理 < 整数 < 数値 < 複素数 < 文字のうち遅い方)に強制されます。  すべての型に対して、NAはNAにマッチし、それ以外の値にはマッチしません。実数と複素数の値に対して、NaN値は他のNaN値にはマッチしますが、NAにはマッチしないとみなされます。文字列は、入力が "bytes "とマークされている場合はバイト列として比較され、そうでない場合は、エンコーディングが異なっていてもUTF-8に変換すれば一致する場合は等しいとみなされる（エンコーディングを参照）。
1引数形式のmatch.arg(arg)では、選択肢はmatch.argが呼び出された関数の形式引数argのデフォルト設定から得られます。  (デフォルトの引数マッチングはargを選択肢に設定するので、これは'several.okがTRUEでない限り長さは1'という規則の例外として許可され、最初の要素を返します。)マッチングはpmatchを使って行われるので、argは省略することができます。
match.callはプリミティブ関数(引数のマッチングは通常位置指定)をサポートしていません。match.callは2つの状況で最もよく使われます：後で再利用するために呼び出しを記録する：例えば、ほとんどのモデルフィッティング関数は、返すリストの要素呼び出しとして呼び出しを記録します。  ここではデフォルトのexpand.dots = TRUEが適切です。呼び出しの大部分を別の関数（多くの場合model.frame）に渡す。  ここでは、expand.dots = FALSEが使用され、マッチした呼び出しの ... 要素が削除されるのが一般的なイディオムです。  別の方法としては、lmで行われているように、渡される引数を明示的に選択することです。関数外で定義を指定せずにmatch.callを呼び出すとエラーになります。
FUNが関数の場合、それが返されます。  FUNが関数の場合、それが返されます。FUNがシンボル（例えば、バッククォートで囲まれたもの）または長さ1の文字ベクトルの場合、呼び出し元の親の環境でgetを使用して検索されます。  descend=TRUEの場合、match.funは与えられた名前を持つ非関数オブジェクトを過去に探します。
S3メソッドを書くことができる4つのグループ、すなわち "Math"、"Ops"、"Summary"、"Complex "グループがあります。  これらはベースRのRオブジェクトではないが、メソッドを提供することができ、ベースRは最初の3つのグループのためのfactor、data.frame、difftimeメソッドを含んでいる。  (Opsのorderedメソッド、MathとOpsのPOSIXtメソッドとDateメソッド、OpsとSummaryのpackage_versionメソッド、statsパッケージのOpsのtsメソッドもあります)。グループ "Math":abs、sign、sqrt、floor、ceiling、trunc、round、signifexp、log、expm1、log1p、cos、sin、tan、cospi、sinpi、tanpi、acos、asin、atancosh、sinh、tanh、acosh、asinh、atanhlgamma、gamma、digamma、trigammacumsum、cumprod、cummax、cumminこのグループのメンバはxに対してディスパッチします。  ほとんどのメンバは1つの引数しか受け付けないが、log、round、signifは1つまたは2つの引数を受け付け、truncは1つ以上の引数を受け付ける。グループ "Ops": "+", "-", "*", "/", "^", "%%", "%/%""&", "|", "!""==", "!=", "<", "<=", ">=", ">"このグループには、二項演算子と単項演算子（+, -, ！)：単項演算子に遭遇すると、Opsメソッドが1つの引数で呼び出され、e2が欠落します。このグループの任意のメンバーをディスパッチする際に、両方の引数のクラスが考慮されます。  各引数のクラスのベクトルは、一致する特定の（優先される）またはOpsメソッドがあるかどうかを確認するために検査されます。  異なるメソッドが見つかった場合、'互換性のないメソッド'についての警告が表示されます。比較演算子("Compare": ==, <, ...)および論理演算子("Logic": & | and !) のための data.frame メソッドは、利便性とバックコンパチビリティのために、データフレームの代わりに論理行列を返します。このグループのメンバが関数として呼び出される場合、位置マッチングが常に使用されるように、引数名は削除されます。グループ "Summary":all、anysum、prodmin、maxrangeこのグループのメンバは、最初に与えられた引数に対してディスパッチされる、fulfillingグループ "Complex":Arg, Conj, Im, Mod, Reこのグループのメンバーは、zにディスパッチする。内部コードはoldClassにディスパッチし、onclassにはディスパッチしないので、メソッドは、"class "属性に対応する場合のみ、これらのグループの1つまたはそのメンバーの1つに使用されることに注意。  Math "グループ・ジェネリック・メソッドのプリミティブ・メンバのために提供された引数の数は、ディスパッチする前にチェックされません。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。多くのメソッドの中から、いくつかのメソッドについては個別にドキュメント化されています。
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。R 4.1.0以降では、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、レベルが要素のレベル集合に出現する順序で、要素のレベル集合の和を持つ因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとします。  もしどちらも与えられない場合、1列の行列が返される。もし行列を埋めるにはデータの要素が少なすぎる場合、データの要素は再利用される。  データの長さが0の場合，アトミックベクトルの場合は適切な型のNA（生のベクトルの場合は0）が使用され，リストの場合はNULLが使用されます．is.matrixは，xがベクトルで長さ2の "dim "属性を持つ場合にTRUEを返し，そうでない場合はFALSEを返します．  この関数は汎用の関数です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。  データフレーム用のメソッドは、atomic列と(numeric/logical/complex)以外の列しかない場合は文字行列を返し、それ以外の文字列にはas.vectortを適用して因子と書式を指定します、as.matrixのデフォルトメソッドはas.vector(x)を呼び出すので、例えば因子を文字ベクトルに強制します。is.matrixはプリミティブな関数です。行列のprintメソッドは、各要素の名前またはインデックスを矩形にレイアウトします。  リスト行列の場合，長さが1でないエントリは，型と長さを示す integer,7 の形式で出力される．
na.rmがFALSEの場合、引数のいずれかにNAの値があればNAの値が返され、そうでなければNAの値は無視されます。数値の空集合の最小値と最大値は、+InfとInf（この順序で！）であり、これは他律性を保証します、min(x1, min(x2)) == min(x1, x2)。  数値xmax(x) == -Inf、min(x) == +Infは、length(x) == 0のとき（要求があれば欠損値を取り除いた後）。  pmaxとpminは1つ以上のベクトル(または行列)を引数として取り,そのベクトルの'並列'最大値(または最小値)を1つのベクトルとして返します.結果の最初の要素は'並列'最大値(または最小値)です.  結果の第1要素はすべての引数の第1要素の最大値（最小値）であり、結果の第2要素はすべての引数の第2要素の最大値（最小値）である。  より短い入力（0以外の長さ）は、必要に応じて再利用される。  pmax.intとpmin.intは、全ての引数が原子ベクトルであり、クラスが存在しない場合にのみ使用される、より高速な内部バージョンです: これらは全ての属性を削除します(生ベクトルや複雑なベクトルでは順序付けがないため、全てのバージョンは失敗することに注意してください)。  定義では、NaNを含む数値ベクトルの最小/最大はNaNであるが、NaNを含むベクトルの最小/最大はNaNである。文字バージョンは辞書順にソートされるが、これは使用するロケールの照合順序に依存する。  空の文字ベクトルの最大/最小は、文字NAと定義される。  (「"」が最小の文字要素であるため、最大値は「"」であるべきだという議論もありうるが、最小値の候補は明らかでない)。
ties.method="random "の場合、デフォルトのように、同点はランダムに解消される。  ties.method="first "の場合、max.colは、各行における複数の最大値の最初の列番号を返します。
NA
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、その暦が使用されていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。また、いくつかのメソッドについては個別にドキュメント化されています。
NA
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループメソッドは、このクラスのオブジェクトに対して、round、 signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがある。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、1970年（UTCタイムゾーン）の始まりからの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからの秒単位のオフセット。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が間違っている場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
Infのサイズを指定すると、リミットがそのプラットフォームで可能な最大値に設定されます。デフォルトの最大値はほとんどのプラットフォームで無制限ですが、メモリで説明したように環境変数を使って調整することができます。macOSでは、macOSがメモリをオーバーコミットしたときにRプロセスが強制終了しないように、デフォルトのベクトル・ヒープ制限を低くしています。ベクトル・ヒープ・サイズの上限を調整することは、特にmacOSで有用ですが、注意して行ってください。
Infのサイズを指定すると、制限値がそのプラットフォームで可能な最大値に設定されます。デフォルトの最大値はほとんどのプラットフォームで無制限ですが、「メモリ」で説明するように環境変数を使用して調整できます。macOSでは、macOSがメモリをオーバーコミットしたときにRプロセスが強制終了しないように、デフォルトのベクトル・ヒープ制限を低くしています。ベクトル・ヒープ・サイズの上限を調整することは、特にmacOSで有用ですが、注意して行ってください。
type = "unknown "は、(もしあれば)適用されている圧縮のタイプを検出しようとする。  これは、gzip プログラムによって (そして gzfile によって書かれたファイルに対して) ファイルに追加される 'magic' ヘッダ ("\x1fx8b") を自動検出するが、 memCompress はそのようなヘッダを追加しない。(gzip は圧縮と展開のために RFC 1950 フォーマット (時には 'zlib' フォーマットとして知られる) をサポートし、 展開のためだけに RFC1952 をサポートする。) gzip 圧縮は基底ライブラリのデフォルトの圧縮レベル (通常は 6) を使用する。  基底ライブラリは、2^31 - 1 要素までのメモリ内 (de) 圧縮のみをサポートする。  type = "xz" での圧縮は、 xz -9e (マジックヘッダの追加を含む) での圧縮と等価である。  gzip" と "bzip2" については、最大拡張は既知であり、somemCompress は常に十分な領域を確保できる。  xz" では、出力が大きすぎる場合に圧縮に失敗する可能性がある (しかし、その可能性は極めて低い)。
type = "unknown" は、 (もしあれば) 適用された圧縮の種類を検出しようとする: これは bzip2compression では常に成功し、 適切なヘッダがあれば他の形式でも成功する。  これは、gzip プログラムによって (そして gzfile によって書かれたファイルに対して) ファイルに追加される 'magic' ヘッダ ("\x1fx8b") を自動検出するが、 memCompress はそのようなヘッダを追加しない。(gzip は圧縮と展開のために RFC 1950 フォーマット (時には 'zlib' フォーマットとして知られる) をサポートし、 展開のためだけに RFC1952 をサポートする。) gzip 圧縮は基底ライブラリのデフォルトの圧縮レベル (通常は 6) を使用する。  基底ライブラリは、2^31 - 1 要素までのメモリ内 (de) 圧縮のみをサポートする。  type = "xz" での圧縮は、 xz -9e (マジックヘッダの追加を含む) での圧縮と等価である。  gzip" と "bzip2" については、最大拡張は既知であり、somemCompress は常に十分な領域を確保できる。  xz" では、出力が大きすぎる場合に圧縮に失敗する可能性がある (しかし、その可能性は極めて低い)。
現在の型とその用途は、インクルード・ファイル'Rinternals.h'にリストされている。
デフォルトのメソッドでは、データフレームに引数を強制し、"data.frame "メソッドを呼び出します。デフォルトでは、データフレームは両者が持つ名前の列でマージされますが、by.xとby.yで列を別々に指定することもできます。  一致する行が複数ある場合は、一致する可能性のあるすべての行が1つの行に寄与する。  マージの対象となる列は、名前、数値、または論理ベクトルで指定することができる。"row.names "という名前、または "0 "という数値で行名を指定する。  byまたはby.xとby.yの両方が長さ0（長さ0のベクトルまたはNULL）の場合、結果のrはxとyのカルテシア積、つまりall.xが真の場合、xのマッチしないケースは全て結果に追加され、yの対応する列にはNAが埋められます。  by.xカラム名がyカラム名の1つと一致し、no.dupsが（デフォルトで）真である場合、yバージョンにも接尾辞が付けられ、結果内のカラム名の重複を回避します。SQLデータベース用語では、デフォルト値のall = FALSEは自然結合（innerjoinの特殊なケース）を与えます。all.x = TRUEを指定すると左（外側）結合、all.y = TRUEを指定すると右（外側）結合、both(all = TRUE)を指定すると（完全な）外側結合になります。  DBMSはNULLレコードにマッチしません。Rではincomparables = NAに相当します。
mergeはデータフレームを主な対象とする汎用関数です。デフォルトのメソッドは、引数をデータフレームに強制し、"data.frame "メソッドを呼び出します。デフォルトでは、データフレームは両者が持つ名前の列でマージされますが、by.xとby.yで列を個別に指定することができます。  一致する行が複数ある場合は、一致する可能性のあるすべての行が1つの行に寄与する。  マージの対象となる列は、名前、数値、または論理ベクトルで指定することができる。"row.names "という名前、または "0 "という数値で行名を指定する。  byまたはby.xとby.yの両方が長さ0（長さ0のベクトルまたはNULL）である場合、結果のrはxとyのカルテシアン積になります、all.xが真の場合、xのマッチしないケースは全て結果に追加され、yの対応する列にはNAが埋められます。  by.xカラム名がyカラム名の1つと一致し、no.dupsが（デフォルトで）真である場合、yバージョンにも接尾辞が付けられ、結果内のカラム名の重複を回避します。SQLデータベース用語では、デフォルト値のall = FALSEは自然結合（innerjoinの特殊なケース）を与えます。all.x = TRUEを指定すると左（外側）結合、all.y = TRUEを指定すると右（外側）結合、both(all = TRUE)を指定すると（完全な）外側結合になります。  DBMSはNULLレコードにマッチしません。Rではincomparables = NAに相当します。
mergeはデータフレームを主な対象とする汎用関数です。デフォルトのメソッドは、引数をデータフレームに強制し、"data.frame "メソッドを呼び出します。デフォルトでは、データフレームは両者が持つ名前の列でマージされますが、by.xとby.yで列を個別に指定することができます。  一致する行が複数ある場合は、一致する可能性のあるすべての行が1つの行に寄与する。  マージの対象となる列は、名前、数値、または論理ベクトルで指定することができる。"row.names "という名前、または "0 "という数値で行名を指定する。  byまたはby.xとby.yの両方が長さ0（長さ0のベクトルまたはNULL）である場合、結果のrはxとyのカルテシアン積になります、all.xが真の場合、xのマッチしないケースはすべて結果に追加され、yの対応する列はNAで塗りつぶされる。  もしby.xの列名がyの列名の1つと一致し、no.dupsが（デフォルトで）真であれば、yのバージョンにも接尾辞が付加され、結果の列名の重複を避けることができます。SQLデータベース用語では、デフォルト値のall = FALSEは自然結合（innerjoinの特殊なケース）を意味します。all.x = TRUEを指定すると左（外側）結合、all.y = TRUEを指定すると右（外側）結合、both(all = TRUE)を指定すると（完全な）外側結合になります。  DBMSはNULLレコードにマッチしません。Rのincomparables = NAに相当します。
messageは、警告でもエラーでもない「単純な」診断メッセージを生成するために使用されます。  デフォルトのハンドラは、メッセージをstderr()接続に送ります。messageに条件オブジェクトを与える場合、引数はそれだけであるべきで、それ以上の引数は無視され、警告が表示されます。packageStartupMessageはその変種で、suppressPackageStartupMessagesによって個別にメッセージを抑制することができます。  (makeMessageはmessage、warning、stopで使用されるユーティリティで、...引数からテキストメッセージを生成し、可能な翻訳(gettextを参照)と連結(セパレータなし)を行います。）
pos 引数は、オブジェクトを探す環境をいくつかの方法で指定することができます: 正の整数 (検索リスト内の位置)、検索リスト内の要素の文字列名、または、環境 (現在アクティブな関数呼び出しにアクセスするために sys.framet を使用することを含む)。  デフォルトの-1は、toget呼び出しの現在の環境を示す。envir引数は、環境を指定する別の方法です。これらの関数は、指定された環境において、それぞれの名前xに値が束縛されているかどうかを調べます。  inheritsがTRUEであり、指定された環境内でxに値が見つからない場合、xという名前に出会うまでその環境を囲むフレームが検索されます。  modeが指定された場合、その型のオブジェクトのみが探索されます。ここでのmodeは、typeofとmodeの意味が混在しています：「mgetの場合、modeとifnotfoundの値は、xと同じ長さか、長さ1でなければならない。  引数ifnotfoundは、要求された項目が見つからなかった場合に使用する値か、項目が見つからなかった場合に呼び出される引数1つの関数を含むリストでなければならない。  dynGet()はやや実験的なもので、他の関数の内部で使用されます。これは、呼び出し側、つまり関数のsys.frame()内でオブジェクトを探します。  注意して使用してください。
na.rmがFALSEの場合、引数のいずれかにNAの値があるとNAの値が返され、そうでない場合はNAの値は無視されます、min(x1, min(x2)) == min(x1, x2)。  数値xmax(x) == -Inf、min(x) == +Infは、length(x) == 0のとき（必要であれば欠損値を取り除いた後）です。  pmaxとpminは1つ以上のベクトル(または行列)を引数として取り,そのベクトルの'並列'最大値(または最小値)を1つのベクトルとして返します.結果の最初の要素は'並列'最大値(または最小値)です.  結果の第1要素はすべての引数の第1要素の最大値（最小値）であり、結果の第2要素はすべての引数の第2要素の最大値（最小値）である。  より短い入力（0以外の長さ）は、必要に応じて再利用される。  pmax.intとpmin.intは、全ての引数が原子ベクトルであり、クラスが存在しない場合にのみ使用される、より高速な内部バージョンです: これらは全ての属性を削除します(生ベクトルや複雑なベクトルでは順序付けがないため、全てのバージョンは失敗することに注意してください)。  定義では、NaNを含む数値ベクトルの最小/最大はNaNであるが、NaNを含むベクトルの最小/最大はNaNである。文字バージョンは辞書順にソートされるが、これは使用するロケールの照合順序に依存する。  空の文字ベクトルの最大/最小は、文字NAと定義される。  (「"」が最小の文字要素であるため、最大値は「"」であるべきだという議論もありうるが、最小値の明らかな候補はない)。
特に、x <- match.arg(x)の後は常に偽になります。この例では、プロットする点のx座標とy座標を与える2つのベクトル、またはそれらのインデックスに対してプロットするy値を与える1つのベクトルのどちらでも動作するように、プロット関数を書く方法を示しています。現在のところ、missingは引数を定義する関数の本体でのみ使用でき、入れ子関数やローカルコールの本体では使用できません。  これは将来変更される可能性があります。これは「特別な」プリミティブ関数であり、引数を評価してはなりません。
複素数ベクトルはcomplexで作成できます。  ベクトルは、その長さ、実部と虚部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、つまり実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られませんが、実数部または虚数部がNaNの複素数は得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義され、solve, eigen, svdも定義されている。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。 NA_complex_と上記を参照)、またはプラスマイナス無限大になる。
modeとstorage.modeはどちらも、オブジェクトの（格納）モードを文字列で返す - 多くの場合、同じである - typeof(x)の出力に依存する。  これは、適切なas.newmode関数、例えば "logical"、"integer"、"double"、"complex"、"raw"、"character"、"list"、"expression"、"name"、"symbol"、"function "が存在する場合にのみサポートされます。  storage.mode(x)<-"newmode "はmode<-のより効率的なプリミティブバージョンで、内部型（typeofを参照）の一つである "newmode "では機能するが、"single "では機能しない。  ストレージモード "single "はRの擬似モードに過ぎないので、modeやstorage.mode: useattr(object, "Csingle")では報告されない。  しかし、mode<-を使用してモードを "single "に設定することができ、これは実際のモードを "double "に設定し、"Csingle "属性をTRUEに設定します。  他のモードを設定すると、この属性は削除される。（以下の例では）いくつかの呼び出しは、S互換であるmode"("を持つことに注意。
modeとstorage.modeはどちらも、オブジェクトの（ストレージ）モードを文字列で返す。  これは、適切なas.newmode関数、例えば "logical"、"integer"、"double"、"complex"、"raw"、"character"、"list"、"expression"、"name"、"symbol"、"function "が存在する場合にのみサポートされます。  storage.mode(x)<-"newmode "はmode<-のより効率的なプリミティブバージョンで、内部型（typeofを参照）の一つである "newmode "では機能するが、"single "では機能しない。  ストレージモード "single "はRの擬似モードに過ぎないので、modeやstorage.mode: useattr(object, "Csingle")では報告されない。  しかし、mode<-を使用してモードを "single "に設定することができ、これは実際のモードを "double "に設定し、"Csingle "属性をTRUEに設定します。  他のモードを設定すると、この属性は削除される。（以下の例では）S互換のmode"("を持つ呼び出しがあることに注意。
LETTERS：ローマ字の大文字26文字、letters：ローマ字の小文字26文字、month.abb：英語の月名の3文字の省略形、month.name：1年の月の英語名、π：円の円周と直径の比。これらは、適切な値をとる基本名前空間の変数として実装されている。
LETTERS：ローマ字の大文字26文字、letters：ローマ字の小文字26文字、month.abb：英語の月名の3文字の省略形、month.name：年の月の英語名、π：円の円周と直径の比。これらは、適切な値をとる基本名前空間の変数として実装されている。
NA
NA
NA
いくつかの属性（class、comment、dim、dimnames、names、row.names、tsp）は特別に扱われ、設定できる値に制限があることに注意してください。  (これは、levels置換関数を使用して要因に設定されるべきlevelsには当てはまらないことに注意してください。)属性は、内部的にはリストとして格納されておらず、ベクトルではなく集合として考えるべきです。  これは、デフォルト引数attrib.as.set = TRUEを指定した場合のidentical()の動作にも反映されている。  mostattributes代入では、dim属性、names属性、dimnames属性に特別な注意が払われ、有効であることが分かっている場合のみ代入されます。  これは主に配列を対象としたもので、クラス化されたオブジェクトでは注意して使用する必要があります。  NULLオブジェクトはアトリビュートを持つことができず、アトリビュートを割り当てようとするとオブジェクトは空リストになります。
namesは一般的なアクセサ関数で、names<-は一般的な置換関数です。  names(as.list(env, all.names = TRUE))は、ls(env, all.names = TRUE, sorted = FALSE)でも与えられます。  もし環境がハッシュテーブルとして使用されるなら、names(env)はその "キー "です。もしvalueがxより短いなら、それはcharacterNAsによってxの長さまで拡張されます。一般規則によってnames属性の一部だけを更新することが可能です：例を参照してください。  これは、z <- "names<-"(z, "[<-"(names(z), 3, "c2"))という式で評価されるからです。""という名前は特殊で、（アトミックまたはジェネリック）ベクトルの要素に関連する名前がないことを示すために使われます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表す。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
namesは一般的なアクセサ関数で、names<-は一般的な置換関数です。  names(as.list(env, all.names = TRUE))は、ls(env, all.names = TRUE, sorted = FALSE)でも与えられます。  もし環境がハッシュテーブルとして使用されるなら、names(env)はその "キー "です。もしvalueがxより短いなら、それはcharacterNAsによってxの長さまで拡張されます。一般規則によってnames属性の一部だけを更新することが可能です：例を参照してください。  これは、z <- "names<-"(z, "[<-"(names(z), 3, "c2"))という式で評価されるからです。""という名前は特殊で、（アトミックまたはジェネリック）ベクトルの要素に関連する名前がないことを示すために使われます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTC時間帯）開始からの（符号付き）秒数を数値ベクトルで表す。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではなく（現在はすべてそうなっています）、'NAMESPACE'ファイルを持っているかどうかを示します。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、そのような使い方は想定されていません。
これはかなり間接的な方法で発生する可能性があり、例えばx[]は `[.some_method`(x, )への呼び出しをディスパッチするかもしれません。
文字列の'サイズ'は、次の3つの方法（type引数に対応）のいずれかで測定することができます：文字列を格納するのに必要なバイト数（さらにC言語では、カウントされない最後のターミネータを含む）.文字数.等幅フォントで文字列を印刷するためにcatが使用する列数。  文字数が計算できない場合はcharsと同じ。これらは同じになることが多く、通常はシングルバイテロカルになる（ただし、typeによってデフォルトのforkeepNAが決まることに注意）。  as.characterのデフォルトメソッドに相当する内部メソッドはxに対して実行されます（したがって、メソッドディスパッチはありません）。  ベクトルでないオブジェクトを操作する場合は、最初にdeparseを通す必要がある。
NA
NA
もしinitが与えられると、Reduceは論理的にそれをxの先頭（左から右へ進む場合）または末尾にそれぞれ追加します。この拡張される可能性のあるベクトルvがn > 1の要素を持つ場合、Reduceはvの要素に左から右へ、または右から左へ、それぞれfを連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  現在の実装は、安定性とスケーラビリティを確保するために非再帰的である。  duceはfold（Haskellなど）やaccumulate（C++標準テンプレート・ライブラリなど）としても知られている。  Filterは単項述語関数fをxの要素に適用し、必要であれば論理に強制し、これが真を返すxの部分集合を返します。  可能性のあるNA値は現在常にfalseとして扱われることに注意してください。  FindとPositionはそれぞれCommon Lispのfind-ifとposition-ifに倣ったものです。  述語関数がtrueを与える要素がある場合、rightがfalse（デフォルト）かtrueかによって、そのような要素の最初か最後、またはその位置がそれぞれ返されます。  そのような要素がない場合は、nomatchで指定された値が返されます。  Mapはmapplyの単純なラッパーであり、結果を単純化するようなことはしていません。  NegateはCommon Lispの補語に相当する。  述語）関数fが与えられると、fが返す論理否定を返す関数を作成します。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピー・セマンティクスがあるため、注意が必要です。
breakはfor、while、repeatループから抜け出し、制御は最内周のループの外側にある最初の文に移される。  breakもnextも、入れ子になったループの一番内側だけに適用される。よくある間違いだが、ステートメントを中括弧（{ .. }）で囲むのを忘れることがある、特に、キーボードやソースからif...else構文を入力する際の構文エラーを避けるために、}とelseの間に改行を入れるべきではありません。そのため、防御的なプログラミングの（やや極端な）姿勢の1つとして、if句などには常に中括弧を使用することが挙げられます。  seqの長さがゼロの場合、ループ本体はスキップされる。そうでなければ、変数varにseqの各要素の値が順番に代入される。ループ本体内でvarに代入することもできるが、次の繰り返しには影響しない。  ループが終了しても、varは最新の値を含む変数として残ります。
クラス属性は、オブジェクトが継承するクラスの名前を示す文字ベクトルです。オブジェクトがクラス属性を持たない場合、そのオブジェクトは暗黙のクラスを持ちます。  ほとんどのベクトルはmode(x)の結果がclassになります。ただし、整数ベクトルはclass c("整数", "数値")、実数ベクトルはclass c("double", "数値")です。UseMethod("fun")を呼び出す関数がクラス属性c("first", "second")を持つオブジェクトに適用されると、システムはfun.firstと呼ばれる関数を検索し、見つかればそれをオブジェクトに適用します。  もしそのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  関数メソッドは、特定のジェネリック関数またはクラスのメソッドについて調べるために使用できます。UseMethodはプリミティブ関数ですが、標準的な引数マッチングを使用します。  UseMethodはプリミティブ関数ですが、標準的な引数マッチングを使用します。UseMethodは現在、オブジェクトでない引数でも暗黙のクラスでディスパッチしますが、他のディスパッチ手段ではディスパッチしません。NextMethodは次のメソッドを呼び出します（ジェネリックに供給されたオブジェクトのクラスベクタ、またはメソッドが直接呼び出された場合はNextMethodを含む関数の最初の引数によって決定されます）。  NextMethodはUseMethodによって呼び出されるメソッドか、内部ジェネリック（InternalGenericsを参照）から呼び出されるメソッド以外では呼び出されるべきではありません。  特に、匿名呼び出し関数（例えば、get("print.ts")(AirPassengers)）の中では動作しません。名前空間は、ジェネリック関数のメソッドを登録できます。  これをサポートするために、UseMethodとNextMethodはジェネリック関数が呼び出される環境と、ジェネリックが定義される環境(通常は名前空間)の登録データベースの2つの場所でメソッドを検索します。  R 3.5.0から、登録データベースは呼び出し環境のトップレベル環境(seetopenv)の後(トップレベル環境の親の前)に検索されます。
domain が NULL または "" で、gettext または ngettext がパッケージ pkg の名前空間の関数から呼び出された場合、 domain は "R-pkg" に設定されます。  適切なドメインが見つかった場合、各文字列は翻訳され、現在の言語への翻訳が見つかればそれに置き換えられる。  メッセージの翻訳に使用される言語は、OSのデフォルトやRの起動時のロケール設定（Sys.getlocale()参照）、特にLANGUAGE環境変数によって決定される。通常、パッケージpkgのRの警告/エラーメッセージのドメインは "R-pkg "であり、Cレベルのメッセージのドメインは "pkg "です。  このようなメッセージの翻訳には、言語ごとに特有のルールがあります: GNU Gettextマニュアルを参照してください。  文字列には、insprintfで使用される%dのインスタンスが1つ含まれます。  bindtextdomainは、同じ名前のC関数のラッパーである。  dirnameがanon-NULLの場合、メッセー ジカタログを探す場所を指定します。domain = NULLの場合、現在の場所を返します。
実際のファクターレベル（存在する場合）はlevels関数で取得できます。
noquote は、引数を "noquote" クラスのオブジェクトとして返します。  c()メソッドと添え字メソッド("[.noquote")があり、サブセットによってクラスが失われないようにします。  printメソッド(print.noquote)は、文字列を引用符なしで表示します（"...... "は......と表示されます）。print(x, right=*)の呼び出しでrightが指定された場合、xの可能なright設定（例えば、x <- noquote(*, right=TRUE)）よりも優先されます。これらの関数は、ユーティリティとして、また(S3)クラスとオブジェクト指向の使用例として存在します。
norm()の基本メソッドは、LAPACK関数dlangeを呼び出します。1-、Inf-、"M "ノルムは、Frobeniusノルムよりも計算が速いことに注意してください。
チルデ展開（path.expandを参照）は、まずパスに対して行われます。Unixに似たプラットフォームがサポートしている場合、それはパスを正規形（./、./、記号リンクなし）の絶対パスに変えようとします。  これはPOSIXのシステム関数realpathに依存しています。プラットフォームがrealpathを持っていない場合（現在の例を知りません）、結果は絶対パスになりますが、正規形ではないかもしれません。  Windowsでは、相対パスを絶対パスに変換し、シンボリックリンクを解決し、パス要素の短い名前を長い名前に変換し、これらのパラメータがwinslashで指定されたものであることを保証します。  通常の名前検索と同様に、大文字小文字を区別せずに各要素をマッチさせ、 正規の大文字小文字を返す。これはWindows API関数GetFinalPathNameByHandleに依存しており、(パーミッションが十分でないなどの)エラーが発生した場合、現在のところR 3.6(およびそれ以前)の実装にフォールバックします。この実装は、GetFullPathNameおよびGetLongPathNameに依存しており、注意セクションで説明されている制限があります。GetFinalPathNameByHandle が UNC パスを返したが、GetLongPathName がドライブ文字で始まるパスを返した場合、R は R 3.6 (およびそれ以前) の実装に戻ります。現在のロケールでは有効でない UTF-8 エンコードされたパスを使用できます。
NA
NA
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれません。
as.numericは汎用関数ですが、S3のメソッドはas.double用に記述する必要があります。  これはas.doubleと同じです。is.numericは内部汎用プリミティブ関数です：オブジェクトの特定のクラスを処理するメソッドを書くことができます。  is.doubleとは異なります。  因子はデフォルト・メソッドで処理され、"Date"、"POSIXt"、"difftime "クラス用のメソッドがあります（これらは全てfalseを返します）。  is.numericのメソッドは、そのクラスの基本型がdoubleまたはintegerであり、値が数値として合理的に見なされる場合（例えば、その値に対する算術演算が理にかなっており、比較は基本型で行われるべき）にのみtrueを返すべきです。
数値型は1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
numToBits(.)とpackBits(., type="double")は互いに逆関数で、例も参照してください。
numToBits(.)とpackBits(., type="double")は、互いに逆関数である。
文字列の「サイズ」は、次の3つの方法（type引数に対応）のいずれかで測定することができる：文字列を格納するのに必要なバイト数（C言語では最後のターミネーターもカウントされない）。  文字数が計算できない場合はcharsと同じ。これらは同じになることが多く、通常はシングルバイテロカルになる（ただし、typeによってデフォルトのforkeepNAが決まることに注意）。  as.characterのデフォルトメソッドに相当する内部メソッドはxに対して実行されます（したがって、メソッドディスパッチはありません）。  ベクトルでないオブジェクトを操作する場合は、最初にdeparseを通す必要があります。
name引数には、オブジェクト名が取得される環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または明示的な環境（現在アクティブな関数呼び出しにアクセスするためのingsys.frameの使用を含む）のいずれかの形式で指定することができます。sorted=TRUEの場合の文字列の順序はロケールに依存することに注意してください。  sorted = FALSEの場合、順序は任意であり、環境がハッシュ化されているかどうか、オブジェクトの挿入順序などに依存する。
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明する。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトは、オブジェクトが継承するクラスの名前を与える文字ベクトルであるclass属性を持っています（関数oldClassおよびoldClass<-は、この属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからない場合、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性設定と同様にclass属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトであれば is を使用し、そうでなければ class(x) の全ての要素が what に含まれる場合に TRUE を返します。
ここでは、いわゆる "S3 "クラス（とメソッド）について説明する。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトは、オブジェクトが継承するクラスの名前を与える文字ベクトルであるclass属性を持っています（関数oldClassおよびoldClass<-は、この属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性設定と同様にclass属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトであれば is を使用し、そうでなければ class(x) の全要素が what に含まれていれば TRUE を返します。inherits と isa 以外はすべてプリミティブ関数です。
タイムゾーンはシステム固有のトピックであるが、最近ではほとんどすべてのRplatformsが同様の基本コードを使用しており、Linux、macOS、Solaris、AIX、FreeBSDで使用され、WindowsではRと一緒にインストールされる。  (残念ながら、実装にはシステム固有のエラーが多くあります。) Windowsだけでなく、Unix系でもRソースのバージョンのコードを使用することが可能です: macOSではこれがデフォルトで、Solarisではこれが推奨されています。  Sys.timezone()は、TZが初期に設定されていればその値を返し（OSによっては常に設定されている）、そうでなければ、TZが設定されていれば初期タイムゾーンを示す値をOSから取得しようとする。(TZが設定されているが無効な場合、ほとんどのプラットフォームではUTCがデフォルトとなり、俗にGMTと呼ばれるタイムゾーンとなる（https://en.wikipedia.org/wiki/Coordinated_Universal_Time）。(タイムゾーンが使われるようになったのは19世紀半ばで、20世紀になってから広く採用されるようになった。サマータイムは20世紀初頭に導入され、最も広く使われたのは1916年だった。  過去100年の間に、地域は主要なタイムゾーン間の所属を変更し、様々な年にサマータイムを選択したり（または参加したり）、サマータイムルールの変更を遅く採用したり、まったく採用しなかったりした。  (一部の国（アイルランド共和国はそのひとつ）では、夏時間が「標準」時間であり、冬には別の名称が使用される。  POSIXctのごく一般的なシステム実装は符号付き32ビット整数であるため、1901年末までしか遡れない。このようなシステムでは、Rはそれ以前の日付が1902年と同じタイムゾーンにあると仮定する。  世界の大半は1902年までタイムゾーンを採用していなかったが（そのため、経度に基づくローカルな「平均時」を使用していた）、いくつかの場所ではそれ以前にタイムゾーンが変更されていた。  64ビット表示が一般的になりつつあるが、残念ながら64ビットOSでは、データベース情報が32ビットであるため、1901年から2038年の範囲しか利用できず、終了年については不完全である。R 3.5.0から、セッションでタイムゾーンの場所が最初に見つかると、その値はbase環境のオブジェクト.sys.timezoneにキャッシュされるようになった。
on.exitに渡されたexpr引数は、評価されずに記録されます。  その後に同じ関数内の別のon.exit呼び出しによって削除/置換されなければ、その関数が終了するときに（標準エラー処理中も含めて）その関数のevaluationフレームで評価されます。  複数のon.exit式がadd = TRUEを使用して設定されている場合、1つの式がエラーを通知してもすべての式が実行されます。これは「特別な」プリミティブ関数です。
最初の11個の関数はコネクションを作成します。  デフォルトでは、接続はオープンされません（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することでオープンされる可能性があります。fileの場合、記述はオープンされるファイルへのパス（チルダ展開が行われる場合）または完全なURL（urlの呼び出しと同じ場合）、または""（デフォルト）または "clipboard"（「クリップボード」のセクションを参照）です。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルだけをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルだけをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができます。
srcfile関数は、ソース・コード・ファイルの名前とディレクトリ、およびタイムスタンプを含むsrcfileクラスのオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーに使用するソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むクラス srcfile のオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)と解析された行(要素7, 8)は、 #lineディレクティブがコード内で使用されている場合、異なるかもしれません: 前者はディレクティブを尊重し、後者は単に行数をカウントします。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーに使用するソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むクラス srcfile のオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについてはfileを、プラットフォームで許可されるエンコーディングの一覧についてはiconvlistを参照してください。srcfilecopy関数は、子孫クラスsrcfilecopyのオブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)と解析された行(要素7, 8)は、 #lineディレクティブがコード内で使用されている場合、異なるかもしれません: 前者はディレクティブを尊重し、後者は単に行数をカウントします。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  useSource=FALSEでsrcrefオブジェクトが印刷された場合、<srcref: ...>レコードが印刷されます。isOpenは内部的な使用を目的としており、srcfileオブジェクトに関連付けられた接続が開いているかどうかをチェックします。
S3 メソッドを記述できるグループは、"Math"、"Ops"、"Summary"、"Complex" の 4 つです。  これらはベースRのRオブジェクトではないが、メソッドを提供することができ、ベースRには最初の3つのグループのためのfactor、data.frame、difftimeメソッドが含まれている。  (Opsのorderedメソッド、MathとOpsのPOSIXtメソッドとDateメソッド、OpsとSummaryのpackage_versionメソッド、statsパッケージのOpsのtsメソッドもあります)。グループ "Math":abs、sign、sqrt、floor、ceiling、trunc、round、signifexp、log、expm1、log1p、cos、sin、tan、cospi、sinpi、tanpi、acos、asin、atancosh、sinh、tanh、acosh、asinh、atanhlgamma、gamma、digamma、trigammacumsum、cumprod、cummax、cumminこのグループのメンバはxに対してディスパッチします。  ほとんどのメンバは1つの引数しか受け付けないが、log、round、signifは1つまたは2つの引数を受け付け、truncは1つ以上の引数を受け付ける。グループ "Ops": "+", "-", "*", "/", "^", "%%", "%/%""&", "|", "!""==", "!=", "<", "<=", ">=", ">"このグループには、二項演算子と単項演算子（+, -, ！)：単項演算子に遭遇すると、Opsメソッドが1つの引数で呼び出され、e2が欠落します。このグループの任意のメンバーをディスパッチする際に、両方の引数のクラスが考慮されます。  各引数のクラスのベクトルは、一致する特定の（優先される）またはOpsメソッドがあるかどうかを確認するために検査されます。  異なるメソッドが見つかった場合、'互換性のないメソッド'についての警告が表示されます。比較演算子("Compare": ==, <, ...)および論理演算子("Logic": & | and !) のための data.frame メソッドは、利便性とバックコンパチビリティのために、データフレームの代わりに論理行列を返します。このグループのメンバが関数として呼び出される場合、位置マッチングが常に使用されるように、引数名は削除されます。グループ "Summary":all、anysum、prodmin、maxrangeこのグループのメンバは、最初に与えられた引数に対してディスパッチされる、fulfillingグループ "Complex":Arg, Conj, Im, Mod, Reこのグループのメンバーは、zにディスパッチする。内部コードはoldClassにディスパッチし、onclassにはディスパッチしないので、メソッドは、"class "属性に対応する場合のみ、これらのグループの1つまたはそのメンバーの1つに使用されることに注意。  Math "グループ・ジェネリック・メソッドのプリミティブ・メンバーに提供された引数の数は、ディスパッチする前にチェックされません。グループ・ジェネリック関数の引数の遅延評価はありません。
数値ベクトルとして指定された場合、x は整数である必要はありませんが、Dates のヘルプの端数日に関するコメントを参照してください。
difftime関数は、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime "クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。units = "auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる可能な最大の単位（"weeks "を除く）が選択されます。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は要素のレベル集合の和をレベルとする因子になり、レベルが要素のレベル集合に出現する順番になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合になることを意味します）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使います。
ベクトル x の型は制限されません。as.character メソッドを持ち、ソート可能（byorder）でなければなりません。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。R 4.1.0以降では、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、レベルが要素のレベル集合に出現する順序で、要素のレベル集合の和を持つ因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからの秒単位のオフセット。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
引数なしでoptions()を起動すると、オプションの現在の値を含むリストが返される。  以下のすべてのオプションが初期設定されているわけではないことに注意してください。  1つのオプションの値にアクセスするには、長さ1のリストであるoptions("width")ではなく、例えばgetOption("width")を使うべきである。
最初のベクトルで同値の場合は、2番目のベクトルで同値を解消する。  使用されるソートは安定しているので（method = "quick "を除く）、未解決の同値は元の順序のまま残されます。複素数の値は、最初に実数部、次に虚数部でソートされます。メソッド "radix "を除き、文字ベクトルのソート順は、使用するロケールの照合順序に依存する: 比較を参照のこと。メソッド "shell "は、一般的に最も安全な賭けであり、短い因子、数値ベクトル、整数ベクトル、論理ベクトルを除き、デフォルトのメソッドである。注意点はあるが、他の方法を凌駕している(sortを参照)。  sort.listのメソッド "quick "は、na.last = NAの数値xに対してのみサポートされ、安定せず、"radix "よりも遅い。partial = NULLは、Sの他の実装との互換性のためにサポートされているが、他の値は受け付けられず、順序付けは常に完全である。  因子の場合、これは内部コードでソートされ、順序付き因子に特に適しています。
順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なって扱います。ベクトルのエンコーディングは次のように行われます。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（おそらく順序付けられた）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（おそらく順序付けられた）因子であれば、結果は、レベルが要素のレベル集合に出現する順序で、要素のレベル集合の和を持つ因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
XとYはFUNの適切な引数でなければならない。  FUNはこれら2つの拡張されたベクトルを引数として呼び出されます（さらに...の引数も）。  FUNはこれら2つの拡張されたベクトルを引数として呼び出されます(さらに...の引数も)。FUNはベクトル化された関数(またはその名前)でなければならず、少なくとも2つの引数を期待し、最初の引数(および2番目の引数)と同じ長さの値を返します。それらが存在する場合、XとYの[dim]名が答えにコピーされ、XとYの次元(次元が存在しない場合は長さ)の積である次元が割り当てられます。FUN="*"は、as.vector(X) %*% t(as.vector(Y))による特殊なケースとして扱われ、数値ベクトルや配列のみを対象としています。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(パッケージの'DESCRIPTION'ファイルなど)は、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷が可能な表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
setHookは、ユーザーがシステム（またはユーザー）関数から呼び出される関数のリストであるフックを登録するための一般的なメカニズムを提供します。  フックを完全に削除するには、setHook(hookName, NULL, "replace")を呼び出します。Rパッケージがライブラリでアタッチされたり、その他の方法でロードされたりすると、初期化コードを呼び出すことができます。  初期化中に呼び出されるパッケージ・フック関数の説明については、.onLoadを参照してください。  ユーザは、setHook()で提供されるフックを使って独自の初期化コードを追加することができます。この関数は、atry呼び出しの内部でfunname(pkgname, pkgpath)として呼び出されます。  すべてのフックが定義され、パッケージがアタッチされている場合、初期化イベントの順序は次のようになる：パッケージ・ネームスペースがロードされる。パッケージの.onLoad関数が実行される。S4メソッドのディスパッチがオンの場合、setLoadActionで設定されたアクションが実行されます。名前空間がシールされる。ユーザーの "onLoad "フックが実行される。パッケージが検索パスに追加される。パッケージの .onAttach 関数が実行されます。パッケージ環境が封印される。ユーザーの "attach "フックが実行される。パッケージがデタッチされ、その名前空間がアンロードされると、同様のシーケンス（ただし逆）が実行される：ユーザーの "detach "フックが実行される。パッケージの.Last.lib関数が実行される。パッケージが検索パスから削除される。ユーザーの「onUnload」フックが実行される。パッケージの .onUnload 関数が実行される。パッケージの名前空間がアンロードされます。Rセッションが終了しても、パッケージは削除されず、名前空間もアンロードされないので、対応するフックは実行されないことに注意してください。また、ユーザー・フックの中には、パッケージが検索パスにない状態で実行されるものがあるので、そのようなフックでは、パッケージ内のオブジェクトを、例のようにダブル（またはトリプル）コロン演算子を使って参照する必要があることにも注意してください。複数のフックが追加された場合、通常はgetHookで示された順番で実行されますが、"detach "と "onUnload "フックは逆の順番で実行されるため、パッケージイベントのデフォルトは既存のフックの「内側」にフックを追加することになります。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在はすべてそうなっています)。むしろ'NAMESPACE'ファイルを持っているかどうかを示すもので、baseパッケージや一部のレガシーパッケージにはありません。  しかし、それを使うことを意図しているわけではありません。
find.packageは、指定されたパッケージが見つかる場所へのパスを返します。  lib.locがNULLの場合、ライブラリの前にロードされた名前空間が検索されます。  パッケージが複数回見つかった場合は、最初にマッチしたものが使用されます。  quiet = TRUEでない限り、名前付きパッケージが見つからなかった場合は警告が、見つからなかった場合はエラーが表示されます。  verbose = TRUE の場合、複数回見つかったパッケージについての警告が表示されます。  find.packageは通常、パッケージが使用可能かどうかを調べるための正しいツールではありません。  path.packageは、指定されたパッケージがロードされたパス、または指定されたパッケージがない場合は、現在アタッチされているすべてのパッケージを返します。コンディション・オブジェクトは、フィールドpackageとlib.loc.を含んでいます。  
messageは、警告でもエラーでもない「単純な」診断メッセージを生成するために使用されます。  デフォルトのハンドラは、メッセージをstderr()接続に送ります。messageに条件オブジェクトを与える場合、引数はそれだけであるべきで、それ以上の引数は無視され、警告が表示されます。packageStartupMessageはその変種で、suppressPackageStartupMessagesによって個別にメッセージを抑制することができます。  (makeMessageはmessage、warning、stopで使用されるユーティリティで、 ...引数からテキストメッセージを生成します。
numToBits(.)とpackBits(., type="double")は互いに逆関数であり、例も参照してください。
LISPのような）伝統的なドット付きペア・リストも利用できますが、ユーザが目にすることはほとんどありません（関数の形式として利用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、ペアリストのタグとしてリストの名前が使われます。他のタイプの引数の戻り値は文書化されていません。list、is.list、is.pairlistは基本関数です。
環境は、フレームまたは名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成される。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピー・セマンティクスがあるため、注意が必要です。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピーのセマンティクスがあるため、注意が必要です。
sys.call、sys.function、およびsys.frameは、引数whichに整数値を指定できます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
Rのすべてのバージョンは、LF（Unixで使われる）、CRLF（DOS/Windowsで使われる）、CR（クラシックMac OSで使われる）で行末がマークされた接続からの入力を受け付ける。  コンソールから入力を受ける場合、n = NULLはton = 1と等価であり、n < 0はEOF文字が読まれるまで読み込まれる。  (EOF文字はWindowsフロントエンドではCtrl-Zである。) コンソールから読み込む場合、行の長さの上限は4095バイトである。  keep.sourceがTRUEでない場合、srcfiledのデフォルトは文字列で、"<text>"またはfileから派生した文字列です。  keep.source が TRUE の場合、text が使用されると、srcfile は text を含む asrcfilecopy に設定されます。  srcfile が文字列の場合、エラーメッセージには名前が含まれますが、ソース参照情報は結果に追加されません。  srcfile が srcfile オブジェクトの場合、ソース参照情報は保持されます。文字ベクトルの場合、str2expression(s) は toparse(text = s, keep.source=FALSE) に対応します。文字列の場合、str2lang(s)は、toparse(text = s, keep.source=FALSE)[[1]]に対応します（さらに、sとparse(*)結果の両方が長さ1であることをチェックします）。  別の言い方をすると、str2lang(.)の値は呼び出しかその一部、要するに "呼び出しかもっと単純なもの "です。現在、エンコーディングはstr2lang()とstr2expression()では扱われていません。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではなく(現在はすべてそうなっている)、むしろ'NAMESPACE'ファイルを持っているかどうかを示す。  しかし、それを使うことを意図しているわけではありません。
pasteは（as.characterで）引数を文字列に変換し、（sepで指定した文字列で区切って）連結します。  引数がベクタの場合、それらを項ごとに連結して文字ベクタの結果を得ます。  ベクトル引数は必要に応じて再利用され、ゼロ長の引数はrecycle0が真でないか collapseがNULLでない場合にのみ""に再利用される、paste0(...、collapse)は、paste(...、sep = ""、collapse)と同等ですが、若干効率的です。collapseに値が指定された場合、結果の値は1つの文字列に連結され、要素はcollapseの値で区切られます。
pasteは引数を(as.characterで)文字列に変換し、(sepで指定した文字列で区切って)連結します。  引数がベクタの場合、それらを項ごとに連結して文字ベクタの結果を得ます。  ベクトル引数は必要に応じて再利用され、ゼロ長の引数はrecycle0が真でないか collapseがNULLでない場合にのみ""に再利用される、paste0(...、collapse)は、paste(...、sep = ""、collapse)と同等ですが、若干効率的です。collapseに値が指定された場合、結果の値は1つの文字列に連結され、要素はcollapseの値で区切られます。
Rのほとんどのビルドでは、先頭の~userはユーザーのホームディレクトリに展開される（R 4.1.0からはreadlineも使用されなくなった）。home'ディレクトリの定義は'rw-FAQ'Q2.14にあります: セッションで最初にpath.expandが呼ばれたときにR_USER環境変数から取得されます。
find.packageは、指定されたパッケージが見つかる場所へのパスを返します。  lib.locがNULLの場合、ライブラリの前にロードされた名前空間が検索されます。  パッケージが複数回見つかった場合は、最初にマッチしたものが使用されます。  quiet = TRUEでない限り、名前付きパッケージが見つからなかった場合は警告が、見つからなかった場合はエラーが表示されます。  verbose = TRUE の場合、複数回見つかったパッケージについての警告が表示されます。  find.packageは通常、パッケージが使用可能かどうかを調べるための正しいツールではありません。  path.packageは、指定されたパッケージがロードされたパス、または指定されたパッケージがない場合は、現在アタッチされているすべてのパッケージを返します。コンディション・オブジェクトは、フィールドpackageとlib.loc.を含んでいます。  
NA
LETTERS：ローマ字の大文字26文字、letters：ローマ字の小文字26文字、month.abb：英語の月名の3文字の省略形、month.name：1年の月の英語名、π：円の円周と直径の比。
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptによって作成されたソケット接続とserverSocketによって作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することによってオープンされるかもしれません。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
2つのステップタイプはx-yの優先順位が異なる：x1<x2で(x1,y1)から(x2,y2)に移動する場合、type = "s "はまず水平に移動し、次に垂直に移動するが、type = "S "は逆に移動する。
動作はduplicates.okの値によって異なる。まず、これが真の場合を考える。  最初に完全一致が考慮され、最初の完全一致の位置が記録される。次に、一意な部分一致が考慮され、見つかった場合は記録されます。  (部分一致は、xの要素の全体が表の要素の先頭に一致する場合に起こる)。  さらに、空文字列は何もマッチせず、空文字列と完全にマッチすることもない。  duplicates.okがFALSEの場合、一度マッチしたtableの値は、それ以降のマッチの検索から除外されます。  charmatchは、pmatch withduplicates.ok trueと似ていますが、違いは、マッチしないかあいまいな部分マッチかを区別すること、空文字列にマッチすること、複数の完全マッチを許さないことです。
na.rmがFALSEの場合、引数のいずれかにNA値があればNA値が返され、そうでなければNA値は無視されます。数値の空集合の最小値と最大値は、+InfとInf（この順序で！）であり、これは他律性を保証します、min(x1, min(x2)) == min(x1, x2)。  数値xmax(x) == -Inf、min(x) == +Infは、length(x) == 0のとき（必要であれば欠損値を取り除いた後）です。  pmaxとpminは1つ以上のベクトル(または行列)を引数として取り,そのベクトルの'並列'最大値(または最小値)を1つのベクトルとして返します.結果の最初の要素は'並列'最大値(または最小値)です.  結果の第1要素はすべての引数の第1要素の最大値（最小値）であり、結果の第2要素はすべての引数の第2要素の最大値（最小値）である。  より短い入力（0以外の長さ）は、必要に応じて再利用される。  pmax.intとpmin.intは、全ての引数が原子ベクトルであり、クラスが存在しない場合にのみ使用される、より高速な内部バージョンです: これらは全ての属性を削除します(生ベクトルや複雑なベクトルでは順序付けがないため、全てのバージョンは失敗することに注意してください)。  定義では、NaNを含む数値ベクトルの最小/最大はNaNであるが、NaNを含むベクトルの最小/最大はNaNである。文字バージョンは辞書順にソートされるが、これは使用するロケールの照合順序に依存する。  空の文字ベクトルの最大/最小は、文字NAと定義される。  (「"」が最小の文字要素であるため、最大値は「"」であるべきだという議論もあり得ますが、最小値の候補は明らかではありません)。
na.rmがFALSEの場合、引数のいずれかにNA値があればNA値が返され、そうでなければNA値は無視されます。数値空集合の最小値と最大値は、+InfとInf(この順序で!)であり、これにより他律性が保証されます、min(x1, min(x2)) == min(x1, x2)。  数値xmax(x) == -Inf、min(x) == +Infは、length(x) == 0のとき（要求があれば欠損値を取り除いた後）。  pmaxとpminは1つ以上のベクトル(または行列)を引数として取り,そのベクトルの'並列'最大値(または最小値)を1つのベクトルとして返します.結果の最初の要素は'並列'最大値(または最小値)です.  結果の第1要素はすべての引数の第1要素の最大値（最小値）であり、結果の第2要素はすべての引数の第2要素の最大値（最小値）である。  より短い入力（0以外の長さ）は、必要に応じて再利用される。  pmax.intとpmin.intは、全ての引数が原子ベクトルであり、クラスが存在しない場合にのみ使用される、より高速な内部バージョンです: これらは全ての属性を削除します(生ベクトルや複雑なベクトルでは順序付けがないため、全てのバージョンは失敗することに注意してください)。  定義では、NaNを含む数値ベクトルの最小/最大はNaNであるが、NaNを含むベクトルの最小/最大はNaNである。文字バージョンは辞書順にソートされるが、これは使用するロケールの照合順序に依存する。  空の文字ベクトルの最大/最小は、文字NAと定義される。  (「"」が最小の文字要素であるため、最大値は「"」であるべきだという議論もあり得ますが、最小値の候補は明らかではありません)。
na.rmがFALSEの場合、引数のいずれかにNA値があればNA値が返され、そうでなければNA値は無視されます。数値空集合の最小値と最大値は、+InfとInf(この順序で!)であり、これにより他律性が保証されます、min(x1, min(x2)) == min(x1, x2)。  数値xmax(x) == -Inf、min(x) == +Infは、length(x) == 0のとき（要求があれば欠損値を取り除いた後）。  pmaxとpminは1つ以上のベクトル(または行列)を引数として取り,そのベクトルの'並列'最大値(または最小値)を1つのベクトルとして返します.結果の最初の要素は'並列'最大値(または最小値)です.  結果の第1要素はすべての引数の第1要素の最大値（最小値）であり、結果の第2要素はすべての引数の第2要素の最大値（最小値）である。  より短い入力（0以外の長さ）は、必要に応じて再利用される。  pmax.intとpmin.intは、全ての引数が原子ベクトルであり、クラスが存在しない場合にのみ使用される、より高速な内部バージョンです: これらは全ての属性を削除します(生ベクトルや複雑なベクトルでは順序付けがないため、全てのバージョンは失敗することに注意してください)。  定義では、NaNを含む数値ベクトルの最小/最大はNaNであるが、NaNを含むベクトルの最小/最大はNaNである。文字バージョンは辞書順にソートされるが、これは使用するロケールの照合順序に依存する。  空の文字ベクトルの最大/最小は、文字NAと定義される。  (「"」が最小の文字要素であるため、最大値は「"」であるべきだという議論もあり得ますが、最小値の候補は明らかではありません)。
na.rmがFALSEの場合、引数のいずれかにNA値があればNA値が返され、そうでなければNA値は無視されます。数値空集合の最小値と最大値は、+InfとInf(この順序で!)であり、これにより他律性が保証されます、min(x1, min(x2)) == min(x1, x2)。  数値xmax(x) == -Inf、min(x) == +Infは、length(x) == 0のとき（必要なら欠損値を取り除いた後）。  pmaxとpminは1つ以上のベクトル(または行列)を引数として取り,そのベクトルの'並列'最大値(または最小値)を1つのベクトルとして返します.結果の最初の要素は'並列'最大値(または最小値)です.  結果の第1要素はすべての引数の第1要素の最大値（最小値）であり、結果の第2要素はすべての引数の第2要素の最大値（最小値）である。  より短い入力（0以外の長さ）は、必要に応じて再利用される。  pmax.intとpmin.intは、全ての引数が原子ベクトルであり、クラスが存在しない場合にのみ使用される、より高速な内部バージョンです: これらは全ての属性を削除します(生ベクトルや複雑なベクトルでは順序付けがないため、全てのバージョンは失敗することに注意してください)。  定義では、NaNを含む数値ベクトルの最小/最大はNaNであるが、NaNを含むベクトルの最小/最大はNaNである。文字バージョンは辞書順にソートされるが、これは使用するロケールの照合順序に依存する。  空の文字ベクトルの最大/最小は、文字NAと定義される。  (「"」が最小の文字要素であるため、最大値は「"」であるべきだという議論もありうるが、最小値の候補は明らかでない)。
p(x)=z1+z2*x+...+z[n]*x^(n-1)の次数n - 1の多項式は、その係数ベクトルz[1:n]で与えられる。polyrootは、Jenkins-Traubアルゴリズムを用いてp(x)のn-1個の複素ゼロを返す。
環境内のオブジェクトを操作するためのいくつかのR関数（getやlsなど）では、検索パス内の対応する位置から環境を指定することができます。pos.to.envは、これらの位置を対応する環境に変換するプログラマのための便利な関数です。  これはプリミティブな関数で、-1は関数が呼び出された環境として解釈されます。
initが与えられると、Reduceは論理的にそれをxの開始点（左から右に進む場合）または終了点にそれぞれ追加します。この拡張される可能性のあるベクトルvがn > 1個の要素を持つ場合、Reduceはfをvの要素に左から右、または右から左にそれぞれ連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  現在の実装は、安定性とスケーラビリティを確保するために非再帰的である。  duceはfold（Haskellなど）やaccumulate（C++標準テンプレート・ライブラリなど）としても知られている。  Filterは単項述語関数fをxの要素に適用し、必要であれば論理に強制し、これが真を返すxの部分集合を返します。  可能性のあるNA値は、現在のところ常に偽とみなされることに注意してください。  FindとPositionはそれぞれCommon Lispのfind-ifとposition-ifに倣ったものです。  述語関数がtrueを与える要素がある場合、rightがfalse（デフォルト）かtrueかによって、そのような要素の最初か最後、またはその位置がそれぞれ返されます。  そのような要素がない場合は、nomatchで指定された値が返されます。  Mapはmapplyの単純なラッパーであり、結果を単純化するようなことはしていません。  NegateはCommon Lispの補語に相当する。  (述語)関数fが与えられると、fが返す関数の論理否定を返す関数を作成します。
dが(非常に近い)0でない場合、c <- d/nとし、そうでない場合、多かれ少なかれc <- max(abs(range(x)))*shrink.sml / min.nとする。b≦c＜10b.ここで、基本単位uを{1,2,5,10} bの1つに決定し、[1,10]内のonc/bと2つの'バイアス'係数、h =high.u.biasとf =u5.bias......に依存する。
dが0に(非常に近い)でなければ、c <- d/nとし、そうでなければc <- max(abs(range(x)))*shrink.sml / min.nとする。ここで、基本単位uを{1,2,5,10} bのいずれかに決定し、[1,10]内のonc/bと2つの'バイアス'係数、h =high.u.biasとf =u5.bias......に依存する。
数値については、formatC()は必要に応じてprettyNum()を呼び出し、それ自体が.format.zeros(*, replace=replace.zero)を呼び出す("必要なとき": zero.printがNULLでないとき、drop0trailingがtrueのとき、またはbig.mark、small.mark、decimal.markのいずれかがデフォルトでないとき)。formatを設定すると、modeの設定が上書きされる。formatC(c(6.11,13.1),digits = 2, format = "fg") はc("6.1", " 13")を与える。formatC(c(6.11, 13.1), digits = 2, format = "fg")はc("6.1", " 13")を与える。  複数の数字に共通の書式が必要な場合は、format.prettyNumを使用します。prettyNumは、xをきれいにするためのユーティリティ関数です。  xが文字でない場合、format(x[i], ...)が各要素に適用され、他のすべての引数がデフォルトの場合、変更されません。  gsubはbig.markとsmall.markを挿入するために使用されるので、特殊文字はエスケープする必要があります。  
デフォルト・メソッドであるprint.defaultには、それ自身のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。print.factorでは、いくつかのカスタマイズが可能で、順序付き因数の印刷にも使用されます。テーブルを印刷するprint.tableでは、その他のカスタマイズが可能です。  R 3.0.0では、0-extentsを持つテーブルの場合にのみ説明が表示されます（これは、分類子に有効なデータがない場合に起こり得ます）。特定の表示メソッドを主目的とするクラスの例として、noquoteを参照してください。
関数Iには2つの主な用途があります。関数data.frameにおいて。  Iは、データ・フレームに追加されるオブジェクトや、as.data.frameを介してデータ・フレームに変換されるオブジェクトを保護するためにも使用できます。  クラス "AsIs "は、for [, as.data.frame,printとformatを含むいくつかの独自のメソッドを持っています。関数式では。  そこでは、"+", "-", "*", "^"といった演算子を数式演算子として解釈することを禁止するために使用されます。  これはterms.formulaによって記号として解釈される。
デフォルトの方法では、次元を持つオブジェクト（行列など）がデータフレームに連結され、データフレーム法が適用されます。  他のオブジェクトもデータ・フレームに強制されるが、FUN はデータ・フレームの各列（のサブセット）に別々に適用される。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すことはできません。
最初の11の関数は接続を作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することでオープンされる可能性があります。fileの場合、記述はオープンされるファイルへのパス（チルダ展開が行われる場合）または完全なURL（urlの呼び出しと同じ場合）、または""（デフォルト）または "clipboard"（「クリップボード」のセクションを参照）です。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
quote=TRUEを指定すると、行名や列名ではなく、項目のみが引用符で囲まれます。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、この暦が使用されていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  多くのメソッドの中から、methods(class = "Date")を参照してください。
NAを表示する際のデフォルトは、これが文字NAでquote = FALSEでない限り、NA（引用符なし）を表示します。  これは、digitsが使用される有効数字の最小数を指定し、少なくとも1つのエントリがその最小数でエンコードされることを意味する。  しかし、符号化されたすべての要素が末尾に0を持つ場合、小数点以下の桁数は、少なくとも1つの要素が0でない末尾の桁を持つまで減らされます。  オプションwidthはベクトル、行列、配列の表示を制御し、オプションdeparse.cutoffは呼び出しや式のような言語オブジェクトの表示を制御します。methodsパッケージがアタッチされている場合、printはオプション引数なしで呼び出された場合、形式クラス（'S4'）を持つRオブジェクトを表示します。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のためのメソッドもあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
デフォルト・メソッドであるprint.defaultには、それ自身のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。  R 3.0.0では、0-extentsを持つテーブルの場合（分類子に有効なデータがない場合に起こり得ます）の説明のみを表示します。特定の印刷メソッドを主目的とするクラスの例として、noquoteを参照してください。
これは DLL を管理する内部テーブルに問い合わせます。
DLL を管理する内部テーブルに問い合わせます。
これは、R内部によって登録され処理された後の登録情報を受け取ります。  このクラスにはprintメソッドがあり、登録されたルーチンを持つ型のみを表示します。
対称性が指定されていない場合、isSymmetric(x)はその行列が対称であるかどうかを、もっともらしい数値的な不正確さまで判定します。  行列の固有ベクトルを計算するのは、大きな行列では時間がかかる部分です。行列の固有分解を計算するのは、現実世界のコンピュータでは誤差が生じます。  あなたが望むことができるのは、適切に近い毒素の問題に対する解である。  したがって、実数の非対称なxが実数の固有値を繰り返す代数的な解を持つとしても、計算された解は複素共役な固有値の組を持つ類似の行列である可能性がある。
デフォルトのメソッドprint.defaultにはそれ自身のヘルプページがある。printジェネリックのすべてのメソッドを得るにはmethods("print")を使用する。  R 3.0.0では、0-extentsを持つテーブルの場合にのみ説明が表示されます（これは、分類子に有効なデータがない場合に起こり得ます）。主な目的が特定の表示メソッドであるクラスの例として、noquoteを参照してください。
デフォルト・メソッドであるprint.defaultには、それ自身のヘルプ・ページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。print.factorでは、いくつかのカスタマイズが可能で、順序付き因子の印刷にも使用されます。  R 3.0.0では、0-extentsを持つテーブルの場合にのみ説明が表示されます（これは、分類子に有効なデータがない場合に起こり得ます）。主な目的が特定の表示メソッドであるクラスの例として、noquoteを参照してください。
hexmode "クラスは、単に16進数で出力されることを保証するためだけに使用される、そのクラス属性を持つ整数ベクトルから構成されます。hexmodeは、（"integer "または "double "型の）整数と、0-9, a-f, A-F（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができる。
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、そのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locにデフォルト値(NULL)を指定すると、ライブラリより先に付属パッケージが検索されます。
methods("print")を使用すると、printジェネリックのすべてのメソッドが得られます。print.factorは、いくつかのカスタマイズが可能で、順序付き因子の印刷にも使用されます。  R 3.0.0では、0-extentsのテーブルの場合のみ説明を表示します（これは、分類子に有効なデータがない場合に起こりえます）。特定の印刷メソッドを主目的とするクラスの例として、noquoteを参照してください。
これは、R内部によって登録され処理された後の登録情報を受け取ります。  このクラスにはprintメソッドがあり、ルーチンを登録した型のみを表示します。
noquoteは引数を "noquote "クラスのオブジェクトとして返します。  c()メソッドと添え字メソッド("[.noquote")があり、サブセットによってクラスが失われないようにします。  printメソッド(print.noquote)は、文字列を引用符なしで表示します（"...... "は......と表示されます）。rightがprint(x, right=*)の呼び出しで指定された場合、xの可能なright設定（例えばx <- noquote(*, right=TRUE)）よりも優先されます。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルから構成され、特に755のようなUnixライクなファイルパーミッションのために、8進数で表示されることを保証するためだけに使用されます。  width=NULL(デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数(integer型またはdouble型)や、要素が0〜7桁のみを含む(またはNAである)文字ベクトルをクラス "octmode "に変換することができます。
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、そのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locにデフォルト値(NULL)を指定すると、ライブラリよりも先に付属パッケージが検索されます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年始以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
proc.timeは後方互換性のために5つの要素を返しますが、そのprintメソッドは長さ3の名前付きベクトルを表示します。最初の2つのエントリは、現在のRプロセスと待機している子プロセスの合計ユーザーCPU時間とシステムCPU時間であり、3番目のエントリはプロセスが開始されてからの「実際の」経過時間です。
コンディション・システムは、エラーや警告を含む異常な状態を通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによって不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。式を評価する間、suspendInterrupts を使用して割り込みを中断できます。  allowInterrupts を使用すると、割り込みを有効にしている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、および.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。
inverse.rle()はrle()の逆関数で、実行値からxを再構築する。
デフォルトのメソッドであるprint.defaultには、それ自身のヘルプページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。  R 3.0.0では、0-extentsを持つテーブルの場合にのみ説明が表示されます（これは、分類子に有効なデータがない場合に起こり得ます）。特定のprintメソッドを主目的とするクラスの例として、noquoteを参照してください。
srcfile関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーで使用するソース・コード・ファイルの名前とディレクトリ、およびタイムスタンプを含むsrcfileクラスのオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含む srcfile クラスのオブジェクトを生成し、ソース・レベルのデバッグ（未実装）やソース・エコーに使用します。  ファイルのエンコーディングが保存されます。エンコーディングについてはfileを、プラットフォームで許可されるエンコーディングの一覧についてはiconvlistを参照してください。srcfilecopy関数は、子孫クラスsrcfilecopyのオブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で印刷された場合、<srcref: ...> レコードが印刷されます。isOpen は内部的な使用を目的としており、srcfile オブジェクトに関連付けられている接続が開いているかどうかをチェックします。
引数 dnn が与えられない場合、内部関数 list.names が呼び出され、'dimname names' が計算されます。  ...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、除外された値をカウントしないように注意されています（以前はNAcountに含まれていました）。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(warningが生成される時点)の最大値であり、デフォルトでは50であることに注意してください。  例えば、options(warn)が変更された場合や、致命的なエラーが発生した場合などである。
関数 summary.lm および summary.glm は、lm および glm によって生成された結果を要約する特定のメソッドの例です。
デフォルトのメソッドであるprint.defaultには、それ自身のヘルプページがあります。printジェネリックのすべてのメソッドを取得するには、methods("print")を使用してください。  R 3.0.0では、0-extentsを持つテーブルの場合（これは分類子に有効なデータがない場合に起こり得ます）の説明のみを表示します。特定の表示メソッドを主目的とするクラスの例としてnoquoteを参照してください。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照してください。  last.warning "の長さは、options("nwarnings")(warningが生成された時点)の最大値であり、デフォルトでは50であることに注意してください。  例えば、options(warn)が変更された場合や、致命的なエラーが発生した場合などである。
prmatrixは、print.matrixの初期の形式であり、同名のS関数に非常によく似ている。
proc.timeは後方互換性のために5つの要素を返すが、そのprintメソッドは長さ3の名前付きベクトルを表示する。最初の2つのエントリーは、現在のRプロセスと待機している子プロセスの合計ユーザーCPU時間とシステムCPU時間であり、3番目のエントリーは、プロセスが開始されてからの「実際の」経過時間である。
na.rmがFALSEの場合、引数のいずれかにNA値があるとNA値が返され、そうでなければNA値は無視されます。これはジェネリック関数であり、メソッドは直接定義することも、Summaryグループのgenericを介して定義することもできます。
NA
NA
関数 dimnames と dimnames<- は汎用的なもので、配列（特に行列）に対して、オブジェクトの dimnames 属性（属性を参照）を取得または設定します。  配列/行列の置換メソッドは、vectorとfactorelementsの値をcharacterに強制しますが、as.characterのメソッドはディスパッチしません。  長さ0の要素はNULLに、長さ0のリストはNULLに強制されます。  valueが次元数より短いリストの場合、必要な長さまでNULLで拡張されます。  データ・フレームの dimnames は、row.names と name です。  provideDimnames(x)は、"missing "の場合にdimnamesを提供し、その結果が各成分のcharacterdimnamesを持つようにします。  デフォルトでuniqueがtrueの場合、make.unique(*, sep=sep)によって各コンポーネント内で一意になります。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lγ関数、digamma関数、trigamma関数は、内部ジェネリックプリミティブ関数です：メソッドは、個別に定義することも、Mathグループジェネリックを介して定義することもできます。
これらの関数はスタックを形成するので、最初に取り出される行は、最後にpushBackを呼び出したときの最初の文字列になります。  プッシュバックされた行は、readLinesやscanのような通常のテキスト読み取り関数によって、接続からの通常の入力の前に読み取られる。  このため、変換できない文字が <U+xxxx> として表示されることがあります。  encoding = "UTF-8 "の場合はUTF-8に変換され、encoding = "bytes "の場合はそのままになります。
複数の文字列を1回または複数回プッシュバックすることができる。プッシュバックされた文字列はスタックを形成するので、最初に取り出される行は、最後にpushBackを呼び出したときの最初の文字列となる。  プッシュバックされた行は、readLinesやscanのような通常のテキスト読み取り関数によって、接続からの通常の入力の前に読み取られます。  このため、変換できない文字が <U+xxxx> として表示されることがあります。  encoding = "UTF-8 "の場合はUTF-8に変換され、encoding = "bytes "の場合はそのままになります。
saveには "no"、"yes"、"ask"、"default "のいずれかを指定する。  最初の場合はワークスペースは保存されず、2番目の場合は保存され、3番目の場合はユーザーにプロンプトが表示され、終了しないこともできます。  通常の終了の直前に、.Last()関数が存在し、かつrunLastがtrueの場合、.Last()が実行される。  インタラクティブな使用で.Last関数にエラーがある場合、制御はコマンド・プロンプトに戻されるので、関数を十分にテストしてください。  runLastがtrueの場合、.Last()の後に実行される.Last.sys()がある。Rセッションの終了時に何が起こるかは、使用しているプラットフォームとGUIインターフェースに依存する。  典型的なシーケンスは、.Last()と.Last.sys()を実行し(runLastがfalseでない限り)、要求があればワークスペースを保存し(ほとんどの場合、セッション履歴も保存します。savehistoryを参照してください)、次に終了時に実行するように設定されているファイナライザ(reg.finalizerを参照してください)を実行し、開いているすべてのグラフィック・デバイスを閉じ、セッションの一時ディレクトリを削除し、残っている警告(例えば、.Last()とデバイスのクローズから)を表示します。  非対話的な使用に対するデフォルトのエラーハンドラは、効果的にq("no", 1, FALSE)を呼び出し、エラーステータス1を返します。  エラー・ステータス2はRの'suicide'、つまり壊滅的な失敗に対して使用され、他の小さな数字は初期化の失敗に対して特定のポートによって使用される。  ステータスの有効値はシステムに依存するが、通常は0～255が有効である。  (多くのOSは、値の最後のバイトを報告する。つまり、256のモジュロの値を報告する。  しかしすべてではない)。
QR分解は多くの統計手法で重要な役割を果たしている。  QR分解は多くの統計技法で重要な役割を果たします。特に、行列 ⒶとベクトルⒷが与えられたとき、方程式 Ⓑ{Ax} = Ⓑ{b} を解くのに使えます。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q} 行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。
QR分解は多くの統計的手法において重要な役割を果たす。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q} 行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。
QR分解は多くの統計的手法において重要な役割を果たす。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q} 行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。
QR分解は多くの統計的手法において重要な役割を果たす。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q} 行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。LAPACK コードからの結果がうまくいかないと、正のエラーコードを与えるエラーが発生する。
NA
QR分解は多くの統計的手法において重要な役割を果たす。  特に、与えられた行列(at)とベクトル(at)に対して、方程式(at)=(at)=(at)=(at)=(at)=(at)を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q} 行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。
QR分解は多くの統計的手法において重要な役割を果たす。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q}行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。LAPACK コードからの結果がうまくいかないと、正のエラーコードを与えるエラーが発生する。
NA
QR分解は多くの統計的手法において重要な役割を果たす。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q}行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートする。
QR分解は多くの統計的手法において重要な役割を果たす。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q}行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インターフェースは、2^31 以下の要素を持つ行列 x に限定される。qr.fitted と qr.resid は、LINPACK インターフェースのサポートのみである。
NA
NA
NA
NA
save は、"no"、"yes"、"ask"、"default "のいずれかでなければならない。  最初の場合、ワークスペースは保存されず、2 番目の場合は保存され、3 番目の場合はユーザーにプロンプトが表示され、終了しないことも決定できる。  通常の終了の直前に、.Last()関数が存在し、かつrunLastがtrueの場合、.Last()が実行される。  インタラクティブな使用で.Last関数にエラーがある場合、制御はコマンド・プロンプトに戻されるので、関数を十分にテストしてください。  runLastがtrueの場合、.Last()の後に実行される.Last.sys()がある。Rセッションの終了時に何が起こるかは、使用しているプラットフォームとGUIインターフェースに依存する。  典型的なシーケンスは、.Last()と.Last.sys()を実行し(runLastがfalseでない限り)、要求があればワークスペースを保存し(ほとんどの場合、セッション履歴も保存します。savehistoryを参照してください)、次に終了時に実行するように設定されているファイナライザ(reg.finalizerを参照してください)を実行し、開いているすべてのグラフィック・デバイスを閉じ、セッションの一時ディレクトリを削除し、残っている警告(例えば、.Last()とデバイスのクローズから)を表示します。  非対話的な使用に対するデフォルトのエラーハンドラは、効果的にq("no", 1, FALSE)を呼び出し、エラーステータス1を返します。  エラー・ステータス2はRの'suicide'、つまり壊滅的な失敗に対して使用され、他の小さな数字は初期化の失敗に対して特定のポートによって使用される。  ステータスの有効値はシステムに依存するが、通常は0～255が有効である。  (多くのOSは、値の最後のバイトを報告する。つまり、256のモジュロの値を報告する。  しかしすべてではない)。
以下のmyplotの例では、この機能の簡単な使い方を示している。deparse関数とsubstitute関数を使用して、myplot関数の実際の引数の文字列バージョンであるプロットのラベルを作成している：envのバインドシンボルでなければ、変更される。  もしそれがpromiseオブジェクト、つまり関数の正式な引数であるか、delayedAssign()を使って明示的に作成されたものであれば、promiseの式スロットがシンボルを置き換えます。  envが.GlobalEnvの場合はシンボルは変更されません。quoteとsubstitutionはどちらも引数を評価しない「特別な」プリミティブ関数です。
数値バージョンは1つ以上の非負整数のシーケンスで、通常は（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
Rのホーム・ディレクトリは、実行中のRinstallationのトップ・レベルのディレクトリである。Rのホーム・ディレクトリは、しばしばR_HOMEと呼ばれ、Rsessionの中でその名前の環境変数の値である。
これは、RがビルドされたOSの詳細であり、現在実行されているOSの詳細ではない（これについてはSys.infoを参照）。
これは、RがビルドされたOSの詳細を示すものであり、現在実行されているOSの詳細を示すものではない（これについてはSys.infoを参照）。OS名が期待するものと異なる可能性があることに注意してください：たとえば、macOSMavericks 10.9.4は自身をdarwin13.3.0、Linuxは通常linux-gnu、Solaris 10はsolaris2.10と識別します。
例えば、macOSMavericks 10.9.4はdarwin13.3.0、Linuxは通常linux-gnu、Solaris 10はsolaris2.10としている。
na.rmがFALSEの場合、引数のいずれかにNA値やNaN値があるとNA値が返され、そうでなければNA値は無視されます。finiteがTRUEの場合、すべての有限値の最小値と最大値が計算されます、特別な状況は、（NAの省略後に）空でない引数が残っていない場合に発生します。
na.rmがFALSEの場合、引数のどれかにNAやNaN値があるとNA値が返され、そうでなければNA値は無視されます、finiteがTRUEの場合、すべての有限値の最小値と最大値が計算されます。すなわち、finite = TRUEはna.rm = TRUEを含みます。
すべての成分が異なる（そしてNAがない）場合、ランクはseq_along(x)の値でうまく定義される。  いくつかの値が等しい(「同値」と呼ばれる)場合、引数ties.methodは対応する添字での結果を決定する。  first "メソッドは、同値の各インデックスセットで値が増加する並べ替えとなり、同様に "last "メソッドは値が減少する並べ替えとなる。  random "メソッドは、これらをランダムな順番に並べる。一方、デフォルトの "average "は、これらを平均値で置き換え、"max "と "min "は、それぞれ最大値と最小値で置き換える。na.last=TRUEとna.last=FALSEの場合、それらはxの中で出現する順番に別々の順位が与えられます。 注意：rankはそれ自体ジェネリックではありませんが、xtfrmはジェネリックであり、xtfrmメソッドがあればrank(xtfrm(x), ....)は望ましい結果をもたらします。  そうでない場合、rankは==、>、is.naとクラス化されたオブジェクトの抽出メソッドを使用します。
この関数には2つの基本モードがある。  How = "replace "の場合、オブジェクトの要素のうち、それ自体がリスト状ではなく、classに含まれるクラスを持つものは、その要素にfを適用した結果で置き換えられます。そうでない場合、How = "list "またはHow = "unlist "のモードでは、オブジェクトは概念的にコピーされ、classに含まれるクラスを持つリスト状でない要素はすべて、その要素にfを適用した結果で置き換えられ、それ以外はすべてdefltで置き換えられます。  最後に、もしhow = "unlist "であれば、結果に対してunlist(recursive = TRUE)が呼び出される。
raw型は生のバイトを保持するためのものである。  バイトのシーケンスを抽出したり、要素を置換したりすることができる（ただし、rawベクトルの要素に限る）。  関係演算子（バイト表現の数値順序を使用した比較を参照）は、ビット単位の解釈を持つ論理演算子（論理を参照）と同様に動作します。  rawへの強制は、入力値を小さい（10進）整数を表すものとして扱うので、入力はまず整数に強制され、[0 ... 255]の範囲外かNAの値は0（ヌルバイト）に設定されます。as.rawとis.rawはプリミティブ関数です。
as.rawとis.rawはプリミティブ関数です。入力raw接続がオープンされ、接続オブジェクトの生成時にrawベクトルがコピーされ、クローズされるとコピーが破棄されます。  生ベクトルはConnectionValueで取得することができます。入力と出力の両方で接続がオープンされている場合は、接続がオープンされたときに供給された最初の生ベクトルがコピーされます。
入力未加工コネクションがオープンされ、コネクション・オブジェクトが作成された時点で未加工ベクトルがコピーされ、クローズされるとコピーは破棄される。  生ベクトルは、ConnectionValueから取得することができます。接続が入力と出力の両方でオープンされている場合、提供された最初の生ベクトルは、接続がオープンされているときにコピーされます。
numToBits(.)と packBits(.,type="double")は互いに逆関数であり、例も参照してください。
numToBits(.)と packBits(.,type="double")は、互いに逆関数である。
numToBits(.)とpackBits(., type="double")は互いの逆関数である。
関数cbindとrbindはS3汎用関数で、データフレーム用のメソッドがあります。  少なくとも1つの引数がデータフレームで、残りがベクトルまたは行列の場合、データフレームメソッドが使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスの場合、つまりisS4(.)がtrueの場合、S4メソッドが求められ、パッケージ・メソッドから隠されたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、defaultメソッドと同様にdeparse.levelに従います。defaultメソッドでは、すべてのベクトル/行列はアトミック（vector参照）かリストでなければなりません。  言語オブジェクト（式や呼び出しなど）とペアリストはリストに強制され、その他のオブジェクト（名前や外部ポインタなど）はリスト結果の要素として含まれます。  複数の行列引数がある場合、それらはすべて同じ列数（または行数）でなければならず、これが結果の列数（または行数）となります。  すべての引数がベクトルの場合、結果の列（行）数は最長のベクトルの長さに等しい。  引数に行列とベクトルが混在している場合、結果の列(行)数は行列引数の列(行)数によって決定されます。  cbind(rbind)では、Sとの互換性のため、結果が0行(0列)にならない限り、長さ0のベクトル(NULLを含む)は無視される(S3では0行(0列)の行列は存在せず、Rでも無視されない)。行列は、64ビットシステムでも2^31行(行)および2列(列)以下に制限される。  R 3.2.0からは、より多くの要素を持つ（しかし行と列の制限を満たす）入力行列が許可されます。
関数cbindとrbindは、データフレーム用のメソッドを持つS3汎用関数です。  データ・フレーム・メソッドは、少なくとも1つの引数がデータ・フレームで、残りがベクトルまたは行列の場合に使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスの場合、つまりisS4(.)がtrueの場合、S4メソッドが求められ、パッケージ・メソッドから隠されたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、defaultメソッドと同様にdeparse.levelに従います。defaultメソッドでは、すべてのベクトル/行列はアトミック（vector参照）かリストでなければなりません。  言語オブジェクト（式や呼び出しなど）とペアリストはリストに強制され、その他のオブジェクト（名前や外部ポインタなど）はリスト結果の要素として含まれます。  複数の行列引数がある場合、それらはすべて同じ列数（または行数）でなければならず、これが結果の列数（または行数）となります。  すべての引数がベクトルの場合、結果の列（行）数は最長のベクトルの長さに等しい。  引数に行列とベクトルが混在している場合、結果の列(行)数は行列引数の列(行)数によって決定されます。  cbind(rbind)では、Sとの互換性のため、結果が0行(0列)にならない限り、長さ0のベクトル(NULLを含む)は無視される(S3では0行(0列)の行列は存在せず、Rでも無視されない)。行列は、64ビットシステムでも2^31行(行)および2列(列)以下に制限される。  R 3.2.0からは、より多くの要素を持つ（しかし行と列の制限を満たす）入力行列が許容される。
kappa()では、exact = FALSE (デフォルト)の場合、2-normcondition numberは、安価な近似によって推定されます。  しかし、厳密な計算(svd経由)も十分に速い。1ノルムとInfノルムの条件数は、計算がはるかに速いことに注意。kappa_triはkappa.qrとkappa.defaultから呼び出される内部関数です。LAPACKコードからの結果がうまくいかないと、エラーコードが表示されます。
複素数ベクトルはcomplexで作成できる。  ベクトルはその長さ、実数部と虚数部、またはモジュラスと引数を与えて指定することができる。  (長さだけを与えると複素数のゼロのベクトルが生成されます。)as.complexは引数が複素数型であることを強制しようとします: as.vectorのように名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、すなわち実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られませんが、実数部または虚数部がNaNの複素数は得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義され、solve, eigen, svdも定義されている。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。NA_complex_と上記を参照)、またはプラスマイナス無限大になる。
DCFは、データベースを人間が直接読み書きできるプレーンテキストファイルに格納するためのシンプルなフォーマットである。  DCFは、パッケージの説明や内容など、Rのシステム情報を格納するためにさまざまな場所で使用されている：データベースは1つ以上のレコードから構成され、各レコードは1つ以上の名前付きフィールドを持つ。  すべてのレコードに各フィールドが含まれている必要はない。規則的な行は空白以外の文字で始まる。すなわち、フィールドの名前タグと値を:で区切って持つ（最初の:だけがカウントされる）。  値は空でもよい（つまり空白のみ）。空白で始まる行は、その行の少なくとも1文字が空白でない場合、（前のフィールドへの）継続行となる。  空白でない文字が.だけである継続行は空行とみなされる（複数段落のフィールド値が可能）。レコードは1行以上の空行（すなわち空白のみ）で区切られる。R3.0.2以前では、1行の長さの限界は約8191バイトであった。read.dcf(all = FALSE)は、ファイルをバイト単位で読み込むことに注意する。
conが文字列の場合、関数はfileを呼び出してバイナリモードのファイル接続を取得し、その接続は関数呼び出しの間オープンされる。  接続がオープンされている場合、現在の位置から読み取り/書き込みが行われます。 接続がオープンされていない場合、適切なモード（バイナリ読み取りまたは書き込み）で呼び出しの間オープンされ、その後再びクローズされます。  オープンされている接続は、バイナリ・モードでなければなりません。readBin が生のベクタ con で呼び出された場合、ベクタ内のデータが入力として使用されます。  sizeが指定され、オブジェクトの自然なサイズでない場合、ベクタの各要素は、書き込む前または読み込む前に適切な型に強制されます。  可能なサイズは、整数または論理ベクトルでは1、2、4、場合によっては8、数値ベクトルでは4、8、場合によっては12/16です。  (サイズ1と2の整数を読み込むときにsigned = FALSEの場合を除き、符号付き型として強制演算が行われることに注意。)サイズを変更してもNAは保持されない可能性が高く、拡張精度のサイズはプラットフォーム間で移植性が低い。  readCharとwriteCharは、固定長文字列の読み書きに使用できる。  文字列が現在のロケールのエンコーディングで有効であるかどうかのチェックは行われません。Rの欠損値や特殊値（Inf、-Inf、NaN）の取り扱いについては、「Rデータのインポート/エクスポート」マニュアルで説明されています。
これらの関数は、Cスタイルのゼロ終端文字列を読み書きするreadBinとwriteBinを補完するものです。  これらの関数は、長さが既知の文字列を対象としており、オプションで文字列の終端マークを書き込むことができる。  conが文字列の場合、関数はfileを呼び出してバイナリモードのファイル接続を取得し、その接続は関数呼び出しの間オープンされる。  接続がオープンされている場合、現在の位置から読み取り/書き込みが行われます。 接続がオープンされていない場合、適切なモード（バイナリ読み取りまたは書き込み）で呼び出しの間オープンされ、その後再びクローズされます。  オープンされている接続は、バイナリ・モードでなければなりません。readCharがcon rawベクトルで呼び出された場合、ベクトル内のデータが入力として使用されます。  ASCIIのnul(s)を含む文字列は、readCharによって正しく読み込まれますが、最初のnulで切り捨てられ、警告が表示されます。readCharで要求された文字長が、接続で利用可能なデータよりも長い場合、利用可能なものが返されます。  writeCharでは、要求された文字数が多すぎる場合、出力はゼロパディングされ、警告が表示される。
プロンプト文字列は、通常は256文字(ソースコードで変更可能)の最大許容長に切り詰められる。
conが文字列の場合、関数はfileを呼び出してファイル接続を取得し、そのファイル接続は関数呼び出しの間オープンされる。  これは圧縮ファイルでもよい（ファイルパスのチルダ展開はfileが行う）。  最終行が不完全な場合（最終EOLマーカーがない場合）、動作は接続がブロッキングされているかどうかに依存する。  ブロッキングされていないテキストモード接続の場合、不完全な行は静かにプッシュバックされる。  接続がどのようなモードでオープンされていても、LF、CRLF、CRのいずれかが行のEOLマーカーとして受け入れられます。入力ストリームに埋め込まれたnulは、警告とともに現在読み込まれている行を終了します（skipNul = TRUEまたはwarn = FALSEでない限り）。conがデフォルト以外のエンコーディング引数を持つalready-openでない接続である場合、テキストはUTF-8に変換され、そのように宣言されます（readLinesのエンコーディング引数は無視されます）。
saveRDSとreadRDSは、1つのRobjectを接続（通常はファイル）に保存し、場合によっては別の名前でオブジェクトをリストアする手段を提供します。  これはsaveやloadとは異なり、1つ以上の名前付きオブジェクトを環境に保存したりリストアしたりするものです。  関数serializeとunserializは、シリアライズに対する少し低レベルのインターフェイスを提供します：serializeによって接続にシリアライズされたオブジェクトは、readRDSによって読み戻すことができます。save(compress=FALSE)がfileを使用する場合を除き、fileがファイル名の場合、それはgzfileによって開かれます。  圧縮は、ファイルがファイル名のときにオープンされた接続によって処理されるため、接続によって処理される場合は、ファイルが接続のときにのみ可能です。  接続が提供された場合、まだオープンされていなければ、関数の実行時間の間、(バイナリモードで)オープンされます。すでにオープンされている場合は、saveRDS(ascii = FALSE)または非ASCII保存を読み込むために、バイナリモードでなければなりません。
NA
NA
もしinitが与えられると、Reduceは論理的にそれをxの先頭（左から右へ進む場合）または末尾にそれぞれ追加する。もしこの拡張される可能性のあるベクトルvがn > 1の要素を持つ場合、Reduceはvの要素に左から右へ、または右から左へそれぞれfを連続して適用する。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vが単一の要素しか持たない場合はこれが返され、要素がない場合はNULLが返される。  現在の実装は、安定性とスケーラビリティを確保するために非再帰的である。  duceはfold（Haskellなど）やaccumulate（C++標準テンプレート・ライブラリなど）としても知られている。  Filterは単項述語関数fをxの要素に適用し、必要であれば論理に強制し、これが真を返すxの部分集合を返します。  可能性のあるNA値は現在常にfalseとして扱われることに注意してください。  FindとPositionはそれぞれCommon Lispのfind-ifとposition-ifに倣ったものです。  述語関数がtrueを与える要素がある場合、rightがfalse（デフォルト）かtrueかによって、そのような要素の最初か最後、またはその位置がそれぞれ返されます。  そのような要素がない場合は、nomatchで指定された値が返されます。  Mapはmapplyの単純なラッパーであり、結果を単純化するようなことはしていません。  NegateはCommon Lispの補語に相当する。  述語）関数fが与えられると、fが返す論理否定を返す関数を作成します。
この関数の主な目的は、外部アイテム（例えば一時ファイル）を参照するオブジェクトがR内部から参照されなくなったときにクリーンアップ処理を実行できるようにすることです。特に、.Lastを操作することなく、Rセッションの終了時に実行されるコードをプログラムする方法を提供します。パッケージで使用する場合、名前空間内のオブジェクトにファイナライザを設定するのは良い考えです。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。これらの関数は、それぞれ3つのモードのいずれかで動作します: fixed = TRUE: 完全一致を使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対し、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでなければNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。 これらの関数は、それぞれ3つのモードのいずれかで動作します: fixed = TRUE: 完全一致を使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対し、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでなければNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。perl = TRUE による regexpr および gregexpr は、Python スタイルの名前付きキャプチャを許可しますが、長いベクトル入力は許可しません。現在のロケールでの無効な入力は、最大 5 回まで警告されます。非 ASCII 文字に対する perl = TRUE によるケースレスマッチングは、PCRE ライブラリが 'Unicodeproperty support' でコンパイルされているかどうかに依存します。
packageHasNamespace は、パッケージが名前空間を持っているかどうかを示すのではなく (現在はすべてそうなっています)、むしろ 'NAMESPACE' ファイルを持っているかどうかを示します。  しかし、それはあなたが意図して使っているわけではありません。
packageHasNamespace はパッケージが名前空間を持つかどうかを示すのではありません (現在はすべてそうなっています)。  しかし、そのような使い方は想定されていません。
invertがFALSE（デフォルト）の場合、regmatchesはマッチデータで指定されたマッチ部分文字列を抽出します。  (正規表現から得られる)ベクトルマッチデータの場合、空のマッチは取り除かれます。 リストマッチデータの場合、空のマッチは空の成分(長さゼロの文字ベクトル)を与えます、invertがNAの場合、regmatchesはマッチしていない部分文字列とマッチした部分文字列の両方を抽出し、常にマッチしていない部分文字列で始まり、マッチしていない部分文字列で終わります（マッチがそれぞれ最初か最後に起こった場合は空です）。  そうでない場合は、 mと同じ長さの文字ベクトルのリストとなり、それぞれが必要な置換数と同じ長さになります。  置換は、値を文字またはリストに強制し、必要に応じて値を再利用する。
invertがFALSE（デフォルト）の場合、regmatchesはマッチデータで指定されたマッチ部分文字列を抽出します。  リストマッチデータの場合、空のマッチは空の成分(長さ0の文字ベクトル)を与えます。 invertがTRUEの場合、regmatchesはマッチした部分文字列を抽出します、invertがNAの場合、regmatchesはマッチしていない部分文字列とマッチした部分文字列の両方を抽出し、常にマッチしていない部分文字列で始まり、マッチしていない部分文字列で終わります（マッチがそれぞれ最初か最後に起こった場合は空です）。  そうでない場合は、 mと同じ長さの文字ベクトルのリストとなり、それぞれが必要な置換数と同じ長さになります。  置換は、値を文字またはリストに強制し、必要に応じて値を再利用します。
pos 引数は、オブジェクトを削除する環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするために sys.frame を使用することを含む）として指定することができます。以前のバージョンのRでは、...で文字ベクトルを指定すると、その文字ベクトルで指定されたオブジェクトが削除されるという誤った主張がありましたが、これは文字ベクトルが削除されるのです。  文字ベクトルでオブジェクトを指定するにはlist引数を使用する。
トップレベル・タスクは、入力行全体ではなく個々の式である。  トップレベル・タスクのコールバックは、トップレベル・タスクの式、トップレベル・タスクの結果、正常に終了したかどうかを示す論理値（常にTRUE）、結果がプリントされたかどうかを示す論理値で呼び出される。  コールバック関数は論理値を返す必要があります。値がFALSEの場合、コールバックはタスクリストから削除され、このメカニズムによって再度呼び出されることはありません。関数がTRUEを返した場合、その関数はリストに保持され、次のトップレベルタスクの完了時に呼び出されます。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つだけ指定されますが、それぞれが他の2つのどちらかと一緒に指定された場合、その複製が最初に実行され、その後、timesまたはlength.outによって暗示される複製が実行されます。timesが1つの整数で構成されている場合、結果は、この回数だけ繰り返された入力全体から構成されます。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され、それが正の場合、値は抽出規則、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つしか指定されませんが、他の2つの引数のいずれかと一緒に指定された場合、その複製が最初に実行され、次にtimesまたはlength.outで指定された複製が実行されます。timesが1つの整数で構成されている場合、結果は入力全体がこの回数だけ繰り返されたものになります。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され、それが正の場合、値は抽出規則、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つしか指定されませんが、他の2つの引数のいずれかと一緒に指定された場合、その複製が最初に実行され、次にtimesまたはlength.outで指定された複製が実行されます。timesが1つの整数で構成されている場合、結果は入力全体がこの回数だけ繰り返されたものになります。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され正の場合、値は抽出規則、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、 signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のためのメソッドもあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つだけ指定されますが、他の2つの引数のいずれかと一緒に指定された場合、その複製が最初に実行され、その後、timesまたはlength.outによって暗示される複製が実行されます。timesが1つの整数で構成されている場合、結果は、この回数だけ繰り返された入力全体から構成されます。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され、それが正の場合、値は抽出ルール、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つしか指定されませんが、他の2つの引数のいずれかと一緒に指定された場合、その複製が最初に実行され、次にtimesまたはlength.outで指定された複製が実行されます。timesが1つの整数で構成されている場合、結果は入力全体がこの回数だけ繰り返されたものになります。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され、それが正の場合、値は抽出ルール、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷が可能な表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つだけ指定されるが、他の2つの引数のいずれかと一緒に指定された場合、その複製が最初に実行され、次にtimesまたはlength.outで指定された複製が実行される。timesが1つの整数で構成されている場合、結果は入力全体がこの回数だけ繰り返されたものになる。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され、それが正の場合、値は抽出規則、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
デフォルトの動作は、呼び出された場合と同じです。  通常、追加引数は1つしか指定されませんが、他の2つの引数のいずれかと一緒に指定された場合、その複製が最初に実行され、次にtimesまたはlength.outで指定された複製が実行されます。timesが1つの整数で構成されている場合、結果は入力全体がこの回数だけ繰り返されたものになります。  length.outがtimesの代わりに与えられることもあり、その場合xはこの長さのベクトルを作るのに必要な回数だけ繰り返される。  もし両方が与えられた場合、length.outが優先され、timesは無視される。timesの非整数値はゼロに向かって切り捨てられる。もしtimesが計算量であれば、小さなファズを加えるか、roundを使うのが賢明である。  xの長さがゼロでlength.outが供給され、それが正である場合、値は抽出ルール、つまりアトミックベクトルの場合は適切なクラスのNA（生のベクトルの場合は0）、リストの場合はNULLで埋められます。
breakはfor、while、またはrepeatループから抜け出し、制御は最内周のループの外側にある最初の文に移されます。  breakもnextも、入れ子になったループの一番内側だけに適用される。よくある間違いだが、ステートメントを中括弧（{ .. }）で囲むのを忘れることがある、特に、キーボードやソースからif...else構文を入力する際の構文エラーを避けるために、}とelseの間に改行を入れるべきではありません。そのため、防御的なプログラミングの（やや極端な）姿勢の1つとして、if句などには常に中括弧を使用することが挙げられます。  seqの長さがゼロの場合、ループの本体はスキップされる。そうでなければ、変数varにseqの各要素の値が順番に代入される。ループ本体内でvarに代入することもできるが、次の繰り返しには影響しない。  ループが終了しても、varは最新の値を含む変数として残る。
NA
FUNは、match.funの呼び出しによって検出され、通常、関数またはシンボル（例えば、バッククォートされた名前）として指定される、関数FUNは、Xの要素のいずれかを入力として受け取ることができなければならない。後者がアトミックベクトルの場合、FUNは常にXと同じ型の長さ1のベクトルを渡される。  汎用的なコードでは、...を通過させる場合、最初の2つの引数にXとFUNという名前を付けるのが良い方法である。これにより、FUNへの部分一致を避けることができ、XまたはFUNという名前の引数が...を通過した場合、賢明なエラーメッセージが表示されるようになる。  共通の長さが 1 の場合、結果はベクトルになり、1 より大きい場合は X の各要素に対応する列を持つ行列になります。  この関数は、FUNの全ての値がFUN.VALUEと互換性があり、長さと型が同じでなければならないことをチェックします(型は、logical< integer < double < complexの順序で上位の型に昇格することができますが、降格することはできません)。S4クラスのユーザは、lapplyとvapplyにリストを渡す必要があります: 内部的な強制は、基本名前空間内のas.listによって行われ、ユーザによって定義されるものではありません(例えば、基本関数にS4methodsを設定することによって)。
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、そのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locのデフォルト値(NULL)とともに使用すると、ライブラリよりも先にアタッチされているパッケージが検索されます。
関数loadNamespaceとattachNamespaceは、通常、libraryを使用して名前空間と必要なインポートをロードするときに暗黙的に呼び出されます。  loadNamespace は、指定された名前空間をロードし、内部データベースに登録します。  指定された名前空間がすでにロードされているときに、その名前空間をロードするように要求しても、何の効果もありません。  引数は、libraryへの対応する引数と同じ意味を持っています。libraryのヘルプ・ページでは、特定のインストール済みパッケージがどのように選択されるかの詳細が説明されています。  ロード後、loadNamespaceは.onLoadという名前のフック関数を名前空間の内部変数として探します（これはエクスポートされるべきではありません）。  loadNamespaceは読み込んだ名前空間を検索パスにアタッチしません。attachNamespaceを使用すると、名前空間のエクスポートされた値を含むフレームを検索パスにアタッチできます（ただし、これはほとんどの場合ライブラリ経由で実行されます）。  isNamespaceLoaded(pkg)はpkg %in%loadedNamespaces()と同等ですが、pkg %in%loadedNamespaces()よりも効率的です。unloadNamespaceを使用すると、名前空間を強制的にアンロードすることができます。  名前空間がアタッチされている場合、最初にその名前空間がデタッチされ、それによって、名前空間に.onDetach関数または.Last.lib関数がエクスポートされている場合はその関数が実行されます。  名前空間が他のロードされた名前空間によってインポートされた場合、エラーがシグナルされ、名前空間はアンロードされない。  定義されている場合、内部レジストリから名前空間を削除する前にフック関数.onUnloadが実行されます。名前空間のアンロードと再ロードに関するいくつかの問題については、detachのヘルプのコメントを参照してください。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができ、その場合はfindRestartを使用してrestartを見つけます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すことはできません。
tracememとuntracememは、Rがメモリ・プロファイリング付きでコンパイルされていない場合にエラーを出しますが、retracememはエラーを出しません（そのため、開発中のコードに残しておくことができます）。C関数duplicateによるオブジェクトのコピーがトレースされると、.Cまたは.Fortranに引数を渡すときの型強制やコピーと同様に、標準出力にメッセージが出力される。メッセージは、文字列tracemem、コピーされるオブジェクトと作成される新しいオブジェクトの識別文字列、および複製が発生した場所を示すスタックトレースで構成される、関数をトレースすることはできません。trace と競合するためです。また、NULL、環境、約束、弱い参照、外部ポインタ・オブジェクトをトレースすることは有用ではありません。
引数リストの名前は、バッククォートされた非標準名（'backquote'を参照）であることができます。  単一の式の場合、評価された式の値が返されます。(式は、return が呼び出されるとすぐに、関数の評価枠内で、on.exit 式が評価される前に評価されます。)return が呼び出されずに関数の終わりに達した場合、最後に評価された式の値が返されます。この短縮形は、単純な関数式を含むコードを読みやすくするのに役立ちます。
trace関数は、関数（またはシグネチャが指定された場合はメソッド）の改訂版を構築し、元のオブジェ クトが見つかった場所に新しいオブジェクトを代入します。what引数だけが指定された場 合、関数を呼び出すたびに1行のtrace出力が生成されます（以前のバージョンのtraceと互換性 があります）。traceによって構築されるオブジェクトは、"function "を継承したクラスであり、オリジナルの、トレースされていないバージョンを含んでいます。untraceの呼び出しは、このバージョンを再割り当てします。引数tracerまたはexitが関数の名前である場合、トレース式は、引数なしで、その関数の呼び出しになります。  前者はトレースされる関数のフレームをブラウズし、後者は現在アクティブな呼び出しのいずれかをブラウズすることができます。引数tracerとexitは、それらが関数であるかどうかを確認するために評価されますが、それらの名前だけがトレース式で使用されます。  tracerまたはexitの引数は、評価されない式（quoteまたはsubstituteの呼び出しによって返されるような）であることもできます。  この式自体はトレースされる関数に挿入されるため、通常はトレースされる関数の引数やローカルオブジェクトを含むことになります。  この形式の式は、特定の条件が適用された場合にのみ対話したい場合に便利です（この場合、おそらくtraceの呼び出しでもprint = FALSEを指定したいでしょう）。at引数が指定された場合、関数本体のサブステップを参照する整数のベクトルにすることができます（これは、関数本体が{ ...}で囲まれている場合にのみ機能します）。  この場合、トレーサーは入力時に呼び出されるのではなく、at.でリストされた各ステップを評価する直前に呼び出されます。  (ヒント:印刷されたバージョンの関数のステップを数えようとしないでください。代わりに、as.list(body(f))を見て、関数fのステップに関連する数字を取得してください。)at引数は、整数ベクトルのリストであることもできます。  この場合、各ベクトルは関数の別のステップに入れ子になっているステップを指します。  例えば、at = list(c(3,4))は、関数の第3ステップの第4ステップの直前にトレーサーを呼び出します。  exit引数はon.exit処理中に呼び出されます。  on.exit式では、関数が返そうとしている値を得るために、実験的なreturnValue()関数を呼び出すことができる。exit引数の本質的な制限は、関数自体がon.exitをadd= FALSE（デフォルト）で使用している場合、既存の呼び出しがtraceによって提供されたものを上書きするため、機能しないということです。  トレースはネストしません。トレースを呼び出すと、その関数やメソッドの以前にトレースされたバージョンが置き換えられます（後述する編集バージョンを除く）。  (ネストされたトレースを許すと、混乱や誤ってトレースされたバージョンを残してしまう可能性が高すぎます。)edit引数が繰り返し使用され、その間に同じ関数やメソッドでtountraceが呼び出されない場合、以前に編集されたバージョンが保持されます。  以前のトレースをすべて捨ててから編集したい場合は、次にtraceを呼び出す前にuntraceを呼び出してください。  編集は自動トレースと組み合わせることができます。tracerなどの他の引数とedit引数を指定するだけです。  edit = TRUE引数はデフォルトのエディタを使用します(editを参照)。ベースパッケージからのプリミティブ関数(組み込み関数と特殊関数)のトレースは機能しますが、特別なメカニズムによってのみ機能し、あまり有益ではありません。  プリミティブをトレースすると、プリミティブは引数...（だけ）を持つ関数で置き換えられます。  少しは情報が得られますが、それほど多くはありません。  トレースされた関数は、セッションイメージに保存されている場合、トレースされた関数のトレースされたバージョンは、セッションから別のセッションに引き継がれます。  (次のセッションでは、untraceでトレースが削除されます。) 一方、グローバル環境ではなく、パッケージ内にあった関数は、イメージに保存されません。S4メソッドのトレースは基本的に関数のトレースと同じですが、トレースされたバージョンは直接の代入ではなくsetMethodの呼び出しによって保存され、untraceの呼び出しの後にはトレースされないバージョンになるという例外があります。  S-Plusのトレースはセッション・フレームを使用し、その結果、トレースはあるセッションから別のセッションに引き継がれることはない（Rdはセッション・フレームを持たない）。  もう一つの違いは、トレースとは直接関係ありません：  S-Plusのブラウザは、ブラウズしているフレームに変更を加えることができ、ブラウザを終了しても変更は持続します。  Rブラウザーは変更が可能だが、ブラウザーが終了すると消えてしまう。  このことは、S-Plus版ではコードの変更をインタラクティブに試すことができるが、R版ではできないことに関係していると思われる。  (将来のリビジョンでは、R用の「破壊的」ブラウザが含まれるかもしれない)。
NA
NA
inverse.rle()はrle()の逆関数で、runからxを再構築します。
pos 引数は、いくつかの方法でオブジェクトを削除する環境を指定することができます： 整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするために sys.frame を使用することを含む）として。以前のバージョンのRでは、...で文字ベクトルを指定すると、その文字ベクトルで指定されたオブジェクトが削除されるという誤った主張がありましたが、これは文字ベクトルが削除されるのです。  文字ベクトルでオブジェクトを指定するにはlist引数を使用する。
現在利用可能なRNGの種類を以下に示す。  デフォルトは "Mersenne-Twister "である。.Random.seed[-1] == r[1:3]は長さ3の整数ベクトルで、各r[i]は1:(p[i] - 1)の中にある。Wichmann-Hill生成器のサイクル長は6.9536e12(=prod(p-1)/4, Applied Statistics (1984)33, 123を参照)である。TestU01のCrushスイートでは12回、BigCrushスイートでは22回の明らかな失敗がある(L'Ecuyer, 2007).GeorgeMarsagliaがメーリングリスト'sci.stat.math'への投稿で推奨しているmultiply-with-carry RNGが使われている。L'EcuyerのTestU01 Crush suiteでは、40の明確な失敗がある。Ahrens-DieterやKinderman-Ramageと組み合わせると、一変量分布の生成でも正規性からのずれを示す。  種は2つの整数（すべての値が許される）。Marsagliaの70年代の有名なSuper-Duper。  DiehardbatteryのMTUPLEテストに合格しないオリジナルバージョン。  ほとんどの初期シードに対して約4.6*10^18の周期を持つ。  2つの種はそれぞれTauswortheとcongruenceの長整数である。  S'sの.Random.seed[1:12]への一対一のマッピングも可能であるが、少なくともこのジェネレータが最近のバージョンのS-PLUSのものと全く同じでないため、公開はしない。TestU01 Crush suite (L'Ecuyer, 2007)では、25の明らかな失敗を示している。  RはB. D. Ripleyによる独自の初期化法を用いており、2002年の更新で対処されたMatsumoto and Nishimuraの1998年のコードにおける初期化の問題には影響されない。TestU01 CrushとBigCrushスイート(L'Ecuyer, 2007)のそれぞれで2つの明確な失敗を示す。  つまり、使用される再帰はX[j] = (X[j-100] - X[j-37]) mod 2^30であり、「シード」は最後の100個の数字の集合である（実際には101個の数字として記録され、最後の数字はバッファの周期的シフトである）。  2002年のバージョンは、それ以前のバージョンと後方互換性がなかった：種からのGFSRの初期化が変更され、Rは連続した種、報告された'弱点'を選択することができず、すでに種をスクランブルした。それ以外は、アルゴリズムはKnuth-TAOCP-2002と同じで、同じラグを持つフィボナッチ漸化式である。このジェネレータの初期化は解釈されたRコードで行われるため、短時間ではあるが顕著な時間がかかる。TestU01 Crushスイートでは3回、BigCrushスイートでは4回明らかな失敗を示した(L'Ecuyer, 2007)。L'Ecuyer(1999)の「複合多重再帰ジェネレータ」は、各要素が3つの整数要素を持つフィードバック乗算ジェネレータである：したがって、シードは長さ6の(符号付き)整数ベクトルである。  最初の3つも最後の3つもすべて0であってはならず、それぞれ4294967087と4294944443以下に制限される。これ自体は特に面白くはないが、パッケージ・パラレルで使用される複数のストリームの基礎となる。TestU01 CrushとBigCrushスイート（L'Ecuyer, 2007）では、それぞれ6つの明確な失敗が見られる。  normal.kindには、"Kinderman-Ramage"、"Buggy Kinderman-Ramage"（set.seedでは使用不可）、"Ahrens-Dieter"、"Box-Muller"、"Inversion"（デフォルト）、または "user-supplied "が使用できる。  (1.7.0より前のバージョンで使用されていたKinderman-Ramageジェネレータ(現在は "Buggy "と呼ばれています)にはいくつかの近似誤差があり、古い結果の再現にのみ使用すべきです。  Box-Muller "ジェネレータは、正規値のペアが順次生成され返されるため、ステートフルです。  サンプル.kindは "Rounding "または "Rejection"、あるいはこれらの部分一致にすることができる。  前者は3.6.0より前のバージョンではデフォルトでした。これは大きな母集団でサンプルが著しく不均一になるため、古い結果の再現にのみ使用すべきです。  set.seedは1つの整数引数を用いて、必要な数のseedを設定します。  set.seedは、小さな整数引数を指定することで、かなり異なるseedを得るための簡単な方法であり、また、より複雑な手法（特に "Mersenne-Twister "と "Knuth-TAOCP"）に対して有効なseedセットを得るための方法でもある。  seedの値が異なるとRNGの播種が異なるという保証はないが、例外は極めて稀であろう。  RNGkindまたはset.seedでkind = NULL、normal.kind = NULLまたはsample.kind = NULLを使用すると、現在使用されているジェネレータが選択されます(ワークスペースが復元されている場合、前のセッションで使用されたものも含む)。
現在使用可能なRNGの種類を以下に示す。  デフォルトは "Mersenne-Twister "である。.Random.seed[-1] == r[1:3]は長さ3の整数ベクトルで、各r[i]は1:(p[i] - 1)に含まれる。Wichmann-Hill生成器のサイクル長は6.9536e12(=prod(p-1)/4, Applied Statistics (1984)33, 123を参照)である。TestU01のCrushスイートでは12回、BigCrushスイートでは22回の明らかな失敗がある(L'Ecuyer, 2007).GeorgeMarsagliaがメーリングリスト'sci.stat.math'への投稿で推奨しているmultiply-with-carry RNGが使われている。L'EcuyerのTestU01 Crush suiteでは、40の明確な失敗がある。Ahrens-DieterやKinderman-Ramageと組み合わせると、一変量分布の生成でも正規性からのずれを示す。  種は2つの整数（すべての値が許される）。Marsagliaの70年代の有名なSuper-Duper。  DiehardbatteryのMTUPLEテストに合格しないオリジナルバージョン。  ほとんどの初期シードに対して約4.6*10^18の周期を持つ。  2つの種はそれぞれTauswortheとcongruenceの長整数である。  S'sの.Random.seed[1:12]への一対一のマッピングも可能であるが、少なくともこのジェネレータが最近のバージョンのS-PLUSのものと全く同じでないため、公開はしない。TestU01 Crush suite (L'Ecuyer, 2007)では、25の明らかな失敗を示している。  RはB. D. Ripleyによる独自の初期化法を用いており、2002年の更新で対処されたMatsumoto and Nishimuraの1998年のコードにおける初期化の問題には影響されない。TestU01 CrushとBigCrushスイート(L'Ecuyer, 2007)のそれぞれで2つの明確な失敗を示す。  つまり、使用される再帰はX[j] = (X[j-100] - X[j-37]) mod 2^30であり、「シード」は最後の100個の数字の集合である（実際には101個の数字として記録され、最後の数字はバッファの周期的なシフトである）。  2002年のバージョンは、それ以前のバージョンと後方互換性がなかった：種からのGFSRの初期化が変更され、Rは連続した種、報告された'弱点'を選択することができず、すでに種をスクランブルした。それ以外は、アルゴリズムはKnuth-TAOCP-2002と同じで、同じラグを持つフィボナッチ漸化式である。このジェネレータの初期化は解釈されたRコードで行われるため、短時間ではあるが顕著な時間がかかる。TestU01 Crushスイートでは3回、BigCrushスイートでは4回明らかな失敗を示した(L'Ecuyer, 2007)。L'Ecuyer(1999)の「複合多重再帰ジェネレータ」は、各要素が3つの整数要素を持つフィードバック乗算ジェネレータである：したがって、シードは長さ6の(符号付き)整数ベクトルである。  最初の3つも最後の3つもすべて0であってはならず、それぞれ4294967087と4294944443以下に制限される。これ自体は特に面白くはないが、パッケージ・パラレルで使用される複数のストリームの基礎となる。TestU01 CrushとBigCrushスイート（L'Ecuyer, 2007）では、それぞれ6つの明確な失敗が見られる。  normal.kindには、"Kinderman-Ramage"、"Buggy Kinderman-Ramage"（set.seedでは使用不可）、"Ahrens-Dieter"、"Box-Muller"、"Inversion"（デフォルト）、または "user-supplied "が使用できる。  (1.7.0より前のバージョンで使用されていたKinderman-Ramageジェネレータ(現在は "Buggy "と呼ばれています)にはいくつかの近似誤差があり、古い結果の再現にのみ使用すべきです。  Box-Muller "ジェネレータは、正規値のペアが順次生成され返されるため、ステートフルです。  サンプル.kindは "Rounding "または "Rejection"、あるいはこれらの部分一致にすることができる。  前者は3.6.0より前のバージョンではデフォルトでした。これは大きな母集団でサンプルが著しく不均一になるため、古い結果の再現にのみ使用すべきです。  set.seedは1つの整数引数を用いて、必要な数のseedを設定します。  set.seedは、小さな整数引数を指定することで、かなり異なるseedを得るための簡単な方法であり、また、より複雑な手法（特に "Mersenne-Twister "と "Knuth-TAOCP"）に対して有効なseedセットを得るための方法でもある。  seedの値が異なるとRNGの播種が異なるという保証はないが、例外は極めて稀であろう。  RNGkindまたはset.seedでkind = NULL、normal.kind = NULLまたはsample.kind = NULLを使用すると、現在使用されているジェネレータが選択されます(ワークスペースが復元されている場合、前のセッションで使用されたものも含む)。
5を四捨五入する場合、IEC 60559標準（'IEEE 754'も参照）が使用され、'偶数桁に行く'ことが期待されていることに注意してください。  ただし、これはOSのサービスや表示誤差に依存する（例えば0.15は正確に表現されていないため、丸めルールは表現された数字に適用され、印刷された数字には適用されないため、round(0.15, 1)は0.1にも0.2にもなりうる）。例えば、 round(x, digits = -2) は、最も近い100に丸められます。signifの場合、digitsの認識値は1...22であり、欠落していない値は、その範囲の最も近い整数に丸められます。  複素数は、指定された桁数を保持するように、成分の大きいほうに丸められます。  これらはすべてプリミティブ関数です。
時刻は、秒、分、時、日、月、年のいずれかに丸められたり切り捨てられたりします。  タイムゾーンは、現在のタイムゾーンの真夜中が使用される場合、日以上にのみ関連しています。クラス "Date "のメソッドは、端数の日を削除する以外にはほとんど使用されません。
時刻は、秒、分、時、日、月、年の単位で丸められたり、切り捨てられたりします。  タイムゾーンは、現在のタイムゾーンの深夜が使用される場合、日以上にのみ関連します。クラス "Date" のメソッドは、端数日を削除する以外にはほとんど使用されません。
NA
データフレームは（定義上）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落した値も重複した値も含みません。  行名のシーケンスがこの要求を満たすためにソフトウェアによって追加された場合、それらは'自動的'とみなされます。行名は現在のところ整数でも文字でもかまいませんが、後方互換性のために（R <= 2.4.0との）row.namesは常に文字ベクトルを返します。  (整数値の行名の集合を取り出す必要がある場合は、attr(x, "row.names")を使用してください。) 値にNULLを使用すると、行名はseq_len(nrow(x))にリセットされ、'自動'とみなされます。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落した値も重複した値も含みません。  行名のシーケンスがこの要求を満たすためにソフトウェアによって追加された場合、それらは'automatic'とみなされます。行名は現在のところ整数でも文字でもかまいませんが、後方互換性のために（R <= 2.4.0との）row.namesは常に文字ベクトルを返します。  (整数値の行名の集合を取り出す必要がある場合は、attr(x, "row.names")を使用してください。) 値にNULLを使用すると、行名はseq_len(nrow(x))にリセットされ、'自動'とみなされます。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落した値も重複した値も含みません。  行名のシーケンスがこの要求を満たすためにソフトウェアによって追加された場合、それらは'automatic'とみなされます。行名は現在のところ整数でも文字でもかまいませんが、後方互換性のために（R <= 2.4.0との）row.namesは常に文字ベクトルを返します。  (整数値の行名の集合を取り出す必要がある場合は、attr(x, "row.names")を使用してください。) 値にNULLを使用すると、行名はseq_len(nrow(x))にリセットされ、'自動'とみなされます。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落した値も重複した値も含みません。  行名のシーケンスがこの要求を満たすためにソフトウェアによって追加された場合、それらは'automatic'とみなされます。行名は現在のところ整数でも文字でもかまいませんが、後方互換性のために（R <= 2.4.0との）row.namesは常に文字ベクトルを返します。  (整数値の行名の集合を取り出す必要がある場合は、attr(x, "row.names")を使用してください。) 値にNULLを使用すると、行名はseq_len(nrow(x))にリセットされ、'自動'とみなされます。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落した値も重複した値も含みません。  行名のシーケンスがこの要求を満たすためにソフトウェアによって追加された場合、それらは'automatic'とみなされます。行名は現在のところ整数でも文字でもかまいませんが、後方互換性のために（R <= 2.4.0との）row.namesは常に文字ベクトルを返します。  (整数値の行名の集合を取り出す必要がある場合は、attr(x, "row.names")を使用してください。) 値にNULLを使用すると、行名はseq_len(nrow(x))にリセットされ、'自動'とみなされます。
データフレームは（定義により）行名のベクトルを持ち、そのベクトルはデータフレームの行数と同じ長さを持ち、欠落した値も重複した値も含みません。  行名のシーケンスがこの要求を満たすためにソフトウェアによって追加された場合、それらは'automatic'とみなされます。行名は現在のところ整数でも文字でもかまいませんが、後方互換性のために（R <= 2.4.0との）row.namesは常に文字ベクトルを返します。  (整数値の行名の集合を取得する必要がある場合は、attr(x, "row.names")を使用してください。) 値にNULLを使用すると、行名はseq_len(nrow(x))にリセットされ、'自動'とみなされます。
これらの関数は、applyにFUN = meanまたはFUN = sumを適切なマージン付きで使用するのと同等ですが、より高速です。  これらの関数は高速化のために書かれているため、NaNとNAの微妙な点がぼやけてしまっている。  もしna.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、これはプラットフォームに依存するかもしれない。欠損値の省略は列または行単位で行われるので、列の平均は同じ行の集合にならないかもしれないし、その逆もあり得ることに注意。  完全な行または列のみを使用するには、まずna.omitまたはcomplete.cases（xの転置の場合あり）でそれらを選択します。名前に最初のドットが付いたバージョン（.colSums()など）は、プログラミングで使用するための「素の」バージョンです：これらは数値（のような）行列にのみ適用され、結果に名前を付けません。
オブジェクトに dimnamest がある場合、最初のコンポーネントは行名として使用され、2番目のコンポーネント（もしあれば）は列名として使用されます。  do.NULLがFALSEの場合、nodimnamesが存在するか、dimnamesの対応する成分がNULLであれば、単純な数値の前に接頭辞を付加した文字ベクトル（長さNROW(x)またはNCOL(x)）が返されます。配列/行列の置換メソッドは、value の vector と factor の値を文字に強制しますが、foras.character のメソッドはディスパッチしません。データフレームの場合、rownames の value は、重複せず欠落しない名前の文字ベクトルであるべきであり（これは強制されます）、colnames の value は、（できれば）一意な構文的に有効な名前の文字ベクトルであるべきです。  どちらの場合も、valueはas.characterに強制され、colnamesを設定すると行名がcharacterに変換されます。
オブジェクトがdimnamestを持つ場合、第1成分が行名として使用され、第2成分（もしあれば）が列名として使用されます。  do.NULLがFALSEの場合、nodimnamesが存在するか、dimnamesの対応する成分がNULLであれば、単純な数値の前に接頭辞を付加した文字ベクトル（長さNROW(x)またはNCOL(x)）が返されます。配列/行列の置換メソッドは、value の vector と factor の値を文字に強制しますが、foras.character のメソッドはディスパッチしません。データフレームの場合、rownames の value は、重複せず欠落していない名前の文字ベクトルであるべきであり（これは強制されます）、colnames の value は、（できれば）一意な構文的に有効な名前の文字ベクトルであるべきです。  どちらの場合も、valueはas.characterに強制され、colnamesを設定すると行名がcharacterに変換されます。
デフォルトは、以下の例のように、tapplyと一致するように行を並べ替える。  元の関数はTerry Therneauによって書かれたが、これはハッシュを使用した新しい実装であり、大きな行列に対してより高速である。行列の全ての行（つまり、1つのグループ）の和を求めるには、ecolSumsを使用するとさらに高速である。整数引数の場合、和を求める際のオーバーフロー/アンダーフローの結果はNAとなる。
デフォルトでは、以下の例のようにtapplyと一致するように行を並べ替える。  元の関数はTerry Therneauによって書かれたが、これはハッシュを使用した新しい実装であり、大きな行列に対してより高速である。行列のすべての行（つまり、1つのグループ）の和を求めるには、ecolSumsを使用するとさらに高速である。
デフォルトでは、以下の例のようにtapplyと一致するように行を並べ替える。  元の関数はTerry Therneauによって書かれたが、これはハッシュを使用した新しい実装であり、大きな行列に対してより高速である。行列のすべての行（すなわち、1つのグループ）の和を求めるには、ecolSumsを使用する。
これらの関数は、FUN = meanまたはFUN = sumで適切なマージンをとってapplyを使用するのと同じですが、より高速です。  これらの関数は高速化のために書かれているため、NaNとNAの微妙な点がぼやけてしまっている。  もしna.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、これはプラットフォームに依存するかもしれない。欠損値の省略は列または行単位で行われるので、列の平均は同じ行の集合にならないかもしれないし、その逆もあり得ることに注意。  完全な行または列のみを使用するには、まずna.omitまたはcomplete.cases（xの転置の場合もある）でそれらを選択する。名前に最初のドットが付いたバージョン（.colSums()など）は、プログラミングで使用するための「基本的な」バージョンであり、数値（のような）行列にのみ適用され、結果に名前を付けない。
xの長さが1であり、（is.numericの意味で）数値であり、x >= 1である場合、サンプルのサンプリングは1:xから行われます。  この便利な機能は、sample(x)のような呼び出しでxが様々な長さである場合、望ましくない動作につながる可能性があることに注意してください。  そうでなければ、xは、長さと整数によるサブセットが意味を持つ任意のRオブジェクトにすることができます：sample(x)はx(または1:x)の要素のランダムな並べ替えを生成します。n = 0または長さゼロのxでsize = 0のサンプルを求めることは可能ですが、そうでなければn > 0または正の長さ(x)が要求されます。オプションのprob引数は、サンプリングされるベクトルの要素を得るための重みのベクトルを与えるために使用することができます。  replaceがtrueの場合、Walkerのエイリアス法(Ripley, 1987)が200以上の値がある場合に使用される。  引数nはinteger型の最大の整数より大きく、double型の表現可能な最大の整数まで指定できる。  一様サンプリングのみがサポートされる。  大きな整数を一様にサンプリングするために2つの乱数が使われる。
xの長さが1であり、（is.numericの意味で）数値であり、x >= 1である場合、サンプリングは1:xから行われる。  この便利な機能は、sample(x)のような呼び出しで、xが様々な長さである場合、望ましくない動作につながる可能性があることに注意してください。  そうでなければ、xは、長さと整数によるサブセットが意味を持つ任意のRオブジェクトにすることができます：sample(x)はx(または1:x)の要素のランダムな並べ替えを生成します。n = 0または長さゼロのxでsize = 0のサンプルを求めることは可能ですが、そうでなければn > 0または正の長さ(x)が要求されます。オプションのprob引数は、サンプリングされるベクトルの要素を得るための重みのベクトルを与えるために使用することができます。  replaceがtrueの場合、Walkerのエイリアス法(Ripley, 1987)が200以上の値がある場合に使用される。  引数nはinteger型の最大の整数より大きく、double型の表現可能な最大の整数まで指定できる。  一様サンプリングのみがサポートされる。  大きな整数を一様にサンプリングするために2つの乱数が使われる。
FUNはmatch.funの呼び出しによって検出され、通常、関数またはシンボル（バッククオートされた名前など）として指定される、FUNはmatch.funの呼び出しによって発見され、通常、関数またはシンボル（バッククオートされた名前など）、あるいはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定される。関数FUNはXの要素のいずれかを入力として受け取ることができなければならない。後者がアトミックベクトルの場合、FUNは常にXと同じ型の長さ1のベクトルを渡される。  汎用的なコードでは、...を通過させる場合、最初の2つの引数にXとFUNという名前を付けるのが良い方法である。これにより、FUNへの部分一致を避けることができ、XまたはFUNという名前の引数が...を通過した場合、賢明なエラーメッセージが表示されるようになる。  共通の長さが 1 の場合、結果はベクトルになり、1 より大きい場合は X の各要素に対応する列を持つ行列になります。  この関数は、FUNの全ての値がFUN.VALUEと互換性があり、長さと型が同じであることをチェックします(型は、logical< integer < double < complexの順序で上位の型に昇格することができますが、降格することはできません)。S4クラスのユーザは、lapplyとvapplyにリストを渡す必要があります: 内部的な強制は、基本名前空間内のas.listによって行われ、ユーザによって定義されるものではありません(例えば、基本関数にS4methodsを設定することによって)。
...でシンボル（または文字列）として、またはlistで文字ベクトルとして指定されたオブジェクトの名前は、環境envirからオブジェクトを検索するために使用されます。  デフォルトでは、プロミスは評価されますが、eval.promise = FALSEの場合、プロミスは（評価環境とともに）保存されます（オブジェクトに埋め込まれたプロミスは常に評価されずに保存されます）。すべてのRプラットフォームでは、バイナリ保存ファイルのCのintとdoublesのXDR（bigendian）表現が使用され、これらはすべてのRプラットフォーム間で移植可能です。  ASCIIセーブは、圧縮を使用しない場合、バイナリ・セーブよりもコンパクトになりますが、読み込みと書き込みの両方でほとんど常に低コストになります。  save.defaults "オプション(saveとsave.imageの両方で使用)で、ascii、compress、safe、versionの引数のデフォルト値を変更することができます。  もし "save.image.defaults "オプションが設定されていれば、それは関数save.imageの "save.defaults "よりも優先して使用されます（これは異なるデフォルトを持つことを可能にします）。  さらに、"save.defaults "オプションの一部として、"compression_level "を指定することもできます。まだ開いていない接続は、"wb "モードで開かれます。  開いていてバイナリ・モードでない接続を指定するとエラーになります。
...でシンボル（または文字列）として、またはlistで文字ベクトルとして指定されたオブジェクトの名前は、環境envirからオブジェクトを検索するために使用されます。  デフォルトでは、プロミスは評価されますが、eval.promise = FALSEの場合、プロミスは（その評価環境とともに）保存されます（オブジェクトに埋め込まれたプロミスは常に評価されずに保存されます）。すべてのRプラットフォームで、バイナリ保存ファイルのCのintとdoublesのXDR（bigendian）表現が使用され、これらはすべてのRプラットフォームで移植可能です。  ASCIIセーブは、圧縮を使用しない場合、バイナリ・セーブよりもコンパクトになりますが、読み込みと書き込みの両方でほとんど常に低コストになります。  save.defaults "オプション(saveとsave.imageの両方で使用)で、ascii、compress、safe、versionの引数のデフォルト値を変更することができます。  もし "save.image.defaults "オプションが設定されていれば、それは関数save.imageの "save.defaults "よりも優先して使用されます（これは異なるデフォルトを持つことを可能にします）。  さらに、"save.defaults "オプションの一部として、"compression_level "を指定することもできます。まだ開いていない接続は、"wb "モードで開かれます。  バイナリモードでない接続がオープンされている場合、エラーが発生します。
saveRDSとreadRDSは、1つのRobjectを接続（通常はファイル）に保存し、そのオブジェクトをリストアするための手段です。  これは、1つまたは複数の名前付きオブジェクトを環境に保存および復元するsaveおよびloadとは異なります。  関数serializeとunserializは、シリアライズに対する少し低レベルのインターフェイスを提供します：serializeによって接続にシリアライズされたオブジェクトは、readRDSによって読み戻すことができます。save(compress=FALSE)がfileを使用する場合を除き、fileがファイル名の場合、それはgzfileによって開かれます。  圧縮は、ファイルがファイル名のときにオープンされた接続によって処理されるため、接続によって処理される場合は、ファイルが接続のときにのみ可能です。  すでに開いている場合は、saveRDS(ascii = FALSE)または非ASCII保存を読み込むためにバイナリモードでなければなりません。
centerの値は、列のセンタリングをどのように行うかを決定する。  centerがxの列数と同じ長さの数値類似ベクトルである場合、xの各列はcenterから対応する値を差し引かれる。  centerがTRUEの場合、xの列平均（NAは除く）を対応する列から差し引くことでセンタリングが行われ、centerがFALSEの場合、センタリングは行われない。scaleの値は、（センタリング後に）列のスケーリングをどのように行うかを決定する。  scaleがTRUEの場合、スケーリングはxの(センタリングされた)列を、centerがTRUEの場合はその標準偏差で除算し、それ以外の場合は二乗平均平方根で除算します。ここで、x は欠損していない値のベクトルで、n は欠損していない値の個数です。  center = TRUEの場合、これは標準偏差と同じですが、一般的にはそうではありません。  (センタリングせずに標準偏差でスケーリングするには、scale(x, center = FALSE, scale = apply(x, 2, sd, na.rm = TRUE))を使用します)。
centerの値によって、列のセンタリングがどのように行われるかが決まります。  centerがxの列数と同じ長さの数値類似ベクトルである場合、xの各列はcenterから対応する値を差し引かれる。  centerがTRUEの場合、xの列平均（NAは除く）を対応する列から差し引くことでセンタリングが行われ、centerがFALSEの場合、センタリングは行われない。scaleの値は、（センタリング後に）列のスケーリングをどのように行うかを決定する。  scale が TRUE の場合、スケーリングは x の(センタリングされた)列を、center が TRUE の場合はその標準偏差で除算し、それ以外の場合は二乗平均平方根で除算します。ここで、x は欠損していない値のベクトルで、n は欠損していない値の個数です。  center = TRUEの場合、これは標準偏差と同じですが、一般的にはそうではありません。  (センタリングせずに標準偏差でスケーリングするには、scale(x, center = FALSE, scale = apply(x, 2, sd, na.rm = TRUE))を使用します)。
この場合、canはwhatの要素のtypesで与えられた型を持つベクトルのリストを返します。  これは、列データの読み方を提供する。  whatまたはその構成要素の型は、6つの原子ベクトル型のうちの1つ、またはNULL（is.atomicを参照）である。この関数では、「空白文字」はスペース、水平タブ、キャリッジリターン、改行から1文字以上連続した文字と定義される。  空の数値フィールドは常に欠落値とみなされる。空の文字フィールドは、"na "でない限り、空の文字ベク ターとしてスキャンされる。文字列が""を含む場合、それらは欠損値とみなされる。数値フィールドに許可される入力は、オプションの空白の後にNA、またはオプションの符号の後に10進数または16進数の定数（NumericConstantsを参照）、またはNaN、Inf、またはinfinity（大文字と小文字は無視される）である。  範囲外の値は、Inf、-Inf、または0として記録されます。整数フィールドの場合、入力可能な値は空白で、その後にNAまたは任意の符号と1桁以上の数字(0-9)が続きます: 範囲外の値はすべてNA_integer_に変換されます。sepがデフォルト("")である場合、引用符で囲まれた文字列内の文字"˶" は次の文字をエスケープするので、引用符をエスケープすることで文字列内に引用 符を含めることができます。sepがデフォルトでない場合、フィールドは'.csv'ファイル のスタイルで引用符で囲まれる可能性があります。このスタイルでは、引用符内のセパレータ(' または"")は無視され、引用符を二重引用符にすることで文字列内に引用 符を入れることができます。  ただし、sep = "˶"の場合、デフォルトで行全体を逐語的に読み込むと見なされます。引用符は、文字フィールドとNULLフィールド(文字フィールドをスキップする可能性がある)でのみ解釈されます。sepはセパレータでありターミネータではないので、scan("foo", sep = "˶", blank.lines.skip = FALSE)でファイルを読み込むと、ファイルが改行で終わる場合は最終行が空になり、改行で終わらない場合は空にならないことに注意してください。  comment.charが発生した場合（引用符で囲まれた文字フィールド内を除く）、その行の残りをコメントとみなし、破棄することを通知します。  コメント文字で始まる行は空行として扱われる。コンソールから読み込む場合、行の長さには4095バイトの制限がある（それ以下の制限が課されることもある：「R入門」を参照）。fileが文字列でfileEncodingがデフォルトでない場合、またはデフォルトでないエンコーディング引数を持つalready-openでない接続の場合、テキストはUTF-8に変換され、そのように宣言されます（scanのエンコーディング引数は無視されます）。  入力ストリームにnulが埋め込まれていると、scanを呼び出すごとに警告が表示され、現在読み込まれているフィールドが終了します。  kipNul=TRUEに設定すると、それらは無視される。
NA
NA
isSeekable は、接続が原則的にシークをサポートしているかどうかを返します: 現時点では (おそらくgz圧縮された) ファイル接続のみがサポートしています。  可能な値は、64ビットビルドや一部の32ビットビルドでは、Rintegerで表現可能な最大の数値を超える可能性があることに注意してください。ファイル接続は、書き込み/追加の両方で開くことができ、その場合、Rは読み込みと書き込みのために別々の位置を保持します。  どちらのシークを参照するかは、rw引数で設定できる。デフォルトは、最後に使用されたモード（読み込みまたは書き込み）である。  ほとんどのファイルは読み書きのためだけにオープンされているので、デフォルトはその状態である。  読み書きの初期位置は常にファイルの先頭である。書き込みの初期位置は、"r+"モードと "r+b "モードではファイルの先頭であり、そうでなければファイルの末尾である。  プラットフォームによっては、追記モードではファイルの末尾にしか書き込めないものもある。  (アペンドモードでオープンされたファイルの報告される書き込み位置は、 通常、ファイルが書き込まれるまで信頼できない。)gzfile接続は、いくつかの制限付きでシークをサポートしており、 展開されたファイルのファイル位置を使用する。  seekがwhereの非NA値で呼び出された場合、テキストモード接続でのプッシュバックはすべて破棄される。  これは、ファイル接続でのみ動作し、すべてのプラットフォームで実装されているわけではありません。他のプラットフォーム（Windowsを含む）では、大きなファイル（> 2Gb）では動作しません。
isSeekable は、接続が原則としてシークをサポートしているかどうかを返します: 現時点では (おそらく gz 圧縮された) ファイル接続のみがサポートしています。  可能な値は、64ビットビルドや一部の32ビットビルドでは、Rintegerで表現可能な最大の数値を超える可能性があることに注意してください。ファイル接続は、書き込み/追加の両方で開くことができ、その場合、Rは読み込みと書き込みのために別々の位置を保持します。  どちらのシークを参照するかは、rw引数で設定できる。デフォルトは、最後に使用されたモード（読み込みまたは書き込み）である。  ほとんどのファイルは読み書きのためだけにオープンされているので、デフォルトはその状態である。  読み書きの初期位置は常にファイルの先頭である。書き込みの初期位置は、"r+"モードと "r+b "モードではファイルの先頭であり、そうでなければファイルの末尾である。  プラットフォームによっては、追記モードではファイルの末尾にしか書き込めないものもある。  (アペンドモードでオープンされたファイルの報告される書き込み位置は、 通常、ファイルが書き込まれるまで信頼できない。)gzfile接続は、いくつかの制限付きでシークをサポートしており、 展開されたファイルのファイル位置を使用する。  seekがwhereの非NA値で呼び出された場合、テキストモード接続でのプッシュバックはすべて破棄される。  これはファイル接続でのみ動作し、すべてのプラットフォームで実装されているわけではありません: 他のプラットフォーム(Windowsを含む)では、大きな(> 2Gb)ファイルでは動作しません。
seqとseq.intの名前のない引数の解釈は標準的ではないので、プログラミングする際には常に引数に名前を付けることを推奨する。seqは汎用的であり、ここではデフォルトのメソッドのみを説明する。  seq.intは内部ジェネリックで、最初に与えられた引数のクラスに基づいて（引数のマッチングの前に）"seq "のメソッドをディスパッチします。2番目の形式は、from、from+by、...、to以下のシーケンス値までを生成します。  to - fromとbyを反対の符号で指定するのは誤りである。  計算された最終値は、丸め誤差を許容するためにtoをちょうど超えることができるが、toに切り捨てられることに注意。  (3番目は、length.outをfromからtoまで等間隔に並べたものを生成します。  (length.outは通常lengthまたはlenと省略され、seq_lenの方がはるかに速い。)4番目の形式は、整数列1, 2, ..., length(along.with)を生成する。  (along.withは通常alongと省略され、seq_alongの方がずっと速い。)第5の形式は、(Sとの互換性のためにseq(0)であっても)引数が1:fromとして解釈されるときに長さ1の数値でない限り、(引数along.withが指定されたかのように)シーケンス1, 2, ..., length(from)を生成する。seq_alongかseq_lenのどちらかを使う方がずっと好ましい(厳密なSとの互換性が不可欠でない限り)。seq(のみ)では、length.outまたはalong.withが指定されていれば、 from, to, byのうち2つまで複素数値として与えることができます。  seq.int、seq_along、seq_lenはプリミティブです。
seqとseq.intの名前のない引数の解釈は標準的ではなく、プログラミングを行う際には常に引数に名前を付けることが推奨されます。seqはジェネリックであり、ここではデフォルトのメソッドのみを説明します。  seq.intは内部ジェネリックで、最初に与えられた引数のクラスに基づいて（引数のマッチングの前に）"seq "のメソッドをディスパッチします。2番目の形式は、from、from+by、...、to以下のシーケンス値までを生成します。  to - fromとbyを反対の符号で指定するのは誤りである。  計算された最終値は、丸め誤差を許容するためにtoをちょうど超えることができるが、toに切り捨てられることに注意。  (3番目は、length.outをfromからtoまで等間隔に並べたものを生成します。  (length.outは通常lengthまたはlenと省略され、seq_lenの方がはるかに速い。)4番目の形式は、整数列1, 2, ..., length(along.with)を生成する。  (along.withは通常alongと省略され、seq_alongの方がずっと速い。)第5の形式は、(Sとの互換性のためにseq(0)であっても)引数が1:fromとして解釈されるときに長さ1の数値でない限り、(引数along.withが指定されたかのように)シーケンス1, 2, ..., length(from)を生成する。seq_alongかseq_lenのどちらかを使う方がずっと好ましい(厳密なSとの互換性が不可欠でない限り)。seq(のみ)では、length.outまたはalong.withが指定されていれば、 from, to, byのうち2つまでを複素数値として与えることができます。  seq.int、seq_along、seq_lenはプリミティブです。
seqとseq.intの名前のない引数の解釈は標準的ではなく、プログラミングを行う際には常に引数に名前を付けることが推奨されます。seqはジェネリックであり、ここではデフォルトのメソッドのみを説明します。  seq.intは内部ジェネリックで、最初に与えられた引数のクラスに基づいて（引数のマッチングの前に）"seq "のメソッドをディスパッチします。2番目の形式は、from、from+by、...、to以下のシーケンス値までを生成します。  to - fromとbyを反対の符号で指定するのは誤りである。  計算された最終値は、丸め誤差を許容するためにtoをちょうど超えることができるが、toに切り捨てられることに注意。  (3番目は、length.outをfromからtoまで等間隔に並べたものを生成します。  (length.outは通常lengthまたはlenと省略され、seq_lenの方がはるかに速い。)4番目の形式は、整数列1, 2, ..., length(along.with)を生成する。  (along.withは通常alongと省略され、seq_alongの方がずっと速い。)第5の形式は、(Sとの互換性のためにseq(0)であっても)引数が1:fromとして解釈されるときに長さ1の数値でない限り、(引数along.withが指定されたかのように)シーケンス1, 2, ..., length(from)を生成する。seq_alongかseq_lenのどちらかを使う方がずっと好ましい(厳密なSとの互換性が不可欠でない限り)。seq(のみ)では、length.outまたはalong.withが指定されていれば、 from, to, byのうち2つまでを複素数値として与えることができます。  seq.int、seq_along、seq_lenはプリミティブです。
by はいくつかの方法で指定できます。日単位の数値。difftimeクラスのオブジェクト "day"、"week"、"month"、"quarter"、"year "のいずれかを含む文字列。"month "の詳細についてはseq.POSIXtを参照のこと。
seqとseq.intの名前のない引数の解釈は標準的ではないので、プログラミングするときには常に引数に名前を付けることが推奨される。  seq.intは内部ジェネリックで、最初に与えられた引数のクラスに基づいて（引数のマッチングの前に）"seq "のメソッドをディスパッチします。2番目の形式は、from、from+by、...、to以下のシーケンス値までを生成します。  to - fromとbyを反対の符号で指定するのは誤りである。  計算された最終値は、丸め誤差を許容するためにtoをちょうど超えることができるが、toに切り捨てられることに注意。  (3番目は、length.outをfromからtoまで等間隔に並べたものを生成します。  (length.outは通常lengthまたはlenと省略され、seq_lenの方がはるかに速い。)4番目の形式は、整数列1, 2, ..., length(along.with)を生成する。  (along.withは通常alongと省略され、seq_alongの方がずっと速い。)第5の形式は、(Sとの互換性のためにseq(0)であっても)引数が1:fromとして解釈されるときに長さ1の数値でない限り、(引数along.withが指定されたかのように)シーケンス1, 2, ..., length(from)を生成する。seq_alongかseq_lenのどちらかを使う方がずっと好ましい(厳密なSとの互換性が不可欠でない限り)。seq(のみ)では、length.outまたはalong.withが指定されていれば、 from, to, byのうち2つまでを複素数値として与えることができます。  seq.int、seq_along、seq_lenはプリミティブです。
seqとseq.intの名前のない引数の解釈は標準的ではなく、プログラミングを行う際には常に引数に名前を付けることが推奨されます。seqはジェネリックであり、ここではデフォルトのメソッドのみを説明します。  seq.intは内部ジェネリックで、最初に与えられた引数のクラスに基づいて（引数のマッチングの前に）"seq "のメソッドをディスパッチします。2番目の形式は、from、from+by、...、to以下のシーケンス値までを生成します。  to - fromとbyを反対の符号で指定するのは誤りである。  計算された最終値は、丸め誤差を許容するためにtoをちょうど超えることができるが、toに切り捨てられることに注意。  (3番目は、length.outをfromからtoまで等間隔に並べたものを生成します。  (length.outは通常lengthまたはlenと省略され、seq_lenの方がはるかに速い。)4番目の形式は、整数列1, 2, ..., length(along.with)を生成する。  (along.withは通常alongと省略され、seq_alongの方がずっと速い。)第5の形式は、(Sとの互換性のためにseq(0)であっても)引数が1:fromとして解釈されるときに長さ1の数値でない限り、(引数along.withが指定されたかのように)シーケンス1, 2, ..., length(from)を生成する。seq_alongかseq_lenのどちらかを使う方が(厳密なSとの互換性が不可欠でない限り)ずっと好ましい。seq(のみ)では、length.outまたはalong.withが指定されていれば、 from, to, byのうち2つまでを複素数値として与えることができます。  seq.int、seq_along、seq_lenはプリミティブです。
by はいくつかの方法で指定できます。秒単位の数値。difftimeクラスのオブジェクト "sec"、"min"、"hour"、"day"、"DSTday"、"week"、"month"、"quarter"、"year "のいずれかを含む文字列。"day "と "DSTday "の違いは、"day "はサマータイムの変更を無視し、"DSTday "は毎日同じ時刻を取るということです。  「week "はサマータイムを無視する（144時間の期間である）が、"7 DSTdays "を代替に使うことができる。  「month "と "year "はサマータイムに対応する。結果のタイムゾーンはfromから取得される：GMTはUTCを意味し（イギリスのグリニッジのタイムゾーンではない）、サマータイムがないことを覚えておいてください。
sequence(nvec,from,by=0L)はrep(from,each=nvec)と等価です。この関数は元々Rで実装されており、機能が少なかったのですが、その後より柔軟になり、デフォルトのメソッドはスピードを上げるためにCで実装されています。
sequence(nvec,from,by=0L)はrep(from,each=nvec)と等価です。この関数は元々Rで実装されたもので、機能が少なかったのですが、その後柔軟性が増し、デフォルトのメソッドは高速化のためにCで実装されています。
関数serializeは、オブジェクトを指定されたconnectionにシリアライズします。  参照オブジェクトの共有はオブジェクトの中で保持されますが、serializeの個別の呼び出しの間では保持されません。  serializeのフック関数は、扱いたい参照の文字ベクトルを返すべきです。  unserializeのフックは、serializeに供給された文字ベクトルで呼び出され、適切なオブジェクトを返す必要があります。テキストモード接続の場合、asciiのデフォルト値はTRUEに設定されています：ASCII表現のみがテキストモデック接続に書き込むことができ、ascii = FALSEを使用しようとするとエラーがスローされます：最初の行は、バイナリー・シリアライズの場合はX、ASCIIシリアライズの場合はAという1文字を含み、その後に改行が続く。  (使用されるフォーマットは、readRDSで使用されるものと同じである。)現在使用されているほとんどすべてのシステムがリトルエンディアンであるため、xdr = FALSEを使用すると、あるリトルエンディアン・マシンから別のマシンへ(または同じマシン上のプロセス間で)データを転送する際に、両端でのバイトシャッフルを避けることができる。  システムにもよりますが、これによってシリアライズとアンシリアライズを最大3倍高速化することができます。
最初の11の関数はコネクションを作成します。  デフォルトでは、コネクションはオープンされません（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）が、引数openに空でない値を設定することでオープンされる可能性があります。fileの場合、記述はオープンされるファイルへのパス（チルダ展開が行われる場合）または完全なURL（urlの呼び出しと同じ場合）、または""（デフォルト）または "クリップボード"（「クリップボード」のセクションを参照）です。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つ代わりに）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
現在利用可能なRNGの種類は以下の通りである。  デフォルトは "Mersenne-Twister "である。.Random.seed[-1] == r[1:3]は長さ3の整数ベクトルで、各r[i]は1:(p[i] - 1)に含まれる。Wichmann-Hill生成器のサイクル長は6.9536e12(=prod(p-1)/4, Applied Statistics (1984)33, 123を参照)である。TestU01のCrushスイートでは12回、BigCrushスイートでは22回の明らかな失敗がある(L'Ecuyer, 2007).GeorgeMarsagliaがメーリングリスト'sci.stat.math'への投稿で推奨しているmultiply-with-carry RNGが使われている。L'EcuyerのTestU01 Crush suiteでは、40の明らかな失敗がある。Ahrens-DieterやKinderman-Ramageと組み合わせると、一変量分布の生成でも正規性からのずれを示す。  種は2つの整数（すべての値が許される）。Marsagliaの70年代の有名なSuper-Duper。  DiehardbatteryのMTUPLEテストに合格しないオリジナルバージョン。  ほとんどの初期シードに対して約4.6*10^18の周期を持つ。  2つの種はそれぞれTauswortheとcongruenceの長整数である。  S'sの.Random.seed[1:12]への一対一のマッピングも可能であるが、少なくともこのジェネレータが最近のバージョンのS-PLUSのものと全く同じでないため、公開はしない。TestU01 Crush suite (L'Ecuyer, 2007)では25の明確な失敗を示している。  RはB. D. Ripleyによる独自の初期化法を用いており、2002年の更新で対処されたMatsumoto and Nishimuraの1998年のコードにおける初期化の問題には影響されない。TestU01 CrushとBigCrushスイート(L'Ecuyer, 2007)のそれぞれで2つの明確な失敗を示す。  つまり、使用される再帰はX[j] = (X[j-100] - X[j-37]) mod 2^30であり、「シード」は最後の100個の数字の集合である（実際には101個の数字として記録され、最後の数字はバッファの周期的なシフトである）。  2002年のバージョンは、それ以前のバージョンと後方互換性がなかった：種からのGFSRの初期化が変更され、Rは連続した種、報告された'弱点'を選択することができず、すでに種をスクランブルした。それ以外は、アルゴリズムはKnuth-TAOCP-2002と同じで、同じラグを持つフィボナッチ漸化式である。このジェネレータの初期化は解釈されたRコードで行われるため、短時間ではあるが顕著な時間がかかる。TestU01 Crushスイートでは3回、BigCrushスイートでは4回明らかな失敗を示した(L'Ecuyer, 2007)。L'Ecuyer(1999)の「複合多重再帰ジェネレータ」は、各要素が3つの整数要素を持つフィードバック乗算ジェネレータである：したがって、シードは長さ6の(符号付き)整数ベクトルである。  最初の3つも最後の3つもすべて0であってはならず、それぞれ4294967087と4294944443未満に制限される。これ自体は特に面白くはないが、パッケージ・パラレルで使用される複数のストリームの基礎となる。TestU01 CrushとBigCrushスイート（L'Ecuyer, 2007）では、それぞれ6つの明確な失敗を示した。  normal.kindには、"Kinderman-Ramage"、"Buggy Kinderman-Ramage"（set.seedでは使用不可）、"Ahrens-Dieter"、"Box-Muller"、"Inversion"（デフォルト）、または "user-supplied "が使用できる。  (1.7.0より前のバージョンで使用されていたKinderman-Ramageジェネレータ(現在は "Buggy "と呼ばれています)にはいくつかの近似誤差があり、古い結果の再現にのみ使用すべきです。  Box-Muller "ジェネレータは、正規値のペアが順次生成され返されるため、ステートフルです。  サンプル.kindは "Rounding "または "Rejection"、あるいはこれらの部分一致にすることができる。  前者は3.6.0より前のバージョンではデフォルトでした。これは大きな母集団でサンプルが著しく不均一になるため、古い結果の再現にのみ使用すべきです。  set.seedは1つの整数引数を用いて、必要な数のseedを設定します。  set.seedは、小さな整数引数を指定することで、かなり異なるseedsを得るための簡単な方法であり、また、より複雑な手法（特に "Mersenne-Twister "と "Knuth-TAOCP"）で有効なseedsセットを得るための方法でもある。  seedの値が異なるとRNGの播種が異なるという保証はないが、例外は極めて稀であろう。  RNGkindまたはset.seedでkind = NULL、normal.kind = NULLまたはsample.kind = NULLを使用すると、現在使用されているジェネレータ(ワークスペースが復元されている場合、前のセッションで使用されたものを含む)が選択されます。
union、intersect、setdiff、setequalのそれぞれは、引数の中の重複した値を破棄し、as.vectorを引数に適用します（特に文字ベクトルへの係数を強制します）。
union、intersect、setdiff、setequalの各々は、引数内の重複する値を破棄し、引数に対して.vectorとして適用されます(特に文字ベクトルに対して係数を強要します).is.element(x, y)は、x %in% yと同一です。
setHookは、ユーザーがシステム（またはユーザー）関数から呼び出される関数のリストであるフックを登録するための一般的なメカニズムを提供します。  フックを完全に削除するには、setHook(hookName, NULL, "replace")を呼び出します。Rパッケージがライブラリでアタッチされたり、その他の方法でロードされたりすると、初期化コードを呼び出すことができます。  初期化中に呼び出されるパッケージ・フック関数の説明については、.onLoadを参照してください。  ユーザは、setHook()で提供されるフックを使って独自の初期化コードを追加することができます。この関数は、atry呼び出しの内部でfunname(pkgname, pkgpath)として呼び出されます。  すべてのフックが定義され、パッケージがアタッチされている場合、初期化イベントの順序は次のようになる：パッケージ・ネームスペースがロードされる。パッケージの.onLoad関数が実行される。S4メソッドのディスパッチがオンの場合、setLoadActionで設定されたアクションが実行されます。名前空間がシールされる。ユーザーの "onLoad "フックが実行される。パッケージが検索パスに追加される。パッケージの .onAttach 関数が実行されます。パッケージ環境が封印される。ユーザーの "attach "フックが実行される。パッケージがデタッチされ、その名前空間がアンロードされると、同様のシーケンス（ただし逆）が実行される：ユーザーの "detach "フックが実行される。パッケージの.Last.lib関数が実行される。パッケージが検索パスから削除される。ユーザーの「onUnload」フックが実行される。パッケージの .onUnload 関数が実行される。パッケージの名前空間がアンロードされます。Rセッションが終了しても、パッケージは削除されず、名前空間もアンロードされないので、対応するフックは実行されないことに注意してください。また、ユーザー・フックの中には、パッケージが検索パスにない状態で実行されるものがあるので、そのようなフックでは、パッケージ内のオブジェクトを、例のようにダブル（またはトリプル）コロン演算子を使って参照する必要があることにも注意してください。複数のフックが追加された場合、通常はgetHookで示された順番で実行されますが、"detach "と "onUnload "フックは逆の順番で実行されるため、パッケージイベントのデフォルトは、既存のフックの「内側」にフックを追加することになります。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すものではありません(現在はすべてそうなっています)。むしろ'NAMESPACE'ファイルを持っているかどうかを示すもので、baseパッケージや一部のレガシーパッケージにはありません。  しかし、それを使うことを意図しているわけではありません。
setTimeLimitは、コンソールまたはファイルから入力されたコマンドライン（継続行を含む）の各トップレベル計算に適用される制限を設定する。  setSessionTimeLimitは、残りのセッションの制限を設定します。  時間制限は、ユーザー割り込みが発生する可能性があるときにチェックされます。これは、RコードやSys.sleep中に頻繁に発生しますが、コード作成者が特定したコンパイル済みCおよびFortranコードのポイントでのみ発生します。
setTimeLimitは、コンソールまたはファイルから入力されたコマンド行（継続行を含む）である、各トップレベル計算に適用される制限を設定する。  setSessionTimeLimitは、残りのセッションの制限を設定します。  時間制限は、ユーザー割り込みが発生する可能性があるときにチェックされます。これは、RコードやSys.sleep中に頻繁に発生しますが、コード作成者が特定したコンパイル済みCおよびFortranコード内のポイントでのみ発生します。「総cpu時間」には、後者が報告されている場合、子プロセスによって使用された時間が含まれます。
マークされたエンコーディングのファイルパスがどのように解釈されるかについては、ファイルを参照のこと。
