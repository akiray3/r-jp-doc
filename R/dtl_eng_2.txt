x
Calling gctorture(TRUE) instructs the memory manager to force afull GC on every allocation. gctorture2 provides a more refinedinterface that allows the start of the GC torture to be deferred andalso gives the option of running a GC only every stepallocations.The third argument to gctorture2 is only used if R has beenconfigured with a strict write barrier enabled.  When this is the caseall garbage collections are full collections, and the memory managermarks free nodes and enables checks in many situations that signal anerror when a free node is used.  This can help greatly in isolatingunprotected values in C code.  It does not detect the case where anode becomes free and is reallocated.  The inhibit_releaseargument can be used to prevent such reallocation.  This will causememory to grow and should be used with caution and in conjunction withoperating system facilities to monitor and limit process memory use.gctorture2 can also be invoked via environment variables at thestart of the R session.  R_GCTORTURE corresponds to thestep argument, R_GCTORTURE_WAIT to wait, andR_GCTORTURE_INHIBIT_RELEASE to inhibit_release.
Calling gctorture(TRUE) instructs the memory manager to force afull GC on every allocation. gctorture2 provides a more refinedinterface that allows the start of the GC torture to be deferred andalso gives the option of running a GC only every stepallocations.The third argument to gctorture2 is only used if R has beenconfigured with a strict write barrier enabled.  When this is the caseall garbage collections are full collections, and the memory managermarks free nodes and enables checks in many situations that signal anerror when a free node is used.  This can help greatly in isolatingunprotected values in C code.  It does not detect the case where anode becomes free and is reallocated.  The inhibit_releaseargument can be used to prevent such reallocation.  This will causememory to grow and should be used with caution and in conjunction withoperating system facilities to monitor and limit process memory use.gctorture2 can also be invoked via environment variables at thestart of the R session.  R_GCTORTURE corresponds to thestep argument, R_GCTORTURE_WAIT to wait, andR_GCTORTURE_INHIBIT_RELEASE to inhibit_release.
The pos argument can specify the environment in which to lookfor the object in any of several ways: as a positive integer (theposition in the search list); as the character stringname of an element in the search list; or as anenvironment (including using sys.frameto access the currently active function calls).  The default of-1 indicates the current environment of the call toget. The envir argument is an alternative way tospecify an environment.These functions look to see if each of the name(s) x have avalue bound to it in the specified environment.  If inherits isTRUE and a value is not found for x in the specifiedenvironment, the enclosing frames of the environment are searcheduntil the name x is encountered.  See environmentand the ‘R Language Definition’ manual for details about thestructure of environments and their enclosures.If mode is specified then only objects of that type are sought.mode here is a mixture of the meanings of typeofand mode: "function" covers primitive functionsand operators, "numeric", "integer" and "double"all refer to any numeric type, "symbol" and "name" areequivalent but "language" must be used (and not"call" or "(").For mget, the values of mode and ifnotfound canbe either the same length as x or of length 1.  The argumentifnotfound must be a list containing either the value to use ifthe requested item is not found or a function of one argument whichwill be called if the item is not found, with argument the name of theitem being requested.dynGet() is somewhat experimental and to be used insideanother function.  It looks for an object in the callers, i.e.,the sys.frame()s of the function.  Use with caution.
The where argument can specify the environment in which to lookfor the object in any of several ways: as an integer (the position inthe search list); as the character string name of anelement in the search list; or as an environment(including using sys.frame to access the currently activefunction calls).  The envir argument is an alternative way tospecify an environment, but is primarily there for back compatibility.This function looks to see if the name x has a value bound toit in the specified environment.  If inherits is TRUE anda value is not found for x in the specified environment, theenclosing frames of the environment are searched until the name xis encountered.  See environment and the ‘RLanguage Definition’ manual for details about the structure ofenvironments and their enclosures.Warning:inherits = TRUE is the default behaviour for R but not for S.If mode is specified then only objects of that type are sought.The mode may specify one of the collections "numeric" and"function" (see mode): any member of thecollection will suffice.  (This is true even if a member of acollection is specified, so for example mode = "special" willseek any type of function.)
stdin(), stdout() and stderr() are standardconnections corresponding to input, output and error on the consolerespectively (and not necessarily to file streams).  They are text-modeconnections of class "terminal" which cannot be opened orclosed, and are read-only, write-only and write-only respectively.The stdout() and stderr() connections can bere-directed by sink (and in some circumstances theoutput from stdout() can be split: see the help page).The encoding for stdin() when redirected canbe set by the command-line flag --encoding.nullfile() returns filename of the null device ("/dev/null"on Unix, "nul:" on Windows).showConnections returns a matrix of information.  If aconnection object has been lost or forgotten, getConnectionwill take a row number from the table and return a connection objectfor that connection, which can be used to close the connection,for example.  However, if there is no R level object referring to theconnection it will be closed automatically at the next garbagecollection (except for gzcon connections).closeAllConnections closes (and destroys) all userconnections, restoring all sink diversions as it doesso.isatty returns true if the connection is one of the class"terminal" connections and it is apparently connected to aterminal, otherwise false.  This may not be reliable in embeddedapplications, including GUI consoles.
NA
NA
stdin(), stdout() and stderr() are standardconnections corresponding to input, output and error on the consolerespectively (and not necessarily to file streams).  They are text-modeconnections of class "terminal" which cannot be opened orclosed, and are read-only, write-only and write-only respectively.The stdout() and stderr() connections can bere-directed by sink (and in some circumstances theoutput from stdout() can be split: see the help page).The encoding for stdin() when redirected canbe set by the command-line flag --encoding.nullfile() returns filename of the null device ("/dev/null"on Unix, "nul:" on Windows).showConnections returns a matrix of information.  If aconnection object has been lost or forgotten, getConnectionwill take a row number from the table and return a connection objectfor that connection, which can be used to close the connection,for example.  However, if there is no R level object referring to theconnection it will be closed automatically at the next garbagecollection (except for gzcon connections).closeAllConnections closes (and destroys) all userconnections, restoring all sink diversions as it doesso.isatty returns true if the connection is one of the class"terminal" connections and it is apparently connected to aterminal, otherwise false.  This may not be reliable in embeddedapplications, including GUI consoles.
This takes the registration information after it has been registeredand processed by the R internals.  In other words, it uses the extendedinformation.There is print methods for the class, which prints only thetypes which have registered routines.
This takes the registration information after it has been registeredand processed by the R internals.  In other words, it uses the extendedinformation.There is print methods for the class, which prints only thetypes which have registered routines.
This takes the registration information after it has been registeredand processed by the R internals.  In other words, it uses the extendedinformation.There is print methods for the class, which prints only thetypes which have registered routines.
These operators are generic.  You can write methods to handle indexingof specific classes of objects, see InternalMethods as well as[.data.frame and [.factor.  Thedescriptions here apply only to the default methods.  Note thatseparate methods are required for the replacement functions[<-, [[<- and $<- for use when indexing occurs onthe assignment side of an expression.The most important distinction between [, [[ and$ is that the [ can select more than one element whereasthe other two select a single element.The default methods work somewhat differently for atomic vectors,matrices/arrays and for recursive (list-like, seeis.recursive) objects.  $ is only valid forrecursive objects (and NULL), and is only discussed in the section below onrecursive objects.Subsetting (except by an empty index) will drop all attributes exceptnames, dim and dimnames.Indexing can occur on the right-hand-side of an expression forextraction, or on the left-hand-side for replacement.  When an indexexpression appears on the left side of an assignment (known assubassignment) then that part of x is set to the valueof the right hand side of the assignment.  In this case no partialmatching of character indices is done, and the left-hand-side iscoerced as needed to accept the values.  For vectors, the answer willbe of the higher of the types of x and value in thehierarchy raw < logical < integer < double < complex < character <list < expression.  Attributes are preserved (although names,dim and dimnames will be adjusted suitably).Subassignment is done sequentially, so if an index is specified morethan once the latest assigned value for an index will result.It is an error to apply any of these operators to an object which isnot subsettable (e.g., a function).
The error action is controlled by error handlers established withinthe executing code and by the current default error handler set byoptions(error=).  The error is first signaled as if usingsignalCondition().  If there are no handlers or if all handlersreturn, then the error message is printed (ifoptions("show.error.messages") is true) and the default errorhandler is used.  The default behaviour (the NULLerror-handler) in interactive use is to return to the top levelprompt or the top level browser, and in non-interactive use to(effectively) call q("no", status = 1, runLast = FALSE).The default handler stores the error message in a buffer; it can beretrieved by geterrmessage().  It also stores a trace ofthe call stack that can be retrieved by traceback().Errors will be truncated to getOption("warning.length")characters, default 1000.If a condition object is supplied it should be the only argument, andfurther arguments will be ignored, with a warning.
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
setHook provides a general mechanism for users to registerhooks, a list of functions to be called from system (or user)functions.  The initial set of hooks was associated with events onpackages/namespaces: these hooks are named via calls topackageEvent.To remove a hook completely, call setHook(hookName, NULL, "replace").When an R package is attached by library or loaded byother means, it can call initialization code.  See.onLoad for a description of the package hook functionscalled during initialization.  Users can add their own initializationcode via the hooks provided by setHook(), functions which willbe called as funname(pkgname, pkgpath) inside atry call.The sequence of events depends on which hooks are defined, and whethera package is attached or just loaded.  In the case where all hooksare defined and a package is attached, the order of initializationevents is as follows: The package namespace is loaded. The package's .onLoad function is run. If S4 methods dispatch is on, any actions set bysetLoadAction are run. The namespace is sealed. The user's "onLoad" hook is run. The package is added to the search path. The package's .onAttach function is run. The package environment is sealed. The user's "attach" hook is run.A similar sequence (but in reverse) is run when a package is detachedand its namespace unloaded: The user's "detach" hook is run. The package's .Last.lib function is run. The package is removed from the search path. The user's "onUnload" hook is run. The package's .onUnload function is run. The package namespace is unloaded.Note that when an R session is finished, packages are not detached andnamespaces are not unloaded, so the corresponding hooks will not berun.Also note that some of the user hooks are run without the packagebeing on the search path, so in those hooks objects in the packageneed to be referred to using the double (or triple) colon operator,as in the example.If multiple hooks are added, they are normally run in the order shownby getHook, but the "detach" and "onUnload" hooksare run in reverse order so the default for package events is to addhooks ‘inside’ existing ones.The hooks are stored in the environment .userHooksEnv in thebase package, with ‘mangled’ names.
This queries the internal table that manages the DLLs.
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
getExportedValue returns the value of the exported variablename in namespace ns.getNamespace returns the environment representing the namespace name.  The namespace is loaded if necessary.getNamespaceExports returns a character vector of the namesexported by ns.getNamespaceImports returns a representation of the importsused by namespace ns.  This representation is experimentaland subject to change.getNamespaceName and getNamespaceVersion return the nameand version of the namespace ns.getNamespaceUsers returns a character vector of the names ofthe namespaces that import namespace ns.
This uses the same mechanism for resolving symbols as is usedin all the native interfaces (.Call, etc.).If the symbol has been explicitly registered by the DLLin which it is contained, information about the number of argumentsand the interface by which it should be called will be returned.Otherwise, a generic native symbol object is returned.
Invoking options() with no arguments returns a list with thecurrent values of the options.  Note that not all options listed beloware set initially.  To access the value of a single option, one shoulduse, e.g., getOption("width") rather thanoptions("width") which is a list of length one.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
NA
If domain is NULL or "", and gettextor ngettext  is called from a function in the namespace ofpackage pkg the domain is set to "R-pkg".  Otherwisethere is no default domain.If a suitable domain is found, each character string is offered fortranslation, and replaced by its translation into the current languageif one is found.  The value (logical) NA suppresses anytranslation.The language to be used for message translation is determined byyour OS default and/or the locale setting at R's startup, seeSys.getlocale(), and notably the LANGUAGE environmentvariable.Conventionally the domain for R warning/error messages in packagepkg is "R-pkg", and that for C-level messages is "pkg".For gettext, leading and trailing whitespace is ignored whenlooking for the translation.ngettext is used where the message needs to vary by a singleinteger.  Translating such messages is subject to very specific rulesfor different languages: see the GNU Gettext Manual.  The stringwill often contain a single instance of %d to be used insprintf.  If English is used, msg1 is returned ifn == 1 and msg2 in all other cases.bindtextdomain is a wrapper for the C function of the samename: your system may have a man page for it.  With anon-NULL dirname it specifies where to look for messagecatalogues: with domain = NULL it returns the current location.
sprintf is a wrapper for the system sprintf C-libraryfunction.  Attempts are made to check that the mode of the valuespassed match the format supplied, and R's special values (NA,Inf, -Inf and NaN) are handled correctly.gettextf is a convenience function which provides C-stylestring formatting with possible translation of the format string.The arguments (including fmt) are recycled if possible a wholenumber of times to the length of the longest, and then the formattingis done in parallel.  Zero-length arguments are allowed and will givea zero-length result.  All arguments are evaluated even if unused, andhence some types (e.g., "symbol" or "language", seetypeof) are not allowed. Arguments unused by fmtresult in a warning. (The format %.0s can be used to“skip” an argument.)The following is abstracted from Kernighan and Ritchie (seeReferences): however the actual implementation will follow the C99standard and fine details (especially the behaviour under user error)may depend on the platform. References to numbered arguments come fromPOSIX.The string fmt contains normal characters,which are passed through to the output string, and also conversionspecifications which operate on the arguments provided through....  The allowed conversion specifications start with a% and end with one of the letters in the setaAdifeEgGosxX%.  These letters denote the following types:Integervalue, o being octal, x and X being hexadecimal (using the same case fora-f as the code).  Numeric variables with exactly integervalues will be coerced to integer.  Formats d and ican also be used for logical variables, which will be converted to0, 1 or NA.Double precision value, in “fixedpoint” decimal notation of the form "[-]mmm.ddd".  The number ofdecimal places ("d") is specified by the precision: the default is 6;a precision of 0 suppresses the decimal point.  Non-finite valuesare converted to NA, NaN or (perhaps a sign followedby) Inf.Double precision value, in“exponential” decimal notation of theform [-]m.ddde[+-]xx or [-]m.dddE[+-]xx.Double precision value, in %e or%E format if the exponent is less than -4 or greater than orequal to the precision, and %f format otherwise.(The precision (default 6) specifies the number ofsignificant digits here, whereas in %f, %e, it isthe number of digits after the decimal point.)Double precision value, in binary notationof the form [-]0xh.hhhp[+-]d.  This is a binary fractionexpressed in hex multiplied by a (decimal) power of 2.  The numberof hex digits after the decimal point is specified by the precision:the default is enough digits to represent exactly the internalbinary representation.  Non-finite values are converted to NA,NaN or (perhaps a sign followed by) Inf.  Format%a uses lower-case for x, p and the hexvalues: format %A uses upper-case.This should be supported on all platforms as it is a feature of C99.The format is not uniquely defined: although it would be possibleto make the leading h always zero or one, this is notalways done.  Most systems will suppress trailing zeros, but a fewdo not.  On a well-written platform, for normal numbers there willbe a leading one before the decimal point plus (by default) 13hexadecimal digits, hence 53 bits.  The treatment of denormalized(aka ‘subnormal’) numbers is very platform-dependent.Character string.  Character NAs areconverted to "NA".Literal % (none of the extra formattingcharacters given below are permitted in this case).Conversion by as.character is used for non-characterarguments with s and by as.double fornon-double arguments with f, e, E, g, G.  NB: the length isdetermined before conversion, so do not rely on the internalcoercion if this would change the length.  The coercion is done onlyonce, so if length(fmt) > 1 then all elements must expect thesame types of arguments.In addition, between the initial % and the terminatingconversion character there may be, in any order:Two numbers separated by a period, denoting thefield width (m) and the precision (n).Left adjustment of converted argument in its field.Always print number with sign: by default onlynegative numbers are printed with a sign.Prefix a space if the first character is not a sign.For numbers, pad to the field width with leadingzeros. For characters, this zero-pads on some platforms and isignored on others.specifies “alternate output” for numbers, itsaction depending on the type:For x or X, 0x or 0X will be prefixedto a non-zero result.  For e, e, f, gand G, the output will always have a decimal point; forg and G, trailing zeros will not be removed.Further, immediately after % may come 1$ to 99$to refer to a numbered argument: this allows arguments to bereferenced out of order and is mainly intended for translators oferror messages.  If this is done it is best if all formats arenumbered: if not the unnumbered ones process the arguments in order.See the examples.  This notation allows arguments to be used more thanonce, in which case they must be used as the same type (integer,double or character).A field width or precision (but not both) may be indicated by anasterisk *: in this case an argument specifies the desirednumber.  A negative field width is taken as a '-' flag followed by apositive field width.  A negative precision is treated as if theprecision were omitted.  The argument should be integer, but a doubleargument will be coerced to integer.There is a limit of 8192 bytes on elements of fmt, and onstrings included from a single %letter conversionspecification.Field widths and precisions of %s conversions are interpretedas bytes, not characters, as described in the C standard.The C doubles used for R numerical vectors have signed zeros, whichsprintf may output as -0, -0.000 ....
See files for how file paths with marked encodings are interpreted.
NA
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
Unlike grep, seeks matching patterns within the rawvector x . This has implications especially in the all =  TRUE case, e.g., patterns matching empty strings are inherentlyinfinite and thus may lead to unexpected results.The argument invert is interpreted as asking to return thecomplement of the match, which is only meaningful for value =  TRUE.  Argument offset determines the start of the search, notof the complement.  Note that invert = TRUE with all =  TRUE will split x into pieces delimited by the patternincluding leading and trailing empty strings (consequently the use ofregular expressions with "^" or "$" in that case maylead to less intuitive results).Some combinations of arguments such as fixed = TRUE withvalue = TRUE are supported but are less meaningful.
The function partially sorts the elements so that identical values areadjacent. NA values come last.  This is guaranteed to bestable, so ties are preserved, and if the data are alreadygrouped/sorted, the grouping is unchanged.  This is useful foraggregation and is particularly fast for character vectors.Under the covers, the "radix" method of order isused, and the same caveats apply, including restrictions on characterencodings and lack of support for long vectors (those with2^31 or more elements). Real-valued numbers are slightlyrounded to account for numerical imprecision.Like order, for a classed R object the grouping is based onthe result of xtfrm.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
If con is open then the modified connection is opened.  Closingthe wrapper connection will also close the underlying connection.Reading from a connection which does not supply a gzip magicheader is equivalent to reading from the original connection ifallowNonCompressed is true, otherwise an error.Compressed output will contain embedded NUL bytes, and so conis not permitted to be a textConnection opened withopen = "w".  Use a writable rawConnection tocompress data into a variable.The original connection becomes unusable: any object pointing to it willnow refer to the modified connection.  For this reason, the newconnection needs to be closed explicitly.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
Function I has two main uses. In function data.frame.  Protecting an object byenclosing it in I() in a call to data.frame inhibits theconversion of character vectors to factors and the dropping ofnames, and ensures that matrices are inserted as single columns.I can also be used to protect objects which are to beadded to a data frame, or converted to a data frame viaas.data.frame.It achieves this by prepending the class "AsIs" to the object'sclasses.  Class "AsIs" has a few of its own methods, includingfor [, as.data.frame, print and format. In function formula.  There it is used toinhibit the interpretation of  operators such as "+","-", "*" and "^" as formula operators, so theyare used as arithmetical operators.  This is interpreted as a symbolby terms.formula.
The names of encodings and which ones are available areplatform-dependent.  All R platforms support "" (for theencoding of the current locale), "latin1" and "UTF-8".Generally case is ignored when specifying an encoding.On most platforms iconvlist provides an alphabetical list ofthe supported encodings.  On others, the information is on the manpage for iconv(5) or elsewhere in the man pages (but bewarethat the system command iconv may not support the same set ofencodings as the C functions R calls).  Unfortunately, the names arerarely supported across all platforms.Elements of x which cannot be converted (perhaps because theyare invalid or because they cannot be represented in the targetencoding) will be returned as NA unless sub is specified.Most versions of iconv will allow transliteration by appending//TRANSLIT to the to encoding: see the examples.Encoding "ASCII" is accepted, and on most systems "C"and "POSIX" are synonyms for ASCII.Any encoding bits (see Encoding) on elements of xare ignored: they will always be translated as if from encodingfrom even if declared otherwise.  enc2native andenc2utf8 provide alternatives which do take declaredencodings into account.Note that implementations of iconv typically do not do muchvalidity checking and will often mis-convert inputs which are invalidin encoding from.If sub = "Unicode" is used for a non-UTF-8 input it is the sameas sub = "byte".
The names of encodings and which ones are available areplatform-dependent.  All R platforms support "" (for theencoding of the current locale), "latin1" and "UTF-8".Generally case is ignored when specifying an encoding.On most platforms iconvlist provides an alphabetical list ofthe supported encodings.  On others, the information is on the manpage for iconv(5) or elsewhere in the man pages (but bewarethat the system command iconv may not support the same set ofencodings as the C functions R calls).  Unfortunately, the names arerarely supported across all platforms.Elements of x which cannot be converted (perhaps because theyare invalid or because they cannot be represented in the targetencoding) will be returned as NA unless sub is specified.Most versions of iconv will allow transliteration by appending//TRANSLIT to the to encoding: see the examples.Encoding "ASCII" is accepted, and on most systems "C"and "POSIX" are synonyms for ASCII.Any encoding bits (see Encoding) on elements of xare ignored: they will always be translated as if from encodingfrom even if declared otherwise.  enc2native andenc2utf8 provide alternatives which do take declaredencodings into account.Note that implementations of iconv typically do not do muchvalidity checking and will often mis-convert inputs which are invalidin encoding from.If sub = "Unicode" is used for a non-UTF-8 input it is the sameas sub = "byte".
Optionally, R can be built to collate character strings by ICU(http://site.icu-project.org).  For such systems,icuSetCollate can be used to tune the way collation is done.On other builds calling this function does nothing, with a warning.Possible arguments areA character string such as "da_DK"giving the language and country whose collation rules are to beused.  If present, this should be the first argument."upper", "lower" or"default", asking for upper- or lower-case characters to besorted first.  The default is usually lower-case first, but not inall languages (not under the default settings for Danish, for example).Controls the handling of‘variable’ characters (mainly punctuation and symbols).Possible values are "non_ignorable" (primary strength) and"shifted" (quaternary strength).Which components should be used?  Possiblevalues "primary", "secondary", "tertiary"(default), "quaternary" and "identical". In a French locale the way accentsaffect collation is from right to left, whereas in most other localesit is from left to right.  Possible values "on", "off"and "default".Should strings be normalized?  Possible valuesare "on" and "off" (default).  This affects thecollation of composite characters.An additional level between secondary andtertiary, used to distinguish large and small Japanese Kanacharacters. Possible values "on" and "off" (default).Possible values "on" (sortHiragana first at quaternary level) and "off".Only the first three are likely to be of interest except to those with adetailed understanding of collation and specialized requirements.Some special values are accepted for locale:ICU is not used for collation: the OS'scollation services are used instead.ICU is not used for collation: the C functionstrcmp is used instead, which should sort byte-by-byte in(unsigned) numerical order.obtains the locale from the OS as is done at the start of thesession.  If environment variable R_ICU_LOCALE is set to anon-empty value, its value is used rather than consulting the OS,unless environment variable LC_ALL is set to 'C' (or unset butLC_COLLATE is set to 'C').the ‘root’ collation: seehttps://www.unicode.org/reports/tr35/tr35-collation.html#Root_Collation.For the specifications of ‘real’ ICU locales, seehttp://userguide.icu-project.org/locale.  Note that ICU does notreport that a locale is not supported, but falls back to its idea of‘best fit’ (which could be rather different and is reported byicuGetCollate("actual"), often "root").  Most Englishlocales fall back to "root" as although e.g. "en_GB" isa valid locale (at least on some platforms), it contains no specialrules for collation.  Note that "C" is not a supported ICU localeand hence R_ICU_LOCALE should never be set to "C".Some examples are case_level = "on", strength = "primary" to ignoreaccent differences and alternate_handling = "shifted" to ignorespace and punctuation characters.Initially ICU will not be used for collation if the OS is set to use theC locale for collation and R_ICU_LOCALE is not set.  Oncethis function is called with a value for locale, ICU will be useduntil it is called again with locale = "none".  ICU will not beused once Sys.setlocale is called with a "C" value forLC_ALL or LC_COLLATE, even if R_ICU_LOCALE is set. ICU will be used again honoring R_ICU_LOCALE onceSys.setlocale is called to set a different collation order. Environment variables LC_ALL (or LC_COLLATE) take precedenceover R_ICU_LOCALE if and only if they are set to 'C'.  Due to theinteraction with other ways of setting the collation order,R_ICU_LOCALE should be used with care and only when needed.All customizations are reset to the default for the locale iflocale is specified: the collation engine is reset if theOS collation locate category is changed by Sys.setlocale.
Optionally, R can be built to collate character strings by ICU(http://site.icu-project.org).  For such systems,icuSetCollate can be used to tune the way collation is done.On other builds calling this function does nothing, with a warning.Possible arguments areA character string such as "da_DK"giving the language and country whose collation rules are to beused.  If present, this should be the first argument."upper", "lower" or"default", asking for upper- or lower-case characters to besorted first.  The default is usually lower-case first, but not inall languages (not under the default settings for Danish, for example).Controls the handling of‘variable’ characters (mainly punctuation and symbols).Possible values are "non_ignorable" (primary strength) and"shifted" (quaternary strength).Which components should be used?  Possiblevalues "primary", "secondary", "tertiary"(default), "quaternary" and "identical". In a French locale the way accentsaffect collation is from right to left, whereas in most other localesit is from left to right.  Possible values "on", "off"and "default".Should strings be normalized?  Possible valuesare "on" and "off" (default).  This affects thecollation of composite characters.An additional level between secondary andtertiary, used to distinguish large and small Japanese Kanacharacters. Possible values "on" and "off" (default).Possible values "on" (sortHiragana first at quaternary level) and "off".Only the first three are likely to be of interest except to those with adetailed understanding of collation and specialized requirements.Some special values are accepted for locale:ICU is not used for collation: the OS'scollation services are used instead.ICU is not used for collation: the C functionstrcmp is used instead, which should sort byte-by-byte in(unsigned) numerical order.obtains the locale from the OS as is done at the start of thesession.  If environment variable R_ICU_LOCALE is set to anon-empty value, its value is used rather than consulting the OS,unless environment variable LC_ALL is set to 'C' (or unset butLC_COLLATE is set to 'C').the ‘root’ collation: seehttps://www.unicode.org/reports/tr35/tr35-collation.html#Root_Collation.For the specifications of ‘real’ ICU locales, seehttp://userguide.icu-project.org/locale.  Note that ICU does notreport that a locale is not supported, but falls back to its idea of‘best fit’ (which could be rather different and is reported byicuGetCollate("actual"), often "root").  Most Englishlocales fall back to "root" as although e.g. "en_GB" isa valid locale (at least on some platforms), it contains no specialrules for collation.  Note that "C" is not a supported ICU localeand hence R_ICU_LOCALE should never be set to "C".Some examples are case_level = "on", strength = "primary" to ignoreaccent differences and alternate_handling = "shifted" to ignorespace and punctuation characters.Initially ICU will not be used for collation if the OS is set to use theC locale for collation and R_ICU_LOCALE is not set.  Oncethis function is called with a value for locale, ICU will be useduntil it is called again with locale = "none".  ICU will not beused once Sys.setlocale is called with a "C" value forLC_ALL or LC_COLLATE, even if R_ICU_LOCALE is set. ICU will be used again honoring R_ICU_LOCALE onceSys.setlocale is called to set a different collation order. Environment variables LC_ALL (or LC_COLLATE) take precedenceover R_ICU_LOCALE if and only if they are set to 'C'.  Due to theinteraction with other ways of setting the collation order,R_ICU_LOCALE should be used with care and only when needed.All customizations are reset to the default for the locale iflocale is specified: the collation engine is reset if theOS collation locate category is changed by Sys.setlocale.
A call to identical is the way to test exact equality inif and while statements, as well as in logicalexpressions that use && or ||.  In all theseapplications you need to be assured of getting a single logicalvalue.Users often use the comparison operators, such as == or!=, in these situations.  It looks natural, but it is not whatthese operators are designed to do in R.  They return an object likethe arguments.  If you expected x and y to be of length1, but it happened that one of them was not, you will not get asingle FALSE.  Similarly, if one of the arguments is NA,the result is also NA.  In either case, the expressionif(x == y).... won't work as expected.The function all.equal is also sometimes used to test equalitythis way, but was intended for something different:  it allows forsmall differences in numeric results.The computations in identical are also reliable and usuallyfast.  There should never be an error.  The only known way to killidentical is by having an invalid pointer at the C level,generating a memory fault.  It will usually find inequality quickly.Checking equality for two large, complicated objects can take longerif the objects are identical or nearly so, but represent completelyindependent copies.  For most applications, however, the computational costshould be negligible.If single.NA is true, as by default, identical seesNaN as different from NA_real_, but allNaNs are equal (and all NA of the same type are equal).Character strings are regarded as identical if they are in differentmarked encodings but would agree when translated to UTF-8.If attrib.as.set is true, as by default, comparison ofattributes view them as a set (and not a vector, so order is nottested).If ignore.bytecode is true (the default), the compiledbytecode of a function (see cmpfun) will be ignored inthe comparison.  If it is false, functions will compare equal only ifthey are copies of the same compiled object (or both areuncompiled).  To check whether two different compiles are equal, youshould compare the results of disassemble().You almost never want to use identical on datetimes of class"POSIXlt": not only can different times in the differenttime zones represent the same time and time zones have multiple names,but several of the components are optional.Note that identical(x, y, FALSE, FALSE, FALSE, FALSE) pickilytests for exact equality.
NA
break breaks out of a for, while or repeatloop; control is transferred to the first statement outside theinner-most loop. next halts the processing of the currentiteration and advances the looping index.  Both break andnext apply only to the innermost of nested loops.Note that it is a common mistake to forget to put braces ({ .. })around your statements, e.g., after if(..) or for(....).In particular, you should not have a newline between } andelse to avoid a syntax error in entering a if ... elseconstruct at the keyboard or via source.For that reason, one (somewhat extreme) attitude of defensive programmingis to always use braces, e.g., for if clauses.The seq in a for loop is evaluated at the start ofthe loop; changing it subsequently does not affect the loop.  Ifseq has length zero the body of the loop is skipped. Otherwise thevariable var is assigned in turn the value of each element ofseq. You can assign to var within the body of the loop,but this will not affect the next iteration.  When the loop terminates,var remains as a variable containing its latest value.
If yes or no are too short, their elements are recycled.yes will be evaluated if and only if any element of testis true, and analogously for no.Missing values in test give missing values in the result.
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
saveRDS and readRDS provide the means to save a single Robject to a connection (typically a file) and to restore the object, quitepossibly under a different name.  This differs from save andload, which save and restore one or more named objects intoan environment.  They are widely used by R itself, for example to storemetadata for a package and to store the help.searchdatabases: the ".rds" file extension is most often used.Functions serialize and unserializeprovide a slightly lower-level interface to serialization: objectsserialized to a connection by serialize can be read back byreadRDS and conversely.Function infoRDS retrieves meta-data about serialization producedby saveRDS or serialize. infoRDS cannot be used todetect whether a file is a serialization nor whether it is valid.All of these interfaces use the same serialization format, but savewrites a single line header (typically "RDXs\n") before theserialization of a single object (a pairlist of all the objects to besaved).If file is a file name, it is opened by gzfileexcept for save(compress = FALSE) which usesfile.  Only for the exception are marked encodings offile which cannot be translated to the native encoding handledon Windows.Compression is handled by the connection opened when file is afile name, so is only possible when file is a connection ifhandled by the connection.  So e.g. urlconnections will need to be wrapped in a call to gzcon.If a connection is supplied it will be opened (in binary mode) for theduration of the function if not already open: if it is already open itmust be in binary mode for saveRDS(ascii = FALSE) or to readnon-ASCII saves.
Here, we describe the so called “S3” classes (and methods). For“S4” classes (and methods), see ‘Formal classes’ below.Many R objects have a class attribute, a character vectorgiving the names of the classes from which the object inherits.(Functions oldClass and oldClass<- get and set theattribute, which can also be done directly.)If the object does not have a class attribute, it has an implicitclass, notably "matrix", "array", "function" or"numeric" or the result oftypeof(x) (which is similar to mode(x)),but for type "language" and mode "call",where the following extra classes exist for the corresponding functioncalls:if, while, for, =, <-, (,{, call.Note that for objects x of an implicit (or an S4) class, when a(S3) generic function foo(x) is called, method dispatch may usemore classes than are returned by class(x), e.g., for a numericmatrix, the foo.numeric() method may apply.  The exact fullcharacter vector of the classes whichUseMethod() uses, is available as .class2(x) sinceR version 4.0.0.  (This also applies to S4 objects when S3 dispatch isconsidered, see below.)Beware that using .class2() for other reasons than didactical,diagnostical or for debugging may rather be a misuse than smart.NULL objects (of implicit class "NULL") cannot haveattributes (hence no class attribute) and attempting to assign aclass is an error.When a generic function fun is applied to an object with classattribute c("first", "second"), the system searches for afunction called fun.first and, if it finds it, applies it tothe object.  If no such function is found, a function calledfun.second is tried.  If no class name produces a suitablefunction, the function fun.default is used (if it exists).  Ifthere is no class attribute, the implicit class is tried, then thedefault method.The function class prints the vector of names of classes anobject inherits from.  Correspondingly, class<- sets theclasses an object inherits from.  Assigning an empty character vector orNULL removes the class attribute, as for oldClass<- ordirect attribute setting.  Whereas it is clearer to explicitly assignNULL to remove the class, using an empty vector is more natural ine.g., class(x) <- setdiff(class(x), "ts").unclass returns (a copy of) its argument with its classattribute removed.  (It is not allowed for objects which cannot becopied, namely environments and external pointers.)inherits indicates whether its first argument inherits from anyof the classes specified in the what argument.  If whichis TRUE then an integer vector of the same length aswhat is returned.  Each element indicates the position in theclass(x) matched by the element of what; zero indicatesno match. If which is FALSE then TRUE isreturned by inherits if any of the names in what matchwith any class.isa tests whether x is an object of class(es) as givenin what by using is if x is an S4object, and otherwise giving TRUE iff all elements ofclass(x) are contained in what.All but inherits and isa are primitive functions.
Integer vectors exist so that data can be passed to C or Fortran codewhich expects them, and so that (small) integer data can be representedexactly and compactly.Note that current implementations of R use 32-bit integers forinteger vectors, so the range of representable integers is restrictedto about +/-2*10^9: doubles canhold much larger integers exactly.
NA
An interactive R session is one in which it is assumed that there isa human operator to interact with, so for example R can prompt forcorrections to incorrect input or ask what to do next or if it is OKto move to the next plot.GUI consoles will arrange to start R in an interactive session.  WhenR is run in a terminal (via Rterm.exe on Windows), itassumes that it is interactive if ‘stdin’ is connected to a(pseudo-)terminal and not if ‘stdin’ is redirected to a file orpipe.  Command-line options --interactive (Unix) and--ess (Windows, Rterm.exe) override the defaultassumption.(On a Unix-alike, whether the readline command-line editor isused is not overridden by --interactive.)Embedded uses of R can set a session to be interactive or not.Internally, whether a session is interactive determines how some errors are handled and reported, e.g. seestop and options("showWarnCalls").  whether one of --save, --no-save or--vanilla is required, and if R ever asks whether to save theworkspace. the choice of default graphics device launched when needed andby dev.new: see options("device") whether graphics devices ever ask for confirmation of a newpage.In addition, R's own R code makes use of interactive(): forexample help, debugger andinstall.packages do.
Each of union, intersect, setdiff andsetequal will discard any duplicated values in the arguments,and they apply as.vector to their arguments (and soin particular coerce factors to character vectors).is.element(x, y) is identical to x %in% y.
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
These will work in any locale, including on platforms that do nototherwise support multi-byte character sets.Unicode defines a name and a number of all of the glyphs itencompasses: the numbers are called code points: since RFC3629they run from 0 to 0x10FFFF (with about 5% beingassigned by version 13.0 of the Unicode standard and 7% reserved for‘private use’).intToUtf8 does not by default handle surrogate pairs: inputs inthe surrogate ranges are mapped to NA.  They might occur if aUTF-16 byte stream has been read as 2-byte integers (in the correctbyte order), in which case allow_surrogate_pairs = TRUE willtry to interpret them (with unmatched surrogate values still treatedas NA).
‘vector’ is used in the sense of is.vector.Missing values are regarded as unequal to the previous value, even ifthat is also missing.inverse.rle() is the inverse function of rle(),reconstructing x from the runs.
This function can be useful when it is desired to have functionsreturn values which can be assigned, but which do not print when theyare not assigned.This is a primitive function.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
An array in R can have one, two or more dimensions.  It is simply avector which is stored with additional attributes giving thedimensions (attribute "dim") and optionally names for thosedimensions (attribute "dimnames").A two-dimensional array is the same thing as a matrix.One-dimensional arrays often look like vectors, but may be handleddifferently by some functions: str does distinguishthem in recent versions of R.The "dim" attribute is an integer vector of length one or morecontaining non-negative values: the product of the values must matchthe length of the array.The "dimnames" attribute is optional: if present it is a listwith one component for each dimension, either NULL or acharacter vector of the length given by the element of the"dim" attribute for that dimension.is.array is a primitive function.For a list array, the print methods prints entries of lengthnot one in the form integer,7 indicating the type and length.
is.atomic is true for the atomic types("logical", "integer", "numeric","complex", "character" and "raw") and NULL.Most types of objects are regarded as recursive.  Exceptions are the atomictypes, NULL, symbols (as given by as.name),S4 objects with slots, external pointers, and—rarely visiblefrom R—weak references and byte code, see typeof.It is common to call the atomic types ‘atomic vectors’, butnote that is.vector imposes further restrictions: anobject can be atomic but not a vector (in that sense).These are primitive functions.
returns an unevaluated function call, that is, anunevaluated expression which consists of the named function applied tothe given arguments (name must be a string which givesthe name of a function to be called).  Note that although the call isunevaluated, the arguments ... are evaluated.call is a primitive, so the first argument istaken as name and the remaining arguments as arguments for theconstructed call: if the first argument is named the name mustpartially match name.is used to determine whether x is a call (i.e.,of mode "call" or "(").  Note thatis.call(x) is strictly equivalent totypeof(x) == "language".is.language() is also true for calls (but alsofor symbols and expressions whereis.call() is false).Objects of mode "list" can be coerced to mode "call".The first element of the list becomes the function part of the call,so should be a function or the name of one (as a symbol; a character string will not do).If you think of using as.call(<string>), consider usingstr2lang(*) which is an efficient version ofparse(text=*).Note that call() and as.call(), whenapplicable, are much preferable to these parse() basedapproaches.All three are primitive functions.as.call is generic: you can write methods to handle specificclasses of objects, see InternalMethods.
as.character and is.character are generic: you canwrite methods to handle specific classes of objects,see InternalMethods.  Further, for as.character thedefault method calls as.vector, so dispatch is first onmethods for as.character and then for methods for as.vector.as.character represents real and complex numbers to 15 significantdigits (technically the compiler's setting of the ISO C constantDBL_DIG, which will be 15 on machines supporting IEC60559arithmetic according to the C99 standard).  This ensures that all thedigits in the result will be reliable (and not the result ofrepresentation error), but does mean that conversion to character andback to numeric may change the number.  If you want to convert numbersto character with the maximum possible precision, useformat.
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
as.data.frame is a generic function with many methods, andusers and packages can supply further methods.  For classes that actas vectors, often a copy of as.data.frame.vector will workas the method.If a list is supplied, each element is converted to a column in thedata frame.  Similarly, each column of a matrix is converted separately.This can be overridden if the object has a class which hasa method for as.data.frame: two examples arematrices of class "model.matrix" (which areincluded as a single column) and list objects of class"POSIXlt" which are coerced to class"POSIXct".Arrays can be converted to data frames.  One-dimensional arrays aretreated like vectors and two-dimensional arrays like matrices.  Arrayswith more than two dimensions are converted to matrices by‘flattening’ all dimensions after the first and creatingsuitable column labels.Character variables are converted to factor columns unless protectedby I.If a data frame is supplied, all classes preceding "data.frame"are stripped, and the row names are changed if that argument is supplied.If row.names = NULL, row names are constructed from the namesor dimnames of x, otherwise are the integer sequencestarting at one.  Few of the methods check for duplicated row names.Names are removed from vector columns unless I.
double creates a double-precision vector of the specifiedlength.  The elements of the vector are all equal to 0.It is identical to numeric.as.double is a generic function.  It is identical toas.numeric.  Methods should return an object of base type"double".is.double is a test of double type.R has no single precision data type.  All real numbers arestored in double precision format.  The functions as.singleand single are identical to as.double and doubleexcept they set the attribute Csingle that is used in the.C and .Fortran interface, and they areintended only to be used in that context.
Each of union, intersect, setdiff andsetequal will discard any duplicated values in the arguments,and they apply as.vector to their arguments (and soin particular coerce factors to character vectors).is.element(x, y) is identical to x %in% y.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
‘Expression’ here is not being used in its colloquial sense,that of mathematical expressions.  Those are calls (seecall) in R, and an R expression vector is a list ofcalls, symbols etc, for example as returned by parse.As an object of mode "expression" is a list, it can besubsetted by [, [[ or $, the latter two extractingindividual calls etc.  The replacement forms of these operators can beused to replace or delete elements.expression and is.expression are primitive functions.expression is ‘special’: it does not evaluate its arguments.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
is.finite returns a vector of the same length as x thejth element of which is TRUE if x[j] is finite (i.e., itis not one of the values NA, NaN, Inf or-Inf) and FALSE otherwise.  Complexnumbers are finite if both the real and imaginary parts are.is.infinite returns a vector of the same length as x thejth element of which is TRUE if x[j] is infinite (i.e.,equal to one of Inf or -Inf) and FALSEotherwise.  This will be false unless x is numeric or complex.Complex numbers are infinite if either the real or the imaginary part is.is.nan tests if a numeric value is NaN.  Do not testequality to NaN, or even use identical, sincesystems typically have many different NaN values.  One of these isused for the numeric missing value NA, and is.nan isfalse for that value.  A complex number is regarded as NaN ifeither the real or imaginary part is NaN but not NA.All elements of logical, integer and raw vectors are considered not tobe NaN.All three functions accept NULL as input and return a lengthzero result. The default methods accept character and raw vectors, andreturn FALSE for all entries. Prior to R version 2.14.0 theyaccepted all input, returning FALSE for most non-numericvalues; cases which are not atomic vectors are now signalled aserrors.All three functions are generic: you can write methods to handlespecific classes of objects, see InternalMethods.
is.primitive(x) tests if x is a primitive function,i.e, if typeof(x) is either "builtin" or"special".
is.finite returns a vector of the same length as x thejth element of which is TRUE if x[j] is finite (i.e., itis not one of the values NA, NaN, Inf or-Inf) and FALSE otherwise.  Complexnumbers are finite if both the real and imaginary parts are.is.infinite returns a vector of the same length as x thejth element of which is TRUE if x[j] is infinite (i.e.,equal to one of Inf or -Inf) and FALSEotherwise.  This will be false unless x is numeric or complex.Complex numbers are infinite if either the real or the imaginary part is.is.nan tests if a numeric value is NaN.  Do not testequality to NaN, or even use identical, sincesystems typically have many different NaN values.  One of these isused for the numeric missing value NA, and is.nan isfalse for that value.  A complex number is regarded as NaN ifeither the real or imaginary part is NaN but not NA.All elements of logical, integer and raw vectors are considered not tobe NaN.All three functions accept NULL as input and return a lengthzero result. The default methods accept character and raw vectors, andreturn FALSE for all entries. Prior to R version 2.14.0 theyaccepted all input, returning FALSE for most non-numericvalues; cases which are not atomic vectors are now signalled aserrors.All three functions are generic: you can write methods to handlespecific classes of objects, see InternalMethods.
Integer vectors exist so that data can be passed to C or Fortran codewhich expects them, and so that (small) integer data can be representedexactly and compactly.Note that current implementations of R use 32-bit integers forinteger vectors, so the range of representable integers is restrictedto about +/-2*10^9: doubles canhold much larger integers exactly.
NA
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
The objects dyn.load loads are called ‘dynamicallyloadable libraries’ (abbreviated to ‘DLL’) on all platformsexcept macOS, which uses the term for a different sortof object.  On Unix-alikes they are also called ‘dynamicshared objects’ (‘DSO’), or ‘shared objects’ forshort.  (The POSIX standards use ‘executable object file’,but no one else does.)See ‘See Also’ and the ‘Writing R Extensions’ and‘R Installation and Administration’ manuals for how to createand install a suitable DLL.Unfortunately a very few platforms (e.g., Compaq Tru64) do not handlethe PACKAGE argument correctly, and may incorrectly findsymbols linked into R.The additional arguments to dyn.load mirror the differentaspects of the mode argument to the dlopen() routine on POSIXsystems.  They are available so that users can exercise greater controlover the loading process for an individual library.  In general, thedefault values are appropriate and you should override them only ifthere is good reason and you understand the implications.The local argument allows one to control whether the symbols inthe DLL being attached are visible to other DLLs.  While maintainingthe symbols in their own namespace is good practice, the ability toshare symbols across related ‘chapters’ is useful in manycases.  Additionally, on certain platforms and versions of anoperating system, certain libraries must have their symbols loadedglobally to successfully resolve all symbols.One should be careful of the potential side-effect of using lazyloading via the now argument as FALSE.  If a routine iscalled that has a missing symbol, the process will terminateimmediately.  The intended use is for library developers to call withvalue TRUE to check that all symbols are actually resolved andfor regular users to call with FALSE so that missing symbolscan be ignored and the available ones can be called.The initial motivation for adding these was to avoid such terminationin the _init() routines of the Java virtual machine library.However, symbols loaded locally may not be (read probably) availableto other DLLs.  Those added to the global table are available to allother elements of the application and so can be shared across twodifferent DLLs.Some (very old) systems do not provide (explicit) support forlocal/global and lazy/eager symbol resolution.  This can be the sourceof subtle bugs.  One can arrange to have warning messages emitted whenunsupported options are used.  This is done by setting either of theoptions verbose or warn to be non-zero via theoptions function.There is a short discussion of these additional arguments with someexample code available athttp://www.stat.ucdavis.edu/~duncan/R/dynload/.
TRUE and FALSE are reserved words denoting logicalconstants in the R language, whereas T and F are globalvariables whose initial values set to these.  All four arelogical(1) vectors.Logical vectors are coerced to integer vectors in contexts where anumerical value is required, with TRUE being mapped to1L, FALSE to 0L and NA to NA_integer_.
If one of nrow or ncol is not given, an attempt ismade to infer it from the length of data and the otherparameter.  If neither is given, a one-column matrix is returned.If there are too few elements in data to fill the matrix,then the elements in data are recycled.  If data haslength zero, NA of an appropriate type is used for atomicvectors (0 for raw vectors) and NULL for lists.is.matrix returns TRUE if x is a vector and has a"dim" attribute of length 2 and FALSE otherwise.Note that a data.frame is not a matrix by thistest.  The function is generic: you can write methods to handlespecific classes of objects, see InternalMethods.as.matrix is a generic function.  The method for data frameswill return a character matrix if there is only atomic columns and anynon-(numeric/logical/complex) column, applying as.vectorto factors and format to other non-character columns.Otherwise, the usual coercion hierarchy (logical < integer < double <complex) will be used, e.g., all-logical data frames will be coercedto a logical matrix, mixed logical-integer will give a integer matrix,etc.The default method for as.matrix calls as.vector(x), andhence e.g. coerces factors to character vectors.When coercing a vector, it produces a one-column matrix, andpromotes the names (if any) of the vector to the rownames of the matrix.is.matrix is a primitive function.The print method for a matrix gives a rectangular layout withdimnames or indices.  For a list matrix, the entries of length notone are printed in  the form integer,7 indicating the typeand length.
The NA of character type is distinct from the string"NA".  Programmers who need to specify an explicit missingstring should use NA_character_ (rather than "NA") or setelements to NA using is.na<-.is.na and anyNA are generic: you can writemethods to handle specific classes of objects, seeInternalMethods.Function is.na<- may provide a safer way to set missingness.It behaves differently for factors, for example.Numerical computations using NA will normally result inNA: a possible exception is where NaN is alsoinvolved, in which case either might result (which may depend onthe R platform).  However, this is not guaranteed and future CPUsand/or compilers may behave differently. Dynamic binary translation mayalso impact this behavior (with valgrind, computations using NAmay result in NaN even when no NaN is involved).Logical computations treat NA as a missing TRUE/FALSEvalue, and so may return TRUE or FALSE if the expressiondoes not depend on the NA operand.The default method for anyNA handles atomic vectors without aclass and NULL.  It calls any(is.na(x)) on objects withclasses and for recursive = FALSE, on lists and pairlists.
The NA of character type is distinct from the string"NA".  Programmers who need to specify an explicit missingstring should use NA_character_ (rather than "NA") or setelements to NA using is.na<-.is.na and anyNA are generic: you can writemethods to handle specific classes of objects, seeInternalMethods.Function is.na<- may provide a safer way to set missingness.It behaves differently for factors, for example.Numerical computations using NA will normally result inNA: a possible exception is where NaN is alsoinvolved, in which case either might result (which may depend onthe R platform).  However, this is not guaranteed and future CPUsand/or compilers may behave differently. Dynamic binary translation mayalso impact this behavior (with valgrind, computations using NAmay result in NaN even when no NaN is involved).Logical computations treat NA as a missing TRUE/FALSEvalue, and so may return TRUE or FALSE if the expressiondoes not depend on the NA operand.The default method for anyNA handles atomic vectors without aclass and NULL.  It calls any(is.na(x)) on objects withclasses and for recursive = FALSE, on lists and pairlists.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
The NA of character type is distinct from the string"NA".  Programmers who need to specify an explicit missingstring should use NA_character_ (rather than "NA") or setelements to NA using is.na<-.is.na and anyNA are generic: you can writemethods to handle specific classes of objects, seeInternalMethods.Function is.na<- may provide a safer way to set missingness.It behaves differently for factors, for example.Numerical computations using NA will normally result inNA: a possible exception is where NaN is alsoinvolved, in which case either might result (which may depend onthe R platform).  However, this is not guaranteed and future CPUsand/or compilers may behave differently. Dynamic binary translation mayalso impact this behavior (with valgrind, computations using NAmay result in NaN even when no NaN is involved).Logical computations treat NA as a missing TRUE/FALSEvalue, and so may return TRUE or FALSE if the expressiondoes not depend on the NA operand.The default method for anyNA handles atomic vectors without aclass and NULL.  It calls any(is.na(x)) on objects withclasses and for recursive = FALSE, on lists and pairlists.
The NA of character type is distinct from the string"NA".  Programmers who need to specify an explicit missingstring should use NA_character_ (rather than "NA") or setelements to NA using is.na<-.is.na and anyNA are generic: you can writemethods to handle specific classes of objects, seeInternalMethods.Function is.na<- may provide a safer way to set missingness.It behaves differently for factors, for example.Numerical computations using NA will normally result inNA: a possible exception is where NaN is alsoinvolved, in which case either might result (which may depend onthe R platform).  However, this is not guaranteed and future CPUsand/or compilers may behave differently. Dynamic binary translation mayalso impact this behavior (with valgrind, computations using NAmay result in NaN even when no NaN is involved).Logical computations treat NA as a missing TRUE/FALSEvalue, and so may return TRUE or FALSE if the expressiondoes not depend on the NA operand.The default method for anyNA handles atomic vectors without aclass and NULL.  It calls any(is.na(x)) on objects withclasses and for recursive = FALSE, on lists and pairlists.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Names are limited to 10,000 bytes (and were to 256 bytes in versionsof R before 2.13.0).as.name first coerces its argument internally to a charactervector (so methods for as.character are not used).  It thentakes the first element and provided it is not "", returns asymbol of that name (and if the element is NA_character_, thename is `NA`).as.name is implemented as as.vector(x, "symbol"),and hence will dispatch methods for the generic function as.vector.is.name and is.symbol are primitive functions.
is.finite returns a vector of the same length as x thejth element of which is TRUE if x[j] is finite (i.e., itis not one of the values NA, NaN, Inf or-Inf) and FALSE otherwise.  Complexnumbers are finite if both the real and imaginary parts are.is.infinite returns a vector of the same length as x thejth element of which is TRUE if x[j] is infinite (i.e.,equal to one of Inf or -Inf) and FALSEotherwise.  This will be false unless x is numeric or complex.Complex numbers are infinite if either the real or the imaginary part is.is.nan tests if a numeric value is NaN.  Do not testequality to NaN, or even use identical, sincesystems typically have many different NaN values.  One of these isused for the numeric missing value NA, and is.nan isfalse for that value.  A complex number is regarded as NaN ifeither the real or imaginary part is NaN but not NA.All elements of logical, integer and raw vectors are considered not tobe NaN.All three functions accept NULL as input and return a lengthzero result. The default methods accept character and raw vectors, andreturn FALSE for all entries. Prior to R version 2.14.0 theyaccepted all input, returning FALSE for most non-numericvalues; cases which are not atomic vectors are now signalled aserrors.All three functions are generic: you can write methods to handlespecific classes of objects, see InternalMethods.
NULL can be indexed (see Extract) in just about anysyntactically legal way: whether it makes sense or not, the result isalways NULL.  Objects with value NULL can be changed byreplacement operators and will be coerced to the type of theright-hand side.NULL is also used as the empty pairlist: see theexamples. Because pairlists are often promoted to lists, you mayencounter NULL being promoted to an empty list.Objects with value NULL cannot have attributes as there is onlyone null object: attempts to assign them are either an error(attr) or promote the object to an empty list withattribute(s) (attributes and structure).
numeric is identical to double (and real).It creates a double-precision vector of the specified length with eachelement equal to 0.as.numeric is a generic function, but S3 methods must bewritten for as.double.  It is identical to as.double.is.numeric is an internal generic primitivefunction: you can write methods to handle specific classes of objects,see InternalMethods.  It is not the same asis.double.  Factors are handled by the default method,and there are methods for classes "Date","POSIXt" and "difftime" (all of whichreturn false).  Methods for is.numeric should only return trueif the base type of the class is double or integerand values can reasonably be regarded as numeric(e.g., arithmetic on them makes sense, and comparison should be donevia the base type).
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
numeric is identical to double (and real).It creates a double-precision vector of the specified length with eachelement equal to 0.as.numeric is a generic function, but S3 methods must bewritten for as.double.  It is identical to as.double.is.numeric is an internal generic primitivefunction: you can write methods to handle specific classes of objects,see InternalMethods.  It is not the same asis.double.  Factors are handled by the default method,and there are methods for classes "Date","POSIXt" and "difftime" (all of whichreturn false).  Methods for is.numeric should only return trueif the base type of the class is double or integerand values can reasonably be regarded as numeric(e.g., arithmetic on them makes sense, and comparison should be donevia the base type).
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
numeric is identical to double (and real).It creates a double-precision vector of the specified length with eachelement equal to 0.as.numeric is a generic function, but S3 methods must bewritten for as.double.  It is identical to as.double.is.numeric is an internal generic primitivefunction: you can write methods to handle specific classes of objects,see InternalMethods.  It is not the same asis.double.  Factors are handled by the default method,and there are methods for classes "Date","POSIXt" and "difftime" (all of whichreturn false).  Methods for is.numeric should only return trueif the base type of the class is double or integerand values can reasonably be regarded as numeric(e.g., arithmetic on them makes sense, and comparison should be donevia the base type).
NA
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
is.primitive(x) tests if x is a primitive function,i.e, if typeof(x) is either "builtin" or"special".
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The function has been written such as to correctly run in all versionsof R, S and S-PLUS.In order for code to be runnable in both R and S dialects previous toS-PLUS 8.0, your code must either define is.R or use it asif (exists("is.R") && is.function(is.R) && is.R()) {## R-specific code} else {## S-version of code}
The raw type is intended to hold raw bytes.  It is possible to extractsubsequences of bytes, and to replace elements (but only by elementsof a raw vector).  The relational operators (see Comparison,using the numerical order of the byte representation) work, as do thelogical operators (see Logic) with a bitwise interpretation.A raw vector is printed with each byte separately represented as apair of hex digits.  If you want to see a character representation(with escape sequences for non-printing characters) userawToChar.Coercion to raw treats the input values as representing small(decimal) integers, so the input is first coerced to integer, and thenvalues which are outside the range [0 ... 255] or areNA are set to 0 (the nul byte).as.raw and is.raw are primitive functions.
is.atomic is true for the atomic types("logical", "integer", "numeric","complex", "character" and "raw") and NULL.Most types of objects are regarded as recursive.  Exceptions are the atomictypes, NULL, symbols (as given by as.name),S4 objects with slots, external pointers, and—rarely visiblefrom R—weak references and byte code, see typeof.It is common to call the atomic types ‘atomic vectors’, butnote that is.vector imposes further restrictions: anobject can be atomic but not a vector (in that sense).These are primitive functions.
NA
Names are limited to 10,000 bytes (and were to 256 bytes in versionsof R before 2.13.0).as.name first coerces its argument internally to a charactervector (so methods for as.character are not used).  It thentakes the first element and provided it is not "", returns asymbol of that name (and if the element is NA_character_, thename is `NA`).as.name is implemented as as.vector(x, "symbol"),and hence will dispatch methods for the generic function as.vector.is.name and is.symbol are primitive functions.
If the argument dnn is not supplied, the internal functionlist.names is called to compute the ‘dimname names’.  If thearguments in ... are named, those names are used.  For theremaining arguments, deparse.level = 0 gives an empty name,deparse.level = 1 uses the supplied argument if it is a symbol,and deparse.level = 2 will deparse the argument.Only when exclude is specified (i.e., not by default) andnon-empty, will table potentially drop levels of factorarguments.useNA controls if the table includes counts of NAvalues: the allowed values correspond to never ("no"), only if the count ispositive ("ifany") and even for zero counts ("always").Note the somewhat “pathological” case of two different kinds ofNAs which are treated differently, depending on bothuseNA and exclude, see d.patho in the‘Examples:’ below.Both exclude and useNA operate on an “all or none”basis.  If you want to control the dimensions of a multiway tableseparately, modify each argument using factor oraddNA.Non-factor arguments a are coerced via factor(a,    exclude=exclude).  Since R 3.4.0, care is taken not tocount the excluded values (where they were included in the NAcount, previously).The summary method for class "table" (used for objectscreated by table or xtabs) which gives basicinformation and performs a chi-squared test for independence offactors (note that the function chisq.test currentlyonly handles 2-d tables).
is.unsorted is generic: you can write methods to handlespecific classes of objects, see InternalMethods.
The atomic modes are "logical", "integer","numeric" (synonym "double"), "complex","character" and "raw".If mode = "any", is.vector may return TRUE forthe atomic modes, list and expression.For any mode, it will return FALSE if x has anyattributes except names.  (This is incompatible with S.)  On the otherhand, as.vector removes all attributes including namesfor results of atomic mode (but not those of mode "list" nor"expression").Note that factors are not vectors; is.vector returnsFALSE and as.vector converts a factor to a charactervector for mode = "any".
Here, we describe the so called “S3” classes (and methods). For“S4” classes (and methods), see ‘Formal classes’ below.Many R objects have a class attribute, a character vectorgiving the names of the classes from which the object inherits.(Functions oldClass and oldClass<- get and set theattribute, which can also be done directly.)If the object does not have a class attribute, it has an implicitclass, notably "matrix", "array", "function" or"numeric" or the result oftypeof(x) (which is similar to mode(x)),but for type "language" and mode "call",where the following extra classes exist for the corresponding functioncalls:if, while, for, =, <-, (,{, call.Note that for objects x of an implicit (or an S4) class, when a(S3) generic function foo(x) is called, method dispatch may usemore classes than are returned by class(x), e.g., for a numericmatrix, the foo.numeric() method may apply.  The exact fullcharacter vector of the classes whichUseMethod() uses, is available as .class2(x) sinceR version 4.0.0.  (This also applies to S4 objects when S3 dispatch isconsidered, see below.)Beware that using .class2() for other reasons than didactical,diagnostical or for debugging may rather be a misuse than smart.NULL objects (of implicit class "NULL") cannot haveattributes (hence no class attribute) and attempting to assign aclass is an error.When a generic function fun is applied to an object with classattribute c("first", "second"), the system searches for afunction called fun.first and, if it finds it, applies it tothe object.  If no such function is found, a function calledfun.second is tried.  If no class name produces a suitablefunction, the function fun.default is used (if it exists).  Ifthere is no class attribute, the implicit class is tried, then thedefault method.The function class prints the vector of names of classes anobject inherits from.  Correspondingly, class<- sets theclasses an object inherits from.  Assigning an empty character vector orNULL removes the class attribute, as for oldClass<- ordirect attribute setting.  Whereas it is clearer to explicitly assignNULL to remove the class, using an empty vector is more natural ine.g., class(x) <- setdiff(class(x), "ts").unclass returns (a copy of) its argument with its classattribute removed.  (It is not allowed for objects which cannot becopied, namely environments and external pointers.)inherits indicates whether its first argument inherits from anyof the classes specified in the what argument.  If whichis TRUE then an integer vector of the same length aswhat is returned.  Each element indicates the position in theclass(x) matched by the element of what; zero indicatesno match. If which is FALSE then TRUE isreturned by inherits if any of the names in what matchwith any class.isa tests whether x is an object of class(es) as givenin what by using is if x is an S4object, and otherwise giving TRUE iff all elements ofclass(x) are contained in what.All but inherits and isa are primitive functions.
stdin(), stdout() and stderr() are standardconnections corresponding to input, output and error on the consolerespectively (and not necessarily to file streams).  They are text-modeconnections of class "terminal" which cannot be opened orclosed, and are read-only, write-only and write-only respectively.The stdout() and stderr() connections can bere-directed by sink (and in some circumstances theoutput from stdout() can be split: see the help page).The encoding for stdin() when redirected canbe set by the command-line flag --encoding.nullfile() returns filename of the null device ("/dev/null"on Unix, "nul:" on Windows).showConnections returns a matrix of information.  If aconnection object has been lost or forgotten, getConnectionwill take a row number from the table and return a connection objectfor that connection, which can be used to close the connection,for example.  However, if there is no R level object referring to theconnection it will be closed automatically at the next garbagecollection (except for gzcon connections).closeAllConnections closes (and destroys) all userconnections, restoring all sink diversions as it doesso.isatty returns true if the connection is one of the class"terminal" connections and it is apparently connected to aterminal, otherwise false.  This may not be reliable in embeddedapplications, including GUI consoles.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
When a function flagged for debugging is entered, normal executionis suspended and the body of function is executed one statement at atime.  A new browser context is initiated for each step(and the previous one destroyed).At the debug prompt the user can enter commands or R expressions,followed by a newline.  The commands are described in thebrowser help topic.To debug a function which is defined inside another function,single-step through to the end of its definition, and then calldebug on its name.If you want to debug a function not starting at the very beginning,use trace(..., at = *) or setBreakpoint.Using debug is persistent, and unless debugging is turned offthe debugger will be entered on every invocation (note that if thefunction is removed and replaced the debug state is not preserved).Use debugonce() to enter the debugger only the next time thefunction is invoked.To debug an S4 method by explicit signature, usesignature. When specified, signature indicates the method offun to be debugged. Note that debugging is implemented slightlydifferently for this case, as it uses the trace machinery, rather thanthe debugging bit. As such, text and condition cannot bespecified in combination with a non-null signature. For methodswhich implement the .local rematching mechanism, the.local closure itself is the one that will be ultimatelydebugged (see isRematched).isdebugged returns TRUE if a) signature is NULLand the closure fun has been debugged, or b) signature is notNULL, fun is an S4 generic, and the method of funfor that signature has been debugged. In all other cases, it returnsFALSE.The number of lines printed for the deparsed call when a function isentered for debugging can be limited by settingoptions(deparse.max.lines).When debugging is enabled on a byte compiled function then theinterpreted version of the function will be used until debugging isdisabled.
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
The functions loadNamespace and attachNamespace areusually called implicitly when library is used to load a namespace and any imports needed.  However it may be useful at times tocall these functions directly.loadNamespace loads the specified name space and registers it inan internal data base.  A request to load a name space when one of thatname is already loaded has no effect.  The arguments have the samemeaning as the corresponding arguments to library, whosehelp page explains the details of how a particular installed packagecomes to be chosen.  After loading, loadNamespace looks for ahook function named .onLoad as an internal variable inthe name space (it should not be exported).  Partial loading is usedto support installation with lazy-loading.Optionally the package licence is checked during loading: see section‘Licenses’ in the help for library.loadNamespace does not attach the name space it loads to thesearch path.  attachNamespace can be used to attach a framecontaining the exported values of a name space to the search path (butthis is almost always done via library).  Thehook function .onAttach is run after the name spaceexports are attached.requireNamespace is a wrapper for loadNamespaceanalogous to require that returns a logical value.loadedNamespaces returns a character vector of the names ofthe loaded name spaces.isNamespaceLoaded(pkg) is equivalent to but more efficient thanpkg %in% loadedNamespaces().unloadNamespace can be used to attempt to force a name space tobe unloaded.  If the name space is attached, it is firstdetached, thereby running a .onDetach or.Last.lib function in the name space if one is exported.  Anerror is signaled and the name space is not unloaded if the name spaceis imported by other loaded name spaces.  If defined, a hook function.onUnload is run before removing the name space from theinternal registry.See the comments in the help for detach about someissues with unloading and reloading name spaces.
ISOdatetime and ISOdate are convenience wrappers forstrptime that differ only in their defaults and thatISOdate sets UTC as the time zone.  For dates without times itwould normally be better to use the "Date" class.The main arguments will be recycled using the usual recycling rules.Because these make use of strptime, only years in therange 0:9999 are accepted.
ISOdatetime and ISOdate are convenience wrappers forstrptime that differ only in their defaults and thatISOdate sets UTC as the time zone.  For dates without times itwould normally be better to use the "Date" class.The main arguments will be recycled using the usual recycling rules.Because these make use of strptime, only years in therange 0:9999 are accepted.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
Note that isS4 does not rely on the methodspackage, so in particular it can be used to detect the need torequire that package.asS3 uses the value ofcomplete to control whether an attempt is made to transformobject into a valid object of the implied S3 class.  Ifcomplete is TRUE,then an object from an S4 class extending an S3 class will betransformed into an S3 object with the corresponding S3 class (seeS3Part).  This includes classes extending thepseudo-classes array and matrix: such objects will havetheir class attribute set to NULL.isS4 is primitive.
seek with where = NA returns the current byte offsetof a connection (from the beginning), and with a non-missing whereargument the connection is re-positioned (if possible) to thespecified position.  isSeekable returns whether the connectionin principle supports seek: currently only (possiblygz-compressed) file connections do.where is stored as a real but should represent an integer:non-integer values are likely to be truncated.  Note that the possiblevalues can exceed the largest representable number in an Rinteger on 64-bit builds, and on some 32-bit builds.File connections can be open for both writing/appending, in which caseR keeps separate positions for reading and writing.  Which seekrefers to can be set by its rw argument: the default is thelast mode (reading or writing) which was used.  Most files areonly opened for reading or writing and so default to that state.  If afile is open for both reading and writing but has not been used, thedefault is to give the reading position (0).The initial file position for reading is always at the beginning.The initial position for writing is at the beginning of the filefor modes "r+" and "r+b", otherwise at the end of thefile.  Some platforms only allow writing at the end of the file inthe append modes.  (The reported write position for a file opened inan append mode will typically be unreliable until the file has beenwritten to.)gzfile connections support seek with a number oflimitations, using the file position of the uncompressed file.They do not support origin = "end".  When writing, seeking isonly possible forwards: when reading seeking backwards is supported byrewinding the file and re-reading from its start.If seek is called with a non-NA value of where,any pushback on a text-mode connection is discarded.truncate truncates a file opened for writing at its currentposition.  It works only for file connections, and is notimplemented on all platforms: on others (including Windows) it willnot work for large (> 2Gb) files.None of these should be expected to work on text-mode connections withre-encoding selected.
The matrix method is used inside eigen bydefault to test symmetry of matrices up to rounding error, usingall.equal.  It might not be appropriate in allsituations.Note that a matrix m is only symmetric if its rownames andcolnames are identical.  Consider using unname(m).
The matrix method is used inside eigen bydefault to test symmetry of matrices up to rounding error, usingall.equal.  It might not be appropriate in allsituations.Note that a matrix m is only symmetric if its rownames andcolnames are identical.  Consider using unname(m).
! indicates logical negation (NOT).& and && indicate logical AND and | and ||indicate logical OR.  The shorter form performs elementwisecomparisons in much the same way as arithmetic operators.  The longerform evaluates left to right examining only the first element of eachvector.  Evaluation proceeds only until the result is determined.  Thelonger form is appropriate for programming control-flow and typicallypreferred in if clauses.xor indicates elementwise exclusive OR.isTRUE(x) is the same as{ is.logical(x) && length(x) == 1 && !is.na(x) && x };isFALSE() is defined analogously.  Consequently,if(isTRUE(cond)) may be preferable to if(cond) becauseof NAs.In earlier R versions, isTRUE <- function(x) identical(x, TRUE),had the drawback to be false e.g., for x <- c(val = TRUE).Numeric and complex vectors will be coerced to logical values, withzero being false and all non-zero values being true.  Raw vectors arehandled without any coercion for !, &, | andxor, with these operators being applied bitwise (so ! isthe 1s-complement).The operators !, & and | are generic functions:methods can be written for them individually or via theOps (or S4 Logic, see below)group generic function.  (See Ops forhow dispatch is computed.)NA is a valid logical object.  Where a component ofx or y is NA, the result will be NA if theoutcome is ambiguous.  In other words NA & TRUE evaluates toNA, but NA & FALSE evaluates to FALSE.  See theexamples below.See Syntax for the precedence of these operators: unlike manyother languages (including S) the AND and OR operators do not have thesame precedence (the AND operators have higher precedence than the ORoperators).
The result, say r, is r <- x + runif(n, -a, a)where n <- length(x) and a is the amountargument (if specified).Let z <- max(x) - min(x) (assuming the usual case).The amount a to be added is either provided as positiveargument amount or otherwise computed from z, asfollows:If amount == 0, we set a <- factor * z/50 (same as S).If amount is NULL (default), we seta <- factor * d/5 where d is the smallestdifference between adjacent unique (apart from fuzz) x values.
NA
NA
NA
For kappa(), if exact = FALSE (the default) the 2-normcondition number is estimated by a cheap approximation.  However, theexact calculation (via svd) is also likely to be quickenough.Note that the 1- and Inf-norm condition numbers are much faster tocalculate, and rcond() computes these reciprocalcondition numbers, also for complex matrices, using standard LAPACKroutines.kappa and rcond are different interfaces topartly identical functionality..kappa_tri is an internal function called by kappa.qr andkappa.default.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
For kappa(), if exact = FALSE (the default) the 2-normcondition number is estimated by a cheap approximation.  However, theexact calculation (via svd) is also likely to be quickenough.Note that the 1- and Inf-norm condition numbers are much faster tocalculate, and rcond() computes these reciprocalcondition numbers, also for complex matrices, using standard LAPACKroutines.kappa and rcond are different interfaces topartly identical functionality..kappa_tri is an internal function called by kappa.qr andkappa.default.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
For kappa(), if exact = FALSE (the default) the 2-normcondition number is estimated by a cheap approximation.  However, theexact calculation (via svd) is also likely to be quickenough.Note that the 1- and Inf-norm condition numbers are much faster tocalculate, and rcond() computes these reciprocalcondition numbers, also for complex matrices, using standard LAPACKroutines.kappa and rcond are different interfaces topartly identical functionality..kappa_tri is an internal function called by kappa.qr andkappa.default.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
For kappa(), if exact = FALSE (the default) the 2-normcondition number is estimated by a cheap approximation.  However, theexact calculation (via svd) is also likely to be quickenough.Note that the 1- and Inf-norm condition numbers are much faster tocalculate, and rcond() computes these reciprocalcondition numbers, also for complex matrices, using standard LAPACKroutines.kappa and rcond are different interfaces topartly identical functionality..kappa_tri is an internal function called by kappa.qr andkappa.default.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
If X and Y do not have the same number ofdimensions, the smaller array is padded with dimensions of sizeone.  The returned array comprises submatrices constructed bytaking X one term at a time and expanding that term asFUN(x, Y, ...).%x% is an alias for kronecker (whereFUN is hardwired to "*").
‘A Latin-1 locale’ includes supersets (for printablecharacters) such as Windows codepage 1252 but not Latin-9 (ISO 8859-15).On Windows (where the resulting list contains codepageand system.codepage components additionally), commoncodepages are 1252 (Western European), 1250 (Central European),1251 (Cyrillic), 1253 (Greek), 1254 (Turkish), 1255 (Hebrew), 1256(Arabic), 1257 (Baltic), 1258 (Vietnamese), 874 (Thai), 932(Japanese), 936 (Simplified Chinese), 949 (Korean) and 950(Traditional Chinese).  Codepage 28605 is Latin-9 and 65001 is UTF-8(where supported).  R does not allow the C locale, and uses 1252 asthe default codepage.
NA
NA
The singular value decomposition plays an important role in manystatistical techniques.  svd and La.svd provide twointerfaces which differ in their return values.Computing the singular vectors is the slow part for large matrices.The computation will be more efficient if both nu <= min(n, p)and nv <= min(n, p), and even more so if both are zero.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code (most often 1): these canonly be interpreted by detailed study of the FORTRAN code but meanthat the algorithm failed to converge.
NA
NA
FUN is found by a call to match.fun and typicallyis specified as a function or a symbol (e.g., a backquoted name) or acharacter string specifying a function to be searched for from theenvironment of the call to lapply.Function FUN must be able to accept as input any of theelements of X.  If the latter is an atomic vector, FUNwill always be passed a length-one vector of the same type as X.Arguments in ... cannot have the same name as any of theother arguments, and care may be needed to avoid partial matching toFUN.  In general-purpose code it is good practice to name thefirst two arguments X and FUN if ... is passedthrough: this both avoids partial matching to FUN and ensuresthat a sensible error message is given if arguments named X orFUN are passed through ....Simplification in sapply is only attempted if X haslength greater than zero and if the return values from all elementsof X are all of the same (positive) length.  If the commonlength is one the result is a vector, and if greater than one is amatrix with a column corresponding to each element of X.Simplification is always done in vapply.  This functionchecks that all values of FUN are compatible with theFUN.VALUE, in that they must have the same length and type.(Types may be promoted to a higher type within the ordering logical< integer < double < complex, but not demoted.)Users of S4 classes should pass a list to lapply andvapply: the internal coercion is done by the as.list inthe base namespace and not one defined by a user (e.g., by setting S4methods on the base function).
These are internal functions for use only by R itself.The function lazyLoad is the workhorse function called by thepackage loader to load the code for a package from a database.  Thedatabase consists of two binary files, ‘filebase.rdb’ (theobjects) and ‘filebase.rdx’ (an index).The objects are not themselves loaded into envir: ratherpromises are created that will load the object from the database onfirst access.  (See delayedAssign.)The function lazyLoadDBexec contains the core implementationand is also used by the mechanism for loading processed help filedata.
These are internal functions for use only by R itself.The function lazyLoad is the workhorse function called by thepackage loader to load the code for a package from a database.  Thedatabase consists of two binary files, ‘filebase.rdb’ (theobjects) and ‘filebase.rdx’ (an index).The objects are not themselves loaded into envir: ratherpromises are created that will load the object from the database onfirst access.  (See delayedAssign.)The function lazyLoadDBexec contains the core implementationand is also used by the mechanism for loading processed help filedata.
The functions .subset and .subset2 are essentiallyequivalent to the [ and [[ operators,except that methods dispatch does not take place.  This is to avoidexpensive unclassing when applying the default method to an object.  Theyshould not normally be invoked by end users.  Note that unlike theoperators they are builtins and not specials (all arguments areevaluated) and hence do not allow missing arguments..getRequiredPackages2 attaches all the packages mentioned in theDepends field: failure to find a package is an error.  It alsochecks the versions of the packages found against the Depends field..getRequiredPackages is a wrapper to.getRequiredPackages2 using a ‘DESCRIPTION’ file.The function .isMethodsDispatchOn() returns TRUE ifthe S4 method dispatch has been turned on in the evaluator (usually byloading package methods).  It is meant for R internal use only.sys.save.image is a system function that is called by q()and its GUI analogs; sys.load.image is called by the startup code.These functions should not be called directly and are subject to change.sys.save.image closes all connections first, to ensure that itis able to open a connection to save the image.  This is appropriatewhen called from q() and allies, but reinforces the warningthat it should not be called directly.row.names can be stored internally in compact form..set_row_names(n) generates that form for automatic row namesof length n, to be assigned toattr(<a data frame>, "row.names").  .row_names_infogives information on the internal form of the row names for a dataframe: for details of what information see the argument type..GenericArgsEnv and .ArgsEnv are environments thatcontain closures with the argument lists that the primitives wouldhave had had they been closures.  All the primitives that are internalS3 generics have corresponding members of .GenericArgsEnv andthe remaining non-language-element primitives correspond to.ArgsEnv.  See the ‘R Internals’ manual for furtherdetails.  They are used by args andprint.default and the QC functions codocand checkS3methods.findPackageEnv is invoked by the unserialize code to set asaved environment if possible..TAOCP1997init is the initialization code for the"Knuth-TAOCP" RNG..gt and .gtn are callbacks from rank andis.unsorted used for (S3 or S4) classed objects..primTrace and .primUntrace are the primitivefunctions underlying trace and untracerespectively..Date, .POSIXct, .POSIXlt and .difftimeare class generators..cache_class caches the inheritance of an S4 class for use inS3 method dispatch.  With NULL second argument it returns thecached inheritance, for diagnostic use..popath is a variable created at startup which records wherethe translations package in use is..detach is a ‘bare-bones’ version of detach foruse in other R packages..maskedMsg is a utility called both from attach()and library() for consistency to produce the warning message.Objects starting .C_ and .F_ are references toregistered C and Fortran entry points.Only on Windows:.fixupGFortranStdout and .fixupGFortranStderr are helper functionsto enable standard output and standard error units in gfortran whenexecuting external code via system and system2. By default, theseunits are disabled by the Windows profile when running inside RGui.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
Both functions are generic: you can write methods to handle specificclasses of objects, see InternalMethods.  length<- has a"factor" method.The replacement form can be used to reset the length of a vector.  Ifa vector is shortened, extra values are discarded and when a vector islengthened, it is padded out to its new length with NAs(nul for raw vectors).Both are primitive functions.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
Both functions are generic: you can write methods to handle specificclasses of objects, see InternalMethods.  length<- has a"factor" method.The replacement form can be used to reset the length of a vector.  Ifa vector is shortened, extra values are discarded and when a vector islengthened, it is padded out to its new length with NAs(nul for raw vectors).Both are primitive functions.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
Both functions are generic: you can write methods to handle specificclasses of objects, see InternalMethods.  length<- has a"factor" method.The replacement form can be used to reset the length of a vector.  Ifa vector is shortened, extra values are discarded and when a vector islengthened, it is padded out to its new length with NAs(nul for raw vectors).Both are primitive functions.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
This function loops over x and returns a compatible vectorcontaining the length of each element in x.  Effectively,length(x[[i]]) is called for all i, so any methods onlength are considered.lengths is generic: you can write methods to handlespecific classes of objects, see InternalMethods.
R has a small number of built-in constants.The following constants are available:LETTERS: the 26 upper-case letters of the Romanalphabet;letters: the 26 lower-case letters of the Romanalphabet;month.abb: the three-letter abbreviations for theEnglish month names;month.name: the English names for the months of theyear;pi: the ratio of the circumference of a circle to itsdiameter.These are implemented as variables in the base namespace takingappropriate values.
R has a small number of built-in constants.The following constants are available:LETTERS: the 26 upper-case letters of the Romanalphabet;letters: the 26 lower-case letters of the Romanalphabet;month.abb: the three-letter abbreviations for theEnglish month names;month.name: the English names for the months of theyear;pi: the ratio of the circumference of a circle to itsdiameter.These are implemented as variables in the base namespace takingappropriate values.
Both the extractor and replacement forms are generic and new methodscan be written for them.  The most important method for the replacementfunction is that for factors.For the factor replacement method, a NA in valuecauses that level to be removed from the levels and the elementsformerly with that level to be replaced by NA.Note that for a factor, replacing the levels vialevels(x) <- value is not the same as (and is preferred to)attr(x, "levels") <- value.The replacement function is primitive.
Both the extractor and replacement forms are generic and new methodscan be written for them.  The most important method for the replacementfunction is that for factors.For the factor replacement method, a NA in valuecauses that level to be removed from the levels and the elementsformerly with that level to be replaced by NA.Note that for a factor, replacing the levels vialevels(x) <- value is not the same as (and is preferred to)attr(x, "levels") <- value.The replacement function is primitive.
Both the extractor and replacement forms are generic and new methodscan be written for them.  The most important method for the replacementfunction is that for factors.For the factor replacement method, a NA in valuecauses that level to be removed from the levels and the elementsformerly with that level to be replaced by NA.Note that for a factor, replacing the levels vialevels(x) <- value is not the same as (and is preferred to)attr(x, "levels") <- value.The replacement function is primitive.
Both the extractor and replacement forms are generic and new methodscan be written for them.  The most important method for the replacementfunction is that for factors.For the factor replacement method, a NA in valuecauses that level to be removed from the levels and the elementsformerly with that level to be replaced by NA.Note that for a factor, replacing the levels vialevels(x) <- value is not the same as (and is preferred to)attr(x, "levels") <- value.The replacement function is primitive.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
NA
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
See dyn.load for what sort of objects these functions handle.library.dynam is designed to be used inside a package ratherthan at the command line, and should really only be used inside.onLoad.  The system-specific extension for DLLs (e.g.,‘.so’ or ‘.sl’ on Unix-alike systems,‘.dll’ on Windows) should not be added.library.dynam.unload is designed for use in.onUnload: it unloads the DLL and updates the value of.dynLibs().dynLibs is used for getting (with no argument) or setting theDLLs which are currently loaded by packages (using library.dynam).
See dyn.load for what sort of objects these functions handle.library.dynam is designed to be used inside a package ratherthan at the command line, and should really only be used inside.onLoad.  The system-specific extension for DLLs (e.g.,‘.so’ or ‘.sl’ on Unix-alike systems,‘.dll’ on Windows) should not be added.library.dynam.unload is designed for use in.onUnload: it unloads the DLL and updates the value of.dynLibs().dynLibs is used for getting (with no argument) or setting theDLLs which are currently loaded by packages (using library.dynam).
R is distributed under the terms of the GNU GENERAL PUBLIC LICENSE,either Version 2, June 1991 or Version 3, June 2007.  A copy of theversion 2 license is in file ‘R_HOME/doc/COPYING’and can be viewed by RShowDoc("COPYING").  Version 3 of thelicense can be displayed by RShowDoc("GPL-3").A small number of files (some of the API header files) are distributedunder the LESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.  Acopy of this license is in file ‘$R_SHARE_DIR/licenses/LGPL-2.1’and can be viewed by RShowDoc("LGPL-2.1").  Version 3 of thelicense can be displayed by RShowDoc("LGPL-3").
R is distributed under the terms of the GNU GENERAL PUBLIC LICENSE,either Version 2, June 1991 or Version 3, June 2007.  A copy of theversion 2 license is in file ‘R_HOME/doc/COPYING’and can be viewed by RShowDoc("COPYING").  Version 3 of thelicense can be displayed by RShowDoc("GPL-3").A small number of files (some of the API header files) are distributedunder the LESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.  Acopy of this license is in file ‘$R_SHARE_DIR/licenses/LGPL-2.1’and can be viewed by RShowDoc("LGPL-2.1").  Version 3 of thelicense can be displayed by RShowDoc("LGPL-3").
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
NA
NA
Note that all list elements are taken “as is” (apart frompossibly replicating to the same length).
This will be very slow for large inputs unless hashing is used on theenvironment.Environments must have uniquely named entries, but named lists neednot: where the list has duplicate names it is the last elementwith the name that is used.  Empty names throw an error.
load can load R objects saved in the current or any earlierformat.  It can read a compressed file (see save)directly from a file or from a suitable connection (including a callto url).A not-open connection will be opened in mode "rb" and closedafter use.  Any connection other than a gzfile orgzcon connection will be wrapped in gzconto allow compressed saves to be handled: note that this leaves theconnection in an altered state (in particular, binary-only), and thatit needs to be closed explicitly (it will not be garbage-collected).Only R objects saved in the current format (used since R 1.4.0)can be read from a connection.  If no input is available on aconnection a warning will be given, but any input not in the currentformat will result in a error.Loading from an earlier version will give a warning about the‘magic number’: magic numbers 1971:1977 are from R <0.99.0, and RD[ABX]1 from R 0.99.0 to R 1.3.1.  These are allobsolete, and you are strongly recommended to re-save such files in acurrent format.The verbose argument is mainly intended for debugging.  If itis TRUE, then as objects from the file are loaded, theirnames will be printed to the console.  If verbose is set toan integer value greater than one, additional names corresponding toattributes and other parts of individual objects will also be printed.Larger values will print names to a greater depth.Objects can be saved with references to namespaces, usually as part ofthe environment of a function or formula.  Such objects can be loadedeven if the namespace is not available: it is replaced by a referenceto the global environment with a warning.  The warning identifies thefirst object with such a reference (but there may be more than one).
The functions loadNamespace and attachNamespace areusually called implicitly when library is used to load a namespace and any imports needed.  However it may be useful at times tocall these functions directly.loadNamespace loads the specified name space and registers it inan internal data base.  A request to load a name space when one of thatname is already loaded has no effect.  The arguments have the samemeaning as the corresponding arguments to library, whosehelp page explains the details of how a particular installed packagecomes to be chosen.  After loading, loadNamespace looks for ahook function named .onLoad as an internal variable inthe name space (it should not be exported).  Partial loading is usedto support installation with lazy-loading.Optionally the package licence is checked during loading: see section‘Licenses’ in the help for library.loadNamespace does not attach the name space it loads to thesearch path.  attachNamespace can be used to attach a framecontaining the exported values of a name space to the search path (butthis is almost always done via library).  Thehook function .onAttach is run after the name spaceexports are attached.requireNamespace is a wrapper for loadNamespaceanalogous to require that returns a logical value.loadedNamespaces returns a character vector of the names ofthe loaded name spaces.isNamespaceLoaded(pkg) is equivalent to but more efficient thanpkg %in% loadedNamespaces().unloadNamespace can be used to attempt to force a name space tobe unloaded.  If the name space is attached, it is firstdetached, thereby running a .onDetach or.Last.lib function in the name space if one is exported.  Anerror is signaled and the name space is not unloaded if the name spaceis imported by other loaded name spaces.  If defined, a hook function.onUnload is run before removing the name space from theinternal registry.See the comments in the help for detach about someissues with unloading and reloading name spaces.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
The functions loadNamespace and attachNamespace areusually called implicitly when library is used to load a namespace and any imports needed.  However it may be useful at times tocall these functions directly.loadNamespace loads the specified name space and registers it inan internal data base.  A request to load a name space when one of thatname is already loaded has no effect.  The arguments have the samemeaning as the corresponding arguments to library, whosehelp page explains the details of how a particular installed packagecomes to be chosen.  After loading, loadNamespace looks for ahook function named .onLoad as an internal variable inthe name space (it should not be exported).  Partial loading is usedto support installation with lazy-loading.Optionally the package licence is checked during loading: see section‘Licenses’ in the help for library.loadNamespace does not attach the name space it loads to thesearch path.  attachNamespace can be used to attach a framecontaining the exported values of a name space to the search path (butthis is almost always done via library).  Thehook function .onAttach is run after the name spaceexports are attached.requireNamespace is a wrapper for loadNamespaceanalogous to require that returns a logical value.loadedNamespaces returns a character vector of the names ofthe loaded name spaces.isNamespaceLoaded(pkg) is equivalent to but more efficient thanpkg %in% loadedNamespaces().unloadNamespace can be used to attempt to force a name space tobe unloaded.  If the name space is attached, it is firstdetached, thereby running a .onDetach or.Last.lib function in the name space if one is exported.  Anerror is signaled and the name space is not unloaded if the name spaceis imported by other loaded name spaces.  If defined, a hook function.onUnload is run before removing the name space from theinternal registry.See the comments in the help for detach about someissues with unloading and reloading name spaces.
eval evaluates the expr argument in theenvironment specified by envir and returns the computed value.If envir is not specified, then the default isparent.frame() (the environment where the call toeval was made).Objects to be evaluated can be of types call orexpression or name (when the name is lookedup in the current scope and its binding is evaluated), a promiseor any of the basic types such as vectors, functions and environments(which are returned unchanged).The evalq form is equivalent to eval(quote(expr), ...).eval evaluates its first argument in the current scopebefore passing it to the evaluator: evalq avoids this.eval.parent(expr, n) is a shorthand foreval(expr, parent.frame(n)).If envir is a list (such as a data frame) or pairlist, it iscopied into a temporary environment (with enclosure enclos),and the temporary environment is used for evaluation.  So ifexpr changes any of the components named in the (pair)list, thechanges are lost.If envir is NULL it is interpreted as an empty list sono values could be found in envir and look-up goes directly toenclos.local evaluates an expression in a local environment.  It isequivalent to evalq except that its default argument creates anew, empty environment.  This is useful to create anonymous recursivefunctions and as a kind of limited namespace feature since variablesdefined in the environment are not visible from the outside.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
All except logb are generic functions: methods can be definedfor them individually or via the Mathgroup generic.log10 and log2 are only convenience wrappers, but logsto bases 10 and 2 (whether computed via log or the wrappers)will be computed more efficiently and accurately where supported by the OS.Methods can be set for them individually (and otherwise methods forlog will be used).logb is a wrapper for log for compatibility with S.  If(S3 or S4) methods are set for log they will be dispatched.Do not set S4 methods on logb itself.All except log are primitive functions.
TRUE and FALSE are reserved words denoting logicalconstants in the R language, whereas T and F are globalvariables whose initial values set to these.  All four arelogical(1) vectors.Logical vectors are coerced to integer vectors in contexts where anumerical value is required, with TRUE being mapped to1L, FALSE to 0L and NA to NA_integer_.
NA
The name argument can specify the  environment from whichobject names are taken in one of several forms:as an integer (the position in the search list); asthe character string name of an element in the search list; or as anexplicit environment (including usingsys.frame to access the currently active function calls).By default, the environment of the call to ls or objectsis used. The pos and envir arguments are an alternativeway to specify an environment, but are primarily there for backcompatibility.Note that the order of strings for sorted = TRUE islocale dependent, see Sys.getlocale.  If sorted =    FALSE the order is arbitrary, depending if the environment ishashed, the order of insertion of objects, ....
A syntactically valid name consists of letters, numbers and the dot orunderline characters and starts with a letter or the dot not followedby a number.  Names such as ".2way" are not valid, and neitherare the reserved words.The definition of a letter depends on the current locale, butonly ASCII digits are considered to be digits.The character "X" is prepended if necessary.All invalid characters are translated to ".".  A missing valueis translated to "NA".  Names which match R keywords have a dotappended to them.  Duplicated values are altered bymake.unique.
The algorithm used by make.unique has the property thatmake.unique(c(A, B)) == make.unique(c(make.unique(A), B)).In other words, you can append one string at a time to a vector,making it unique each time, and get the same result as applyingmake.unique to all of the strings at once.If character vector A is already unique, thenmake.unique(c(A, B)) preserves A.
The function lockEnvironment locks its environment argument.Locking theenvironment prevents adding or removing variable bindings from theenvironment.  Changing the value of a variable is still possible unlessthe binding has been locked.  The namespace environments of packageswith namespaces are locked when loaded.lockBinding locks individual bindings in the specifiedenvironment.  The value of a locked binding cannot be changed.  Lockedbindings may be removed from an environment unless the environment islocked.makeActiveBinding installs fun in environment envso that getting the value of sym calls fun with noarguments, and assigning to sym calls fun with oneargument, the value to be assigned.  This allows the implementation ofthings like C variables linked to R variables and variables linked todatabases, and is used to implement setRefClass.  It mayalso be useful for making thread-safe versions of some system globals.Currently active bindings are not preserved during package installation,but they can be created in .onLoad.
If init is given, Reduce logically adds it to the start(when proceeding left to right) or the end of x, respectively.If this possibly augmented vector v has n > 1 elements,Reduce successively applies f to the elements of vfrom left to right or right to left, respectively.  I.e., a leftreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,and returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce doesr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})and returns r_1 = f(v_1, r_2).  (E.g., if v is thesequence (2, 3, 4) and f is division, left and right reduce give(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)If v has only a single element, this is returned; if there areno elements, NULL is returned.  Thus, it is ensured thatf is always called with 2 arguments.The current implementation is non-recursive to ensure stability andscalability.Reduce is patterned after Common Lisp's reduce.  Areduce is also known as a fold (e.g., in Haskell) or an accumulate(e.g., in the C++ Standard Template Library).  The accumulativeversion corresponds to Haskell's scan functions.Filter applies the unary predicate function f to eachelement of x, coercing to logical if necessary, and returns thesubset of x for which this gives true.  Note that possibleNA values are currently always taken as false; control overNA handling may be added in the future.  Filtercorresponds to filter in Haskell or remove-if-not inCommon Lisp.Find and Position are patterned after Common Lisp'sfind-if and position-if, respectively.  If there is anelement for which the predicate function gives true, then the first orlast such element or its position is returned depending on whetherright is false (default) or true, respectively.  If there is nosuch element, the value specified by nomatch is returned.  Thecurrent implementation is not optimized for performance.Map is a simple wrapper to mapply which does notattempt to simplify the result, similar to Common Lisp's mapcar(with arguments being recycled, however).  Future versions may allowsome control of the result type.Negate corresponds to Common Lisp's complement.  Given a(predicate) function f, it creates a function which returns thelogical negation of what f returns.
mapply calls FUN for the values of ...(re-cycled to the length of the longest, unless any have length zero),followed by the arguments given in MoreArgs.  The arguments inthe call will be named if ... or MoreArgs are named.For the arguments in ... (or components in dots) class specificsubsetting (such as [) and length methods will beused where applicable.
NA
NA
NA
%in% is currently defined as "%in%" <- function(x, table) match(x, table, nomatch = 0) > 0Factors, raw vectors and lists are converted to character vectors, andthen x and table are coerced to a common type (the laterof the two types in R's ordering, logical < integer < numeric <complex < character) before matching.  If incomparables haspositive length it is coerced to the common type.Matching for lists is potentially very slow and best avoided except insimple cases.Exactly what matches what is to some extent a matter of definition.For all types, NA matches NA and no other value.For real and complex values, NaN values are regardedas matching any other NaN value, but not matching NA,where for complex x, real and imaginary parts must match both(unless containing at least one NA).Character strings will be compared as byte sequences if any input ismarked as "bytes", and otherwise are regarded as equal if they arein different encodings but would agree when translated to UTF-8 (seeEncoding).That %in% never returns NA makes it particularlyuseful in if conditions.
In the one-argument form match.arg(arg), the choices areobtained from a default setting for the formal argument arg ofthe function from which match.arg was called.  (Since defaultargument matching will set arg to choices, this isallowed as an exception to the ‘length one unlessseveral.ok is TRUE’ rule, and returns the firstelement.)Matching is done using pmatch, so arg may beabbreviated.
‘function’ on this help page means an interpreted function(also known as a ‘closure’):  match.call does not supportprimitive functions (where argument matching is normallypositional).match.call is most commonly used in two circumstances: To record the call for later re-use: for example mostmodel-fitting functions record the call as element call ofthe list they return.  Here the default expand.dots = TRUEis appropriate. To pass most of the call to another function, oftenmodel.frame.  Here the common idiom is thatexpand.dots = FALSE is used, and the ... elementof the matched call is removed.  An alternative is toexplicitly select the arguments to be passed on, as is done inlm.Calling match.call outside a function without specifyingdefinition is an error.
match.fun is not intended to be used at the top level since itwill perform matching in the parent of the caller.If FUN is a function, it is returned.  If it is a symbol (forexample, enclosed in backquotes) or acharacter vector of length one, it will be looked up using getin the environment of the parent of the caller.  If it is of any othermode, it is attempted first to get the argument to the caller as asymbol (using substitute twice), and if that fails, an error isdeclared.If descend = TRUE, match.fun will look past non-functionobjects with the given name; otherwise if FUN points to anon-function object then an error is generated.This is used in base functions such as apply,lapply, outer, and sweep.
There are four groups for which S3 methods can be written,namely the "Math", "Ops", "Summary" and"Complex" groups.  These are not R objects in base R, butmethods can be supplied for them and base R containsfactor, data.frame anddifftime methods for the first three groups.  (There isalso a ordered method for Ops,POSIXt and Date methods for Mathand Ops, package_version methods for Opsand Summary, as well as a ts method forOps in package stats.) Group "Math":abs, sign, sqrt,floor, ceiling, trunc,round, signifexp, log,  expm1, log1p,cos, sin, tan,cospi, sinpi, tanpi,acos, asin, atancosh, sinh, tanh,acosh, asinh, atanhlgamma, gamma, digamma, trigammacumsum, cumprod, cummax, cumminMembers of this group dispatch on x.  Most members acceptonly one argument, but members log, round andsignif accept one or two arguments, and trunc acceptsone or more. Group "Ops":"+", "-", "*", "/","^", "%%", "%/%""&", "|", "!""==", "!=","<", "<=", ">=", ">"This group contains both binary and unary operators (+,- and !): when a unary operator is encountered theOps method is called with one argument and e2 ismissing.The classes of both arguments are considered in dispatching anymember of this group.  For each argument its vector of classes isexamined to see if there is a matching specific (preferred) orOps method.  If a method is found for just one argument orthe same method is found for both, it is used.If different methods are found, there is a warning about‘incompatible methods’: in that case or if no method is foundfor either argument the internal method is used.Note that the data.frame methods for the comparison("Compare": ==, <, ...) and logic("Logic": & | and !) operators return alogical matrix instead of a data frame, forconvenience and back compatibility.If the members of this group are called as functions, any argumentnames are removed to ensure that positional matching is always used. Group "Summary":all, anysum, prodmin, maxrangeMembers of this group dispatch on the first argument supplied.Note that the data.frame methods for the"Summary" and "Math" groups require “numeric-alike”columns x, i.e., fulfilling  Group "Complex":Arg, Conj, Im, Mod, ReMembers of this group dispatch on z.Note that a method will be used for one of these groups or one of itsmembers only if it corresponds to a "class" attribute,as the internal code dispatches on oldClass and not onclass.  This is for efficiency: having to dispatch on,say, Ops.integer would be too slow.The number of arguments supplied for primitive members of the"Math" group generic methods is not checked prior to dispatch.There is no lazy evaluation of arguments for group-generic functions.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
If one of nrow or ncol is not given, an attempt ismade to infer it from the length of data and the otherparameter.  If neither is given, a one-column matrix is returned.If there are too few elements in data to fill the matrix,then the elements in data are recycled.  If data haslength zero, NA of an appropriate type is used for atomicvectors (0 for raw vectors) and NULL for lists.is.matrix returns TRUE if x is a vector and has a"dim" attribute of length 2 and FALSE otherwise.Note that a data.frame is not a matrix by thistest.  The function is generic: you can write methods to handlespecific classes of objects, see InternalMethods.as.matrix is a generic function.  The method for data frameswill return a character matrix if there is only atomic columns and anynon-(numeric/logical/complex) column, applying as.vectorto factors and format to other non-character columns.Otherwise, the usual coercion hierarchy (logical < integer < double <complex) will be used, e.g., all-logical data frames will be coercedto a logical matrix, mixed logical-integer will give a integer matrix,etc.The default method for as.matrix calls as.vector(x), andhence e.g. coerces factors to character vectors.When coercing a vector, it produces a one-column matrix, andpromotes the names (if any) of the vector to the rownames of the matrix.is.matrix is a primitive function.The print method for a matrix gives a rectangular layout withdimnames or indices.  For a list matrix, the entries of length notone are printed in  the form integer,7 indicating the typeand length.
max and min return the maximum or minimum of allthe  values present in their arguments, as integer ifall are logical or integer, as double ifall are numeric, and character otherwise.If na.rm is FALSE an NA value in any of thearguments will cause a value of NA to be returned, otherwiseNA values are ignored.The minimum and maximum of a numeric empty set are +Inf and-Inf (in this order!) which ensures transitivity, e.g.,min(x1, min(x2)) == min(x1, x2).  For numeric xmax(x) == -Inf and min(x) == +Infwhenever length(x) == 0 (after removing missing values ifrequested).  However, pmax and pmin returnNA if all the parallel elements are NA even forna.rm = TRUE.pmax and pmin take one or more vectors (or matrices) asarguments and return a single vector giving the ‘parallel’maxima (or minima) of the vectors.  The first element of the result isthe maximum (minimum) of the first elements of all the arguments, thesecond element of the result is the maximum (minimum) of the secondelements of all the arguments and so on.  Shorter inputs (of non-zerolength) are recycled if necessary.  Attributes (seeattributes: such as names ordim) are copied from the first argument (if applicable,e.g., not for an S4 object).pmax.int and pmin.int are faster internal versions onlyused when all arguments are atomic vectors and there are no classes:they drop all attributes.  (Note that all versions fail for raw andcomplex vectors since these have no ordering.)max and min are generic functions: methods can bedefined for them individually or via theSummary group generic.  For this towork properly, the arguments ... should be unnamed, anddispatch is on the first argument.By definition the min/max of a numeric vector containing an NaNis NaN, except that the min/max of any vector containing anNA is NA even if it also contains an NaN.Note that max(NA, Inf) == NA even though the maximum would beInf whatever the missing value actually is.Character versions are sorted lexicographically, and this depends onthe collating sequence of the locale in use: the help for‘Comparison’ gives details.  The max/min of an emptycharacter vector is defined to be character NA.  (One couldargue that as "" is the smallest character element, the maximumshould be "", but there is no obvious candidate for theminimum.)
When ties.method = "random", as per default, ties are broken atrandom.  In this case, the determination of a tie assumes thatthe entries are probabilities: there is a relative tolerance of1e-5, relative to the largest (in magnitude, omittinginfinity) entry in the row.If ties.method = "first", max.col returns thecolumn number of the first of several maxima in every row, thesame   as unname(apply(m, 1, which.max)).Correspondingly, ties.method = "last" returns the lastof possibly several indices.
NA
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
NA
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
New Limits lower than current usage are ignored.Specifying a size of Inf sets the limit to the maximal possiblevalue for the platform.The default maximal values are unlimited on most platforms, but can beadjusted using environment variables as described inMemory. On macOS a lower default vector heap limit isused to protect against the R process being killed when macOSover-commits memory.Adjusting the maximal number of nodes is rarely necessary. Adjustingthe vector heap size limit can be useful on macOS in particular butshould be done with caution.
New Limits lower than current usage are ignored.Specifying a size of Inf sets the limit to the maximal possiblevalue for the platform.The default maximal values are unlimited on most platforms, but can beadjusted using environment variables as described inMemory. On macOS a lower default vector heap limit isused to protect against the R process being killed when macOSover-commits memory.Adjusting the maximal number of nodes is rarely necessary. Adjustingthe vector heap size limit can be useful on macOS in particular butshould be done with caution.
type = "none" passes the input through unchanged, but may beuseful if type is a variable.type = "unknown" attempts to detect the type of compressionapplied (if any): this will always succeed for bzip2compression, and will succeed for other forms if there is a suitableheader.  It will auto-detect the ‘magic’ header("\x1f\x8b") added to files by the gzip program (andto files written by gzfile), but memCompress doesnot add such a header. (It supports RFC 1950 format, sometimes knownas ‘zlib’ format, for compression and decompression and RFC1952 for decompression only.)gzip compression uses whatever is the default compressionlevel of the underlying library (usually 6).bzip2 compression always adds a header ("BZh").  Theunderlying library only supports in-memory (de)compression of up to2^31 - 1 elements.  Compression is equivalent tobzip2 -9 (the default).Compressing with type = "xz" is equivalent to compressing afile with xz -9e (including adding the ‘magic’header): decompression should cope with the contents of any filecompressed by xz version 4.999 and later, as well as by someversions of lzma.  There are other versions, in particular‘raw’ streams, that are not currently handled.All the types of compression can expand the input: for "gzip"and "bzip2" the maximum expansion is known and somemCompress can always allocate sufficient space.  For"xz" it is possible (but extremely unlikely) that compressionwill fail if the output would have been too large.
type = "none" passes the input through unchanged, but may beuseful if type is a variable.type = "unknown" attempts to detect the type of compressionapplied (if any): this will always succeed for bzip2compression, and will succeed for other forms if there is a suitableheader.  It will auto-detect the ‘magic’ header("\x1f\x8b") added to files by the gzip program (andto files written by gzfile), but memCompress doesnot add such a header. (It supports RFC 1950 format, sometimes knownas ‘zlib’ format, for compression and decompression and RFC1952 for decompression only.)gzip compression uses whatever is the default compressionlevel of the underlying library (usually 6).bzip2 compression always adds a header ("BZh").  Theunderlying library only supports in-memory (de)compression of up to2^31 - 1 elements.  Compression is equivalent tobzip2 -9 (the default).Compressing with type = "xz" is equivalent to compressing afile with xz -9e (including adding the ‘magic’header): decompression should cope with the contents of any filecompressed by xz version 4.999 and later, as well as by someversions of lzma.  There are other versions, in particular‘raw’ streams, that are not currently handled.All the types of compression can expand the input: for "gzip"and "bzip2" the maximum expansion is known and somemCompress can always allocate sufficient space.  For"xz" it is possible (but extremely unlikely) that compressionwill fail if the output would have been too large.
The current types and their uses are listed in the include file‘Rinternals.h’.
merge is a generic function whose principal method is for dataframes: the default method coerces its arguments to data frames andcalls the "data.frame" method.By default the data frames are merged on the columns with names theyboth have, but separate specifications of the columns can be given byby.x and by.y.  The rows in the two data frames thatmatch on the specified columns are extracted, and joined together.  Ifthere is more than one match, all possible matches contribute one roweach.  For the precise meaning of ‘match’, seematch.Columns to merge on can be specified by name, number or by a logicalvector: the name "row.names" or the number 0 specifiesthe row names.  If specified by name it must correspond uniquely to anamed column in the input.If by or both by.x and by.y are of length 0 (alength zero vector or NULL), the result, r, is theCartesian product of x and y, i.e.,dim(r) = c(nrow(x)*nrow(y), ncol(x) + ncol(y)).If all.x is true, all the non matching cases of x areappended to the result as well, with NA filled in thecorresponding columns of y;  analogously for all.y.If the columns in the data frames not used in merging have any commonnames, these have suffixes (".x" and ".y" bydefault) appended to try to make the names of the result unique.  Ifthis is not possible, an error is thrown.If a by.x column name matches one of y, and ifno.dups is true (as by default), the y version gets suffixed aswell, avoiding duplicate column names in the result.The complexity of the algorithm used is proportional to the length ofthe answer.In SQL database terminology, the default value of all = FALSEgives a natural join, a special case of an innerjoin. Specifying all.x = TRUE gives a left (outer)join, all.y = TRUE a right (outer) join, and both(all = TRUE) a (full) outer join.  DBMSes do not matchNULL records, equivalent to incomparables = NA in R.
merge is a generic function whose principal method is for dataframes: the default method coerces its arguments to data frames andcalls the "data.frame" method.By default the data frames are merged on the columns with names theyboth have, but separate specifications of the columns can be given byby.x and by.y.  The rows in the two data frames thatmatch on the specified columns are extracted, and joined together.  Ifthere is more than one match, all possible matches contribute one roweach.  For the precise meaning of ‘match’, seematch.Columns to merge on can be specified by name, number or by a logicalvector: the name "row.names" or the number 0 specifiesthe row names.  If specified by name it must correspond uniquely to anamed column in the input.If by or both by.x and by.y are of length 0 (alength zero vector or NULL), the result, r, is theCartesian product of x and y, i.e.,dim(r) = c(nrow(x)*nrow(y), ncol(x) + ncol(y)).If all.x is true, all the non matching cases of x areappended to the result as well, with NA filled in thecorresponding columns of y;  analogously for all.y.If the columns in the data frames not used in merging have any commonnames, these have suffixes (".x" and ".y" bydefault) appended to try to make the names of the result unique.  Ifthis is not possible, an error is thrown.If a by.x column name matches one of y, and ifno.dups is true (as by default), the y version gets suffixed aswell, avoiding duplicate column names in the result.The complexity of the algorithm used is proportional to the length ofthe answer.In SQL database terminology, the default value of all = FALSEgives a natural join, a special case of an innerjoin. Specifying all.x = TRUE gives a left (outer)join, all.y = TRUE a right (outer) join, and both(all = TRUE) a (full) outer join.  DBMSes do not matchNULL records, equivalent to incomparables = NA in R.
merge is a generic function whose principal method is for dataframes: the default method coerces its arguments to data frames andcalls the "data.frame" method.By default the data frames are merged on the columns with names theyboth have, but separate specifications of the columns can be given byby.x and by.y.  The rows in the two data frames thatmatch on the specified columns are extracted, and joined together.  Ifthere is more than one match, all possible matches contribute one roweach.  For the precise meaning of ‘match’, seematch.Columns to merge on can be specified by name, number or by a logicalvector: the name "row.names" or the number 0 specifiesthe row names.  If specified by name it must correspond uniquely to anamed column in the input.If by or both by.x and by.y are of length 0 (alength zero vector or NULL), the result, r, is theCartesian product of x and y, i.e.,dim(r) = c(nrow(x)*nrow(y), ncol(x) + ncol(y)).If all.x is true, all the non matching cases of x areappended to the result as well, with NA filled in thecorresponding columns of y;  analogously for all.y.If the columns in the data frames not used in merging have any commonnames, these have suffixes (".x" and ".y" bydefault) appended to try to make the names of the result unique.  Ifthis is not possible, an error is thrown.If a by.x column name matches one of y, and ifno.dups is true (as by default), the y version gets suffixed aswell, avoiding duplicate column names in the result.The complexity of the algorithm used is proportional to the length ofthe answer.In SQL database terminology, the default value of all = FALSEgives a natural join, a special case of an innerjoin. Specifying all.x = TRUE gives a left (outer)join, all.y = TRUE a right (outer) join, and both(all = TRUE) a (full) outer join.  DBMSes do not matchNULL records, equivalent to incomparables = NA in R.
message is used for generating ‘simple’ diagnosticmessages which are neither warnings nor errors, but neverthelessrepresented as conditions.  Unlike warnings and errors, a finalnewline is regarded as part of the message, and is optional.The default handler sends the message to thestderr() connection.If a condition object is supplied  to message it should bethe only argument, and further arguments will be ignored, with a warning.While the message is being processed, a muffleMessage restartis available.suppressMessages evaluates its expression in a context thatignores all ‘simple’ diagnostic messages.packageStartupMessage is a variant whose messages can besuppressed separately by suppressPackageStartupMessages.  (Theyare still messages, so can be suppressed by suppressMessages.).makeMessage is a utility used by message, warningand stop to generate a text message from the ...arguments by possible translation (see gettext) andconcatenation (with no separator).
The pos argument can specify the environment in which to lookfor the object in any of several ways: as a positive integer (theposition in the search list); as the character stringname of an element in the search list; or as anenvironment (including using sys.frameto access the currently active function calls).  The default of-1 indicates the current environment of the call toget. The envir argument is an alternative way tospecify an environment.These functions look to see if each of the name(s) x have avalue bound to it in the specified environment.  If inherits isTRUE and a value is not found for x in the specifiedenvironment, the enclosing frames of the environment are searcheduntil the name x is encountered.  See environmentand the ‘R Language Definition’ manual for details about thestructure of environments and their enclosures.If mode is specified then only objects of that type are sought.mode here is a mixture of the meanings of typeofand mode: "function" covers primitive functionsand operators, "numeric", "integer" and "double"all refer to any numeric type, "symbol" and "name" areequivalent but "language" must be used (and not"call" or "(").For mget, the values of mode and ifnotfound canbe either the same length as x or of length 1.  The argumentifnotfound must be a list containing either the value to use ifthe requested item is not found or a function of one argument whichwill be called if the item is not found, with argument the name of theitem being requested.dynGet() is somewhat experimental and to be used insideanother function.  It looks for an object in the callers, i.e.,the sys.frame()s of the function.  Use with caution.
max and min return the maximum or minimum of allthe  values present in their arguments, as integer ifall are logical or integer, as double ifall are numeric, and character otherwise.If na.rm is FALSE an NA value in any of thearguments will cause a value of NA to be returned, otherwiseNA values are ignored.The minimum and maximum of a numeric empty set are +Inf and-Inf (in this order!) which ensures transitivity, e.g.,min(x1, min(x2)) == min(x1, x2).  For numeric xmax(x) == -Inf and min(x) == +Infwhenever length(x) == 0 (after removing missing values ifrequested).  However, pmax and pmin returnNA if all the parallel elements are NA even forna.rm = TRUE.pmax and pmin take one or more vectors (or matrices) asarguments and return a single vector giving the ‘parallel’maxima (or minima) of the vectors.  The first element of the result isthe maximum (minimum) of the first elements of all the arguments, thesecond element of the result is the maximum (minimum) of the secondelements of all the arguments and so on.  Shorter inputs (of non-zerolength) are recycled if necessary.  Attributes (seeattributes: such as names ordim) are copied from the first argument (if applicable,e.g., not for an S4 object).pmax.int and pmin.int are faster internal versions onlyused when all arguments are atomic vectors and there are no classes:they drop all attributes.  (Note that all versions fail for raw andcomplex vectors since these have no ordering.)max and min are generic functions: methods can bedefined for them individually or via theSummary group generic.  For this towork properly, the arguments ... should be unnamed, anddispatch is on the first argument.By definition the min/max of a numeric vector containing an NaNis NaN, except that the min/max of any vector containing anNA is NA even if it also contains an NaN.Note that max(NA, Inf) == NA even though the maximum would beInf whatever the missing value actually is.Character versions are sorted lexicographically, and this depends onthe collating sequence of the locale in use: the help for‘Comparison’ gives details.  The max/min of an emptycharacter vector is defined to be character NA.  (One couldargue that as "" is the smallest character element, the maximumshould be "", but there is no obvious candidate for theminimum.)
missing(x) is only reliable if x has not been alteredsince entering the function: in particular it will alwaysbe false after x <- match.arg(x).The example shows how a plotting function can be written to work witheither a pair of vectors giving x and y coordinates of points to beplotted or a single vector giving y values to be plotted against theirindices.Currently missing can only be used in the immediate body ofthe function that defines the argument, not in the body of a nestedfunction or a local call.  This may change in the future.This is a ‘special’ primitive function: it must notevaluate its argument.
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
Both mode and storage.mode return a character stringgiving the (storage) mode of the object — often the same — bothrelying on the output of typeof(x), see the examplebelow.mode(x) <- "newmode" changes the mode of object x tonewmode.  This is only supported if there is an appropriateas.newmode function, for example"logical", "integer", "double", "complex","raw", "character", "list", "expression","name", "symbol" and "function".  Attributes arepreserved (but see below).storage.mode(x) <- "newmode" is a more efficient primitiveversion of mode<-, which works for "newmode" which isone of the internal types (see typeof), but not for"single".  Attributes are preserved.As storage mode "single" is only a pseudo-mode in R, it willnot be reported by mode or storage.mode: useattr(object, "Csingle") to examine this.  However,mode<- can be used to set the mode to "single",which sets the real mode to "double" and the "Csingle"attribute to TRUE.  Setting any other mode will remove thisattribute.Note (in the examples below) that some calls have mode"(" which is S compatible.
Both mode and storage.mode return a character stringgiving the (storage) mode of the object — often the same — bothrelying on the output of typeof(x), see the examplebelow.mode(x) <- "newmode" changes the mode of object x tonewmode.  This is only supported if there is an appropriateas.newmode function, for example"logical", "integer", "double", "complex","raw", "character", "list", "expression","name", "symbol" and "function".  Attributes arepreserved (but see below).storage.mode(x) <- "newmode" is a more efficient primitiveversion of mode<-, which works for "newmode" which isone of the internal types (see typeof), but not for"single".  Attributes are preserved.As storage mode "single" is only a pseudo-mode in R, it willnot be reported by mode or storage.mode: useattr(object, "Csingle") to examine this.  However,mode<- can be used to set the mode to "single",which sets the real mode to "double" and the "Csingle"attribute to TRUE.  Setting any other mode will remove thisattribute.Note (in the examples below) that some calls have mode"(" which is S compatible.
R has a small number of built-in constants.The following constants are available:LETTERS: the 26 upper-case letters of the Romanalphabet;letters: the 26 lower-case letters of the Romanalphabet;month.abb: the three-letter abbreviations for theEnglish month names;month.name: the English names for the months of theyear;pi: the ratio of the circumference of a circle to itsdiameter.These are implemented as variables in the base namespace takingappropriate values.
R has a small number of built-in constants.The following constants are available:LETTERS: the 26 upper-case letters of the Romanalphabet;letters: the 26 lower-case letters of the Romanalphabet;month.abb: the three-letter abbreviations for theEnglish month names;month.name: the English names for the months of theyear;pi: the ratio of the circumference of a circle to itsdiameter.These are implemented as variables in the base namespace takingappropriate values.
NA
NA
NA
Unlike attr it is not an error to set attributes on aNULL object: it will first be coerced to an empty list.Note that some attributes (namely class,comment, dim, dimnames,names, row.names andtsp) are treated specially and have restrictions onthe values which can be set.  (Note that this is not true oflevels which should be set for factors via thelevels replacement function.)Attributes are not stored internally as a list and should be thoughtof as a set and not a vector, i.e, the order of the elements ofattributes() does not matter.  This is also reflected byidentical()'s behaviour with the default argumentattrib.as.set = TRUE.  Attributes must have unique names (andNA is taken as "NA", not a missing value).Assigning attributes first removes all attributes, then sets anydim attribute and then the remaining attributes in the ordergiven: this ensures that setting a dim attribute always precedesthe dimnames attribute.The mostattributes assignment takes special care for thedim, names and dimnamesattributes, and assigns them only when known to be valid whereas anattributes assignment would give an error if any are not.  Itis principally intended for arrays, and should be used with care onclassed objects.  For example, it does not check thatrow.names are assigned correctly for data frames.The names of a pairlist are not stored as attributes, but are reportedas if they were (and can be set by the replacement form ofattributes).NULL objects cannot have attributes and attempts toassign them will promote the object to an empty list.Both assignment and replacement forms of attributes areprimitive functions.
names is a generic accessor function, and names<- is ageneric replacement function.  The default methods get and setthe "names" attribute of a vector (including a list) orpairlist.For an environment env, names(env) givesthe names of the corresponding list, i.e.,names(as.list(env, all.names = TRUE)) which are also given byls(env, all.names = TRUE, sorted = FALSE).  If theenvironment is used as a hash table, names(env) are its“keys”.If value is shorter than x, it is extended by characterNAs to the length of x.It is possible to update just part of the names attribute via thegeneral rules: see the examples.  This works because the expressionthere is evaluated as z <- "names<-"(z, "[<-"(names(z), 3, "c2")).The name "" is special: it is used to indicate that there is noname associated with an element of a (atomic or generic) vector.Subscripting by "" will match nothing (not even elements whichhave no name).A name can be character NA, but such a name will never bematched and is likely to lead to confusion.Both are primitive functions.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
names is a generic accessor function, and names<- is ageneric replacement function.  The default methods get and setthe "names" attribute of a vector (including a list) orpairlist.For an environment env, names(env) givesthe names of the corresponding list, i.e.,names(as.list(env, all.names = TRUE)) which are also given byls(env, all.names = TRUE, sorted = FALSE).  If theenvironment is used as a hash table, names(env) are its“keys”.If value is shorter than x, it is extended by characterNAs to the length of x.It is possible to update just part of the names attribute via thegeneral rules: see the examples.  This works because the expressionthere is evaluated as z <- "names<-"(z, "[<-"(names(z), 3, "c2")).The name "" is special: it is used to indicate that there is noname associated with an element of a (atomic or generic) vector.Subscripting by "" will match nothing (not even elements whichhave no name).A name can be character NA, but such a name will never bematched and is likely to lead to confusion.Both are primitive functions.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
The count includes empty (missing) arguments, so that foo(x,,z)will be considered to have three arguments (see ‘Examples’).This can occur in rather indirect ways, so for example x[]might dispatch a call to `[.some_method`(x, ) which isconsidered to have two arguments.This is a primitive function.
The ‘size’ of a character string can be measured in one ofthree ways (corresponding to the type argument):The number of bytes needed to store the string(plus in C a final terminator which is not counted).The number of characters.The number of columns cat will use toprint the string in a monospaced font.  The same as charsif this cannot be calculated.These will often be the same, and usually will be in single-bytelocales (but note how type determines the default forkeepNA).  There will be differences between the first two withmultibyte character sequences, e.g. in UTF-8 locales.The internal equivalent of the default method ofas.character is performed on x (so there is nomethod dispatch).  If you want to operate on non-vector objectspassing them through deparse first will be required.
NA
NA
If init is given, Reduce logically adds it to the start(when proceeding left to right) or the end of x, respectively.If this possibly augmented vector v has n > 1 elements,Reduce successively applies f to the elements of vfrom left to right or right to left, respectively.  I.e., a leftreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,and returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce doesr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})and returns r_1 = f(v_1, r_2).  (E.g., if v is thesequence (2, 3, 4) and f is division, left and right reduce give(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)If v has only a single element, this is returned; if there areno elements, NULL is returned.  Thus, it is ensured thatf is always called with 2 arguments.The current implementation is non-recursive to ensure stability andscalability.Reduce is patterned after Common Lisp's reduce.  Areduce is also known as a fold (e.g., in Haskell) or an accumulate(e.g., in the C++ Standard Template Library).  The accumulativeversion corresponds to Haskell's scan functions.Filter applies the unary predicate function f to eachelement of x, coercing to logical if necessary, and returns thesubset of x for which this gives true.  Note that possibleNA values are currently always taken as false; control overNA handling may be added in the future.  Filtercorresponds to filter in Haskell or remove-if-not inCommon Lisp.Find and Position are patterned after Common Lisp'sfind-if and position-if, respectively.  If there is anelement for which the predicate function gives true, then the first orlast such element or its position is returned depending on whetherright is false (default) or true, respectively.  If there is nosuch element, the value specified by nomatch is returned.  Thecurrent implementation is not optimized for performance.Map is a simple wrapper to mapply which does notattempt to simplify the result, similar to Common Lisp's mapcar(with arguments being recycled, however).  Future versions may allowsome control of the result type.Negate corresponds to Common Lisp's complement.  Given a(predicate) function f, it creates a function which returns thelogical negation of what f returns.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
break breaks out of a for, while or repeatloop; control is transferred to the first statement outside theinner-most loop. next halts the processing of the currentiteration and advances the looping index.  Both break andnext apply only to the innermost of nested loops.Note that it is a common mistake to forget to put braces ({ .. })around your statements, e.g., after if(..) or for(....).In particular, you should not have a newline between } andelse to avoid a syntax error in entering a if ... elseconstruct at the keyboard or via source.For that reason, one (somewhat extreme) attitude of defensive programmingis to always use braces, e.g., for if clauses.The seq in a for loop is evaluated at the start ofthe loop; changing it subsequently does not affect the loop.  Ifseq has length zero the body of the loop is skipped. Otherwise thevariable var is assigned in turn the value of each element ofseq. You can assign to var within the body of the loop,but this will not affect the next iteration.  When the loop terminates,var remains as a variable containing its latest value.
An R object is a data object which has a classattribute (and this can be tested by is.object).A class attribute is a character vector giving the names ofthe classes from which the object inherits.If the object does not have a class attribute, it has an implicitclass.  Matrices and arrays have class "matrix"or"array" followed by the class of the underlying vector.Most vectors have class the result of mode(x), exceptthat integer vectors have class c("integer", "numeric") andreal vectors have class c("double", "numeric").When a function calling UseMethod("fun") is applied to anobject with class attribute c("first", "second"), the systemsearches for a function called fun.first and, if it finds it,applies it to the object.  If no such function is found a functioncalled fun.second is tried.  If no class name produces asuitable function, the function fun.default is used, if itexists, or an error results.Function methods can be used to find out about themethods for a particular generic function or class.UseMethod is a primitive function but uses standard argumentmatching.  It is not the only means of dispatch of methods, for thereare internal generic and group generic functions.UseMethod currently dispatches on the implicit class even forarguments that are not objects, but the other means of dispatch donot.NextMethod invokes the next method (determined by theclass vector, either of the object supplied to the generic, or ofthe first argument to the function containing NextMethod if amethod was invoked directly).  Normally NextMethod is used withonly one argument, generic, but if further arguments aresupplied these modify the call to the next method.NextMethod should not be called except in methods called byUseMethod or from internal generics (seeInternalGenerics).  In particular it will not work insideanonymous calling functions (e.g., get("print.ts")(AirPassengers)).Namespaces can register methods for generic functions.  To supportthis, UseMethod and NextMethod search for methods intwo places: in the environment in which the generic functionis called, and in the registration data base for theenvironment in which the generic is defined (typically a namespace).So methods for a generic function need to be available in theenvironment of the call to the generic, or they must be registered.(It does not matter whether they are visible in the environment inwhich the generic is defined.)  As from R 3.5.0, the registrationdata base is searched after the top level environment (seetopenv) of the calling environment (but before theparents of the top level environment).
If domain is NULL or "", and gettextor ngettext  is called from a function in the namespace ofpackage pkg the domain is set to "R-pkg".  Otherwisethere is no default domain.If a suitable domain is found, each character string is offered fortranslation, and replaced by its translation into the current languageif one is found.  The value (logical) NA suppresses anytranslation.The language to be used for message translation is determined byyour OS default and/or the locale setting at R's startup, seeSys.getlocale(), and notably the LANGUAGE environmentvariable.Conventionally the domain for R warning/error messages in packagepkg is "R-pkg", and that for C-level messages is "pkg".For gettext, leading and trailing whitespace is ignored whenlooking for the translation.ngettext is used where the message needs to vary by a singleinteger.  Translating such messages is subject to very specific rulesfor different languages: see the GNU Gettext Manual.  The stringwill often contain a single instance of %d to be used insprintf.  If English is used, msg1 is returned ifn == 1 and msg2 in all other cases.bindtextdomain is a wrapper for the C function of the samename: your system may have a man page for it.  With anon-NULL dirname it specifies where to look for messagecatalogues: with domain = NULL it returns the current location.
This is usually applied to a factor, but other objects can have levels.The actual factor levels (if they exist) can be obtainedwith the levels function.
noquote returns its argument as an object of class"noquote".  There is a method for c() and subscriptmethod ("[.noquote") which ensures that the class is not lostby subsetting.  The print method (print.noquote) printscharacter strings without quotes ("...." is printed as ....).If right is specified in a call print(x, right=*), ittakes precedence over a possible right setting of x,e.g., created by x <- noquote(*, right=TRUE).These functions exist both as utilities and as an example of using (S3)class and object orientation.
The base method of norm() calls the LAPACK functiondlange.Note that the 1-, Inf- and "M" norm is faster to calculate thanthe Frobenius one.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
Tilde-expansion (see path.expand) is first done onpaths.Where the Unix-alike platform supports it attempts to turn paths intoabsolute paths in their canonical form (no ./, ../ norsymbolic links).  It relies on the POSIX system functionrealpath: if the platform does not have that (we know of nocurrent example) then the result will be an absolute path but mightnot be canonical.  Even where realpath is used the canonicalpath need not be unique, for example via hard links ormultiple mounts.On Windows it converts relative paths to absolute paths, resolves symboliclinks, converts short names for path elements to long names and ensures theseparator is that specified by winslash.  It will match each pathelement case-insensitively or case-sensitively as during the usual namelookup and return the canonical case. It relies on Windows API functionGetFinalPathNameByHandle and in case of an error (such asinsufficient permissions) it currently falls back to the R 3.6 (andolder) implementation, which relies on GetFullPathName andGetLongPathName with limitations described in the Notes section.An attempt is made not to introduce UNC paths in presence of mapped drivesor symbolic links: if GetFinalPathNameByHandle returns a UNC path,but GetLongPathName returns a path starting with a drive letter, Rfalls back to the R 3.6 (and older) implementation.UTF-8-encoded paths not valid in the current locale can be used.mustWork = FALSE is useful for expressing paths for use inmessages.
NA
NA
stdin(), stdout() and stderr() are standardconnections corresponding to input, output and error on the consolerespectively (and not necessarily to file streams).  They are text-modeconnections of class "terminal" which cannot be opened orclosed, and are read-only, write-only and write-only respectively.The stdout() and stderr() connections can bere-directed by sink (and in some circumstances theoutput from stdout() can be split: see the help page).The encoding for stdin() when redirected canbe set by the command-line flag --encoding.nullfile() returns filename of the null device ("/dev/null"on Unix, "nul:" on Windows).showConnections returns a matrix of information.  If aconnection object has been lost or forgotten, getConnectionwill take a row number from the table and return a connection objectfor that connection, which can be used to close the connection,for example.  However, if there is no R level object referring to theconnection it will be closed automatically at the next garbagecollection (except for gzcon connections).closeAllConnections closes (and destroys) all userconnections, restoring all sink diversions as it doesso.isatty returns true if the connection is one of the class"terminal" connections and it is apparently connected to aterminal, otherwise false.  This may not be reliable in embeddedapplications, including GUI consoles.
numeric is identical to double (and real).It creates a double-precision vector of the specified length with eachelement equal to 0.as.numeric is a generic function, but S3 methods must bewritten for as.double.  It is identical to as.double.is.numeric is an internal generic primitivefunction: you can write methods to handle specific classes of objects,see InternalMethods.  It is not the same asis.double.  Factors are handled by the default method,and there are methods for classes "Date","POSIXt" and "difftime" (all of whichreturn false).  Methods for is.numeric should only return trueif the base type of the class is double or integerand values can reasonably be regarded as numeric(e.g., arithmetic on them makes sense, and comparison should be donevia the base type).
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
The ‘size’ of a character string can be measured in one ofthree ways (corresponding to the type argument):The number of bytes needed to store the string(plus in C a final terminator which is not counted).The number of characters.The number of columns cat will use toprint the string in a monospaced font.  The same as charsif this cannot be calculated.These will often be the same, and usually will be in single-bytelocales (but note how type determines the default forkeepNA).  There will be differences between the first two withmultibyte character sequences, e.g. in UTF-8 locales.The internal equivalent of the default method ofas.character is performed on x (so there is nomethod dispatch).  If you want to operate on non-vector objectspassing them through deparse first will be required.
The name argument can specify the  environment from whichobject names are taken in one of several forms:as an integer (the position in the search list); asthe character string name of an element in the search list; or as anexplicit environment (including usingsys.frame to access the currently active function calls).By default, the environment of the call to ls or objectsis used. The pos and envir arguments are an alternativeway to specify an environment, but are primarily there for backcompatibility.Note that the order of strings for sorted = TRUE islocale dependent, see Sys.getlocale.  If sorted =    FALSE the order is arbitrary, depending if the environment ishashed, the order of insertion of objects, ....
Here, we describe the so called “S3” classes (and methods). For“S4” classes (and methods), see ‘Formal classes’ below.Many R objects have a class attribute, a character vectorgiving the names of the classes from which the object inherits.(Functions oldClass and oldClass<- get and set theattribute, which can also be done directly.)If the object does not have a class attribute, it has an implicitclass, notably "matrix", "array", "function" or"numeric" or the result oftypeof(x) (which is similar to mode(x)),but for type "language" and mode "call",where the following extra classes exist for the corresponding functioncalls:if, while, for, =, <-, (,{, call.Note that for objects x of an implicit (or an S4) class, when a(S3) generic function foo(x) is called, method dispatch may usemore classes than are returned by class(x), e.g., for a numericmatrix, the foo.numeric() method may apply.  The exact fullcharacter vector of the classes whichUseMethod() uses, is available as .class2(x) sinceR version 4.0.0.  (This also applies to S4 objects when S3 dispatch isconsidered, see below.)Beware that using .class2() for other reasons than didactical,diagnostical or for debugging may rather be a misuse than smart.NULL objects (of implicit class "NULL") cannot haveattributes (hence no class attribute) and attempting to assign aclass is an error.When a generic function fun is applied to an object with classattribute c("first", "second"), the system searches for afunction called fun.first and, if it finds it, applies it tothe object.  If no such function is found, a function calledfun.second is tried.  If no class name produces a suitablefunction, the function fun.default is used (if it exists).  Ifthere is no class attribute, the implicit class is tried, then thedefault method.The function class prints the vector of names of classes anobject inherits from.  Correspondingly, class<- sets theclasses an object inherits from.  Assigning an empty character vector orNULL removes the class attribute, as for oldClass<- ordirect attribute setting.  Whereas it is clearer to explicitly assignNULL to remove the class, using an empty vector is more natural ine.g., class(x) <- setdiff(class(x), "ts").unclass returns (a copy of) its argument with its classattribute removed.  (It is not allowed for objects which cannot becopied, namely environments and external pointers.)inherits indicates whether its first argument inherits from anyof the classes specified in the what argument.  If whichis TRUE then an integer vector of the same length aswhat is returned.  Each element indicates the position in theclass(x) matched by the element of what; zero indicatesno match. If which is FALSE then TRUE isreturned by inherits if any of the names in what matchwith any class.isa tests whether x is an object of class(es) as givenin what by using is if x is an S4object, and otherwise giving TRUE iff all elements ofclass(x) are contained in what.All but inherits and isa are primitive functions.
Here, we describe the so called “S3” classes (and methods). For“S4” classes (and methods), see ‘Formal classes’ below.Many R objects have a class attribute, a character vectorgiving the names of the classes from which the object inherits.(Functions oldClass and oldClass<- get and set theattribute, which can also be done directly.)If the object does not have a class attribute, it has an implicitclass, notably "matrix", "array", "function" or"numeric" or the result oftypeof(x) (which is similar to mode(x)),but for type "language" and mode "call",where the following extra classes exist for the corresponding functioncalls:if, while, for, =, <-, (,{, call.Note that for objects x of an implicit (or an S4) class, when a(S3) generic function foo(x) is called, method dispatch may usemore classes than are returned by class(x), e.g., for a numericmatrix, the foo.numeric() method may apply.  The exact fullcharacter vector of the classes whichUseMethod() uses, is available as .class2(x) sinceR version 4.0.0.  (This also applies to S4 objects when S3 dispatch isconsidered, see below.)Beware that using .class2() for other reasons than didactical,diagnostical or for debugging may rather be a misuse than smart.NULL objects (of implicit class "NULL") cannot haveattributes (hence no class attribute) and attempting to assign aclass is an error.When a generic function fun is applied to an object with classattribute c("first", "second"), the system searches for afunction called fun.first and, if it finds it, applies it tothe object.  If no such function is found, a function calledfun.second is tried.  If no class name produces a suitablefunction, the function fun.default is used (if it exists).  Ifthere is no class attribute, the implicit class is tried, then thedefault method.The function class prints the vector of names of classes anobject inherits from.  Correspondingly, class<- sets theclasses an object inherits from.  Assigning an empty character vector orNULL removes the class attribute, as for oldClass<- ordirect attribute setting.  Whereas it is clearer to explicitly assignNULL to remove the class, using an empty vector is more natural ine.g., class(x) <- setdiff(class(x), "ts").unclass returns (a copy of) its argument with its classattribute removed.  (It is not allowed for objects which cannot becopied, namely environments and external pointers.)inherits indicates whether its first argument inherits from anyof the classes specified in the what argument.  If whichis TRUE then an integer vector of the same length aswhat is returned.  Each element indicates the position in theclass(x) matched by the element of what; zero indicatesno match. If which is FALSE then TRUE isreturned by inherits if any of the names in what matchwith any class.isa tests whether x is an object of class(es) as givenin what by using is if x is an S4object, and otherwise giving TRUE iff all elements ofclass(x) are contained in what.All but inherits and isa are primitive functions.
Time zones are a system-specific topic, but these days almost all Rplatforms use similar underlying code, used by Linux, macOS, Solaris,AIX and FreeBSD, and installed with R on Windows.  (Unfortunatelythere are many system-specific errors in the implementations.)  It ispossible to use the R sources' version of the code on Unix-alikes aswell as on Windows: this is the default for macOS and recommended forSolaris.It should be possible to set the current time zone via the environmentvariable TZ: see the section on ‘Time zone names’ forsuitable values.  Sys.timezone() will return the value ofTZ if set initially (and on some OSes it is always set),otherwise it will try to retrieve from the OS a value which if set forTZ would give the initial time zone. (‘Initially’ meansbefore any time-zone functions are used: if TZ is being set tooverride the OS setting or if the ‘try’ does not get thisright, it should be set before the R process is started or (probablyearly enough) in file .Rprofile).If TZ is set but invalid, most platforms default to UTC,the time zone colloquially known as GMT (seehttps://en.wikipedia.org/wiki/Coordinated_Universal_Time).(Some but not all platforms will give a warning for invalid values.)If it is unset or empty the system time zone is used (the onereturned by Sys.timezone).Time zones did not come into use until the middle of the nineteenthcentury and were not widely adopted until the twentieth, anddaylight saving time (DST, also known as summer time)was first introduced in the early twentieth century, most widely in1916.  Over the last 100 years places have changed their affiliationbetween major time zones, have opted out of (or in to) DST in variousyears or adopted DST rule changes late or not at all.  (The UKexperimented with DST throughout 1971, only.)  In a few countries (oneis the Irish Republic) it is the summer time which is the‘standard’ time and a different name is used in winter.  Andthere can be multiple changes during a year, for example for Ramadan.A quite common system implementation of POSIXct is as signed32-bit integers and so only goes back to the end of 1901: on suchsystems R assumes that dates prior to that are in the same time zoneas they were in 1902.  Most of the world had not adopted time zones by1902 (so used local ‘mean time’ based on longitude) but for afew places there had been time-zone changes before then.  64-bitrepresentations are becoming common; unfortunately on some 64-bit OSesthe database information is 32-bit and so only available for the range1901–2038, and incompletely for the end years.As from R 3.5.0, when a time zone location is first found in asession, its value is cached in object .sys.timezone in thebase environment.
The expr argument passed to on.exit is recorded withoutevaluation.  If it is not subsequently removed/replaced by anotheron.exit call in the same function, it is evaluated in theevaluation frame of the function when it exits (including duringstandard error handling).  Thus any functions or variables in theexpression will be looked for in the function and its environment atthe time of exit: to capture the current value in expr usesubstitute or similar.If multiple on.exit expressions are set using add = TRUEthen all expressions will be run even if one signals an error.This is a ‘special’ primitive function: it onlyevaluates the arguments add and after.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
There are four groups for which S3 methods can be written,namely the "Math", "Ops", "Summary" and"Complex" groups.  These are not R objects in base R, butmethods can be supplied for them and base R containsfactor, data.frame anddifftime methods for the first three groups.  (There isalso a ordered method for Ops,POSIXt and Date methods for Mathand Ops, package_version methods for Opsand Summary, as well as a ts method forOps in package stats.) Group "Math":abs, sign, sqrt,floor, ceiling, trunc,round, signifexp, log,  expm1, log1p,cos, sin, tan,cospi, sinpi, tanpi,acos, asin, atancosh, sinh, tanh,acosh, asinh, atanhlgamma, gamma, digamma, trigammacumsum, cumprod, cummax, cumminMembers of this group dispatch on x.  Most members acceptonly one argument, but members log, round andsignif accept one or two arguments, and trunc acceptsone or more. Group "Ops":"+", "-", "*", "/","^", "%%", "%/%""&", "|", "!""==", "!=","<", "<=", ">=", ">"This group contains both binary and unary operators (+,- and !): when a unary operator is encountered theOps method is called with one argument and e2 ismissing.The classes of both arguments are considered in dispatching anymember of this group.  For each argument its vector of classes isexamined to see if there is a matching specific (preferred) orOps method.  If a method is found for just one argument orthe same method is found for both, it is used.If different methods are found, there is a warning about‘incompatible methods’: in that case or if no method is foundfor either argument the internal method is used.Note that the data.frame methods for the comparison("Compare": ==, <, ...) and logic("Logic": & | and !) operators return alogical matrix instead of a data frame, forconvenience and back compatibility.If the members of this group are called as functions, any argumentnames are removed to ensure that positional matching is always used. Group "Summary":all, anysum, prodmin, maxrangeMembers of this group dispatch on the first argument supplied.Note that the data.frame methods for the"Summary" and "Math" groups require “numeric-alike”columns x, i.e., fulfilling  Group "Complex":Arg, Conj, Im, Mod, ReMembers of this group dispatch on z.Note that a method will be used for one of these groups or one of itsmembers only if it corresponds to a "class" attribute,as the internal code dispatches on oldClass and not onclass.  This is for efficiency: having to dispatch on,say, Ops.integer would be too slow.The number of arguments supplied for primitive members of the"Math" group generic methods is not checked prior to dispatch.There is no lazy evaluation of arguments for group-generic functions.
x does not need to be integer if specified as a numeric vector,but see the comments about fractional days in the help forDates.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
Invoking options() with no arguments returns a list with thecurrent values of the options.  Note that not all options listed beloware set initially.  To access the value of a single option, one shoulduse, e.g., getOption("width") rather thanoptions("width") which is a list of length one.
In the case of ties in the first vector, values in the second are usedto break the ties.  If the values are still tied, values in the laterarguments are used to break the tie (see the first example).The sort used is stable (except for method = "quick"),so any unresolved ties will be left in their original ordering.Complex values are sorted first by the real part, then the imaginarypart.Except for method "radix", the sort order for character vectorswill depend on the collating sequence of the locale in use: seeComparison.The "shell" method is generally the safest bet and is thedefault method, except for short factors, numeric vectors,integer vectors and logical vectors, where "radix" is assumed.Method "radix" stably sorts logical,numeric and character vectors in linear time. It outperforms the othermethods, although there are caveats (see sort).  Method"quick" for sort.list is only supported for numericx with na.last = NA, is not stable, and is slower than"radix". partial = NULL is supported for compatibility with otherimplementations of S, but no other values are accepted and ordering isalways complete.For a classed R object, the sort order is taken fromxtfrm: as its help page notes, this can be slow unless asuitable method has been defined or is.numeric(x) istrue.  For factors, this sorts on the internal codes, which isparticularly appropriate for ordered factors.
The type of the vector x is not restricted; it only must havean as.character method and be sortable (byorder).Ordered factors differ from factors only in their class, but methodsand the model-fitting functions treat the two classes quite differently.The encoding of the vector happens as follows.  First all the valuesin exclude are removed from levels. If x[i]equals levels[j], then the i-th element of the result isj.  If no match is found for x[i] in levels(which will happen for excluded values) then the i-th elementof the result is set to NA.Normally the ‘levels’ used as an attribute of the result arethe reduced set of levels after removing those in exclude, butthis can be altered by supplying labels.  This should eitherbe a set of new labels for the levels, or a character string, inwhich case the levels are that character string with a sequencenumber appended.factor(x, exclude = NULL) applied to a factor withoutNAs is a no-operation unless there are unused levels: inthat case, a factor with the reduced level set is returned.  Ifexclude is used, since R version 3.4.0, excluding non-existingcharacter levels is equivalent to excluding nothing, and whenexclude is a character vector, that isapplied to the levels of x.Alternatively, exclude can be factor with the same level set asx and will exclude the levels present in exclude.The codes of a factor may contain NA.  For a numericx, set exclude = NULL to make NA an extralevel (prints as <NA>); by default, this is the last level.If NA is a level, the way to set a code to be missing (asopposed to the code of the missing level) is touse is.na on the left-hand-side of an assignment (as inis.na(f)[i] <- TRUE; indexing inside is.na does not work).Under those circumstances missing values are currently printed as<NA>, i.e., identical to entries of level NA.is.factor is generic: you can write methods to handlespecific classes of objects, see InternalMethods.Where levels is not supplied, unique is called.Since factors typically have quite a small number of levels, for largevectors x it is helpful to supply nmax as an upper boundon the number of unique values.Since R 4.1.0, when using c to combine a (possiblyordered) factor with other objects, if all objects are (possiblyordered) factors, the result will be a factor with levels the union ofthe level sets of the elements, in the order the levels occur in thelevel sets of the elements (which means that if all the elements havethe same level set, that is the level set of the result), equivalentto how unlist operates on a list of factor objects.
X and Y must be suitable arguments for FUN.  Eachwill be extended by rep to length the products of thelengths of X and Y before FUN is called.FUN is called with these two extended vectors as arguments(plus any arguments in ...).  It must be a vectorizedfunction (or the name of one) expecting at least two arguments andreturning a value with the same length as the first (and the second).Where they exist, the [dim]names of X and Y will becopied to the answer, and a dimension assigned which is theconcatenation of the dimensions of X and Y (or lengthsif dimensions do not exist).FUN = "*" is handled as a special case viaas.vector(X) %*% t(as.vector(Y)), and is intended only fornumeric vectors and arrays.%o% is binary operator providing a wrapper forouter(x, y, "*").
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
setHook provides a general mechanism for users to registerhooks, a list of functions to be called from system (or user)functions.  The initial set of hooks was associated with events onpackages/namespaces: these hooks are named via calls topackageEvent.To remove a hook completely, call setHook(hookName, NULL, "replace").When an R package is attached by library or loaded byother means, it can call initialization code.  See.onLoad for a description of the package hook functionscalled during initialization.  Users can add their own initializationcode via the hooks provided by setHook(), functions which willbe called as funname(pkgname, pkgpath) inside atry call.The sequence of events depends on which hooks are defined, and whethera package is attached or just loaded.  In the case where all hooksare defined and a package is attached, the order of initializationevents is as follows: The package namespace is loaded. The package's .onLoad function is run. If S4 methods dispatch is on, any actions set bysetLoadAction are run. The namespace is sealed. The user's "onLoad" hook is run. The package is added to the search path. The package's .onAttach function is run. The package environment is sealed. The user's "attach" hook is run.A similar sequence (but in reverse) is run when a package is detachedand its namespace unloaded: The user's "detach" hook is run. The package's .Last.lib function is run. The package is removed from the search path. The user's "onUnload" hook is run. The package's .onUnload function is run. The package namespace is unloaded.Note that when an R session is finished, packages are not detached andnamespaces are not unloaded, so the corresponding hooks will not berun.Also note that some of the user hooks are run without the packagebeing on the search path, so in those hooks objects in the packageneed to be referred to using the double (or triple) colon operator,as in the example.If multiple hooks are added, they are normally run in the order shownby getHook, but the "detach" and "onUnload" hooksare run in reverse order so the default for package events is to addhooks ‘inside’ existing ones.The hooks are stored in the environment .userHooksEnv in thebase package, with ‘mangled’ names.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
find.package returns path to the locations where thegiven packages are found.  If lib.loc is NULL, thenloaded namespaces are searched before the libraries.  If a package isfound more than once, the first match is used.  Unless quiet =  TRUE a warning will be given about the named packages which are notfound, and an error if none are.  If verbose is true, warningsabout packages found more than once are given.  For a package to bereturned it must contain a either a ‘Meta’ subdirectory or a‘DESCRIPTION’ file containing a valid version field, butit need not be installed (it could be a source package iflib.loc was set suitably).find.package is not usually the right tool to find out if apackage is available for use: the only way to do that is to userequire to try to load it.  It need not be installed forthe correct platform, it might have a version requirement not met bythe running version of R, there might be dependencies which are notavailable, ....path.package returns the paths from which the named packageswere loaded, or if none were named, for all currently attached packages.Unless quiet = TRUE it will warn if some of the packages namedare not attached, and given an error if none are.packageNotFoundError creates an error condition object of classpackageNotFoundError for signaling errors. The condition objectcontains the fields package and lib.loc.  
message is used for generating ‘simple’ diagnosticmessages which are neither warnings nor errors, but neverthelessrepresented as conditions.  Unlike warnings and errors, a finalnewline is regarded as part of the message, and is optional.The default handler sends the message to thestderr() connection.If a condition object is supplied  to message it should bethe only argument, and further arguments will be ignored, with a warning.While the message is being processed, a muffleMessage restartis available.suppressMessages evaluates its expression in a context thatignores all ‘simple’ diagnostic messages.packageStartupMessage is a variant whose messages can besuppressed separately by suppressPackageStartupMessages.  (Theyare still messages, so can be suppressed by suppressMessages.).makeMessage is a utility used by message, warningand stop to generate a text message from the ...arguments by possible translation (see gettext) andconcatenation (with no separator).
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
Almost all lists in R internally are Generic Vectors, whereastraditional dotted pair lists (as in LISP) remain available butrarely seen by users (except as formals of functions).The arguments to list or pairlist are of the formvalue or tag = value.  The functions return a list ordotted pair list composed of its arguments with each value eithertagged or untagged, depending on how the argument was specified.alist handles its arguments as if they described functionarguments.  So the values are not evaluated, and tagged arguments withno value are allowed whereas list simply ignores them.alist is most often used in conjunction with formals.as.list attempts to coerce its argument to a list.  Forfunctions, this returns the concatenation of the list of formalarguments and the function body.  For expressions, the list ofconstituent elements is returned.  as.list is generic, and asthe default method calls as.vector(mode = "list") for anon-list, methods for as.vector may be invoked.  as.listturns a factor into a list of one-element factors.  Attributes maybe dropped unless the argument already is a list or expression.  (Thisis inconsistent with functions such as as.characterwhich always drop attributes, and is for efficiency since lists can beexpensive to copy.)is.list returns TRUE if and only if its argumentis a list or a pairlist of length > 0.is.pairlist returns TRUE if and only if the argumentis a pairlist or NULL (see below).The "environment" method for as.list copies thename-value pairs (for names not beginning with a dot) from anenvironment to a named list.  The user can request that all namedobjects are copied.  Unless sorted = TRUE, the list is in noparticular order (the orderdepends on the order of creation of objects and whether theenvironment is hashed).  No enclosing environments are searched.(Objects copied are duplicated so this can be an expensive operation.)Note that there is an inverse operation, theas.environment() method for list objects.An empty pairlist, pairlist() is the same asNULL.  This is different from list(): some butnot all operations will promote an empty pairlist to an empty list.as.pairlist is implemented as as.vector(x,  "pairlist"), and hence will dispatch methods for the generic functionas.vector.  Lists are copied element-by-element into a pairlistand the names of the list used as tags for the pairlist: the returnvalue for other types of argument is undocumented.list, is.list and is.pairlist areprimitive functions.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
Environments consist of a frame, or collection of namedobjects, and a pointer to an enclosing environment.  The mostcommon example is the frame of variables local to a function call; itsenclosure is the environment where the function was defined(unless changed subsequently).  The enclosing environment isdistinguished from the parent frame: the latter (returned byparent.frame) refers to the environment of the caller ofa function.  Since confusion is so easy, it is best never to use‘parent’ in connection with an environment (despite thepresence of the function parent.env).When get or exists search an environmentwith the default inherits = TRUE, they look for the variablein the frame, then in the enclosing frame, and so on.The global environment .GlobalEnv, more often known as theuser's workspace, is the first item on the search path.  It can alsobe accessed by globalenv().  On the search path, each item'senclosure is the next item.The object .BaseNamespaceEnv is the namespace environment forthe base package.  The environment of the base package itself isavailable as baseenv().If one follows the chain of enclosures found by repeatedly callingparent.env from any environment, eventually one reaches theempty environment emptyenv(), into which nothing maybe assigned.The replacement function parent.env<- is extremely dangerous asit can be used to destructively change environments in ways thatviolate assumptions made by the internal C code.  It may be removedin the near future.The replacement form of environment, is.environment,baseenv, emptyenv and globalenv areprimitive functions.System environments, such as the base, global and empty environments,have names as do the package and namespace environments and thosegenerated by attach().  Other environments can be named bygiving a "name" attribute, but this needs to be done with careas environments have unusual copying semantics.
.GlobalEnv is given number 0 in the list of frames.Each subsequent function evaluation increases the frame stack by 1.The call, function definition and the environment for evaluationof that function are returned by sys.call, sys.functionand sys.frame with the appropriate index.sys.call, sys.function and sys.frame acceptinteger values for the argument which.  Non-negative values ofwhich are frame numbers starting from .GlobalEnvwhereas negative values are counted back from the frame number of thecurrent evaluation.The parent frame of a function evaluation is the environment in whichthe function was called.  It is not necessarily numbered one less thanthe frame number of the current evaluation, nor is it the environmentwithin which the function was defined.  sys.parent returns thenumber of the parent frame if n is 1 (the default), thegrandparent if n is 2, and so on.  See also the ‘Note’.sys.nframe returns an integer, the number of the current frameas described in the first paragraph.sys.calls and sys.frames give a pairlist of all theactive calls and frames, respectively, and sys.parents returnsan integer vector of indices of the parent frames of each of thoseframes.Notice that even though the sys.xxx functions (exceptsys.status) are interpreted, their contexts are not counted norare they reported.  There is no access to them.sys.status() returns a list with components sys.calls,sys.parents and sys.frames, the results of calls tothose three functions (which will include the call tosys.status: see the first example).sys.on.exit() returns the expression stored for use byon.exit in the function currently being evaluated.(Note that this differs from S, which returns a list of expressionsfor the current frame and its parents.)parent.frame(n) is a convenient shorthand forsys.frame(sys.parent(n)) (implemented slightly more efficiently).
If text has length greater than zero (after coercion) it is used inpreference to file.All versions of R accept input from a connection with end of linemarked by LF (as used on Unix), CRLF (as used on DOS/Windows)or CR (as used on classic Mac OS).  The final line can be incomplete,that is missing the final EOL marker.When input is taken from the console, n = NULL is equivalent ton = 1, and n < 0 will read until an EOF character isread.  (The EOF character is Ctrl-Z for the Windows front-ends.)  Theline-length limit is 4095 bytes when reading from the console (whichmay impose a lower limit: see ‘An Introduction to R’).The default for srcfile is set as follows.  Ifkeep.source is not TRUE, srcfiledefaults to a character string, either "<text>" or onederived from file.  When keep.source isTRUE, if text is used, srcfile will be set to asrcfilecopy containing the text.  If a characterstring is used for file, a srcfile objectreferring to that file will be used.When srcfile is a character string, error messages willinclude the name, but source reference information will not be addedto the result.  When srcfile is a srcfileobject, source reference information will be retained.for a character vectors, str2expression(s) corresponds toparse(text = s, keep.source=FALSE), which is always oftype (typeof) and class expression.for a character strings, str2lang(s) corresponds toparse(text = s, keep.source=FALSE)[[1]] (plus a checkthat both s and the parse(*) result are of length one)which is typically a call but may also be a symbol akaname, NULL or an atomic constant such as2, 1L, or TRUE.  Put differently, the value ofstr2lang(.) is a call or one of its parts, in short“a call or simpler”.Currently, encoding is not handled in str2lang() andstr2expression().
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
paste converts its arguments (viaas.character) to character strings, and concatenatesthem (separating them by the string given by sep).  If thearguments are vectors, they are concatenated term-by-term to give acharacter vector result.  Vector arguments are recycled as needed,with zero-length arguments being recycled to "" only ifrecycle0 is not true or collapse is notNULL.Note that paste() coerces NA_character_, thecharacter missing value, to "NA" which may seemundesirable, e.g., when pasting two character vectors, or verydesirable, e.g. in paste("the value of p is ", p).paste0(..., collapse) is equivalent topaste(..., sep = "", collapse), slightly more efficiently.If a value is specified for collapse, the values in the resultare then concatenated into a single string, with the elements beingseparated by the value of collapse.
paste converts its arguments (viaas.character) to character strings, and concatenatesthem (separating them by the string given by sep).  If thearguments are vectors, they are concatenated term-by-term to give acharacter vector result.  Vector arguments are recycled as needed,with zero-length arguments being recycled to "" only ifrecycle0 is not true or collapse is notNULL.Note that paste() coerces NA_character_, thecharacter missing value, to "NA" which may seemundesirable, e.g., when pasting two character vectors, or verydesirable, e.g. in paste("the value of p is ", p).paste0(..., collapse) is equivalent topaste(..., sep = "", collapse), slightly more efficiently.If a value is specified for collapse, the values in the resultare then concatenated into a single string, with the elements beingseparated by the value of collapse.
On most builds of R a leading ~user will expand to the homedirectory of user (since R 4.1.0 also without readlinein use).There are possibly different concepts of ‘home directory’: thatusually used is the setting of the environment variable HOME.The ‘path names’ need not exist nor be valid path names butthey do need to be representable in the session encoding.The definition of the ‘home’ directory is in the ‘rw-FAQ’Q2.14: it is taken from the R_USER environment variable whenpath.expand is first called in a session.The ‘path names’ need not exist nor be valid path names.
find.package returns path to the locations where thegiven packages are found.  If lib.loc is NULL, thenloaded namespaces are searched before the libraries.  If a package isfound more than once, the first match is used.  Unless quiet =  TRUE a warning will be given about the named packages which are notfound, and an error if none are.  If verbose is true, warningsabout packages found more than once are given.  For a package to bereturned it must contain a either a ‘Meta’ subdirectory or a‘DESCRIPTION’ file containing a valid version field, butit need not be installed (it could be a source package iflib.loc was set suitably).find.package is not usually the right tool to find out if apackage is available for use: the only way to do that is to userequire to try to load it.  It need not be installed forthe correct platform, it might have a version requirement not met bythe running version of R, there might be dependencies which are notavailable, ....path.package returns the paths from which the named packageswere loaded, or if none were named, for all currently attached packages.Unless quiet = TRUE it will warn if some of the packages namedare not attached, and given an error if none are.packageNotFoundError creates an error condition object of classpackageNotFoundError for signaling errors. The condition objectcontains the fields package and lib.loc.  
NA
R has a small number of built-in constants.The following constants are available:LETTERS: the 26 upper-case letters of the Romanalphabet;letters: the 26 lower-case letters of the Romanalphabet;month.abb: the three-letter abbreviations for theEnglish month names;month.name: the English names for the months of theyear;pi: the ratio of the circumference of a circle to itsdiameter.These are implemented as variables in the base namespace takingappropriate values.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The two step types differ in their x-y preference: Going from(x1,y1) to (x2,y2) with x1 < x2, type = "s"moves first horizontal, then vertical, whereas type = "S" movesthe other way around.
The behaviour differs by the value of duplicates.ok. Considerfirst the case if this is true.  First exact matches are considered,and the positions of the first exact matches are recorded. Then uniquepartial matches are considered, and if found recorded.  (A partialmatch occurs if the whole of the element of x matches thebeginning of the element of table.)  Finally,all remaining elements of x are regarded as unmatched.In addition, an empty string can match nothing, not even an exactmatch to an empty string.  This is the appropriate behaviour forpartial matching of character indices, for example.If duplicates.ok is FALSE, values of table oncematched are excluded from the search for subsequent matches.  Thisbehaviour is equivalent to the R algorithm for argumentmatching, except for the consideration of empty strings (which inargument matching are matched after exact and partial matching to anyremaining arguments).charmatch is similar to pmatch withduplicates.ok true, the differences being that itdifferentiates between no match and an ambiguous partial match,  itdoes match empty strings, and it does not allow multiple exact matches.NA values are treated as if they were the string constant"NA".
max and min return the maximum or minimum of allthe  values present in their arguments, as integer ifall are logical or integer, as double ifall are numeric, and character otherwise.If na.rm is FALSE an NA value in any of thearguments will cause a value of NA to be returned, otherwiseNA values are ignored.The minimum and maximum of a numeric empty set are +Inf and-Inf (in this order!) which ensures transitivity, e.g.,min(x1, min(x2)) == min(x1, x2).  For numeric xmax(x) == -Inf and min(x) == +Infwhenever length(x) == 0 (after removing missing values ifrequested).  However, pmax and pmin returnNA if all the parallel elements are NA even forna.rm = TRUE.pmax and pmin take one or more vectors (or matrices) asarguments and return a single vector giving the ‘parallel’maxima (or minima) of the vectors.  The first element of the result isthe maximum (minimum) of the first elements of all the arguments, thesecond element of the result is the maximum (minimum) of the secondelements of all the arguments and so on.  Shorter inputs (of non-zerolength) are recycled if necessary.  Attributes (seeattributes: such as names ordim) are copied from the first argument (if applicable,e.g., not for an S4 object).pmax.int and pmin.int are faster internal versions onlyused when all arguments are atomic vectors and there are no classes:they drop all attributes.  (Note that all versions fail for raw andcomplex vectors since these have no ordering.)max and min are generic functions: methods can bedefined for them individually or via theSummary group generic.  For this towork properly, the arguments ... should be unnamed, anddispatch is on the first argument.By definition the min/max of a numeric vector containing an NaNis NaN, except that the min/max of any vector containing anNA is NA even if it also contains an NaN.Note that max(NA, Inf) == NA even though the maximum would beInf whatever the missing value actually is.Character versions are sorted lexicographically, and this depends onthe collating sequence of the locale in use: the help for‘Comparison’ gives details.  The max/min of an emptycharacter vector is defined to be character NA.  (One couldargue that as "" is the smallest character element, the maximumshould be "", but there is no obvious candidate for theminimum.)
max and min return the maximum or minimum of allthe  values present in their arguments, as integer ifall are logical or integer, as double ifall are numeric, and character otherwise.If na.rm is FALSE an NA value in any of thearguments will cause a value of NA to be returned, otherwiseNA values are ignored.The minimum and maximum of a numeric empty set are +Inf and-Inf (in this order!) which ensures transitivity, e.g.,min(x1, min(x2)) == min(x1, x2).  For numeric xmax(x) == -Inf and min(x) == +Infwhenever length(x) == 0 (after removing missing values ifrequested).  However, pmax and pmin returnNA if all the parallel elements are NA even forna.rm = TRUE.pmax and pmin take one or more vectors (or matrices) asarguments and return a single vector giving the ‘parallel’maxima (or minima) of the vectors.  The first element of the result isthe maximum (minimum) of the first elements of all the arguments, thesecond element of the result is the maximum (minimum) of the secondelements of all the arguments and so on.  Shorter inputs (of non-zerolength) are recycled if necessary.  Attributes (seeattributes: such as names ordim) are copied from the first argument (if applicable,e.g., not for an S4 object).pmax.int and pmin.int are faster internal versions onlyused when all arguments are atomic vectors and there are no classes:they drop all attributes.  (Note that all versions fail for raw andcomplex vectors since these have no ordering.)max and min are generic functions: methods can bedefined for them individually or via theSummary group generic.  For this towork properly, the arguments ... should be unnamed, anddispatch is on the first argument.By definition the min/max of a numeric vector containing an NaNis NaN, except that the min/max of any vector containing anNA is NA even if it also contains an NaN.Note that max(NA, Inf) == NA even though the maximum would beInf whatever the missing value actually is.Character versions are sorted lexicographically, and this depends onthe collating sequence of the locale in use: the help for‘Comparison’ gives details.  The max/min of an emptycharacter vector is defined to be character NA.  (One couldargue that as "" is the smallest character element, the maximumshould be "", but there is no obvious candidate for theminimum.)
max and min return the maximum or minimum of allthe  values present in their arguments, as integer ifall are logical or integer, as double ifall are numeric, and character otherwise.If na.rm is FALSE an NA value in any of thearguments will cause a value of NA to be returned, otherwiseNA values are ignored.The minimum and maximum of a numeric empty set are +Inf and-Inf (in this order!) which ensures transitivity, e.g.,min(x1, min(x2)) == min(x1, x2).  For numeric xmax(x) == -Inf and min(x) == +Infwhenever length(x) == 0 (after removing missing values ifrequested).  However, pmax and pmin returnNA if all the parallel elements are NA even forna.rm = TRUE.pmax and pmin take one or more vectors (or matrices) asarguments and return a single vector giving the ‘parallel’maxima (or minima) of the vectors.  The first element of the result isthe maximum (minimum) of the first elements of all the arguments, thesecond element of the result is the maximum (minimum) of the secondelements of all the arguments and so on.  Shorter inputs (of non-zerolength) are recycled if necessary.  Attributes (seeattributes: such as names ordim) are copied from the first argument (if applicable,e.g., not for an S4 object).pmax.int and pmin.int are faster internal versions onlyused when all arguments are atomic vectors and there are no classes:they drop all attributes.  (Note that all versions fail for raw andcomplex vectors since these have no ordering.)max and min are generic functions: methods can bedefined for them individually or via theSummary group generic.  For this towork properly, the arguments ... should be unnamed, anddispatch is on the first argument.By definition the min/max of a numeric vector containing an NaNis NaN, except that the min/max of any vector containing anNA is NA even if it also contains an NaN.Note that max(NA, Inf) == NA even though the maximum would beInf whatever the missing value actually is.Character versions are sorted lexicographically, and this depends onthe collating sequence of the locale in use: the help for‘Comparison’ gives details.  The max/min of an emptycharacter vector is defined to be character NA.  (One couldargue that as "" is the smallest character element, the maximumshould be "", but there is no obvious candidate for theminimum.)
max and min return the maximum or minimum of allthe  values present in their arguments, as integer ifall are logical or integer, as double ifall are numeric, and character otherwise.If na.rm is FALSE an NA value in any of thearguments will cause a value of NA to be returned, otherwiseNA values are ignored.The minimum and maximum of a numeric empty set are +Inf and-Inf (in this order!) which ensures transitivity, e.g.,min(x1, min(x2)) == min(x1, x2).  For numeric xmax(x) == -Inf and min(x) == +Infwhenever length(x) == 0 (after removing missing values ifrequested).  However, pmax and pmin returnNA if all the parallel elements are NA even forna.rm = TRUE.pmax and pmin take one or more vectors (or matrices) asarguments and return a single vector giving the ‘parallel’maxima (or minima) of the vectors.  The first element of the result isthe maximum (minimum) of the first elements of all the arguments, thesecond element of the result is the maximum (minimum) of the secondelements of all the arguments and so on.  Shorter inputs (of non-zerolength) are recycled if necessary.  Attributes (seeattributes: such as names ordim) are copied from the first argument (if applicable,e.g., not for an S4 object).pmax.int and pmin.int are faster internal versions onlyused when all arguments are atomic vectors and there are no classes:they drop all attributes.  (Note that all versions fail for raw andcomplex vectors since these have no ordering.)max and min are generic functions: methods can bedefined for them individually or via theSummary group generic.  For this towork properly, the arguments ... should be unnamed, anddispatch is on the first argument.By definition the min/max of a numeric vector containing an NaNis NaN, except that the min/max of any vector containing anNA is NA even if it also contains an NaN.Note that max(NA, Inf) == NA even though the maximum would beInf whatever the missing value actually is.Character versions are sorted lexicographically, and this depends onthe collating sequence of the locale in use: the help for‘Comparison’ gives details.  The max/min of an emptycharacter vector is defined to be character NA.  (One couldargue that as "" is the smallest character element, the maximumshould be "", but there is no obvious candidate for theminimum.)
A polynomial of degree n - 1,    p(x) = z1 + z2 * x + … + z[n] * x^(n-1)is given by its coefficient vector z[1:n].polyroot returns the n-1 complex zeros of p(x)using the Jenkins-Traub algorithm.If the coefficient vector z has zeroes for the highest powers,these are discarded.There is no maximum degree, but numerical stabilitymay be an issue for all but low-degree polynomials.
Several R functions for manipulating objects in environments (such asget and ls) allow specifying environmentsvia corresponding positions in the search path.  pos.to.env isa convenience function for programmers which converts these positionsto corresponding environments; users will typically have no need forit.  It is primitive.-1 is interpreted as the environment the function is calledfrom.This is a primitive function.
If init is given, Reduce logically adds it to the start(when proceeding left to right) or the end of x, respectively.If this possibly augmented vector v has n > 1 elements,Reduce successively applies f to the elements of vfrom left to right or right to left, respectively.  I.e., a leftreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,and returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce doesr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})and returns r_1 = f(v_1, r_2).  (E.g., if v is thesequence (2, 3, 4) and f is division, left and right reduce give(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)If v has only a single element, this is returned; if there areno elements, NULL is returned.  Thus, it is ensured thatf is always called with 2 arguments.The current implementation is non-recursive to ensure stability andscalability.Reduce is patterned after Common Lisp's reduce.  Areduce is also known as a fold (e.g., in Haskell) or an accumulate(e.g., in the C++ Standard Template Library).  The accumulativeversion corresponds to Haskell's scan functions.Filter applies the unary predicate function f to eachelement of x, coercing to logical if necessary, and returns thesubset of x for which this gives true.  Note that possibleNA values are currently always taken as false; control overNA handling may be added in the future.  Filtercorresponds to filter in Haskell or remove-if-not inCommon Lisp.Find and Position are patterned after Common Lisp'sfind-if and position-if, respectively.  If there is anelement for which the predicate function gives true, then the first orlast such element or its position is returned depending on whetherright is false (default) or true, respectively.  If there is nosuch element, the value specified by nomatch is returned.  Thecurrent implementation is not optimized for performance.Map is a simple wrapper to mapply which does notattempt to simplify the result, similar to Common Lisp's mapcar(with arguments being recycled, however).  Future versions may allowsome control of the result type.Negate corresponds to Common Lisp's complement.  Given a(predicate) function f, it creates a function which returns thelogical negation of what f returns.
pretty ignores non-finite values in x.Let d <- max(x) - min(x) ≥ 0.If d is not (very close) to 0, we let c <- d/n,otherwise more or less c <- max(abs(range(x)))*shrink.sml / min.n.Then, the 10 base b is10^(floor(log10(c))) suchthat b ≤ c < 10b.Now determine the basic unit u as one of{1,2,5,10} b, depending onc/b in [1,10)and the two ‘bias’ coefficients, h  =high.u.bias and f =u5.bias..........
pretty ignores non-finite values in x.Let d <- max(x) - min(x) ≥ 0.If d is not (very close) to 0, we let c <- d/n,otherwise more or less c <- max(abs(range(x)))*shrink.sml / min.n.Then, the 10 base b is10^(floor(log10(c))) suchthat b ≤ c < 10b.Now determine the basic unit u as one of{1,2,5,10} b, depending onc/b in [1,10)and the two ‘bias’ coefficients, h  =high.u.bias and f =u5.bias..........
For numbers, formatC() calls prettyNum() when neededwhich itself calls .format.zeros(*, replace=replace.zero).(“when needed”: when zero.print is notNULL, drop0trailing is true, or one of big.mark,small.mark, or decimal.mark is not at default.)If you set format it overrides the setting of mode, soformatC(123.45, mode = "double", format = "d") gives 123.The rendering of scientific format is platform-dependent: some systemsuse n.ddde+nnn or n.dddenn rather than n.ddde+nn.formatC does not necessarily align the numbers on the decimalpoint, so formatC(c(6.11, 13.1), digits = 2, format = "fg") givesc("6.1", " 13").  If you want common formatting for severalnumbers, use format.prettyNum is the utility function for prettifying x.x can be complex (or format(<complex>)), here.  Ifx is not a character, format(x[i], ...) is applied toeach element, and then it is left unchanged if all the other argumentsare at their defaults.  Use the input.d.mark argument forprettyNum(x) when x is a character vector notresulting from something like format(<number>) with a period asdecimal mark.Because gsub is used to insert the big.markand small.mark, special characters need escaping.  In particular,to insert a single backslash, use "\\\\".The C doubles used for R numerical vectors have signed zeros, whichformatC may output as -0, -0.000 ....There is a warning if big.mark and decimal.mark are thesame: that would be confusing to those reading the output.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
Function I has two main uses. In function data.frame.  Protecting an object byenclosing it in I() in a call to data.frame inhibits theconversion of character vectors to factors and the dropping ofnames, and ensures that matrices are inserted as single columns.I can also be used to protect objects which are to beadded to a data frame, or converted to a data frame viaas.data.frame.It achieves this by prepending the class "AsIs" to the object'sclasses.  Class "AsIs" has a few of its own methods, includingfor [, as.data.frame, print and format. In function formula.  There it is used toinhibit the interpretation of  operators such as "+","-", "*" and "^" as formula operators, so theyare used as arithmetical operators.  This is interpreted as a symbolby terms.formula.
A data frame is split by row into data framessubsetted by the values of one or more factors, and functionFUN is applied to each subset in turn.For the default method, an object with dimensions (e.g., a matrix) iscoerced to a data frame and the data frame method applied.  Otherobjects are also coerced to a data frame, but FUN is appliedseparately to (subsets of) each column of the data frame.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
This calls format which formats the data framecolumn-by-column, then converts to a character matrix and dispatchesto the print method for matrices.When quote = TRUE only the entries are quoted not the row namesnor the column names.
Dates are represented as the number of days since 1970-01-01, withnegative values for earlier dates.  They are always printedfollowing the rules of the current Gregorian calendar, even thoughthat calendar was not in use long ago (it was adopted in 1752 inGreat Britain and its colonies).It is intended that the date should be an integer, but this is notenforced in the internal representation.  Fractional days will beignored when printing.  It is possible to produce fractional days viathe mean method or by adding or subtracting (seeOps.Date).From the many methods, see methods(class = "Date"), a few aredocumented separately, see below.
The default for printing NAs is to print NA (withoutquotes) unless this is a character NA and quote =    FALSE, when <NA> is printed.The same number of decimal places is used throughout a vector.  Thismeans that digits specifies the minimum number of significantdigits to be used, and that at least one entry will be encoded withthat minimum number.  However, if all the encoded elements then havetrailing zeroes, the number of decimal places is reduced until atleast one element has a non-zero final digit.  Decimal points are onlyincluded if at least one decimal place is selected.Attributes are printed respecting their class(es), using the values ofdigits to print.default, but using the default values(for the methods called) of the other arguments.Option width controls the printing of vectors, matrices andarrays, and option deparse.cutoff controls the printing oflanguage objects such as calls and formulae.When the methods package is attached, print will callshow for R objects with formal classes (‘S4’)if called with no optional arguments.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
This queries the internal table that manages the DLLs.
This queries the internal table that manages the DLLs.
This takes the registration information after it has been registeredand processed by the R internals.  In other words, it uses the extendedinformation.There is print methods for the class, which prints only thetypes which have registered routines.
If symmetric is unspecified, isSymmetric(x)determines if the matrix is symmetric up to plausible numericalinaccuracies.  It is surer and typically much faster to set the valueyourself.Computing the eigenvectors is the slow part for large matrices.Computing the eigendecomposition of a matrix is subject to errors on areal-world computer: the definitive analysis is Wilkinson (1965).  Allyou can hope for is a solution to a problem suitably close tox.  So even though a real asymmetric x may have analgebraic solution with repeated real eigenvalues, the computedsolution may be of a similar matrix with complex conjugate pairs ofeigenvalues.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code (most often 1): these canonly be interpreted by detailed study of the FORTRAN code.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
Class "hexmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in hex.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.hexmode can convert integers (of type "integer" or"double") and character vectors whose elements contain only0-9, a-f, A-F (or are NA) to class"hexmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
This takes the registration information after it has been registeredand processed by the R internals.  In other words, it uses the extendedinformation.There is print methods for the class, which prints only thetypes which have registered routines.
noquote returns its argument as an object of class"noquote".  There is a method for c() and subscriptmethod ("[.noquote") which ensures that the class is not lostby subsetting.  The print method (print.noquote) printscharacter strings without quotes ("...." is printed as ....).If right is specified in a call print(x, right=*), ittakes precedence over a possible right setting of x,e.g., created by x <- noquote(*, right=TRUE).These functions exist both as utilities and as an example of using (S3)class and object orientation.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
Class "octmode" consists of integer vectors with that classattribute, used merely to ensure that they are printed in octalnotation, specifically for Unix-like file permissions such as755.  Subsetting ([) works too.If width = NULL (the default), the output is padded withleading zeroes to the smallest width needed for all the non-missingelements.as.octmode can convert integers (of type "integer" or"double") and character vectors whose elements contain onlydigits 0-7 (or are NA) to class "octmode".There is a ! method and methods for | and&:these recycle their arguments to the length of the longer and thenapply the operators bitwise to each element.
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
There are two basic classes of date/times.  Class "POSIXct"represents the (signed) number of seconds since the beginning of 1970(in the UTC time zone) as a numeric vector.  Class "POSIXlt" isa named list of vectors representing0–61: seconds.0–59: minutes.0–23: hours.1–31: day of the month0–11: months after the first of the year.years since 1900.0–6 day of the week, starting on Sunday.0–365: day of the year (365 only in leap years).Daylight Saving Time flag.  Positive if inforce, zero if not, negative if unknown.(Optional.) The abbreviation for the time zone inforce at that time: "" if unknown (but "" might alsobe used for UTC).(Optional.) The offset in seconds from GMT:positive values are East of the meridian.  Usually NA ifunknown, but 0 could mean unknown.(The last two components are not present for times in UTC and areplatform-dependent: they are supported on platforms based on BSD orglibc (including Linux and macOS) and those using thetzcode implementation shipped with R (including Windows). Butthey are not necessarily set.).  Note that the internal list structureis somewhat hidden, as many methods (includinglength(x), print() and str)apply to the abstract date-time vector, as for "POSIXct".  Asfrom R 3.5.0, one can extract and replace single componentsvia [ indexing with two indices (see the examples).  Theclasses correspond to the POSIX/C99 constructs of ‘calendartime’ (the time_t data type) and ‘local time’ (orbroken-down time, the struct tm data type), from which theyalso inherit their names.  The components of "POSIXlt" areinteger vectors, except sec and zone."POSIXct" is more convenient for including in data frames, and"POSIXlt" is closer to human-readable forms.  A virtual class"POSIXt" exists from which both of the classes inherit: it isused to allow operations such as subtraction to mix the two classes.Components wday and yday of "POSIXlt" are forinformation, and are not used in the conversion to calendar time.However, isdst is needed to distinguish times at the end ofDST: typically 1am to 2am occurs twice, first in DST and then instandard time.  At all other times isdst can be deduced fromthe first six values, but the behaviour if it is set incorrectly isplatform-dependent.Logical comparisons and some arithmetic operations are available forboth classes.  One can add or subtract a number of seconds from adate-time object, but not add two date-time objects.  Subtraction oftwo date-time objects is equivalent to using difftime.Be aware that "POSIXlt" objects will be interpreted as being inthe current time zone for these operations unless a time zone has beenspecified."POSIXlt" objects will often have an attribute "tzone",a character vector of length 3 giving the time zone name (from the TZenvironment variable or argument tz of functions creating"POSIXlt" objects; "" marks the current time zone)and the names of the base time zoneand the alternate (daylight-saving) time zone.  Sometimes this mayjust be of length one, giving the time zone name."POSIXct" objects may also have an attribute "tzone", acharacter vector of length one.  If set to a non-empty value, it willdetermine how the object is converted to class "POSIXlt" and inparticular how it is printed.  This is usually desirable, but if youwant to specify an object in a particular time zone but to be printedin the current time zone you may want to remove the "tzone"attribute (e.g., by c(x)).Unfortunately, the conversion is complicated by the operation of timezones and leap seconds (according to this version of R's data,27 days have been 86401 seconds long sofar, the last being on (actually, immediately before)2017-01-01: the times of theextra seconds are in the object .leap.seconds).  The details ofthis are entrusted to the OS services where possible.  It seems thatsome rare systems used to use leap seconds, but all known currentplatforms ignore them (as required by POSIX).  This is detected andcorrected for at build time, so "POSIXct" times used by R donot include leap seconds on any platform.Using c on "POSIXlt" objects converts them to thecurrent time zone, and on "POSIXct" objects drops any"tzone" attributes, unless they are all marked with the sametime zone.A few times have specific issues.  First, the leap seconds are ignored,and real times such as "2005-12-31 23:59:60" are (probably)treated as the next second.  However, they will never be generated byR, and are unlikely to arise as input.  Second, on some OSes there isa problem in the POSIX/C99 standard with "1969-12-31 23:59:59 UTC",which is -1 in calendar time and that value is on those OSesalso used as an error code.  Thus as.POSIXct("1969-12-31  23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") may giveNA, and hence as.POSIXct("1969-12-31 23:59:59",  tz = "UTC") will give "1969-12-31 23:59:00".  Other OSes(including the code used by R on Windows) report errors separatelyand so are able to handle that time as valid.The print methods respect options("max.print").
proc.time returns five elements for backwards compatibility,but its print method prints a named vector oflength 3.  The first two entries are the total user and system CPUtimes of the current R process and any child processes on which ithas waited, and the third entry is the ‘real’ elapsed timesince the process was started.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
‘vector’ is used in the sense of is.vector.Missing values are regarded as unequal to the previous value, even ifthat is also missing.inverse.rle() is the inverse function of rle(),reconstructing x from the runs.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
These functions and classes handle source code references.The srcfile function produces an object of classsrcfile, which contains the name and directory of a source codefile, along with its timestamp, for use in source level debugging (notyet implemented) and source echoing.  The encoding of the file issaved; see file for a discussion of encodings, andiconvlist for a list of allowable encodings on your platform.The srcfilecopy function produces an object of the descendantclass srcfilecopy, which saves the source lines in a charactervector.  It copies the value of the isFile argument, to helpdebuggers identify whether this text comes from a real file in thefile system.The srcfilealias function produces an object of the descendantclass srcfilealias, which gives an alternate name to anothersrcfile.  This is produced by the parser when a #line directiveis used.The getSrcLines function reads the specified lines fromsrcfile.The srcref function produces an object of classsrcref, which describes a range of characters in asrcfile.The lloc value gives the following values:Bytes (elements 2, 4) andcolumns (elements 5, 6) may be different due to multibytecharacters.  If only four values are given, the columns and bytesare assumed to match.  Lines (elements 1, 3) and parsed lines(elements 7, 8) may differ if a #line directive is used incode:  the former will respect the directive, the latter will justcount lines.  If only 4 or 6 elements are given, the parsed lineswill be assumed to match the lines.Methods are defined for print, summary, open,and close for classes srcfile and srcfilecopy.The open method opens its internal file connection ata particular line; if it was already open, it will be repositionedto that line.Methods are defined for print, summary andas.character for class srcref.  The as.charactermethod will read the associated source file to obtain the textcorresponding to the reference.  If the to argument is given,it should be a second srcref that follows the first, in thesame file; they will be treated as one reference to the wholerange.  The exact behaviour depends on theclass of the source file.  If the source file inherits fromclass srcfilecopy, the lines are taken from the saved copyusing the “parsed” line counts.  If not, an attemptis made to read the file, and the original line numbers of thesrcref record (i.e., elements 1 and 3) are used.  If an erroroccurs (e.g., the file no longer exists), text like<srcref: "file" chars 1:1 to 2:10> will be returned instead,indicating the line:column ranges of the first and lastcharacter.  The summary method defaults to this type ofdisplay.Lists of srcref objects may be attached to expressions as the"srcref" attribute.  (The list of srcref objects should be the samelength as the expression.)  By default, expressions are printed byprint.default using the associated srcref.  Tosee deparsed code instead, call print with argumentuseSource = FALSE.  If a srcref objectis printed with useSource = FALSE, the <srcref: ...>record will be printed..isOpen is intended for internal use:  it checks whether theconnection associated with a srcfile object is open.
If the argument dnn is not supplied, the internal functionlist.names is called to compute the ‘dimname names’.  If thearguments in ... are named, those names are used.  For theremaining arguments, deparse.level = 0 gives an empty name,deparse.level = 1 uses the supplied argument if it is a symbol,and deparse.level = 2 will deparse the argument.Only when exclude is specified (i.e., not by default) andnon-empty, will table potentially drop levels of factorarguments.useNA controls if the table includes counts of NAvalues: the allowed values correspond to never ("no"), only if the count ispositive ("ifany") and even for zero counts ("always").Note the somewhat “pathological” case of two different kinds ofNAs which are treated differently, depending on bothuseNA and exclude, see d.patho in the‘Examples:’ below.Both exclude and useNA operate on an “all or none”basis.  If you want to control the dimensions of a multiway tableseparately, modify each argument using factor oraddNA.Non-factor arguments a are coerced via factor(a,    exclude=exclude).  Since R 3.4.0, care is taken not tocount the excluded values (where they were included in the NAcount, previously).The summary method for class "table" (used for objectscreated by table or xtabs) which gives basicinformation and performs a chi-squared test for independence offactors (note that the function chisq.test currentlyonly handles 2-d tables).
See the description of options("warn") for thecircumstances under which there is a last.warning object andwarnings() is used.  In essence this is if options(warn =    0) and warning has been called at least once.Note that the length(last.warning) is maximallygetOption("nwarnings") (at the time the warnings aregenerated) which is 50 by default.  To increase, use somethinglike It is possible that last.warning refers to the last recordedwarning and not to the last warning, for example if options(warn) hasbeen changed or if a catastrophic error occurred.
For factors, the frequency of the first maxsum - 1most frequent levels is shown, and the less frequent levels aresummarized in "(Others)" (resulting in at most maxsumfrequencies).The functions summary.lm and summary.glm are examplesof particular methods which summarize the results produced bylm and glm.
The default method, print.default has its own help page.Use methods("print") to get all the methods for theprint generic.print.factor allows some customization and is used for printingordered factors as well.print.table for printing tables allows othercustomization.  As of R 3.0.0, it only prints a description in case of a tablewith 0-extents (this can happen if a classifier has no valid data).See noquote as an example of a class whose mainpurpose is a specific print method.
See the description of options("warn") for thecircumstances under which there is a last.warning object andwarnings() is used.  In essence this is if options(warn =    0) and warning has been called at least once.Note that the length(last.warning) is maximallygetOption("nwarnings") (at the time the warnings aregenerated) which is 50 by default.  To increase, use somethinglike It is possible that last.warning refers to the last recordedwarning and not to the last warning, for example if options(warn) hasbeen changed or if a catastrophic error occurred.
prmatrix is an earlier form of print.matrix, andis very similar to the S function of the same name.
proc.time returns five elements for backwards compatibility,but its print method prints a named vector oflength 3.  The first two entries are the total user and system CPUtimes of the current R process and any child processes on which ithas waited, and the third entry is the ‘real’ elapsed timesince the process was started.
If na.rm is FALSE an NAvalue in any of the arguments will causea value of NA to be returned, otherwiseNA values are ignored.This is a generic function: methods can be defined for itdirectly or via the Summary group generic.For this to work properly, the arguments ... should beunnamed, and dispatch is on the first argument.Logical true values are regarded as one, false values as zero.For historical reasons, NULL is accepted and treated as if itwere numeric(0).
NA
NA
The functions dimnames and dimnames<- are generic.For an array (and hence in particular, for amatrix), they retrieve or set the dimnamesattribute (see attributes) of the object.  A listvalue can have names, and these will be used to label thedimensions of the array where appropriate.The replacement method for arrays/matrices coerces vector and factorelements of value to character, but does not dispatch methodsfor as.character.  It coerces zero-length elements toNULL, and a zero-length list to NULL.  If valueis a list shorter than the number of dimensions, it is extended withNULLs to the needed length.Both have methods for data frames.  The dimnames of a data frame areits row.names and its names.  For thereplacement method each component of value will be coerced byas.character.For a 1D matrix the names are the same thing as the(only) component of the dimnames.Both are primitive functions.provideDimnames(x) provides dimnames where“missing”, such that its result has characterdimnames for each component.  If unique is true as by default,they are unique within each component via make.unique(*,    sep=sep).
The functions beta and lbeta return the beta functionand the natural logarithm of the beta function,B(a,b) = Γ(a)Γ(b)/Γ(a+b).The formal definition isintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258).  Note that it is onlydefined in R for non-negative a and b, and is infiniteif either is zero.The functions gamma and lgamma return the gamma functionΓ(x) and the natural logarithm of the absolute value of thegamma function.  The gamma function is defined by(Abramowitz and Stegun section 6.1.1, page 255)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dtfor all real x except zero and negative integers (whenNaN is returned).  There will be a warning on possible loss ofprecision for values which are too close (within about1e-8) to a negative integer less than -10.factorial(x) (x! for non-negative integer x)is defined to be gamma(x+1) and lfactorial to belgamma(x+1).The functions digamma and trigamma return the first and secondderivatives of the logarithm of the gamma function.psigamma(x, deriv) (deriv >= 0) computes thederiv-th derivative of ψ(x).digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ and its derivatives, the psigamma() functions, areoften called the ‘polygamma’ functions, e.g. inAbramowitz and Stegun (section 6.4.1, page 260); and higherderivatives (deriv = 2:4) have occasionally been called‘tetragamma’, ‘pentagamma’, and ‘hexagamma’.The functions choose and lchoose return binomialcoefficients and the logarithms of their absolute values.  Note thatchoose(n, k) is defined for all real numbers n and integerk.  For k ≥ 1 it is defined asn(n-1)…(n-k+1) / k!,as 1 for k = 0 and as 0 for negative k.Non-integer values of k are rounded to an integer, with a warning.choose(*, k) uses direct arithmetic (instead of[l]gamma calls) for small k, for speed and accuracyreasons.  Note the function combn (packageutils) for enumeration of all possible combinations.The gamma, lgamma, digamma and trigammafunctions are internal generic primitive functions: methods can bedefined for them individually or via theMath group generic.
Several character strings can be pushed back on one or more occasions.The occasions form a stack, so the first line to be retrieved will bethe first string from the last call to pushBack.  Lines whichare pushed back are read prior to the normal input from theconnection, by the normal text-reading functions such asreadLines and scan.Pushback is only allowed for readable connections in text mode.Not all uses of connections respect pushbacks, in particular the inputconnection is still wired directly, so for example parsingcommands from the console and scan("") ignore pushbacks onstdin.When character strings with a marked encoding (seeEncoding) are pushed back they are converted to thecurrent encoding if encoding = "".  This may involverepresenting characters as <U+xxxx> if they cannot beconverted.  They will be converted to UTF-8 if encoding =  "UTF-8" or left as-is if encoding = "bytes".
Several character strings can be pushed back on one or more occasions.The occasions form a stack, so the first line to be retrieved will bethe first string from the last call to pushBack.  Lines whichare pushed back are read prior to the normal input from theconnection, by the normal text-reading functions such asreadLines and scan.Pushback is only allowed for readable connections in text mode.Not all uses of connections respect pushbacks, in particular the inputconnection is still wired directly, so for example parsingcommands from the console and scan("") ignore pushbacks onstdin.When character strings with a marked encoding (seeEncoding) are pushed back they are converted to thecurrent encoding if encoding = "".  This may involverepresenting characters as <U+xxxx> if they cannot beconverted.  They will be converted to UTF-8 if encoding =  "UTF-8" or left as-is if encoding = "bytes".
save must be one of "no", "yes","ask" or "default".  In the first case the workspaceis not saved, in the second it is saved and in the third the user isprompted and can also decide not to quit.  The default is toask in interactive use but may be overridden by command-linearguments (which must be supplied in non-interactive use).Immediately before normal termination, .Last() isexecuted if the function .Last exists and runLast istrue.  If in interactive use there are errors in the .Lastfunction, control will be returned to the command prompt, so do testthe function thoroughly.  There is a system analogue,.Last.sys(), which is run after .Last() ifrunLast is true.Exactly what happens at termination of an R session depends on theplatform and GUI interface in use.  A typical sequence is to run.Last() and .Last.sys() (unless runLast isfalse), to save the workspace if requested (and in most cases alsoto save the session history: see savehistory), thenrun any finalizers (see reg.finalizer) that have beenset to be run on exit, close all open graphics devices, remove thesession temporary directory and print any remaining warnings(e.g., from .Last() and device closure).Some error status values are used by R itself.  The default errorhandler for non-interactive use effectively calls q("no", 1,    FALSE) and returns error status 1.  Error status 2 is used for R‘suicide’, that is a catastrophic failure, and other smallnumbers are used by specific ports for initialization failures.  Itis recommended that users choose statuses of 10 or more.Valid values of status are system-dependent, but 0:255are normally valid.  (Many OSes will report the last byte of thevalue, that is report the value modulo 256.  But not all.)
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
NA
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
NA
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
The QR decomposition plays an important role in manystatistical techniques.  In particular it can be used to solve theequation \bold{Ax} = \bold{b} for given matrix \bold{A},and vector \bold{b}.  It is useful for computing regressioncoefficients and in applying the Newton-Raphson algorithm.The functions qr.coef, qr.resid, and qr.fittedreturn the coefficients, residuals and fitted values obtained whenfitting y to the matrix with QR decomposition qr.(If pivoting is used, some of the coefficients will be NA.)qr.qy and qr.qty return Q %*% y andt(Q) %*% y, where Q is the (complete) \bold{Q} matrix.All the above functions keep dimnames (and names) ofx and y if there are any.solve.qr is the method for solve for qr objects.qr.solve solves systems of equations via the QR decomposition:if a is a QR decomposition it is the same as solve.qr,but if a is a rectangular matrix the QR decomposition iscomputed first.  Either will handle over- and under-determinedsystems, providing a least-squares fit if appropriate.is.qr returns TRUE if x is a listand inherits from "qr".It is not possible to coerce objects to mode "qr".  Objectseither are QR decompositions or they are not.The LINPACK interface is restricted to matrices x with lessthan 2^31 elements.qr.fitted and qr.resid only support the LINPACK interface.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
NA
NA
NA
NA
save must be one of "no", "yes","ask" or "default".  In the first case the workspaceis not saved, in the second it is saved and in the third the user isprompted and can also decide not to quit.  The default is toask in interactive use but may be overridden by command-linearguments (which must be supplied in non-interactive use).Immediately before normal termination, .Last() isexecuted if the function .Last exists and runLast istrue.  If in interactive use there are errors in the .Lastfunction, control will be returned to the command prompt, so do testthe function thoroughly.  There is a system analogue,.Last.sys(), which is run after .Last() ifrunLast is true.Exactly what happens at termination of an R session depends on theplatform and GUI interface in use.  A typical sequence is to run.Last() and .Last.sys() (unless runLast isfalse), to save the workspace if requested (and in most cases alsoto save the session history: see savehistory), thenrun any finalizers (see reg.finalizer) that have beenset to be run on exit, close all open graphics devices, remove thesession temporary directory and print any remaining warnings(e.g., from .Last() and device closure).Some error status values are used by R itself.  The default errorhandler for non-interactive use effectively calls q("no", 1,    FALSE) and returns error status 1.  Error status 2 is used for R‘suicide’, that is a catastrophic failure, and other smallnumbers are used by specific ports for initialization failures.  Itis recommended that users choose statuses of 10 or more.Valid values of status are system-dependent, but 0:255are normally valid.  (Many OSes will report the last byte of thevalue, that is report the value modulo 256.  But not all.)
The typical use of substitute is to create informative labelsfor data sets and plots.The myplot example below shows a simple use of this facility.It uses the functions deparse and substituteto create labels for a plot which are character string versionsof the actual arguments to the function myplot.Substitution takes place by examining each component of the parse treeas follows: If it is not a bound symbol in env, it isunchanged.  If it is a promise object, i.e., a formal argument to afunction or explicitly created using delayedAssign(),the expression slot of the promise replaces the symbol.  If it is anordinary variable, its value is substituted, unless env is.GlobalEnv in which case the symbol is left unchanged.Both quote and substitute are ‘special’primitive functions which do not evaluate their arguments.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
The R home directory is the top-level directory of the Rinstallation being run.The R home directory is often referred to as R_HOME,and is the value of an environment variable of that name in an Rsession.It can be found outside an R session by R RHOME.
This gives details of the OS under which R was built, not the oneunder which it is currently running (for which seeSys.info).Note that OS names might not be what you expect: for example macOSMavericks 10.9.4 identifies itself as darwin13.3.0, Linuxusually as linux-gnu and Solaris 10 as solaris2.10.
This gives details of the OS under which R was built, not the oneunder which it is currently running (for which seeSys.info).Note that OS names might not be what you expect: for example macOSMavericks 10.9.4 identifies itself as darwin13.3.0, Linuxusually as linux-gnu and Solaris 10 as solaris2.10.
This gives details of the OS under which R was built, not the oneunder which it is currently running (for which seeSys.info).Note that OS names might not be what you expect: for example macOSMavericks 10.9.4 identifies itself as darwin13.3.0, Linuxusually as linux-gnu and Solaris 10 as solaris2.10.
range is a generic function: methods can be defined for itdirectly or via the Summary group generic.For this to work properly, the arguments ... should beunnamed, and dispatch is on the first argument.If na.rm is FALSE, NAand NaN values in any of the arguments will cause NA valuesto be returned, otherwise NA values are ignored.If finite is TRUE, the minimumand maximum of all finite values is computed, i.e.,finite = TRUE includes na.rm = TRUE.A special situation occurs when there is no (after omissionof NAs) nonempty argument left, see min.
range is a generic function: methods can be defined for itdirectly or via the Summary group generic.For this to work properly, the arguments ... should beunnamed, and dispatch is on the first argument.If na.rm is FALSE, NAand NaN values in any of the arguments will cause NA valuesto be returned, otherwise NA values are ignored.If finite is TRUE, the minimumand maximum of all finite values is computed, i.e.,finite = TRUE includes na.rm = TRUE.A special situation occurs when there is no (after omissionof NAs) nonempty argument left, see min.
If all components are different (and no NAs), the ranks arewell defined, with values in seq_along(x).  With some values equal(called ‘ties’), the argument ties.method determines theresult at the corresponding indices.  The "first" method resultsin a permutation with increasing values at each index set of ties, andanalogously "last" with decreasing values.  The"random" method puts these in random order whereas thedefault, "average", replaces them by their mean, and"max" and "min" replaces them by their maximum andminimum respectively, the latter being the typical sportsranking.NA values are never considered to be equal: for na.last =    TRUE and na.last = FALSE they are given distinct ranks inthe order in which they occur in x.NB: rank is not itself generic but xtfrmis, and rank(xtfrm(x), ....) will have the desired result ifthere is a xtfrm method.  Otherwise, rank will make useof ==, >, is.na and extraction methods forclassed objects, possibly rather slowly.
This function has two basic modes.  If how = "replace", eachelement of object which is not itself list-like and has a classincluded in classes is replaced by the result of applyingf to the element.Otherwise, with mode how = "list" or how = "unlist",conceptually objectis copied, all non-list elements which have a class included inclasses are replaced by the result of applying f to theelement and all others are replaced by deflt.  Finally, ifhow = "unlist", unlist(recursive = TRUE) is called onthe result.The semantics differ in detail from lapply: inparticular the arguments are evaluated before calling the C code.In R 3.5.x and earlier, object was required to be a list,which was not the case for its list-like components.
The raw type is intended to hold raw bytes.  It is possible to extractsubsequences of bytes, and to replace elements (but only by elementsof a raw vector).  The relational operators (see Comparison,using the numerical order of the byte representation) work, as do thelogical operators (see Logic) with a bitwise interpretation.A raw vector is printed with each byte separately represented as apair of hex digits.  If you want to see a character representation(with escape sequences for non-printing characters) userawToChar.Coercion to raw treats the input values as representing small(decimal) integers, so the input is first coerced to integer, and thenvalues which are outside the range [0 ... 255] or areNA are set to 0 (the nul byte).as.raw and is.raw are primitive functions.
An input raw connection is opened and the raw vector is copiedat the time the connection object is created, and closedestroys the copy.An output raw connection is opened and creates an R raw vectorinternally.  The raw vector can be retrieved viarawConnectionValue.If a connection is open for both input and output the initial rawvector supplied is copied when the connections is open
An input raw connection is opened and the raw vector is copiedat the time the connection object is created, and closedestroys the copy.An output raw connection is opened and creates an R raw vectorinternally.  The raw vector can be retrieved viarawConnectionValue.If a connection is open for both input and output the initial rawvector supplied is copied when the connections is open
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
packBits accepts raw, integer or logical inputs, the last twowithout any NAs.numToBits(.) and packBits(., type="double") areinverse functions of each other, see also the examples.Note that ‘bytes’ are not necessarily the same as characters,e.g. in UTF-8 locales.
The functions cbind and rbind are S3 generic, withmethods for data frames.  The data frame method will be used if atleast one argument is a data frame and the rest are vectors ormatrices.  There can be other methods; in particular, there is one fortime series objects.  See the section on ‘Dispatch’ for howthe method to be used is selected.  If some of the arguments are of anS4 class, i.e., isS4(.) is true, S4 methods are soughtalso, and the hidden cbind / rbind functionsfrom package methods maybe called, which in turn build oncbind2 or rbind2, respectively.  In thatcase, deparse.level is obeyed, similarly to the default method.In the default method, all the vectors/matrices must be atomic (seevector) or lists.  Expressions are not allowed.Language objects (such as formulae and calls) and pairlists will becoerced to lists: other objects (such as names and external pointers)will be included as elements in a list result.  Any classes the inputsmight have are discarded (in particular, factors are replaced by theirinternal codes).If there are several matrix arguments, they must all have the samenumber of columns (or rows) and this will be the number of columns (orrows) of the result.  If all the arguments are vectors, the number ofcolumns (rows) in the result is equal to the length of the longestvector.  Values in shorter arguments are recycled to achieve thislength (with a warning if they are recycled onlyfractionally).When the arguments consist of a mix of matrices and vectors the numberof columns (rows) of the result is determined by the number of columns(rows) of the matrix arguments.  Any vectors have their valuesrecycled or subsetted to achieve this length.For cbind (rbind), vectors of zero length (includingNULL) are ignored unless the result would have zero rows(columns), for S compatibility.(Zero-extent matrices do not occur in S3 and are not ignored in R.)Matrices are restricted to less than 2^31 rows andcolumns even on 64-bit systems.  So input vectors have the same lengthrestriction: as from R 3.2.0 input matrices with more elements (butmeeting the row and column restrictions) are allowed.
The functions cbind and rbind are S3 generic, withmethods for data frames.  The data frame method will be used if atleast one argument is a data frame and the rest are vectors ormatrices.  There can be other methods; in particular, there is one fortime series objects.  See the section on ‘Dispatch’ for howthe method to be used is selected.  If some of the arguments are of anS4 class, i.e., isS4(.) is true, S4 methods are soughtalso, and the hidden cbind / rbind functionsfrom package methods maybe called, which in turn build oncbind2 or rbind2, respectively.  In thatcase, deparse.level is obeyed, similarly to the default method.In the default method, all the vectors/matrices must be atomic (seevector) or lists.  Expressions are not allowed.Language objects (such as formulae and calls) and pairlists will becoerced to lists: other objects (such as names and external pointers)will be included as elements in a list result.  Any classes the inputsmight have are discarded (in particular, factors are replaced by theirinternal codes).If there are several matrix arguments, they must all have the samenumber of columns (or rows) and this will be the number of columns (orrows) of the result.  If all the arguments are vectors, the number ofcolumns (rows) in the result is equal to the length of the longestvector.  Values in shorter arguments are recycled to achieve thislength (with a warning if they are recycled onlyfractionally).When the arguments consist of a mix of matrices and vectors the numberof columns (rows) of the result is determined by the number of columns(rows) of the matrix arguments.  Any vectors have their valuesrecycled or subsetted to achieve this length.For cbind (rbind), vectors of zero length (includingNULL) are ignored unless the result would have zero rows(columns), for S compatibility.(Zero-extent matrices do not occur in S3 and are not ignored in R.)Matrices are restricted to less than 2^31 rows andcolumns even on 64-bit systems.  So input vectors have the same lengthrestriction: as from R 3.2.0 input matrices with more elements (butmeeting the row and column restrictions) are allowed.
For kappa(), if exact = FALSE (the default) the 2-normcondition number is estimated by a cheap approximation.  However, theexact calculation (via svd) is also likely to be quickenough.Note that the 1- and Inf-norm condition numbers are much faster tocalculate, and rcond() computes these reciprocalcondition numbers, also for complex matrices, using standard LAPACKroutines.kappa and rcond are different interfaces topartly identical functionality..kappa_tri is an internal function called by kappa.qr andkappa.default.Unsuccessful results from the underlying LAPACK code will result in anerror giving a positive error code: these can only be interpreted bydetailed study of the FORTRAN code.
Complex vectors can be created with complex.  The vector can bespecified either by giving its length, its real and imaginary parts, ormodulus and argument.  (Giving just the length generates a vector ofcomplex zeroes.)as.complex attempts to coerce its argument to be of complextype: like as.vector it strips attributes includingnames.  Up to R versions 3.2.x, all forms of NA and NaNwere coerced to a complex NA, i.e., the NA_complex_constant, for which both the real and imaginary parts are NA.Since R 3.3.0, typically only objects which are NA in partsare coerced to complex NA, but others with NaN parts,are not.  As a consequence, complex arithmetic where onlyNaN's (but no NA's) are involved typically willnot give complex NA but complex numbers with real orimaginary parts of NaN.Note that is.complex and is.numeric are never bothTRUE.The functions Re, Im, Mod, Arg andConj have their usual interpretation as returning the realpart, imaginary part, modulus, argument and complex conjugate forcomplex values.  The modulus and argument are also called the polarcoordinates.  If z = x + i y with real x and y, forr = Mod(z) = √(x^2 + y^2),and φ = Arg(z), x = r*cos(φ) andy = r*sin(φ).  They are allinternal generic primitive functions: methods can bedefined for themindividually or via the Complexgroup generic.In addition to the arithmetic operators (see Arithmetic)+, -, *, /, and ^, the elementarytrigonometric, logarithmic, exponential, square root and hyperbolicfunctions are implemented for complex values.Matrix multiplications (%*%, crossprod,tcrossprod) are also defined for complex matrices(matrix), and so are solve,eigen or svd.Internally, complex numbers are stored as a pair of doubleprecision numbers, either or both of which can be NaN(including NA, see NA_complex_ and above) orplus or minus infinity.
DCF is a simple format for storing databases in plain text files thatcan easily be directly read and written by humans.  DCF is used invarious places to store R system information, like descriptions andcontents of packages.The DCF rules as implemented in R are: A database consists of one or more records, each with one ormore named fields.  Not every record must contain each field.Fields may appear more than once in a record. Regular lines start with a non-whitespace character. Regular lines are of form tag:value, i.e., have a nametag and a value for the field, separated by : (only the first: counts).  The value can be empty (i.e., whitespace only). Lines starting with whitespace are continuation lines (to thepreceding field) if at least one character in the line isnon-whitespace.  Continuation lines where the only non-whitespacecharacter is a . are taken as blank lines (allowing formulti-paragraph field values). Records are separated by one or more empty (i.e., whitespaceonly) lines. Individual lines may not be arbitrarily long; prior to R 3.0.2 thelength limit was approximately 8191 bytes per line.Note that read.dcf(all = FALSE) reads the file byte-by-byte.This allows a ‘DESCRIPTION’ file to be read and only its ASCIIfields used, or its Encoding field used to re-encode theremaining fields.write.dcf does not write NA fields.
These functions can only be used with binary-mode connections.If con is a character string, the functions callfile to obtain a binary-mode file connection which isopened for the duration of the function call.If the connection is open it is read/written from its currentposition.  If it is not open, it is opened for the duration of thecall in an appropriate mode (binary read or write) and then closedagain.  An open connection must be in binary mode.If readBin is called with con a raw vector, the data inthe vector is used as input.  If writeBin is called withcon a raw vector, it is just an indication that a raw vectorshould be returned.If size is specified and not the natural size of the object,each element of the vector is coerced to an appropriate type beforebeing written or as it is read.  Possible sizes are 1, 2, 4 andpossibly 8 for integer or logical vectors, and 4, 8 and possibly 12/16for numeric vectors.  (Note that coercion occurs as signed typesexcept if signed = FALSE when reading integers of sizes 1 and 2.)Changing sizes is unlikely to preserve NAs, and the extendedprecision sizes are unlikely to be portable across platforms.readBin and writeBin read and write C-stylezero-terminated character strings.  Input strings are limited to 10000characters.  readChar and writeChar canbe used to read and write fixed-length strings.  No check is made thatthe string is valid in the current locale's encoding.Handling R's missing and special (Inf, -Inf andNaN) values is discussed in the ‘R Data Import/Export’ manual.Only 2^31 - 1 bytes can be written in a singlecall (and that is the maximum capacity of a raw vector on 32-bitplatforms).‘Endian-ness’ is relevant for size > 1, and shouldalways be set for portable code (the default is only appropriate whenwriting and then reading files on the same platform).
These functions complement readBin andwriteBin which read and write C-style zero-terminatedcharacter strings.  They are for strings of known length, andcan optionally write an end-of-string mark.  They are intended onlyfor character strings valid in the current locale.These functions are intended to be used with binary-mode connections.If con is a character string, the functions callfile to obtain a binary-mode file connection which isopened for the duration of the function call.If the connection is open it is read/written from its currentposition.  If it is not open, it is opened for the duration of thecall in an appropriate mode (binary read or write) and then closedagain.  An open connection must be in binary mode.If readChar is called with con a raw vector, the data inthe vector is used as input.  If writeChar is called withcon a raw vector, it is just an indication that a raw vectorshould be returned.Character strings containing ASCII nul(s) will be readcorrectly by readChar but truncated at the firstnul with a warning.If the character length requested for readChar is longer thanthe data available on the connection, what is available isreturned.  For writeChar if too many characters are requestedthe output is zero-padded, with a warning.Missing strings are written as NA.
The prompt string will be truncated to a maximum allowed length,normally 256 chars (but can be changed in the source code).This can only be used in an interactive session.
If the con is a character string, the function callsfile to obtain a file connection which is opened forthe duration of the function call.  This can be a compressed file.(tilde expansion of the file path is done by file.)If the connection is open it is read from its current position.  If itis not open, it is opened in "rt" mode for the duration ofthe call and then closed (but not destroyed; one must callclose to do that).If the final line is incomplete (no final EOL marker) the behaviourdepends on whether the connection is blocking or not.  For anon-blocking text-mode connection the incomplete line is pushed back,silently.  For all other connections the line will be accepted, with awarning.Whatever mode the connection is opened in, any of LF, CRLF or CR willbe accepted as the EOL marker for a line.Embedded nuls in the input stream will terminate the line currentlybeing read, with a warning (unless skipNul = TRUE or warn    = FALSE).If con is a not-already-open connection with a non-defaultencoding argument, the text is converted to UTF-8 and declaredas such (and the encoding argument to readLines is ignored).See the examples.
saveRDS and readRDS provide the means to save a single Robject to a connection (typically a file) and to restore the object, quitepossibly under a different name.  This differs from save andload, which save and restore one or more named objects intoan environment.  They are widely used by R itself, for example to storemetadata for a package and to store the help.searchdatabases: the ".rds" file extension is most often used.Functions serialize and unserializeprovide a slightly lower-level interface to serialization: objectsserialized to a connection by serialize can be read back byreadRDS and conversely.Function infoRDS retrieves meta-data about serialization producedby saveRDS or serialize. infoRDS cannot be used todetect whether a file is a serialization nor whether it is valid.All of these interfaces use the same serialization format, but savewrites a single line header (typically "RDXs\n") before theserialization of a single object (a pairlist of all the objects to besaved).If file is a file name, it is opened by gzfileexcept for save(compress = FALSE) which usesfile.  Only for the exception are marked encodings offile which cannot be translated to the native encoding handledon Windows.Compression is handled by the connection opened when file is afile name, so is only possible when file is a connection ifhandled by the connection.  So e.g. urlconnections will need to be wrapped in a call to gzcon.If a connection is supplied it will be opened (in binary mode) for theduration of the function if not already open: if it is already open itmust be in binary mode for saveRDS(ascii = FALSE) or to readnon-ASCII saves.
NA
NA
If init is given, Reduce logically adds it to the start(when proceeding left to right) or the end of x, respectively.If this possibly augmented vector v has n > 1 elements,Reduce successively applies f to the elements of vfrom left to right or right to left, respectively.  I.e., a leftreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,and returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce doesr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})and returns r_1 = f(v_1, r_2).  (E.g., if v is thesequence (2, 3, 4) and f is division, left and right reduce give(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)If v has only a single element, this is returned; if there areno elements, NULL is returned.  Thus, it is ensured thatf is always called with 2 arguments.The current implementation is non-recursive to ensure stability andscalability.Reduce is patterned after Common Lisp's reduce.  Areduce is also known as a fold (e.g., in Haskell) or an accumulate(e.g., in the C++ Standard Template Library).  The accumulativeversion corresponds to Haskell's scan functions.Filter applies the unary predicate function f to eachelement of x, coercing to logical if necessary, and returns thesubset of x for which this gives true.  Note that possibleNA values are currently always taken as false; control overNA handling may be added in the future.  Filtercorresponds to filter in Haskell or remove-if-not inCommon Lisp.Find and Position are patterned after Common Lisp'sfind-if and position-if, respectively.  If there is anelement for which the predicate function gives true, then the first orlast such element or its position is returned depending on whetherright is false (default) or true, respectively.  If there is nosuch element, the value specified by nomatch is returned.  Thecurrent implementation is not optimized for performance.Map is a simple wrapper to mapply which does notattempt to simplify the result, similar to Common Lisp's mapcar(with arguments being recycled, however).  Future versions may allowsome control of the result type.Negate corresponds to Common Lisp's complement.  Given a(predicate) function f, it creates a function which returns thelogical negation of what f returns.
The main purpose of this function is to allow objects that refer toexternal items (a temporary file, say) to perform cleanup actions whenthey are no longer referenced from within R.  This only makes sensefor objects that are never copied on assignment, hence the restrictionto environments and external pointers.Inter alia, it provides a way to program code to be run atthe end of an R session without manipulating .Last.For use in a package, it is often a good idea to set a finalizer on anobject in the namespace: then it will be called at the end of thesession, or soon after the namespace is unloaded if that is doneduring the session.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
Arguments which should be character strings or character vectors arecoerced to character if possible.Each of these functions operates in one of three modes:fixed = TRUE: use exact matching.perl = TRUE: use Perl-style regular expressions.fixed = FALSE, perl = FALSE: use POSIX 1003.2extended regular expressions (the default).See the help pages on regular expression for details of thedifferent types of regular expressions.The two *sub functions differ only in that sub replacesonly the first occurrence of a pattern whereas gsubreplaces all occurrences.  If replacement containsbackreferences which are not defined in pattern the result isundefined (but most often the backreference is taken to be "").For regexpr, gregexpr, regexec and gregexecit is an error for pattern to be NA, otherwise NAis permitted and gives an NA match.Both grep and grepl take missing values in x asnot matching a non-missing pattern.The main effect of useBytes = TRUE is to avoid errors/warningsabout invalid inputs and spurious matches in multibyte locales, butfor regexpr it changes the interpretation of the output.  Itinhibits the conversion of inputs with marked encodings, and is forcedif any input is found which is marked as "bytes" (seeEncoding).Caseless matching does not make much sense for bytes in a multibytelocale, and you should expect it only to work for ASCII characters ifuseBytes = TRUE.regexpr and gregexpr with perl = TRUE allowPython-style named captures, but not for long vector inputs.Invalid inputs in the current locale are warned about up to 5 times.Caseless matching with perl = TRUE for non-ASCII charactersdepends on the PCRE library being compiled with ‘Unicodeproperty support’, which PCRE2 is by default.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
If invert is FALSE (default), regmatches extractsthe matched substrings as specified by the match data.  For vectormatch data (as obtained from regexpr), empty matches aredropped; for list match data, empty matches give empty components(zero-length character vectors).If invert is TRUE, regmatches extracts thenon-matched substrings, i.e., the strings are split according to thematches similar to strsplit (for vector match data, atmost a single split is performed).If invert is NA, regmatches extracts bothnon-matched and matched substrings, always starting and ending with anon-match (empty if the match occurred at the beginning or the end,respectively).Note that the match data can be obtained from regular expressionmatching on a modified version of x with the same numbers ofcharacters.The replacement function can be used for replacing the matched ornon-matched substrings.  For vector match data, if invert isFALSE, value should be a character vector with length thenumber of matched elements in m.  Otherwise, it should be alist of character vectors with the same length as m, each aslong as the number of replacements needed.  Replacement coerces valuesto character or list and generously recycles values as needed.Missing replacement values are not allowed.
If invert is FALSE (default), regmatches extractsthe matched substrings as specified by the match data.  For vectormatch data (as obtained from regexpr), empty matches aredropped; for list match data, empty matches give empty components(zero-length character vectors).If invert is TRUE, regmatches extracts thenon-matched substrings, i.e., the strings are split according to thematches similar to strsplit (for vector match data, atmost a single split is performed).If invert is NA, regmatches extracts bothnon-matched and matched substrings, always starting and ending with anon-match (empty if the match occurred at the beginning or the end,respectively).Note that the match data can be obtained from regular expressionmatching on a modified version of x with the same numbers ofcharacters.The replacement function can be used for replacing the matched ornon-matched substrings.  For vector match data, if invert isFALSE, value should be a character vector with length thenumber of matched elements in m.  Otherwise, it should be alist of character vectors with the same length as m, each aslong as the number of replacements needed.  Replacement coerces valuesto character or list and generously recycles values as needed.Missing replacement values are not allowed.
The pos argument can specify the  environment from which to removethe objects in any of several ways:as an integer (the position in the search list); asthe character string name of an element in the search list; or as anenvironment (including using sys.frame toaccess the currently active function calls).The envir argument is an alternative way to specify anenvironment, but is primarily there for back compatibility.It is not allowed to remove variables from the base environment andbase namespace, nor from any environment which is locked (seelockEnvironment).Earlier versions of R incorrectly claimed that supplying a charactervector in ... removed the objects named in the charactervector, but it removed the character vector.  Use the listargument to specify objects via a character vector.
Top-level tasks are individual expressionsrather than entire lines of input.  Thus an inputline of the form expression1 ; expression2will give rise to 2 top-level tasks.A top-level task callback is called with the expression for thetop-level task, the result of the top-level task, a logical valueindicating whether it was successfully completed or not (always TRUEat present), and a logical value indicating whether the result wasprinted or not.  If the data argument was specified in the callto addTaskCallback, that value is given as the fifth argument.The callback function should return a logical value.If the value is FALSE, the callback is removed from the tasklist and will not be called again by this mechanism.If the function returns TRUE, it is kept in the list andwill be called on the completion of the next top-level task.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
Function difftime calculates a difference of two date/timeobjects and returns an object of class "difftime" with anattribute indicating the units.  TheMath group method providesround, signif, floor,ceiling, trunc, abs, andsign methods for objects of this class, and there aremethods for the group-generic (seeOps) logical and arithmeticoperations.If units = "auto", a suitable set of units is chosen, the largestpossible (excluding "weeks") in which all the absolutedifferences are greater than one.Subtraction of date-time objects gives an object of this class,by calling difftime with units = "auto".  Alternatively,as.difftime() works on character-coded or numeric timeintervals; in the latter case, units must be specified, andformat has no effect.Limited arithmetic is available on "difftime" objects: they canbe added or subtracted, and multiplied or divided by a numeric vector.In addition, adding or subtracting a numeric vector by a"difftime" object implicitly converts the numeric vector to a"difftime" object with the same units as the "difftime"object.  There are methods for mean andsum (via the Summarygroup generic), and diff via diff.defaultbuilding on the "difftime" method for arithmetic, notably-.The units of a "difftime" object can be extracted by theunits function, which also has a replacement form.  If theunits are changed, the numerical value is scaled accordingly.  Thereplacement version keeps attributes such as names and dimensions.Note that units = "days" means a period of 24 hours, hencetakes no account of Daylight Savings Time.  Differences in objectsof class "Date" are computed as if in the UTC time zone.The as.double method returns the numeric value expressed inthe specified units.  Using  units = "auto" means the units of theobject.The format method simply formats the numeric value and appendsthe units as a text string.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
Numeric versions are sequences of one or more non-negative integers,usually (e.g., in package ‘DESCRIPTION’ files) represented ascharacter strings with the elements of the sequence concatenated andseparated by single . or - characters.  R packageversions consist of at least two such integers, an R system versionof exactly three (major, minor and patchlevel).Functions numeric_version, package_version andR_system_version create a representation from such strings (ifsuitable) which allows for coercion and testing, combination,comparison, summaries (min/max), inclusion in data frames,subscripting, and printing.  The classes can hold a vector of suchrepresentations.getRversion returns the version of the running R as an Rsystem version object.The [[ operator extracts or replaces a single version.  Toaccess the integers of a version use two indices: see the examples.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
The default behaviour is as if the call was.  Normally just one of the additionalarguments is specified, but if each is specified with eitherof the other two, its replication is performed first, and then thatimplied by times or length.out.If times consists of a single integer, the result consists ofthe whole input repeated this many times.  If times is avector of the same length as x (after replication byeach), the result consists of x[1] repeatedtimes[1] times, x[2] repeated times[2] times andso on.length.out may be given in place of times,in which case x is repeated as many times as isnecessary to create a vector of this length.  If both are given,length.out takes priority and times is ignored.Non-integer values of times will be truncated towards zero.If times is a computed quantity it is prudent to add a smallfuzz or use round.  And analogously for each.If x has length zero and length.out is supplied and ispositive, the values are filled in using the extraction rules, that isby an NA of the appropriate class for an atomic vector(0 for raw vectors) and NULL for a list.
break breaks out of a for, while or repeatloop; control is transferred to the first statement outside theinner-most loop. next halts the processing of the currentiteration and advances the looping index.  Both break andnext apply only to the innermost of nested loops.Note that it is a common mistake to forget to put braces ({ .. })around your statements, e.g., after if(..) or for(....).In particular, you should not have a newline between } andelse to avoid a syntax error in entering a if ... elseconstruct at the keyboard or via source.For that reason, one (somewhat extreme) attitude of defensive programmingis to always use braces, e.g., for if clauses.The seq in a for loop is evaluated at the start ofthe loop; changing it subsequently does not affect the loop.  Ifseq has length zero the body of the loop is skipped. Otherwise thevariable var is assigned in turn the value of each element ofseq. You can assign to var within the body of the loop,but this will not affect the next iteration.  When the loop terminates,var remains as a variable containing its latest value.
NA
FUN is found by a call to match.fun and typicallyis specified as a function or a symbol (e.g., a backquoted name) or acharacter string specifying a function to be searched for from theenvironment of the call to lapply.Function FUN must be able to accept as input any of theelements of X.  If the latter is an atomic vector, FUNwill always be passed a length-one vector of the same type as X.Arguments in ... cannot have the same name as any of theother arguments, and care may be needed to avoid partial matching toFUN.  In general-purpose code it is good practice to name thefirst two arguments X and FUN if ... is passedthrough: this both avoids partial matching to FUN and ensuresthat a sensible error message is given if arguments named X orFUN are passed through ....Simplification in sapply is only attempted if X haslength greater than zero and if the return values from all elementsof X are all of the same (positive) length.  If the commonlength is one the result is a vector, and if greater than one is amatrix with a column corresponding to each element of X.Simplification is always done in vapply.  This functionchecks that all values of FUN are compatible with theFUN.VALUE, in that they must have the same length and type.(Types may be promoted to a higher type within the ordering logical< integer < double < complex, but not demoted.)Users of S4 classes should pass a list to lapply andvapply: the internal coercion is done by the as.list inthe base namespace and not one defined by a user (e.g., by setting S4methods on the base function).
library(package) and require(package) both load thenamespace of the package with name package and attach it on thesearch list.  require is designed for use inside otherfunctions; it returns FALSE and gives a warning (rather than anerror as library() does by default) if the package does notexist.  Both functions check and update the list of currently attachedpackages and do not reload a namespace which is already loaded.  (Ifyou want to reload such a package, call detach(unload =  TRUE) or unloadNamespace first.)  If you want to load apackage without attaching it on the search list, seerequireNamespace.To suppress messages during the loading of packages usesuppressPackageStartupMessages: this will suppress allmessages from R itself but not necessarily all those from packageauthors.If library is called with no package or helpargument, it lists all available packages in the libraries specifiedby lib.loc, and returns the corresponding information in anobject of class "libraryIQR".  (The structure of this class maychange in future versions.)  Use .packages(all = TRUE) toobtain just the names of all available packages, andinstalled.packages() for even more information.library(help = somename) computes basic information about thepackage somename, and returns this in an object of class"packageInfo".  (The structure of this class may change infuture versions.)  When used with the default value (NULL) forlib.loc, the attached packages are searched before the libraries.
The functions loadNamespace and attachNamespace areusually called implicitly when library is used to load a namespace and any imports needed.  However it may be useful at times tocall these functions directly.loadNamespace loads the specified name space and registers it inan internal data base.  A request to load a name space when one of thatname is already loaded has no effect.  The arguments have the samemeaning as the corresponding arguments to library, whosehelp page explains the details of how a particular installed packagecomes to be chosen.  After loading, loadNamespace looks for ahook function named .onLoad as an internal variable inthe name space (it should not be exported).  Partial loading is usedto support installation with lazy-loading.Optionally the package licence is checked during loading: see section‘Licenses’ in the help for library.loadNamespace does not attach the name space it loads to thesearch path.  attachNamespace can be used to attach a framecontaining the exported values of a name space to the search path (butthis is almost always done via library).  Thehook function .onAttach is run after the name spaceexports are attached.requireNamespace is a wrapper for loadNamespaceanalogous to require that returns a logical value.loadedNamespaces returns a character vector of the names ofthe loaded name spaces.isNamespaceLoaded(pkg) is equivalent to but more efficient thanpkg %in% loadedNamespaces().unloadNamespace can be used to attempt to force a name space tobe unloaded.  If the name space is attached, it is firstdetached, thereby running a .onDetach or.Last.lib function in the name space if one is exported.  Anerror is signaled and the name space is not unloaded if the name spaceis imported by other loaded name spaces.  If defined, a hook function.onUnload is run before removing the name space from theinternal registry.See the comments in the help for detach about someissues with unloading and reloading name spaces.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
The condition system provides a mechanism for signaling andhandling unusual conditions, including errors and warnings.Conditions are represented as objects that contain informationabout the condition that occurred, such as a message and the call inwhich the condition occurred.  Currently conditions are S3-styleobjects, though this may eventually change.Conditions are objects inheriting from the abstract classcondition.  Errors and warnings are objects inheritingfrom the abstract subclasses error and warning.The class simpleError is the class used by stopand all internal error signals.  Similarly, simpleWarningis used by warning, and simpleMessage is used bymessage.  The constructors by the same names take a stringdescribing the condition as argument and an optional call.  Thefunctions conditionMessage and conditionCall aregeneric functions that return the message and call of a condition.The function errorCondition can beused to construct error conditions of a particular class withadditional fields specified as the ... argument.warningCondition is analogous for warnings.Conditions are signaled by signalCondition.  In addition,the stop and warning functions have been modified toalso accept condition arguments.The function tryCatch evaluates its expression argumentin a context where the handlers provided in the ...argument are available.  The finally expression is thenevaluated in the context in which tryCatch was called; thatis, the handlers supplied to the current tryCatch call arenot active when the finally expression is evaluated.Handlers provided in the ... argument to tryCatchare established for the duration of the evaluation of expr.If no condition is signaled when evaluating expr thentryCatch returns the value of the expression.If a condition is signaled while evaluating expr thenestablished handlers are checked, starting with the most recentlyestablished ones, for one matching the class of the condition.When several handlers are supplied in a single tryCatch thenthe first one is considered more recent than the second.  If ahandler is found then control is transferred to thetryCatch call that established the handler, the handlerfound and all more recent handlers are disestablished, the handleris called with the condition as its argument, and the resultreturned by the handler is returned as the value of thetryCatch call.Calling handlers are established by withCallingHandlers.  Ifa condition is signaled and the applicable handler is a callinghandler, then the handler is called by signalCondition inthe context where the condition was signaled but with the availablehandlers restricted to those below the handler called in thehandler stack.  If the handler returns, then the next handler istried; once the last handler has been tried, signalConditionreturns NULL.globalCallingHandlers establishes calling handlers globally.These handlers are only called as a last resort, after the otherhandlers dynamically registered with withCallingHandlers havebeen invoked. They are called before the error global option(which is the legacy interface for global handling of errors).Registering the same handler multiple times moves that handler ontop of the stack, which ensures that it is called first. Globalhandlers are a good place to define a general purpose logger (forinstance saving the last error object in the global workspace) or ageneral recovery strategy (e.g. installing missing packages via theretry_loadNamespace restart).Like withCallingHandlers and tryCatch,globalCallingHandlers takes named handlers. Unlike thesefunctions, it also has an options-like interface: youcan establish handlers by passing a single list of named handlers.To unregister all global handlers, supply a single 'NULL'. The listof deleted handlers is returned invisibly. Finally, callingglobalCallingHandlers without arguments returns the list ofcurrently established handlers, visibly.User interrupts signal a condition of class interrupt thatinherits directly from class condition before executing thedefault interrupt action.Restarts are used for establishing recovery protocols.  They can beestablished using withRestarts.  One pre-established restart isan abort restart that represents a jump to top level.findRestart and computeRestarts find the availablerestarts.  findRestart returns the most recently establishedrestart of the specified name.  computeRestarts returns alist of all restarts.  Both can be given a condition argument andwill then ignore restarts that do not apply to the condition.invokeRestart transfers control to the point where thespecified restart was established and calls the restart's handler with thearguments, if any, given as additional arguments toinvokeRestart.  The restart argument to invokeRestartcan be a character string, in which case findRestart is usedto find the restart. If no restart is found, an error is thrown.tryInvokeRestart is a variant of invokeRestart thatreturns silently when the restart cannot be found withfindRestart. Because a condition of a given class might besignalled with arbitrary protocols (error, warning, etc), it isrecommended to use this permissive variant whenever you are handlingconditions signalled from a foreign context. For instance, invocationof a "muffleWarning" restart should be optional because thewarning might have been signalled by the user or from a differentpackage with the stop or message protocols. Only useinvokeRestart when you have control of the signalling context,or when it is a logical error if the restart is not available.New restarts for withRestarts can be specified in several ways.The simplest is in name = function form where the function isthe handler to call when the restart is invoked.  Another simplevariant is as name = string where the string is stored in thedescription field of the restart object returned byfindRestart; in this case the handler ignores its argumentsand returns NULL.  The most flexible form of a restartspecification is as a list that can include several fields, includinghandler, description, and test.  Thetest field should contain a function of one argument, acondition, that returns TRUE if the restart applies to thecondition and FALSE if it does not; the default functionreturns TRUE for all conditions.One additional field that can be specified for a restart isinteractive.  This should be a function of no arguments thatreturns a list of arguments to pass to the restart handler.  The listcould be obtained by interacting with the user if necessary.  Thefunction invokeRestartInteractively calls this function toobtain the arguments to use when invoking the restart.  The defaultinteractive method queries the user for values for theformal arguments of the handler function.Interrupts can be suspended while evaluating an expression usingsuspendInterrupts.  Subexpression can be evaluated withinterrupts enabled using allowInterrupts.  These functionscan be used to make sure cleanup handlers cannot be interrupted..signalSimpleWarning, .handleSimpleError, and.tryResumeInterrupt are used internally and should not becalled directly.
This functionality is optional, determined at compilation, because itmakes R run a little more slowly even when no objects are beingtraced.  tracemem and untracemem give errors when R is notcompiled with memory profiling; retracemem does not (so it can beleft in code during development).It is enabled in the CRAN macOS and Windows builds of R.When an object is traced any copying of the object by the C functionduplicate produces a message to standard output, as does typecoercion and copying when passing arguments to .C or.Fortran.The message consists of the string tracemem, the identifyingstrings for the object being copied and the new object being created,and a stack trace showing where the duplication occurred.retracemem() is used to indicate that a variable should beconsidered a copy of a previous variable (e.g., after subscripting).The messages can be turned off with tracingState.It is not possible to trace functions, as this would conflict withtrace and it is not useful to trace NULL,environments, promises, weak references, or external pointer objects, asthese are not duplicated.These functions are primitive.
The names in an argument list can be back-quoted non-standard names(see ‘backquote’).If value is missing, NULL is returned.  If it is asingle expression, the value of the evaluated expression is returned.(The expression is evaluated as soon as return is called, inthe evaluation frame of the function and before anyon.exit expression is evaluated.)If the end of a function is reached without calling return, thevalue of the last evaluated expression is returned.The shorthand form \(x) x + 1 is parsed as function(x) x    + 1. It may be helpful in making code containing simple functionexpressions more readable.
The trace function operates by constructing a revised versionof the function (or of the method, if signature is supplied),and assigning the new object back where the original was found.If only the what argument is given, a line of trace printing isproduced for each call to the function (back compatible with theearlier version of trace).The object constructed by trace is from a class that extends"function" and which contains the original, untraced version.A call to untrace re-assigns this version.If the argument tracer or exit is the name of afunction, the tracing expression will be a call to that function, withno arguments.  This is the easiest and most common case, with thefunctions browser and recover thelikeliest candidates; the former browses in the frame of the functionbeing traced, and the latter allows browsing in any of the currentlyactive calls. The arguments tracer and exit are evaluated tosee whether they are functions, but only their names are used in thetracing expressions.  The lookup is done again when the traced functionexecutes, so it may not be tracer or exit that will be calledwhile tracing.The tracer or exit argument can also be an unevaluatedexpression (such as returned by a call to quote orsubstitute).  This expression itself is inserted in thetraced function, so it will typically involve arguments or localobjects in the traced function.  An expression of this form is usefulif you only want to interact when certain conditions apply (and inthis case you probably want to supply print = FALSE in the callto trace also).When the at argument is supplied, it can be a vector ofintegers referring to the substeps of the body of the function (thisonly works if the body of the function is enclosed in { ...}).  Inthis case tracer is not called on entry, but insteadjust before evaluating each of the steps listed in at.  (Hint:you don't want to try to count the steps in the printed version of afunction; instead, look at as.list(body(f)) to get the numbersassociated with the steps in function f.)The at argument can also be a list of integer vectors.  Inthis case, each vector refers to a step nested within another step ofthe function.  For example, at = list(c(3,4))will call the tracer just before the fourth step of the third stepof the function.  See the example below.Using setBreakpoint (from package utils) may be analternative, calling trace(...., at, ...).The exit argument is called during on.exitprocessing.  In an on.exit expression, the experimental returnValue()function may be called to obtain the value about to be returned bythe function. Calling this function in other circumstances will giveundefined results.An intrinsic limitation in the exit argument is that it won'twork if the function itself uses on.exit with add=  FALSE (the default), since the existing calls will override the onesupplied by trace.Tracing does not nest.  Any call to trace replaces previouslytraced versions of that function or method (except for editedversions as discussed below), and untrace alwaysrestores an untraced version.  (Allowing nested tracing has too manypotentials for confusion and for accidentally leaving traced versionsbehind.)When the edit argument is used repeatedly with no call tountrace on the same function or method in between, thepreviously edited version is retained.  If you want to throw awayall the previous tracing and then edit, call untrace before the nextcall to trace.  Editing may be combined with automatictracing; just supply the other arguments such as tracer, andthe edit argument as well.  The edit = TRUE argumentuses the default editor (see edit).Tracing primitive functions (builtins and specials) from the basepackage works, but only by a special mechanism and not veryinformatively.  Tracing a primitive causes the primitive to bereplaced by a function with argument ... (only).  You can get a bitof information out, but not much.  A warning message is issued whentrace is used on a primitive.The practice of saving the traced version of the function back wherethe function came from means that tracing carries over from onesession to another, if the traced function is saved in thesession image.  (In the next session, untrace will remove thetracing.)  On the other hand, functions that were in a package, not inthe global environment, are not saved in the image, so tracing expireswith the session for such functions.Tracing an S4 method is basically just like tracing a function, with theexception that the traced version is stored by a call tosetMethod rather than by direct assignment, and so isthe untraced version after a call to untrace.The version of trace described here is largely compatible withthe version in S-Plus, although the two work by entirely differentmechanisms.  The S-Plus trace uses the session frame, with theresult that tracing never carries over from one session to another (Rdoes not have a session frame).  Another relevant distinction hasnothing directly to do with trace:  The browser in S-Plusallows changes to be made to the frame being browsed, and the changeswill persist after exiting the browser.  The R browser allows changes,but they disappear when the browser exits.  This may be relevant inthat the S-Plus version allows you to experiment with code changesinteractively, but the R version does not.  (A future revision mayinclude a ‘destructive’ browser for R.)
NA
NA
‘vector’ is used in the sense of is.vector.Missing values are regarded as unequal to the previous value, even ifthat is also missing.inverse.rle() is the inverse function of rle(),reconstructing x from the runs.
The pos argument can specify the  environment from which to removethe objects in any of several ways:as an integer (the position in the search list); asthe character string name of an element in the search list; or as anenvironment (including using sys.frame toaccess the currently active function calls).The envir argument is an alternative way to specify anenvironment, but is primarily there for back compatibility.It is not allowed to remove variables from the base environment andbase namespace, nor from any environment which is locked (seelockEnvironment).Earlier versions of R incorrectly claimed that supplying a charactervector in ... removed the objects named in the charactervector, but it removed the character vector.  Use the listargument to specify objects via a character vector.
The currently available RNG kinds are given below.  kind ispartially matched to this list.  The default is"Mersenne-Twister".The seed, .Random.seed[-1] == r[1:3] is an integer vector oflength 3, where each r[i] is in 1:(p[i] - 1), wherep is the length 3 vector of primes, p = (30269, 30307,      30323).The Wichmann–Hill generator has a cycle length of6.9536e12 (=prod(p-1)/4, see Applied Statistics (1984)33, 123 which corrects the original article).It exhibits 12 clear failures in the TestU01 Crush suite and 22in the BigCrush suite (L'Ecuyer, 2007).A multiply-with-carry RNG is used, as recommended by GeorgeMarsaglia in his post to the mailing list ‘sci.stat.math’.It has a period of more than 2^60.It exhibits 40 clear failures in L'Ecuyer's TestU01 Crush suite.Combined with Ahrens-Dieter or Kinderman-Ramage it exhibitsdeviations from normality even for univariate distributiongeneration.  See PR#18168 for a discussion.The seed is two integers (all values allowed).Marsaglia's famous Super-Duper from the 70's.  This is the originalversion which does not pass the MTUPLE test of the Diehardbattery.  It has a period of about      4.6*10^18 for most initial seeds.  The seed is two integers (allvalues allowed for the first seed: the second must be odd).We use the implementation by Reeds et al (1982–84).The two seeds are the Tausworthe and congruence long integers,respectively.  A one-to-one mapping to S's .Random.seed[1:12]is possible but we will not publish one, not least as this generatoris not exactly the same as that in recent versions of S-PLUS.It exhibits 25 clear failures in the TestU01 Crush suite (L'Ecuyer, 2007).From Matsumoto and Nishimura (1998); code updated in 2002.A twisted GFSR with period2^19937 - 1 and equidistribution in 623consecutive dimensions (over the whole period).  The ‘seed’ is a624-dimensional set of 32-bit integers plus a current position inthat set.R uses its own initialization method due to B. D. Ripley and isnot affected by the initialization issue in the 1998 code ofMatsumoto and Nishimura addressed in a 2002 update.It exhibits 2 clear failures in each of the TestU01 Crush and theBigCrush suite (L'Ecuyer, 2007).A 32-bit integer GFSR using lagged Fibonacci sequences withsubtraction.  That is, the recurrence used isX[j] = (X[j-100] - X[j-37]) mod 2^30and the ‘seed’ is the set of the 100 last numbers (actuallyrecorded as 101 numbers, the last being a cyclic shift of thebuffer).  The period is around 2^129.An earlier version from Knuth (1997).The 2002 version was not backwards compatible with the earlierversion: the initialization of the GFSR from the seed was altered.R did not allow you to choose consecutive seeds, the reported‘weakness’, and already scrambled the seeds. Otherwise,the algorithm is identical to Knuth-TAOCP-2002, with the samelagged Fibonacci recurrence formula.Initialization of this generator is done in interpreted R codeand so takes a short but noticeable time.It exhibits 3 clear failure in the TestU01 Crush suite and4 clear failures in the BigCrush suite(L'Ecuyer, 2007).A ‘combined multiple-recursive generator’ from L'Ecuyer(1999), each element of which is a feedback multiplicativegenerator with three integer elements: thus the seed is a (signed)integer vector of length 6. The period is around2^191.The 6 elements of the seed are internally regarded as 32-bitunsigned integers.  Neither the first three nor the last threeshould be all zero, and they are limited to less than4294967087 and 4294944443 respectively.This is not particularly interesting of itself, but provides thebasis for the multiple streams used in package parallel.It exhibits 6 clear failures in each of the TestU01 Crush and theBigCrush suite (L'Ecuyer, 2007).Use a user-supplied generator.  See Random.user fordetails.normal.kind can be "Kinderman-Ramage","Buggy Kinderman-Ramage" (not for set.seed),"Ahrens-Dieter", "Box-Muller", "Inversion" (thedefault), or "user-supplied".  (For inversion, see thereference in qnorm.)  The Kinderman-Ramage generatorused in versions prior to 1.7.0 (now called "Buggy") had severalapproximation errors and should only be used for reproduction of oldresults.  The "Box-Muller" generator is stateful as pairs ofnormals are generated and returned sequentially.  The state is resetwhenever it is selected (even if it is the current normal generator)and when kind is changed.sample.kind can be "Rounding" or "Rejection",or partial matches to these.  The former was the default in versionsprior to 3.6.0:  it made sample noticeably non-uniformon large populations, and should only be used for reproduction of oldresults.  See PR#17494 for a discussion. set.seed uses a single integer argument to set as many seedsas are required.  It is intended as a simple way to get quite differentseeds by specifying small integer arguments, and also as a way to getvalid seed sets for the more complicated methods (especially"Mersenne-Twister" and "Knuth-TAOCP").  There is noguarantee that different values of seed will seed the RNGdifferently, although any exceptions would be extremely rare.  Ifcalled with seed = NULL it re-initializes (see ‘Note’)as if no seed had yet been set.The use of kind = NULL, normal.kind = NULL or sample.kind = NULL inRNGkind or set.seed selects the currently-usedgenerator (including that used in the previous session if theworkspace has been restored): if no generator has been used it selects"default".
The currently available RNG kinds are given below.  kind ispartially matched to this list.  The default is"Mersenne-Twister".The seed, .Random.seed[-1] == r[1:3] is an integer vector oflength 3, where each r[i] is in 1:(p[i] - 1), wherep is the length 3 vector of primes, p = (30269, 30307,      30323).The Wichmann–Hill generator has a cycle length of6.9536e12 (=prod(p-1)/4, see Applied Statistics (1984)33, 123 which corrects the original article).It exhibits 12 clear failures in the TestU01 Crush suite and 22in the BigCrush suite (L'Ecuyer, 2007).A multiply-with-carry RNG is used, as recommended by GeorgeMarsaglia in his post to the mailing list ‘sci.stat.math’.It has a period of more than 2^60.It exhibits 40 clear failures in L'Ecuyer's TestU01 Crush suite.Combined with Ahrens-Dieter or Kinderman-Ramage it exhibitsdeviations from normality even for univariate distributiongeneration.  See PR#18168 for a discussion.The seed is two integers (all values allowed).Marsaglia's famous Super-Duper from the 70's.  This is the originalversion which does not pass the MTUPLE test of the Diehardbattery.  It has a period of about      4.6*10^18 for most initial seeds.  The seed is two integers (allvalues allowed for the first seed: the second must be odd).We use the implementation by Reeds et al (1982–84).The two seeds are the Tausworthe and congruence long integers,respectively.  A one-to-one mapping to S's .Random.seed[1:12]is possible but we will not publish one, not least as this generatoris not exactly the same as that in recent versions of S-PLUS.It exhibits 25 clear failures in the TestU01 Crush suite (L'Ecuyer, 2007).From Matsumoto and Nishimura (1998); code updated in 2002.A twisted GFSR with period2^19937 - 1 and equidistribution in 623consecutive dimensions (over the whole period).  The ‘seed’ is a624-dimensional set of 32-bit integers plus a current position inthat set.R uses its own initialization method due to B. D. Ripley and isnot affected by the initialization issue in the 1998 code ofMatsumoto and Nishimura addressed in a 2002 update.It exhibits 2 clear failures in each of the TestU01 Crush and theBigCrush suite (L'Ecuyer, 2007).A 32-bit integer GFSR using lagged Fibonacci sequences withsubtraction.  That is, the recurrence used isX[j] = (X[j-100] - X[j-37]) mod 2^30and the ‘seed’ is the set of the 100 last numbers (actuallyrecorded as 101 numbers, the last being a cyclic shift of thebuffer).  The period is around 2^129.An earlier version from Knuth (1997).The 2002 version was not backwards compatible with the earlierversion: the initialization of the GFSR from the seed was altered.R did not allow you to choose consecutive seeds, the reported‘weakness’, and already scrambled the seeds. Otherwise,the algorithm is identical to Knuth-TAOCP-2002, with the samelagged Fibonacci recurrence formula.Initialization of this generator is done in interpreted R codeand so takes a short but noticeable time.It exhibits 3 clear failure in the TestU01 Crush suite and4 clear failures in the BigCrush suite(L'Ecuyer, 2007).A ‘combined multiple-recursive generator’ from L'Ecuyer(1999), each element of which is a feedback multiplicativegenerator with three integer elements: thus the seed is a (signed)integer vector of length 6. The period is around2^191.The 6 elements of the seed are internally regarded as 32-bitunsigned integers.  Neither the first three nor the last threeshould be all zero, and they are limited to less than4294967087 and 4294944443 respectively.This is not particularly interesting of itself, but provides thebasis for the multiple streams used in package parallel.It exhibits 6 clear failures in each of the TestU01 Crush and theBigCrush suite (L'Ecuyer, 2007).Use a user-supplied generator.  See Random.user fordetails.normal.kind can be "Kinderman-Ramage","Buggy Kinderman-Ramage" (not for set.seed),"Ahrens-Dieter", "Box-Muller", "Inversion" (thedefault), or "user-supplied".  (For inversion, see thereference in qnorm.)  The Kinderman-Ramage generatorused in versions prior to 1.7.0 (now called "Buggy") had severalapproximation errors and should only be used for reproduction of oldresults.  The "Box-Muller" generator is stateful as pairs ofnormals are generated and returned sequentially.  The state is resetwhenever it is selected (even if it is the current normal generator)and when kind is changed.sample.kind can be "Rounding" or "Rejection",or partial matches to these.  The former was the default in versionsprior to 3.6.0:  it made sample noticeably non-uniformon large populations, and should only be used for reproduction of oldresults.  See PR#17494 for a discussion. set.seed uses a single integer argument to set as many seedsas are required.  It is intended as a simple way to get quite differentseeds by specifying small integer arguments, and also as a way to getvalid seed sets for the more complicated methods (especially"Mersenne-Twister" and "Knuth-TAOCP").  There is noguarantee that different values of seed will seed the RNGdifferently, although any exceptions would be extremely rare.  Ifcalled with seed = NULL it re-initializes (see ‘Note’)as if no seed had yet been set.The use of kind = NULL, normal.kind = NULL or sample.kind = NULL inRNGkind or set.seed selects the currently-usedgenerator (including that used in the previous session if theworkspace has been restored): if no generator has been used it selects"default".
These are generic functions: methods can be defined for themindividually or via the Math groupgeneric.Note that for rounding off a 5, the IEC 60559 standard (see also‘IEEE 754’) is expected to be used, ‘go to the even digit’.Therefore round(0.5) is 0 and round(-1.5) is-2.  However, this is dependent on OS services and onrepresentation error (since e.g. 0.15 is not representedexactly, the rounding rule applies to the represented number and notto the printed number, and so round(0.15, 1) could be either0.1 or 0.2).Rounding to a negative number of digits means rounding to a power often, so for example round(x, digits = -2) rounds to the nearesthundred.For signif the recognized values of digits are1...22, and non-missing values are rounded to the nearestinteger in that range.  Complex numbers are rounded to retain thespecified number of digits in the larger of the components.  Eachelement of the vector is rounded individually, unlike printing.These are all primitive functions.
The time is rounded or truncated to the second, minute, hour, day,month or year.  Time zones are only relevant to days or more, whenmidnight in the current time zone is used.The methods for class "Date" are of little use except to removefractional days.
The time is rounded or truncated to the second, minute, hour, day,month or year.  Time zones are only relevant to days or more, whenmidnight in the current time zone is used.The methods for class "Date" are of little use except to removefractional days.
NA
A data frame has (by definition) a vector of row names whichhas length the number of rows in the data frame, and contains neithermissing nor duplicated values.  Where a row names sequence has beenadded by the software to meet this requirement, they are regarded as‘automatic’.Row names are currently allowed to be integer or character, butfor backwards compatibility (with R <= 2.4.0) row.names willalways return a character vector.  (Use attr(x, "row.names") ifyou need to retrieve an integer-valued set of row names.)Using NULL for the value resets the row names toseq_len(nrow(x)), regarded as ‘automatic’.
A data frame has (by definition) a vector of row names whichhas length the number of rows in the data frame, and contains neithermissing nor duplicated values.  Where a row names sequence has beenadded by the software to meet this requirement, they are regarded as‘automatic’.Row names are currently allowed to be integer or character, butfor backwards compatibility (with R <= 2.4.0) row.names willalways return a character vector.  (Use attr(x, "row.names") ifyou need to retrieve an integer-valued set of row names.)Using NULL for the value resets the row names toseq_len(nrow(x)), regarded as ‘automatic’.
A data frame has (by definition) a vector of row names whichhas length the number of rows in the data frame, and contains neithermissing nor duplicated values.  Where a row names sequence has beenadded by the software to meet this requirement, they are regarded as‘automatic’.Row names are currently allowed to be integer or character, butfor backwards compatibility (with R <= 2.4.0) row.names willalways return a character vector.  (Use attr(x, "row.names") ifyou need to retrieve an integer-valued set of row names.)Using NULL for the value resets the row names toseq_len(nrow(x)), regarded as ‘automatic’.
A data frame has (by definition) a vector of row names whichhas length the number of rows in the data frame, and contains neithermissing nor duplicated values.  Where a row names sequence has beenadded by the software to meet this requirement, they are regarded as‘automatic’.Row names are currently allowed to be integer or character, butfor backwards compatibility (with R <= 2.4.0) row.names willalways return a character vector.  (Use attr(x, "row.names") ifyou need to retrieve an integer-valued set of row names.)Using NULL for the value resets the row names toseq_len(nrow(x)), regarded as ‘automatic’.
A data frame has (by definition) a vector of row names whichhas length the number of rows in the data frame, and contains neithermissing nor duplicated values.  Where a row names sequence has beenadded by the software to meet this requirement, they are regarded as‘automatic’.Row names are currently allowed to be integer or character, butfor backwards compatibility (with R <= 2.4.0) row.names willalways return a character vector.  (Use attr(x, "row.names") ifyou need to retrieve an integer-valued set of row names.)Using NULL for the value resets the row names toseq_len(nrow(x)), regarded as ‘automatic’.
A data frame has (by definition) a vector of row names whichhas length the number of rows in the data frame, and contains neithermissing nor duplicated values.  Where a row names sequence has beenadded by the software to meet this requirement, they are regarded as‘automatic’.Row names are currently allowed to be integer or character, butfor backwards compatibility (with R <= 2.4.0) row.names willalways return a character vector.  (Use attr(x, "row.names") ifyou need to retrieve an integer-valued set of row names.)Using NULL for the value resets the row names toseq_len(nrow(x)), regarded as ‘automatic’.
These functions are equivalent to use of apply withFUN = mean or FUN = sum with appropriate margins, butare a lot faster.  As they are written for speed, they blur over someof the subtleties of NaN and NA.  If na.rm =    FALSE and either NaN or NA appears in a sum, theresult will be one of NaN or NA, but which might beplatform-dependent.Notice that omission of missing values is done on a per-column orper-row basis, so column means may not be over the same set of rows,and vice versa.  To use only complete rows or columns, first selectthem with na.omit or complete.cases(possibly on the transpose of x).The versions with an initial dot in the name (.colSums() etc)are ‘bare-bones’ versions for use in programming: they applyonly to numeric (like) matrices and do not name the result.
The extractor functions try to do something sensible for anymatrix-like object x.  If the object has dimnamesthe first component is used as the row names, and the second component(if any) is used for the column names.  For a data frame, rownamesand colnames eventually call row.names andnames respectively, but the latter are preferred.If do.NULL is FALSE, a character vector (of lengthNROW(x) or NCOL(x)) is returned in anycase, prepending prefix to simple numbers, if there are nodimnames or the corresponding component of the dimnames is NULL.The replacement methods for arrays/matrices coerce vector and factorvalues of value to character, but do not dispatch methods foras.character.For a data frame, value for rownames should be acharacter vector of non-duplicated and non-missing names (this isenforced), and for colnames a character vector of (preferably)unique syntactically-valid names.  In both cases, value will becoerced by as.character, and setting colnameswill convert the row names to character.
The extractor functions try to do something sensible for anymatrix-like object x.  If the object has dimnamesthe first component is used as the row names, and the second component(if any) is used for the column names.  For a data frame, rownamesand colnames eventually call row.names andnames respectively, but the latter are preferred.If do.NULL is FALSE, a character vector (of lengthNROW(x) or NCOL(x)) is returned in anycase, prepending prefix to simple numbers, if there are nodimnames or the corresponding component of the dimnames is NULL.The replacement methods for arrays/matrices coerce vector and factorvalues of value to character, but do not dispatch methods foras.character.For a data frame, value for rownames should be acharacter vector of non-duplicated and non-missing names (this isenforced), and for colnames a character vector of (preferably)unique syntactically-valid names.  In both cases, value will becoerced by as.character, and setting colnameswill convert the row names to character.
The default is to reorder the rows to agree with tapply as inthe example below.  Reordering should not add noticeably to the timeexcept when there are very many distinct values of group andx has few columns.The original function was written by Terry Therneau, but this is anew implementation using hashing that is much faster for large matrices.To sum over all the rows of a matrix (i.e., a single group) usecolSums, which should be even faster.For integer arguments, over/underflow in forming the sum results inNA.
The default is to reorder the rows to agree with tapply as inthe example below.  Reordering should not add noticeably to the timeexcept when there are very many distinct values of group andx has few columns.The original function was written by Terry Therneau, but this is anew implementation using hashing that is much faster for large matrices.To sum over all the rows of a matrix (i.e., a single group) usecolSums, which should be even faster.For integer arguments, over/underflow in forming the sum results inNA.
The default is to reorder the rows to agree with tapply as inthe example below.  Reordering should not add noticeably to the timeexcept when there are very many distinct values of group andx has few columns.The original function was written by Terry Therneau, but this is anew implementation using hashing that is much faster for large matrices.To sum over all the rows of a matrix (i.e., a single group) usecolSums, which should be even faster.For integer arguments, over/underflow in forming the sum results inNA.
These functions are equivalent to use of apply withFUN = mean or FUN = sum with appropriate margins, butare a lot faster.  As they are written for speed, they blur over someof the subtleties of NaN and NA.  If na.rm =    FALSE and either NaN or NA appears in a sum, theresult will be one of NaN or NA, but which might beplatform-dependent.Notice that omission of missing values is done on a per-column orper-row basis, so column means may not be over the same set of rows,and vice versa.  To use only complete rows or columns, first selectthem with na.omit or complete.cases(possibly on the transpose of x).The versions with an initial dot in the name (.colSums() etc)are ‘bare-bones’ versions for use in programming: they applyonly to numeric (like) matrices and do not name the result.
If x has length 1, is numeric (in the sense ofis.numeric) and x >= 1, sampling viasample takes place from 1:x.  Note that thisconvenience feature may lead to undesired behaviour when x isof varying length in calls such as sample(x).  See the examples.Otherwise x can be any R object for which length andsubsetting by integers make sense: S3 or S4 methods for theseoperations will be dispatched as appropriate.For sample the default for size is the number of itemsinferred from the first argument, so that sample(x) generates arandom permutation of the elements of x (or 1:x).It is allowed to ask for size = 0 samples with n = 0 ora length-zero x, but otherwise n > 0 or positivelength(x) is required.Non-integer positive numerical values of n or x will betruncated to the next smallest integer, which has to be no larger than.Machine$integer.max.The optional prob argument can be used to give a vector ofweights for obtaining the elements of the vector being sampled.  Theyneed not sum to one, but they should be non-negative and not all zero.If replace is true, Walker's alias method (Ripley, 1987) isused when there are more than 200 reasonably probable values: thisgives results incompatible with those from R < 2.2.0.If replace is false, these probabilities are appliedsequentially, that is the probability of choosing the next item isproportional to the weights amongst the remaining items.  The numberof nonzero weights must be at least size in this case.sample.int is a bare interface in which both n andsize must be supplied as integers.Argument n can be larger than the largest integer oftype integer, up to the largest representable integer in typedouble.  Only uniform sampling is supported.  Tworandom numbers are used to ensure uniform sampling of large integers.
If x has length 1, is numeric (in the sense ofis.numeric) and x >= 1, sampling viasample takes place from 1:x.  Note that thisconvenience feature may lead to undesired behaviour when x isof varying length in calls such as sample(x).  See the examples.Otherwise x can be any R object for which length andsubsetting by integers make sense: S3 or S4 methods for theseoperations will be dispatched as appropriate.For sample the default for size is the number of itemsinferred from the first argument, so that sample(x) generates arandom permutation of the elements of x (or 1:x).It is allowed to ask for size = 0 samples with n = 0 ora length-zero x, but otherwise n > 0 or positivelength(x) is required.Non-integer positive numerical values of n or x will betruncated to the next smallest integer, which has to be no larger than.Machine$integer.max.The optional prob argument can be used to give a vector ofweights for obtaining the elements of the vector being sampled.  Theyneed not sum to one, but they should be non-negative and not all zero.If replace is true, Walker's alias method (Ripley, 1987) isused when there are more than 200 reasonably probable values: thisgives results incompatible with those from R < 2.2.0.If replace is false, these probabilities are appliedsequentially, that is the probability of choosing the next item isproportional to the weights amongst the remaining items.  The numberof nonzero weights must be at least size in this case.sample.int is a bare interface in which both n andsize must be supplied as integers.Argument n can be larger than the largest integer oftype integer, up to the largest representable integer in typedouble.  Only uniform sampling is supported.  Tworandom numbers are used to ensure uniform sampling of large integers.
FUN is found by a call to match.fun and typicallyis specified as a function or a symbol (e.g., a backquoted name) or acharacter string specifying a function to be searched for from theenvironment of the call to lapply.Function FUN must be able to accept as input any of theelements of X.  If the latter is an atomic vector, FUNwill always be passed a length-one vector of the same type as X.Arguments in ... cannot have the same name as any of theother arguments, and care may be needed to avoid partial matching toFUN.  In general-purpose code it is good practice to name thefirst two arguments X and FUN if ... is passedthrough: this both avoids partial matching to FUN and ensuresthat a sensible error message is given if arguments named X orFUN are passed through ....Simplification in sapply is only attempted if X haslength greater than zero and if the return values from all elementsof X are all of the same (positive) length.  If the commonlength is one the result is a vector, and if greater than one is amatrix with a column corresponding to each element of X.Simplification is always done in vapply.  This functionchecks that all values of FUN are compatible with theFUN.VALUE, in that they must have the same length and type.(Types may be promoted to a higher type within the ordering logical< integer < double < complex, but not demoted.)Users of S4 classes should pass a list to lapply andvapply: the internal coercion is done by the as.list inthe base namespace and not one defined by a user (e.g., by setting S4methods on the base function).
The names of the objects specified either as symbols (or characterstrings) in ... or as a character vector in list areused to look up the objects from environment envir.  By defaultpromises are evaluated, but if eval.promises = FALSEpromises are saved (together with their evaluation environments).(Promises embedded in objects are always saved unevaluated.)All R platforms use the XDR (bigendian) representation of C ints anddoubles in binary save-d files, and these are portable across all Rplatforms.ASCII saves used to be useful for moving data between platforms butare now mainly of historical interest.  They can be more compact thanbinary saves where compression is not used, but are almost alwaysslower to both read and write: binary saves compress much better thanASCII ones.  Further, decimal ASCII saves may not restoredouble/complex values exactly, and what value is restored may dependon the R platform.Default values for the ascii, compress, safe andversion arguments can be modified with the"save.defaults" option (used both by save andsave.image), see also the ‘Examples’ section.  If a"save.image.defaults" option is set it is used in preference to"save.defaults" for function save.image (which allowsthis to have different defaults).  In addition,compression_level can be part of the "save.defaults"option.A connection that is not already open will be opened in mode"wb".  Supplying a connection which is open and not in binarymode gives an error.
The names of the objects specified either as symbols (or characterstrings) in ... or as a character vector in list areused to look up the objects from environment envir.  By defaultpromises are evaluated, but if eval.promises = FALSEpromises are saved (together with their evaluation environments).(Promises embedded in objects are always saved unevaluated.)All R platforms use the XDR (bigendian) representation of C ints anddoubles in binary save-d files, and these are portable across all Rplatforms.ASCII saves used to be useful for moving data between platforms butare now mainly of historical interest.  They can be more compact thanbinary saves where compression is not used, but are almost alwaysslower to both read and write: binary saves compress much better thanASCII ones.  Further, decimal ASCII saves may not restoredouble/complex values exactly, and what value is restored may dependon the R platform.Default values for the ascii, compress, safe andversion arguments can be modified with the"save.defaults" option (used both by save andsave.image), see also the ‘Examples’ section.  If a"save.image.defaults" option is set it is used in preference to"save.defaults" for function save.image (which allowsthis to have different defaults).  In addition,compression_level can be part of the "save.defaults"option.A connection that is not already open will be opened in mode"wb".  Supplying a connection which is open and not in binarymode gives an error.
saveRDS and readRDS provide the means to save a single Robject to a connection (typically a file) and to restore the object, quitepossibly under a different name.  This differs from save andload, which save and restore one or more named objects intoan environment.  They are widely used by R itself, for example to storemetadata for a package and to store the help.searchdatabases: the ".rds" file extension is most often used.Functions serialize and unserializeprovide a slightly lower-level interface to serialization: objectsserialized to a connection by serialize can be read back byreadRDS and conversely.Function infoRDS retrieves meta-data about serialization producedby saveRDS or serialize. infoRDS cannot be used todetect whether a file is a serialization nor whether it is valid.All of these interfaces use the same serialization format, but savewrites a single line header (typically "RDXs\n") before theserialization of a single object (a pairlist of all the objects to besaved).If file is a file name, it is opened by gzfileexcept for save(compress = FALSE) which usesfile.  Only for the exception are marked encodings offile which cannot be translated to the native encoding handledon Windows.Compression is handled by the connection opened when file is afile name, so is only possible when file is a connection ifhandled by the connection.  So e.g. urlconnections will need to be wrapped in a call to gzcon.If a connection is supplied it will be opened (in binary mode) for theduration of the function if not already open: if it is already open itmust be in binary mode for saveRDS(ascii = FALSE) or to readnon-ASCII saves.
The value of center determines how column centering isperformed.  If center is a numeric-alike vector with length equal tothe number of columns of x, then each column of x hasthe corresponding value from center subtracted from it.  Ifcenter is TRUE then centering is done by subtracting thecolumn means (omitting NAs) of x from theircorresponding columns, and if center is FALSE, nocentering is done.The value of scale determines how column scaling is performed(after centering).  If scale is a numeric-alike vector with lengthequal to the number of columns of x, then each column ofx is divided by the corresponding value from scale.If scale is TRUE then scaling is done by dividing the(centered) columns of x by their standard deviations ifcenter is TRUE, and the root mean square otherwise.If scale is FALSE, no scaling is done.The root-mean-square for a (possibly centered) column is defined assqrt(sum(x^2)/(n-1)), where x isa vector of the non-missing values and n is the number ofnon-missing values.  In the case center = TRUE, this is thesame as the standard deviation, but in general it is not.  (To scaleby the standard deviations without centering, usescale(x, center = FALSE, scale = apply(x, 2, sd, na.rm = TRUE)).)
The value of center determines how column centering isperformed.  If center is a numeric-alike vector with length equal tothe number of columns of x, then each column of x hasthe corresponding value from center subtracted from it.  Ifcenter is TRUE then centering is done by subtracting thecolumn means (omitting NAs) of x from theircorresponding columns, and if center is FALSE, nocentering is done.The value of scale determines how column scaling is performed(after centering).  If scale is a numeric-alike vector with lengthequal to the number of columns of x, then each column ofx is divided by the corresponding value from scale.If scale is TRUE then scaling is done by dividing the(centered) columns of x by their standard deviations ifcenter is TRUE, and the root mean square otherwise.If scale is FALSE, no scaling is done.The root-mean-square for a (possibly centered) column is defined assqrt(sum(x^2)/(n-1)), where x isa vector of the non-missing values and n is the number ofnon-missing values.  In the case center = TRUE, this is thesame as the standard deviation, but in general it is not.  (To scaleby the standard deviations without centering, usescale(x, center = FALSE, scale = apply(x, 2, sd, na.rm = TRUE)).)
The value of what can be a list of types, in which casescan returns a list of vectors with the types given by thetypes of the elements in what.  This provides a way of readingcolumnar data.  If any of the types is NULL, the correspondingfield is skipped (but a NULL component appears in the result).The type of what or its components can be one of the sixatomic vector types or NULL (see is.atomic).‘White space’ is defined for the purposes of this function asone or more contiguous characters from the set space, horizontal tab,carriage return and line feed.  It does not include form feed norvertical tab, but in Latin-1 and Windows 8-bit locales (but not UTF-8)'space' includes the non-breaking space "\xa0".Empty numeric fields are always regarded as missing values.Empty character fields are scanned as empty character vectors, unlessna.strings contains "" when they are regarded as missingvalues.The allowed input for a numeric field is optional whitespace followedeither NA or an optional sign followed by a decimal orhexadecimal constant (see NumericConstants), or NaN,Inf or infinity (ignoring case).  Out-of-range valuesare recorded as Inf, -Inf or 0.For an integer field the allowed input is optional whitespace,followed by either NA or an optional sign and one or moredigits (0-9): all out-of-range values are converted toNA_integer_.If sep is the default (""), the character \in a quoted string escapes the following character, so quotes may beincluded in the string by escaping them.If sep is non-default, the fields may be quoted in the style of‘.csv’ files where separators inside quotes ('' or"") are ignored and quotes may be put inside strings bydoubling them.  However, if sep = "\n" it is assumedby default that one wants to read entire lines verbatim.Quoting is only interpreted in character fields and in NULLfields (which might be skipping character fields).Note that since sep is a separator and not a terminator,reading a file by scan("foo", sep = "\n", blank.lines.skip = FALSE)will give an empty final line if the file ends in a linefeed and not ifit does not.  This might not be what you expected; see alsoreadLines.If comment.char occurs (except inside a quoted characterfield), it signals that the rest of the line should be regarded as acomment and be discarded.  Lines beginning with a comment character(possibly after white space with the default separator) are treated asblank lines.There is a line-length limit of 4095 bytes when reading from theconsole (which may impose a lower limit: see ‘An Introductionto R’).There is a check for a user interrupt every 1000 lines if whatis a list, otherwise every 10000 items.If file is a character string and fileEncoding isnon-default, or if it is a not-already-open connection with anon-default encoding argument, the text is converted to UTF-8and declared as such (and the encoding argument to scanis ignored).  See the examples of readLines.Embedded nuls in the input stream will terminate the field currentlybeing read, with a warning once per call to scan.  SettingskipNul = TRUE causes them to be ignored.
NA
NA
seek with where = NA returns the current byte offsetof a connection (from the beginning), and with a non-missing whereargument the connection is re-positioned (if possible) to thespecified position.  isSeekable returns whether the connectionin principle supports seek: currently only (possiblygz-compressed) file connections do.where is stored as a real but should represent an integer:non-integer values are likely to be truncated.  Note that the possiblevalues can exceed the largest representable number in an Rinteger on 64-bit builds, and on some 32-bit builds.File connections can be open for both writing/appending, in which caseR keeps separate positions for reading and writing.  Which seekrefers to can be set by its rw argument: the default is thelast mode (reading or writing) which was used.  Most files areonly opened for reading or writing and so default to that state.  If afile is open for both reading and writing but has not been used, thedefault is to give the reading position (0).The initial file position for reading is always at the beginning.The initial position for writing is at the beginning of the filefor modes "r+" and "r+b", otherwise at the end of thefile.  Some platforms only allow writing at the end of the file inthe append modes.  (The reported write position for a file opened inan append mode will typically be unreliable until the file has beenwritten to.)gzfile connections support seek with a number oflimitations, using the file position of the uncompressed file.They do not support origin = "end".  When writing, seeking isonly possible forwards: when reading seeking backwards is supported byrewinding the file and re-reading from its start.If seek is called with a non-NA value of where,any pushback on a text-mode connection is discarded.truncate truncates a file opened for writing at its currentposition.  It works only for file connections, and is notimplemented on all platforms: on others (including Windows) it willnot work for large (> 2Gb) files.None of these should be expected to work on text-mode connections withre-encoding selected.
seek with where = NA returns the current byte offsetof a connection (from the beginning), and with a non-missing whereargument the connection is re-positioned (if possible) to thespecified position.  isSeekable returns whether the connectionin principle supports seek: currently only (possiblygz-compressed) file connections do.where is stored as a real but should represent an integer:non-integer values are likely to be truncated.  Note that the possiblevalues can exceed the largest representable number in an Rinteger on 64-bit builds, and on some 32-bit builds.File connections can be open for both writing/appending, in which caseR keeps separate positions for reading and writing.  Which seekrefers to can be set by its rw argument: the default is thelast mode (reading or writing) which was used.  Most files areonly opened for reading or writing and so default to that state.  If afile is open for both reading and writing but has not been used, thedefault is to give the reading position (0).The initial file position for reading is always at the beginning.The initial position for writing is at the beginning of the filefor modes "r+" and "r+b", otherwise at the end of thefile.  Some platforms only allow writing at the end of the file inthe append modes.  (The reported write position for a file opened inan append mode will typically be unreliable until the file has beenwritten to.)gzfile connections support seek with a number oflimitations, using the file position of the uncompressed file.They do not support origin = "end".  When writing, seeking isonly possible forwards: when reading seeking backwards is supported byrewinding the file and re-reading from its start.If seek is called with a non-NA value of where,any pushback on a text-mode connection is discarded.truncate truncates a file opened for writing at its currentposition.  It works only for file connections, and is notimplemented on all platforms: on others (including Windows) it willnot work for large (> 2Gb) files.None of these should be expected to work on text-mode connections withre-encoding selected.
Numerical inputs should all be finite (that is, not infinite,NaN or NA).The interpretation of the unnamed arguments of seq andseq.int is not standard, and it is recommended always toname the arguments when programming.seq is  generic, and only the default method is described here.Note that it dispatches on the class of the first argumentirrespective of argument names.  This can have unintended consequencesif it is called with just one argument intending this to be taken asalong.with: it is much better to use seq_along in thatcase.seq.int is an internal generic which dispatches onmethods for "seq" based on the class of the first suppliedargument (before argument matching).Typical usages areThe first form generates the sequence from, from+/-1, ..., to(identical to from:to).The second form generates from, from+by, ..., up to thesequence value less than or equal to to.  Specifying to -  from and by of opposite signs is an error.  Note that thecomputed final value can go just beyond to to allow forrounding error, but is truncated to to.  (‘Just beyond’is by up to 1e-10 times abs(from - to).)The third generates a sequence of length.out equally spacedvalues from from to to.  (length.out is usuallyabbreviated to length or len, and seq_len is muchfaster.)The fourth form generates the integer sequence 1, 2, ...,    length(along.with).  (along.with is usually abbreviated toalong, and seq_along is much faster.)The fifth form generates the sequence 1, 2, ..., length(from)(as if argument along.with had been specified), unlessthe argument is numeric of length 1 when it is interpreted as1:from (even for seq(0) for compatibility with S).Using either seq_along or seq_len is much preferred(unless strict S compatibility is essential).The final form generates the integer sequence 1, 2, ...,  length.out unless length.out = 0, when it generatesinteger(0).Very small sequences (with from - to of the order of 10^{-14}times the larger of the ends) will return from.For seq (only), up to two of from, to andby can be supplied as complex values provided length.outor along.with is specified.  More generally, the default methodof seq will handle classed objects with methods forthe Math, Ops and Summary group generics.seq.int, seq_along and seq_len areprimitive.
Numerical inputs should all be finite (that is, not infinite,NaN or NA).The interpretation of the unnamed arguments of seq andseq.int is not standard, and it is recommended always toname the arguments when programming.seq is  generic, and only the default method is described here.Note that it dispatches on the class of the first argumentirrespective of argument names.  This can have unintended consequencesif it is called with just one argument intending this to be taken asalong.with: it is much better to use seq_along in thatcase.seq.int is an internal generic which dispatches onmethods for "seq" based on the class of the first suppliedargument (before argument matching).Typical usages areThe first form generates the sequence from, from+/-1, ..., to(identical to from:to).The second form generates from, from+by, ..., up to thesequence value less than or equal to to.  Specifying to -  from and by of opposite signs is an error.  Note that thecomputed final value can go just beyond to to allow forrounding error, but is truncated to to.  (‘Just beyond’is by up to 1e-10 times abs(from - to).)The third generates a sequence of length.out equally spacedvalues from from to to.  (length.out is usuallyabbreviated to length or len, and seq_len is muchfaster.)The fourth form generates the integer sequence 1, 2, ...,    length(along.with).  (along.with is usually abbreviated toalong, and seq_along is much faster.)The fifth form generates the sequence 1, 2, ..., length(from)(as if argument along.with had been specified), unlessthe argument is numeric of length 1 when it is interpreted as1:from (even for seq(0) for compatibility with S).Using either seq_along or seq_len is much preferred(unless strict S compatibility is essential).The final form generates the integer sequence 1, 2, ...,  length.out unless length.out = 0, when it generatesinteger(0).Very small sequences (with from - to of the order of 10^{-14}times the larger of the ends) will return from.For seq (only), up to two of from, to andby can be supplied as complex values provided length.outor along.with is specified.  More generally, the default methodof seq will handle classed objects with methods forthe Math, Ops and Summary group generics.seq.int, seq_along and seq_len areprimitive.
Numerical inputs should all be finite (that is, not infinite,NaN or NA).The interpretation of the unnamed arguments of seq andseq.int is not standard, and it is recommended always toname the arguments when programming.seq is  generic, and only the default method is described here.Note that it dispatches on the class of the first argumentirrespective of argument names.  This can have unintended consequencesif it is called with just one argument intending this to be taken asalong.with: it is much better to use seq_along in thatcase.seq.int is an internal generic which dispatches onmethods for "seq" based on the class of the first suppliedargument (before argument matching).Typical usages areThe first form generates the sequence from, from+/-1, ..., to(identical to from:to).The second form generates from, from+by, ..., up to thesequence value less than or equal to to.  Specifying to -  from and by of opposite signs is an error.  Note that thecomputed final value can go just beyond to to allow forrounding error, but is truncated to to.  (‘Just beyond’is by up to 1e-10 times abs(from - to).)The third generates a sequence of length.out equally spacedvalues from from to to.  (length.out is usuallyabbreviated to length or len, and seq_len is muchfaster.)The fourth form generates the integer sequence 1, 2, ...,    length(along.with).  (along.with is usually abbreviated toalong, and seq_along is much faster.)The fifth form generates the sequence 1, 2, ..., length(from)(as if argument along.with had been specified), unlessthe argument is numeric of length 1 when it is interpreted as1:from (even for seq(0) for compatibility with S).Using either seq_along or seq_len is much preferred(unless strict S compatibility is essential).The final form generates the integer sequence 1, 2, ...,  length.out unless length.out = 0, when it generatesinteger(0).Very small sequences (with from - to of the order of 10^{-14}times the larger of the ends) will return from.For seq (only), up to two of from, to andby can be supplied as complex values provided length.outor along.with is specified.  More generally, the default methodof seq will handle classed objects with methods forthe Math, Ops and Summary group generics.seq.int, seq_along and seq_len areprimitive.
by can be specified in several ways. A number, taken to be in days. A object of class difftime A character string, containing one of "day","week", "month", "quarter" or "year".This can optionally be preceded by a (positive or negative) integerand a space, or followed by "s".See seq.POSIXt for the details of "month".
Numerical inputs should all be finite (that is, not infinite,NaN or NA).The interpretation of the unnamed arguments of seq andseq.int is not standard, and it is recommended always toname the arguments when programming.seq is  generic, and only the default method is described here.Note that it dispatches on the class of the first argumentirrespective of argument names.  This can have unintended consequencesif it is called with just one argument intending this to be taken asalong.with: it is much better to use seq_along in thatcase.seq.int is an internal generic which dispatches onmethods for "seq" based on the class of the first suppliedargument (before argument matching).Typical usages areThe first form generates the sequence from, from+/-1, ..., to(identical to from:to).The second form generates from, from+by, ..., up to thesequence value less than or equal to to.  Specifying to -  from and by of opposite signs is an error.  Note that thecomputed final value can go just beyond to to allow forrounding error, but is truncated to to.  (‘Just beyond’is by up to 1e-10 times abs(from - to).)The third generates a sequence of length.out equally spacedvalues from from to to.  (length.out is usuallyabbreviated to length or len, and seq_len is muchfaster.)The fourth form generates the integer sequence 1, 2, ...,    length(along.with).  (along.with is usually abbreviated toalong, and seq_along is much faster.)The fifth form generates the sequence 1, 2, ..., length(from)(as if argument along.with had been specified), unlessthe argument is numeric of length 1 when it is interpreted as1:from (even for seq(0) for compatibility with S).Using either seq_along or seq_len is much preferred(unless strict S compatibility is essential).The final form generates the integer sequence 1, 2, ...,  length.out unless length.out = 0, when it generatesinteger(0).Very small sequences (with from - to of the order of 10^{-14}times the larger of the ends) will return from.For seq (only), up to two of from, to andby can be supplied as complex values provided length.outor along.with is specified.  More generally, the default methodof seq will handle classed objects with methods forthe Math, Ops and Summary group generics.seq.int, seq_along and seq_len areprimitive.
Numerical inputs should all be finite (that is, not infinite,NaN or NA).The interpretation of the unnamed arguments of seq andseq.int is not standard, and it is recommended always toname the arguments when programming.seq is  generic, and only the default method is described here.Note that it dispatches on the class of the first argumentirrespective of argument names.  This can have unintended consequencesif it is called with just one argument intending this to be taken asalong.with: it is much better to use seq_along in thatcase.seq.int is an internal generic which dispatches onmethods for "seq" based on the class of the first suppliedargument (before argument matching).Typical usages areThe first form generates the sequence from, from+/-1, ..., to(identical to from:to).The second form generates from, from+by, ..., up to thesequence value less than or equal to to.  Specifying to -  from and by of opposite signs is an error.  Note that thecomputed final value can go just beyond to to allow forrounding error, but is truncated to to.  (‘Just beyond’is by up to 1e-10 times abs(from - to).)The third generates a sequence of length.out equally spacedvalues from from to to.  (length.out is usuallyabbreviated to length or len, and seq_len is muchfaster.)The fourth form generates the integer sequence 1, 2, ...,    length(along.with).  (along.with is usually abbreviated toalong, and seq_along is much faster.)The fifth form generates the sequence 1, 2, ..., length(from)(as if argument along.with had been specified), unlessthe argument is numeric of length 1 when it is interpreted as1:from (even for seq(0) for compatibility with S).Using either seq_along or seq_len is much preferred(unless strict S compatibility is essential).The final form generates the integer sequence 1, 2, ...,  length.out unless length.out = 0, when it generatesinteger(0).Very small sequences (with from - to of the order of 10^{-14}times the larger of the ends) will return from.For seq (only), up to two of from, to andby can be supplied as complex values provided length.outor along.with is specified.  More generally, the default methodof seq will handle classed objects with methods forthe Math, Ops and Summary group generics.seq.int, seq_along and seq_len areprimitive.
by can be specified in several ways. A number, taken to be in seconds. A object of class difftime A character string, containing one of "sec","min", "hour", "day", "DSTday","week", "month", "quarter" or "year".This can optionally be preceded by a (positive or negative) integerand a space, or followed by "s".The difference between "day" and "DSTday" is that theformer ignores changes to/from daylight savings time and the latter takesthe same clock time each day.  "week" ignores DST (it is aperiod of 144 hours), but "7 DSTdays" can be used as analternative.  "month" and "year" allow for DST.The time zone of the result is taken from from: rememberthat GMT means UTC (and not the time zone of Greenwich, England) and sodoes not have daylight savings time.Using "month" first advances the month without changing theday: if this results in an invalid day of the month, it is countedforward into the next month: see the examples.
Negative values are supported for from andby. sequence(nvec, from, by=0L) is equivalent torep(from, each=nvec).This function was originally implemented in R with fewer features, butit has since become more flexible, and the default method isimplemented in C for speed.
Negative values are supported for from andby. sequence(nvec, from, by=0L) is equivalent torep(from, each=nvec).This function was originally implemented in R with fewer features, butit has since become more flexible, and the default method isimplemented in C for speed.
The function serialize serializes object to the specifiedconnection.  If connection is NULL then object isserialized to a raw vector, which is returned as the result ofserialize.Sharing of reference objects is preserved within the object but notacross separate calls to serialize.unserialize reads an object (as written by serialize)from connection or a raw vector.The refhook functions can be used to customize handling ofnon-system reference objects (all external pointers and weakreferences, and all environments other than namespace and packageenvironments and .GlobalEnv).  The hook function forserialize should return a character vector for references itwants to handle; otherwise it should return NULL.  The hook forunserialize will be called with character vectors supplied toserialize and should return an appropriate object.For a text-mode connection, the default value of ascii is setto TRUE: only ASCII representations can be written to text-modeconnections and attempting to use ascii = FALSE will throw anerror.The format consists of a single line followed by the data: the firstline contains a single character: X for binary serializationand A for ASCII serialization, followed by a new line.  (Theformat used is identical to that used by readRDS.)As almost all systems in current use are little-endian, xdr =  FALSE can be used to avoid byte-shuffling at both ends whentransferring data from one little-endian machine to another (orbetween processes on the same machine).  Depending on the system, thiscan speed up serialization and unserialization by a factor of up to3x.
The first eleven functions create connections.  By default theconnection is not opened (except for a socket connection created bysocketConnection or socketAccept and for server socketconnection created by serverSocket), but maybe opened by setting a non-empty value of argument open.For file the description is a path to the file to be opened(when tilde expansion is done) or a complete URL (when it isthe same as calling url), or "" (the default) or"clipboard" (see the ‘Clipboard’ section).  Use"stdin" to refer to the C-level ‘standard input’ of theprocess (which need not be connected to anything in a console orembedded version of R, and is not in RGui on Windows).  Seealso stdin() for the subtly different R-level concept ofstdin. See nullfile() for a platform-independentway to get filename of the null device.For url the description is a complete URL including scheme(such as http://, https://, ftp:// orfile://).  Method "internal" is that available sinceconnections were introduced..  Method "wininet" is onlyavailable on Windows (it uses the WinINet functions of that OS) andmethod "libcurl" (using the library of that name:https://curl.se/libcurl/) is required on a Unix-alike butoptional on Windows.  Method "default" uses method"internal" for file:// URLs and uses "libcurl"(if available) for ftp:// and ftps:// URLs.  On aUnix-alike it uses "libcurl" for http:// andhttps:// URLs; on Windows "wininet" for http://and https:// URLs (and for ftp:// if "libcurl" isunavailable).  Which methods support which schemes has varied by Rversion – currently "internal" supports file://,http:// (deprecated) and ftp:// (deprecated);"wininet" supports file://, http://,https:// and ftp:// (deprecated).  Proxies can bespecified: see download.file.For gzfile the description is the path to a file compressed bygzip: it can also open for reading uncompressed files andthose compressed by bzip2, xz or lzma.For bzfile the description is the path to a file compressed bybzip2.For xzfile the description is the path to a file compressed byxz (https://en.wikipedia.org/wiki/Xz) or (for readingonly) lzma (https://en.wikipedia.org/wiki/LZMA).unz reads (only) single files within zip files, in binary mode.The description is the full path to the zip file, with ‘.zip’extension if required.For pipe the description is the command line to be piped to orfrom.  This is run in a shell, on Windows that specified by theCOMSPEC environment variable.For fifo the description is the path of the fifo.  (Support forfifo connections is optional but they are available on mostUnix platforms and on Windows.)The intention is that file and gzfile can be usedgenerally for text input (from files, http:// andhttps:// URLs) and binary input respectively.open, close and seek are generic functions: thefollowing applies to the methods relevant to connections.open opens a connection.  In general functions usingconnections will open them if they are not open, but then close themagain, so to leave a connection open call open explicitly.close closes and destroys a connection.  This will happenautomatically in due course (with a warning) if there is no longer anR object referring to the connection.A maximum of 128 connections can be allocated (not necessarily open)at any one time.  Three of these are pre-allocated (seestdout).   The OS will impose limits on the numbers ofconnections of various types, but these are usually larger than 125.flush flushes the output stream of a connection open forwrite/append (where implemented, currently for file and clipboardconnections, stdout and stderr).If for a file or (on most platforms) a fifo connectionthe description is "", the file/fifo is immediately opened (in"w+" mode unless open = "w+b" is specified) and unlinkedfrom the file system.  This provides a temporary file/fifo to write toand then read from.socketConnection(server=TRUE) creates a new temporary server socketlistening on the given port.  As soon as a new socket connection isaccepted on that port, the server socket is automatically closed. serverSocket creates a listening server socket which can be usedfor accepting multiple socket connections by socketAccept.  To stoplistening for new connections, a server socket needs to be closedexplicitly by close.socketConnection and socketAccept support setting ofsocket-specific options. Currently only "no-delay" isimplemented which enables the TCP_NODELAY socket option, causingthe socket to flush send buffers immediately (instead of waiting tocollect all output before sending). This option is useful forprotocols that need fast request/response turn-around times.socketTimeout sets connection timeout of a socket connection.  Anegative timeout can be given to query the old value.
The currently available RNG kinds are given below.  kind ispartially matched to this list.  The default is"Mersenne-Twister".The seed, .Random.seed[-1] == r[1:3] is an integer vector oflength 3, where each r[i] is in 1:(p[i] - 1), wherep is the length 3 vector of primes, p = (30269, 30307,      30323).The Wichmann–Hill generator has a cycle length of6.9536e12 (=prod(p-1)/4, see Applied Statistics (1984)33, 123 which corrects the original article).It exhibits 12 clear failures in the TestU01 Crush suite and 22in the BigCrush suite (L'Ecuyer, 2007).A multiply-with-carry RNG is used, as recommended by GeorgeMarsaglia in his post to the mailing list ‘sci.stat.math’.It has a period of more than 2^60.It exhibits 40 clear failures in L'Ecuyer's TestU01 Crush suite.Combined with Ahrens-Dieter or Kinderman-Ramage it exhibitsdeviations from normality even for univariate distributiongeneration.  See PR#18168 for a discussion.The seed is two integers (all values allowed).Marsaglia's famous Super-Duper from the 70's.  This is the originalversion which does not pass the MTUPLE test of the Diehardbattery.  It has a period of about      4.6*10^18 for most initial seeds.  The seed is two integers (allvalues allowed for the first seed: the second must be odd).We use the implementation by Reeds et al (1982–84).The two seeds are the Tausworthe and congruence long integers,respectively.  A one-to-one mapping to S's .Random.seed[1:12]is possible but we will not publish one, not least as this generatoris not exactly the same as that in recent versions of S-PLUS.It exhibits 25 clear failures in the TestU01 Crush suite (L'Ecuyer, 2007).From Matsumoto and Nishimura (1998); code updated in 2002.A twisted GFSR with period2^19937 - 1 and equidistribution in 623consecutive dimensions (over the whole period).  The ‘seed’ is a624-dimensional set of 32-bit integers plus a current position inthat set.R uses its own initialization method due to B. D. Ripley and isnot affected by the initialization issue in the 1998 code ofMatsumoto and Nishimura addressed in a 2002 update.It exhibits 2 clear failures in each of the TestU01 Crush and theBigCrush suite (L'Ecuyer, 2007).A 32-bit integer GFSR using lagged Fibonacci sequences withsubtraction.  That is, the recurrence used isX[j] = (X[j-100] - X[j-37]) mod 2^30and the ‘seed’ is the set of the 100 last numbers (actuallyrecorded as 101 numbers, the last being a cyclic shift of thebuffer).  The period is around 2^129.An earlier version from Knuth (1997).The 2002 version was not backwards compatible with the earlierversion: the initialization of the GFSR from the seed was altered.R did not allow you to choose consecutive seeds, the reported‘weakness’, and already scrambled the seeds. Otherwise,the algorithm is identical to Knuth-TAOCP-2002, with the samelagged Fibonacci recurrence formula.Initialization of this generator is done in interpreted R codeand so takes a short but noticeable time.It exhibits 3 clear failure in the TestU01 Crush suite and4 clear failures in the BigCrush suite(L'Ecuyer, 2007).A ‘combined multiple-recursive generator’ from L'Ecuyer(1999), each element of which is a feedback multiplicativegenerator with three integer elements: thus the seed is a (signed)integer vector of length 6. The period is around2^191.The 6 elements of the seed are internally regarded as 32-bitunsigned integers.  Neither the first three nor the last threeshould be all zero, and they are limited to less than4294967087 and 4294944443 respectively.This is not particularly interesting of itself, but provides thebasis for the multiple streams used in package parallel.It exhibits 6 clear failures in each of the TestU01 Crush and theBigCrush suite (L'Ecuyer, 2007).Use a user-supplied generator.  See Random.user fordetails.normal.kind can be "Kinderman-Ramage","Buggy Kinderman-Ramage" (not for set.seed),"Ahrens-Dieter", "Box-Muller", "Inversion" (thedefault), or "user-supplied".  (For inversion, see thereference in qnorm.)  The Kinderman-Ramage generatorused in versions prior to 1.7.0 (now called "Buggy") had severalapproximation errors and should only be used for reproduction of oldresults.  The "Box-Muller" generator is stateful as pairs ofnormals are generated and returned sequentially.  The state is resetwhenever it is selected (even if it is the current normal generator)and when kind is changed.sample.kind can be "Rounding" or "Rejection",or partial matches to these.  The former was the default in versionsprior to 3.6.0:  it made sample noticeably non-uniformon large populations, and should only be used for reproduction of oldresults.  See PR#17494 for a discussion. set.seed uses a single integer argument to set as many seedsas are required.  It is intended as a simple way to get quite differentseeds by specifying small integer arguments, and also as a way to getvalid seed sets for the more complicated methods (especially"Mersenne-Twister" and "Knuth-TAOCP").  There is noguarantee that different values of seed will seed the RNGdifferently, although any exceptions would be extremely rare.  Ifcalled with seed = NULL it re-initializes (see ‘Note’)as if no seed had yet been set.The use of kind = NULL, normal.kind = NULL or sample.kind = NULL inRNGkind or set.seed selects the currently-usedgenerator (including that used in the previous session if theworkspace has been restored): if no generator has been used it selects"default".
Each of union, intersect, setdiff andsetequal will discard any duplicated values in the arguments,and they apply as.vector to their arguments (and soin particular coerce factors to character vectors).is.element(x, y) is identical to x %in% y.
Each of union, intersect, setdiff andsetequal will discard any duplicated values in the arguments,and they apply as.vector to their arguments (and soin particular coerce factors to character vectors).is.element(x, y) is identical to x %in% y.
setHook provides a general mechanism for users to registerhooks, a list of functions to be called from system (or user)functions.  The initial set of hooks was associated with events onpackages/namespaces: these hooks are named via calls topackageEvent.To remove a hook completely, call setHook(hookName, NULL, "replace").When an R package is attached by library or loaded byother means, it can call initialization code.  See.onLoad for a description of the package hook functionscalled during initialization.  Users can add their own initializationcode via the hooks provided by setHook(), functions which willbe called as funname(pkgname, pkgpath) inside atry call.The sequence of events depends on which hooks are defined, and whethera package is attached or just loaded.  In the case where all hooksare defined and a package is attached, the order of initializationevents is as follows: The package namespace is loaded. The package's .onLoad function is run. If S4 methods dispatch is on, any actions set bysetLoadAction are run. The namespace is sealed. The user's "onLoad" hook is run. The package is added to the search path. The package's .onAttach function is run. The package environment is sealed. The user's "attach" hook is run.A similar sequence (but in reverse) is run when a package is detachedand its namespace unloaded: The user's "detach" hook is run. The package's .Last.lib function is run. The package is removed from the search path. The user's "onUnload" hook is run. The package's .onUnload function is run. The package namespace is unloaded.Note that when an R session is finished, packages are not detached andnamespaces are not unloaded, so the corresponding hooks will not berun.Also note that some of the user hooks are run without the packagebeing on the search path, so in those hooks objects in the packageneed to be referred to using the double (or triple) colon operator,as in the example.If multiple hooks are added, they are normally run in the order shownby getHook, but the "detach" and "onUnload" hooksare run in reverse order so the default for package events is to addhooks ‘inside’ existing ones.The hooks are stored in the environment .userHooksEnv in thebase package, with ‘mangled’ names.
packageHasNamespace does not indicate if the package has anamespace (all now do), rather if it has a ‘NAMESPACE’ file,which base and some legacy packages do not.  But then you arenot intended to be using it ....
setTimeLimit sets limits which apply to each top-levelcomputation, that is a command line (including any continuation lines)entered at the console or from a file.  If it is called from within acomputation the limits apply to the rest of the computation and(unless transient = TRUE) to subsequent top-level computations.setSessionTimeLimit sets limits for the rest of thesession.  Once a session limit is reached it is reset to Inf.Setting any limit has a small overhead – well under 1% on thesystems measured.Time limits are checked whenever a user interrupt could occur.This will happen frequently in R code and during Sys.sleep,but only at points in compiled C and Fortran code identified by thecode author.‘Total cpu time’ includes that used by child processes wherethe latter is reported.
setTimeLimit sets limits which apply to each top-levelcomputation, that is a command line (including any continuation lines)entered at the console or from a file.  If it is called from within acomputation the limits apply to the rest of the computation and(unless transient = TRUE) to subsequent top-level computations.setSessionTimeLimit sets limits for the rest of thesession.  Once a session limit is reached it is reset to Inf.Setting any limit has a small overhead – well under 1% on thesystems measured.Time limits are checked whenever a user interrupt could occur.This will happen frequently in R code and during Sys.sleep,but only at points in compiled C and Fortran code identified by thecode author.‘Total cpu time’ includes that used by child processes wherethe latter is reported.
See files for how file paths with marked encodings are interpreted.
