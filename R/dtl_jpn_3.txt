x
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続である（ファイル・ストリームとは限らない）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれません。
Unix-alikeでサポートされているデフォルトのクォートタイプは、ボーンシェルshのものです。  文字列がシングルクォートを含まない場合、シングルクォートで囲むことができます。  そうでない場合、文字列は二重引用符で囲まれ、ドル、バッククォート、バックスラッシュ以外のメタキャラクタの特別な意味はすべて抑制される。  このタイプのクォートは、bash、ksh、およびzshにも適しています。もう1つのタイプのクォートは、Cシェル（cshおよびtcsh）用です。  この場合も、文字列にシングルクォートが含まれていなければ、シングルクォートで囲めばよい。  シングルクォートを含む文字列の場合は、ドルクォートやバッククォートを含まない限り、ダブルクォートを使うことができます（バックスラッシュ、感嘆符、ダブルクォートをエスケープする必要があります）。  最後の手段として、文字列をシングルクォートを含まない部分に分割し、それぞれをシングルクォートで囲み、シングルクォートをダブルクォートで囲む必要がある。Windowsでは、コマンドラインの解釈はシェルだけでなくアプリケーションでも行われる。  Windowsでは、コマンドラインの解釈はシェルだけでなく、アプリケーションでも行われます。使用するコンパイラーに依存する場合もあります。マイクロソフトのCランタイムに関するルールは、https://docs.microsoft.com/en-us/previous-versions/ms880421(v=msdn.10)に記載されています。アプリケーションのプログラマーの気まぐれによる場合もあります：そのドキュメントを確認してください。  type="cmd "クォーテーションは、文字列を二重引用符で囲み、内部の二重引用符をバックスラッシュでエスケープする。Windowsのパス名は二重引用符を含むことができないため、systemまたはsystem2で使用する場合、多くのアプリケーションで安全に使用できる。  Windowsのcmd.exeシェル（デフォルトではshellで使用）は、type = "cmd2" クォートを使用します。  場合によっては、2種類の引用符を使用する必要があります：まずアプリケーションに対して、次にcmd.exeに対してtype = "cmd2 "を使用します。  以下の例を参照してください。  
これは内部ジェネリック・プリミティブ関数であり、メソッドは直接定義することも、Mathグループ・ジェネリックを介して定義することもできる。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最近確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによって不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すことはできません。
5を四捨五入する場合、IEC 60559標準（'IEEE 754'も参照）が使用され、「偶数桁に行く」ことが期待されていることに注意してください。  ただし、これはOSのサービスや表示誤差に依存する（例えば0.15は正確に表現されていないため、丸めルールは表現された数字に適用され、印刷された数字には適用されないため、round(0.15, 1)は0.1にも0.2にもなりうる）。例えば、 round(x, digits = -2) は、最も近い100に丸められます。signifの場合、digitsの認識値は1...22であり、欠落していない値は、その範囲の最も近い整数に丸められます。  複素数は、指定された桁数を保持するように、成分の大きいほうに丸められます。  これらはすべてプリミティブ関数です。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによって不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、および.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。
FUNは、match.funの呼び出しによって検出され、通常、関数またはシンボル（バッククォートされた名前など）として指定されます、FUNはmatch.funの呼び出しによって見つけられ、通常、関数、シンボル（バッククオート名など）、またはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定されます。関数FUNはXの要素のいずれかを入力として受け入れることができなければなりません。後者がアトミックベクトルの場合、FUNは常にXと同じ型の長さ1のベクトルを渡されます。  汎用的なコードでは、...を通過させる場合、最初の2つの引数にXとFUNという名前を付けるのが良い方法である。これにより、FUNへの部分一致を避けることができ、XまたはFUNという名前の引数が...を通過した場合、賢明なエラーメッセージが表示されるようになる。  共通の長さが 1 の場合、結果はベクトルになり、1 より大きい場合は X の各要素に対応する列を持つ行列になります。  この関数は、FUNの全ての値がFUN.VALUEと互換性があり、長さと型が同じであることをチェックします(型は、logical< integer < double < complexの順序で上位の型に昇格することができますが、降格することはできません)。S4クラスのユーザは、lapplyとvapplyにリストを渡す必要があります: 内部的な強制は、基本名前空間内のas.listによって行われ、ユーザによって定義されるものではありません(例えば、基本関数にS4methodsを設定することによって)。
2つの引数atan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)です、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。これらはすべて、利用可能な場合、同じ名前のシステム・コール（複素引数には接頭辞cをつける）へのラッパーです。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
double は、指定された長さの倍精度ベクトルを作成します。  これは numeric.as.double と同じで、汎用関数です。  as.numericと同じです。  is.doubleはdouble型のテストです。Rには単精度データ型がありません。  すべての実数は倍精度形式で格納されます。  関数as.singleとsingleは、as.doubleとdoubleと同じですが、Cと.Fortranインターフェースで使用される属性Csingleを設定します。
ブランチカットは逆三角関数asin et seqと一致しており、Abramowitzand Stegunの図4.7、86ページで定義されているものと一致しています。   カットの実際の振る舞いは、C99標準に従っており、終点を反時計回りに回ってくる連続性が要求される。
sinkはR出力をコネクションに迂回させる（そして、そのような迂回を終了させるために再度使用しなければならない。）  通常のR出力（接続の標準出力）は、デフォルトのtype = "output "によって流用されます。  プロンプトと（ほとんどの）メッセージだけがコンソールに表示され続ける。  sink()またはsink(file = NULL)は、(指定されたタイプの)最後の流用を終了する。  通常の出力にはダイバージョンのスタックがあり、出力は前のダイバージョンに戻る（ダイバージョンがあった場合）。  split=TRUEは、(Rvprintf経由の)R出力とwriteLinesからのデフォルト出力のみを分割する。メッセージ・ストリームのシンクは、十分に注意して行う必要があります。このストリームの場合、 file は既にオープンされている接続でなければならず、接続のスタックはありません。  異なるエンコーディングが必要な場合（例えば、UTF-8で格納された文字列を表現する場合）、ファイル接続を使用します。
sinkは、Rの出力を接続に転送します（転送を終了するには、再度使用する必要があります。）  通常のR出力(接続の標準出力)は、デフォルトのtype = "output "で流用される。  プロンプトと（ほとんどの）メッセージだけがコンソールに表示され続ける。  sink()またはsink(file = NULL)は、(指定されたタイプの)最後の流用を終了する。  通常の出力にはダイバージョンのスタックがあり、出力は前のダイバージョンに戻る（ダイバージョンがあった場合）。  split=TRUEは、(Rvprintf経由の)R出力とwriteLinesからのデフォルト出力のみを分割する。メッセージ・ストリームのシンクは、十分に注意して行う必要があります。このストリームの場合、 file は既にオープンされている接続でなければならず、接続のスタックはありません。  異なるエンコーディングが必要な場合（例えば、UTF-8で格納された文字列を表現する場合）には、ファイル接続を使用します - しかし、Rの出力を生成するいくつかの方法では、そのような文字列はすでに現在のエンコーディングに変換されています。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)となります、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。これらはすべて、利用可能な場合、同じ名前のシステム・コール（複素引数には接頭辞cをつける）へのラッパーです。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合はcosなどの呼び出しが使用され、2分の1の倍数の場合は特別なケースがあります)。
MARGINが1つの次元を与える場合、これに関するスライス番号iのすべての要素は値iを持つ。一般的に、スライス番号は、MARGINが与える次元内のインデックスのすべての組み合わせに列長順に番号を付けて得られる。  すなわち、m_1, ..., m_kはスライスされた次元数(MARGINの要素)、d_{m_1}, ..., d_{m_k}は対応するエクステントであり、n_1 = 1, n_2 = d_{m_1}, ...,n_k = d_{m_1} となる。... d_{m_{k-1}}, 次元m_1が値i_1,..., 次元m_kが値i_kを持つスライスの数は1 + n_1 (i_1 - 1) + ... + n_k (i_k - 1)である。
最初の11の関数はコネクションを作成します。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルだけをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルだけをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
書き込み中の値は必要に応じて再利用され、socklist と同じ長さの論理ベクトルを構成する。ソケット接続は socklist に複数回現れることがある。
最初の11個の関数はコネクションを生成する。  デフォルトでは、接続はオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケット接続を除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
結果の行名と列名はそれぞれaの列名とbの列名から取られる。  bがない場合、結果の列名はaの行名となる。aの列名とbareの行名が等しいかどうかのチェックは行われない。下位互換性のために、aは(実数)QR分解とすることができるが、その場合はqr.solveを呼び出すべきである。
結果の行名と列名はそれぞれ a の列名と b の列名から取られる。  bがない場合、結果の列名はaの行名となる。aの列名とbareの行名が等しいかどうかのチェックは行われない。下位互換性のためにaは(実)QR分解とすることができるが、その場合はqr.solveを呼び出すべきである。
QR分解は、多くの統計的手法において重要な役割を果たしている。  特に、これは与えられた行列｛A｝とベクトル｛B｝に対する方程式｛Ax｝＝｛B｝を解くのに使うことができる。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q} 行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に制限される。qr.fitted と qr.resid は、LINPACK インタフェースのみをサポートする。
sort はメソッドを書くことができるジェネリック関数であり、 sort.int は最初の3つの引数だけが使用される場合、S と互換性がある内部メソッドである。デフォルトのソートメソッドは、クラス化されたオブジェクトの順序を使用し、これはジェネリック関数xtfrmを使用する（xtfrmメソッドが定義されているか、is.numeric(x)が真でない限り、遅いことがある）。auto "メソッドは、短い(要素数が2^31未満の)数値ベクトル、整数ベクトル、論理ベクトル、因子の場合は "radix "を選択し、それ以外の場合は "shell "を選択する。"radix "メソッドを除き、文字ベクトルのソート順は使用するロケールの照合順序に依存する。partialがNULLでない場合、部分ソートによってソート配列の正しい位置に配置される 結果の要素の添字を含むものとみなされる。  指定された位置にある各結果の値に対して、その値より小さい値はソート済み配列内でより小さいインデックスを持つことが保証され、より大きい値はソート済み配列内でより大きいインデックスを持つことが保証されます。  (これは効率化のために含まれており、多くのオプションは部分ソートでは使用できません。  また、10個を超える場合は完全なソート(可能であればクイックソート)が行われます)。  shell "メソッドはShellsort(Sedgewick (1986)のO(n^{4/3})変種)を使用する。  xが名前を持っている場合、安定な修正が使用されるので、同順序は再順序付けされない。  (これは名前が存在する場合のみ重要である)メソッド "quick "は、Singleton (1969)のHoareのクイックソート法の実装を使用し、xが数値(doubleまたはinteger)で、partialがNULLの場合にのみ使用可能である。  (他の型のxでは、黙ってShellsortが使用されます。) 通常は、Shellsortよりもいくらか高速ですが(長さ100万のベクトルではおそらく50%高速で、10億では2倍高速です)、稀に発生する最悪のケースではパフォーマンスが低下します。  (擬似ランダムな中点を使用したPetoの修正は、最悪のケースをより稀にするために使用される)。  これは安定したソートではなく、同値の並べ替えが行われる可能性がある。「基数」法は、入力サイズに対して線形に時間をスケーリングする単純なハッシュに依存しており、漸近的な時間複雑度はO(n)である。具体的な変種とその実装はdata.tablepackageに由来し、Matt DowleとArun Srinivasanによるものである。  小さな入力(< 200)に対しては、基数ソートの割り当てオーバヘッドを回避するためにインプレースで動作する挿入ソート(O(n^2))を使用する。100,000未満の整数ベクトルに対しては、より単純で高速な線形時間計数ソートに切り替える。すべての場合においてソートは安定しており、同値の順序は保持される。これは整数ベクトルおよび因数に対するデフォルトの手法である。「基数」手法は一般に、特に文字ベクトルや小さな整数に対しては他の手法よりも優れている。クイックソートと比較すると、大きな整数値や実数値を持つベクトルでは若干高速である（しかし、クイックソートとは異なり、radixは安定しており、すべてのna.lastオプションをサポートしている）。この実装は、内部のCHARSXPテーブルを巧みに利用していることもあり、文字ベクトルに対してはシェルソートよりも桁違いに高速です。しかし、基数ソートにはいくつかの注意点があります。UTF-8（ASCIIを含む）とLatin-1エンコーディングのみがサポートされている。照合順序は常に "C" ロケールに従います。長いベクトル (要素が 2^32 以上) や複素数ベクトルはまだサポートされていません。
sortはメソッドを書くことができるジェネリック関数で、sort.intは内部メソッドであり、最初の3つの引数のみが使用される場合、Sと互換性があります。デフォルトのソートメソッドは、クラス化されたオブジェクトの順序を使用し、これはジェネリック関数xtfrmを使用します（xtfrmメソッドが定義されているか、is.numeric(x)がtrueでない限り、遅い場合があります）。auto "メソッドは、短い(要素数が2^31未満の)数値ベクトル、整数ベクトル、論理ベクトル、因子の場合は "radix "を選択し、それ以外の場合は "shell "を選択する。"radix "メソッドを除き、文字ベクトルのソート順は使用するロケールの照合順序に依存する。partialがNULLでない場合、部分ソートによってソート配列の正しい位置に配置される 結果の要素の添字を含むものとみなされる。  指定された位置にある各結果の値に対して、その値より小さい値はソート済み配列内でより小さいインデックスを持つことが保証され、より大きい値はソート済み配列内でより大きいインデックスを持つことが保証されます。  (これは効率化のために含まれており、多くのオプションは部分ソートでは使用できません。  また、10個を超える場合は完全なソート(可能であればクイックソート)が行われます)。  shell "メソッドはShellsort(Sedgewick (1986)のO(n^{4/3})変種)を使用する。  xが名前を持っている場合、安定な修正が使用されるので、同順序は再順序付けされない。  (これは名前が存在する場合のみ重要である)メソッド "quick "は、Singleton (1969)のHoareのクイックソート法の実装を使用し、xが数値(doubleまたはinteger)で、partialがNULLの場合にのみ使用可能である。  (他の型のxでは、黙ってShellsortが使用されます。) 通常は、Shellsortよりもいくらか高速ですが(長さ100万のベクトルではおそらく50%高速で、10億では2倍高速です)、稀に発生する最悪のケースではパフォーマンスが低下します。  (擬似ランダムな中点を使用したPetoの修正は、最悪のケースをより稀にするために使用される)。  これは安定したソートではなく、同値の並べ替えが行われる可能性がある。「基数」法は、入力サイズに対して線形に時間をスケーリングする単純なハッシュに依存しており、漸近的な時間複雑度はO(n)である。具体的な変種とその実装はdata.tablepackageに由来し、Matt DowleとArun Srinivasanによるものである。  小さな入力(< 200)に対しては、基数ソートの割り当てオーバヘッドを回避するためにインプレースで動作する挿入ソート(O(n^2))を使用する。100,000未満の整数ベクトルに対しては、より単純で高速な線形時間計数ソートに切り替える。すべての場合においてソートは安定しており、同値の順序は保持される。これは整数ベクトルおよび因数に対するデフォルトの手法である。「基数」手法は一般に、特に文字ベクトルや小さな整数に対しては他の手法よりも優れている。クイックソートと比較すると、大きな整数値や実数値を持つベクトルでは若干高速である（しかし、クイックソートとは異なり、radixは安定しており、すべてのna.lastオプションをサポートしている）。この実装は、内部のCHARSXPテーブルを巧みに利用していることもあり、文字ベクトルに対してはシェルソートよりも桁違いに高速です。しかし、基数ソートにはいくつかの注意点があります。UTF-8（ASCIIを含む）とLatin-1エンコーディングのみがサポートされている。照合順序は常に "C" ロケールに従います。長いベクトル (要素が 2^32 以上) や複素数ベクトルはまだサポートされていません。
sortはメソッドを書くことができるジェネリック関数で、sort.intは内部メソッドであり、最初の3つの引数のみが使用される場合、Sと互換性があります。デフォルトのソートメソッドは、クラス化されたオブジェクトの順序を使用し、これはジェネリック関数xtfrmを使用します（xtfrmメソッドが定義されているか、is.numeric(x)がtrueでない限り、遅い場合があります）。auto "メソッドは、短い(要素数が2^31未満の)数値ベクトル、整数ベクトル、論理ベクトル、因子の場合は "radix "を選択し、それ以外の場合は "shell "を選択する。"radix "メソッドを除き、文字ベクトルのソート順は使用するロケールの照合順序に依存する。partialがNULLでない場合、部分ソートによってソート配列の正しい位置に配置される 結果の要素の添字を含むものとみなされる。  指定された位置にある各結果の値に対して、その値より小さい値はソート済み配列内でより小さいインデックスを持つことが保証され、より大きい値はソート済み配列内でより大きいインデックスを持つことが保証されます。  (これは効率化のために含まれており、多くのオプションは部分ソートでは使用できません。  また、10個を超える場合は完全なソート(可能であればクイックソート)が行われます)。  shell "メソッドはShellsort(Sedgewick (1986)のO(n^{4/3})変種)を使用する。  xが名前を持っている場合、安定な修正が使用されるので、同順序は再順序付けされない。  (これは名前が存在する場合のみ重要である。)メソッド "quick "は、Singleton (1969)のHoareのクイックソート法の実装を使用し、xが数値(doubleまたはinteger)で、partialがNULLの場合にのみ使用可能である。  (他の型のxでは、黙ってShellsortが使用されます。) 通常は、Shellsortよりもいくらか高速ですが(長さ100万のベクトルではおそらく50%高速で、10億では2倍高速です)、稀に発生する最悪のケースではパフォーマンスが低下します。  (擬似ランダムな中点を使用したPetoの修正は、最悪のケースをより稀にするために使用される)。  これは安定したソートではなく、同値は並び替えられる可能性がある。「基数」法は、入力サイズに対して線形に時間をスケーリングする単純なハッシュに依存している。具体的な変種とその実装はdata.tablepackageに由来し、Matt DowleとArun Srinivasanによるものである。  小さな入力(< 200)に対しては、基数ソートの割り当てオーバヘッドを回避するためにインプレースで動作する挿入ソート(O(n^2))を使用する。100,000未満の整数ベクトルに対しては、より単純で高速な線形時間計数ソートに切り替える。すべての場合においてソートは安定しており、同値の順序は保持される。これは整数ベクトルおよび因数に対するデフォルトの手法である。「基数」手法は一般に、特に文字ベクトルや小さな整数に対しては他の手法よりも優れている。クイックソートと比較すると、大きな整数値や実数値を持つベクトルでは若干高速である（しかし、クイックソートとは異なり、radixは安定しており、すべてのna.lastオプションをサポートしている）。この実装は、内部のCHARSXPテーブルを巧みに利用していることもあり、文字ベクトルに対してはシェルソートよりも桁違いに高速です。しかし、基数ソートにはいくつかの注意点があります。UTF-8（ASCIIを含む）とLatin-1エンコーディングのみがサポートされている。照合順序は常に "C" ロケールに従う。長いベクトル (要素が 2^32 以上) や複素ベクトルはまだサポートされていない。
最初のベクトルで同値の場合は、2番目のベクトルで同値を解消する。  使用されるソートは安定しており (method = "quick "を除く)、未解決の同値は元の順序のまま残されます。複素数の値は、最初に実数部、次に虚数部でソートされます。メソッド "radix "を除き、文字ベクトルのソート順は、使用するロケールの照合順序に依存する: 比較を参照のこと。メソッド "shell "は、一般的に最も安全な賭けであり、短い因子、数値ベクトル、整数ベクトル、論理ベクトルを除き、デフォルトのメソッドである。注意点はあるが、他の方法を凌駕している(sortを参照)。  sort.listのメソッド "quick "は、na.last = NAの数値xに対してのみサポートされ、安定せず、"radix "よりも遅い。partial = NULLは、Sの他の実装との互換性のためにサポートされているが、他の値は受け付けられず、順序付けは常に完全である。  因子の場合、これは内部コードでソートされ、順序付き因子に特に適しています。
sortはメソッドを書くことができるジェネリック関数であり、sort.intは最初の3つの引数のみが使用される場合、Sと互換性のある内部メソッドです。デフォルトのソートメソッドは、クラス化されたオブジェクトのための順序を使用し、これはジェネリック関数xtfrmを使用します（xtfrmメソッドが定義されているか、is.numeric(x)が真でない限り、遅い場合があります）。auto "メソッドは、短い(要素数が2^31未満の)数値ベクトル、整数ベクトル、論理ベクトル、因子の場合は "radix "を選択し、それ以外の場合は "shell "を選択する。"radix "メソッドを除き、文字ベクトルのソート順は使用するロケールの照合順序に依存する。partialがNULLでない場合、部分ソートによってソート配列の正しい位置に配置される 結果の要素の添字を含むものとみなされる。  指定された位置にある各結果の値に対して、その値より小さい値はソート済み配列内でより小さいインデックスを持つことが保証され、より大きい値はソート済み配列内でより大きいインデックスを持つことが保証されます。  (これは効率化のために含まれており、多くのオプションは部分ソートでは使用できません。  また、10個を超える場合は完全なソート(可能であればクイックソート)が行われます)。  shell "メソッドはShellsort(Sedgewick (1986)のO(n^{4/3})変種)を使用する。  xが名前を持っている場合、安定な修正が使用されるので、同順序は再順序付けされない。  (これは名前が存在する場合のみ重要である)メソッド "quick "は、Singleton (1969)のHoareのクイックソート法の実装を使用し、xが数値(doubleまたはinteger)で、partialがNULLの場合にのみ使用可能である。  (他の型のxでは、黙ってShellsortが使用されます。) 通常は、Shellsortよりもいくらか高速ですが(長さ100万のベクトルではおそらく50%高速で、10億では2倍高速です)、稀に発生する最悪のケースではパフォーマンスが低下します。  (擬似ランダムな中点を使用したPetoの修正は、最悪のケースをより稀にするために使用される)。  これは安定したソートではなく、同値の並べ替えが行われる可能性がある。「基数」法は、入力サイズに対して線形に時間をスケーリングする単純なハッシュに依存しており、漸近的な時間複雑度はO(n)である。具体的な変形とその実装はdata.tablepackageに由来し、Matt DowleとArun Srinivasanによるものである。  小さな入力(< 200)に対しては、基数ソートの割り当てオーバヘッドを回避するためにインプレースで動作する挿入ソート(O(n^2))を使用する。100,000未満の整数ベクトルに対しては、より単純で高速な線形時間計数ソートに切り替える。すべての場合においてソートは安定しており、同値の順序は保持される。これは整数ベクトルおよび因数に対するデフォルトの手法である。「基数」手法は一般に、特に文字ベクトルや小さな整数に対しては他の手法よりも優れている。クイックソートと比較すると、大きな整数値や実数値を持つベクトルでは若干高速である（しかし、クイックソートとは異なり、radixは安定しており、すべてのna.lastオプションをサポートしている）。この実装は、内部のCHARSXPテーブルを巧みに利用していることもあり、文字ベクトルに対してはシェルソートよりも桁違いに高速です。しかし、基数ソートにはいくつかの注意点があります。UTF-8（ASCIIを含む）とLatin-1エンコーディングのみがサポートされている。照合順序は常に "C" ロケールに従います。長いベクトル (要素が 2^32 以上) と複素ベクトルはまだサポートされていません。
ソースからのコード実行は、Rコマンドラインからの入力とはいくつかの点で異なることに注意してください。  式はトップ・レベルでは実行されないので、自動プリントは行われません。  そのため、印刷させたいものについては、明示的にprintを呼び出す必要があります（これには、FAQ Q7.22の格子によるプロットも含まれることを覚えておいてください）。  ファイル全体が実行される前に解析されるため、構文エラーはどのコードも実行されないことになります。  Rのすべてのバージョンは、LF（Unixで使用）、CRLF（DOS/Windowsで使用）またはCR（クラシックMac OSで使用）でマークされた行末を持つ接続からの入力を受け付け、これを改行にマップします。  最終行は、行末マーカーを欠いた不完全な行になる可能性があります。keep.sourceがtrueの場合（対話的に使用する場合のデフォルト）、関数のソースが保持されるため、入力として正確にリストすることができます。コンソールからの入力とは異なり、ファイル内または接続上の行は、無制限の文字数を含むことができます。skip.echo > 0の場合、ファイルの先頭にあるコメント行の数はエコーされません。  これは、コードの実行にはまったく影響しません。  echoがtrueで、deparsed式がsmax.deparse.lengthを超えた場合、その文字数だけ出力され、その後に ... が続きます。[TRUNCATED] .
splitとsplit<-は、defaultメソッドとdata.frameメソッドを持つ汎用関数です。  データフレームメソッドは，行列を行列のリストに分割するために使用することもでき，明示的に呼び出すことができれば，同様に置換することもできます．  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  因子のレベルに .が含まれる場合、sep が因子のレベルに存在しない文字列に設定されない限り、因子は期待通りに分割されない可能性があります。
split と split<- は、default とdata.frame メソッドを持つ汎用関数です。  unsplit は，ベクトルまたはデータフレームのリスト（split で作成されたものと同じように，互換性のある構造を持つと仮定される）で動作します．  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  要因のレベルに .が含まれる場合、sep が要因レベルに存在しない文字列に設定されない限り、期待どおりに要因が分割されないことがあります。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使用されていたのはそれほど昔ではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。また、いくつかのメソッドは個別にドキュメント化されています。
splitとsplit<-は、デフォルト・メソッドとdata.frameメソッドを持つ汎用関数です。  unsplit は，ベクトルまたはデータフレームのリスト（split で作成されたものと同じように，互換性のある構造を持っていると仮定されます）に対して動作します．  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  因子のレベルに .が含まれている場合、sep が因子のレベルに存在しない文字列に設定されていない限り、因子は期待どおりに分割されない可能性があります。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年始以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
splitとsplit<-は、defaultとdata.frameメソッドを持つ汎用関数です。  unsplit は、ベクトルまたはデータフレームのリスト（split で作成されたものと同じように、互換性のある構造を持っていると仮定されます）で動作します。  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  因子のレベルに .が含まれる場合、sep が因子のレベルに存在しない文字列に設定されない限り、因子は期待通りに分割されない可能性があります。
split と split<- は、default とdata.frame メソッドを持つ汎用関数です。  unsplit は，ベクトルまたはデータフレームのリスト（split で作成されたものと同じように，互換性のある構造を持つと仮定される）で動作します．  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  因子のレベルに .が含まれる場合、sep が因子のレベルに存在しない文字列に設定されない限り、因子は期待通りに分割されない可能性があります。
split と split<- は、default とdata.frame メソッドを持つ汎用関数です。  unsplit は，ベクトルまたはデータフレームのリスト（split で作成されたものと同じように，互換性のある構造を持つと仮定される）で動作します．  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  因子のレベルに.が含まれている場合、sepが因子のレベルに存在しない文字列に設定されていない限り、因子は期待どおりに分割されない可能性があります。
sprintfはシステムのsprintf C-libraryfunctionのラッパーです。  gettextfは、C-stylestring書式を提供する便宜関数であり、書式文字列の変換が可能である。引数（fmtを含む）は、可能であれば、最長の長さまで何度でも再利用され、その後、並列に書式設定が行われる。  長さゼロの引数は許され、長さゼロの結果を与える。  すべての引数は、未使用であっても評価される。したがって、いくつかの型（例えば "symbol "や "language"、seetypeof）は許可されない。fmtresultで未使用の引数は警告となる。(引数を "スキップ "するには、%.0sという書式を使うことができる。)以下は、KernighanとRitchie(参考文献参照)から抽象化したものである。文字列fmtは、出力文字列に渡される通常の文字と、...を通して提供される 引数に対して操作される変換指定を含んでいる。  許容される変換指定は、a%で始まり、集合aAdifeEgGosxX%中の文字の一つで終わります。  これらの文字は以下の型を示す：整数値、oは8進数、xとXは16進数（a-fはコードと同じ大文字小文字を使用）。  正確に整数値を持つ数値変数は整数に強制される。  倍精度値は、"[-]mmm.ddd "という形式の "固定小数点 "10進数表記になります。  小数点以下の桁数（"d"）は精度によって指定されます：デフォルトは6です。  非定数値は，NA，NaN，または（おそらく符号の後に続く）Inf.倍精度値に変換される。倍精度値は，[-]m.ddde[+-]xxまたは[-]m.dddE[+-]xxの形式の「指数」10進表記で，指数が-4より小さいか精度と等しいより大きい場合は%eまたは%E形式で，そうでない場合は%f形式で表示される。(精度(デフォルト6)は、ここでは有効桁数を指定し、%f、%eでは小数点以下の桁数を指定する。)倍精度値、[-]0xh.hhhp[+-]dの形の2進表記。  小数点以下の16進数桁数は精度によって指定されます。デフォルトは、内部2進数表現を正確に表すのに十分な桁数です。  定数でない値は、NA、NaN、または（おそらく符号の後に続く）Infに変換されます。  フォーマット%aはx、p、16進数値に小文字を使用し、フォーマット%Aは大文字を使用する。これはC99の機能であるため、すべてのプラットフォームでサポートされるべきである。  ほとんどのシステムは末尾のゼロを抑制するが、そうでないものもある。  よく書かれたプラットフォームでは、通常の数値の場合、小数点の前に先頭の1があり、さらに（デフォルトでは）10進数13桁、つまり53ビットがある。  非正規化（別名「サブノーマル」）された数値の扱いは、プラットフォームに大きく依存する。  文字NAは "NA "に変換されます。リテラル%（この場合、以下に示す余分なフォーマット文字はどれも許可されません）。文字以外の引数でsを指定する場合はas.characterによる変換が、文字以外の引数でf, e, E, g, Gを指定する場合はas.doubleによる変換が使用されます。  もしlength(fmt) > 1であれば、全ての要素は同じ型の引数を予期しなければならない。さらに、最初の% と変換の終了文字の間には、どのような順序であっても、次のようなものがある。文字については、あるプラットフォームではゼロパッドされ、他のプラットフォームでは無視される。数値の「代替出力」を指定し、そのタイプに応じた動作をする。  e、e、f、g、Gの場合、出力には常に小数点が付きます; forgとGの場合、末尾のゼロは削除されません。さらに、% の直後に1$から99$を付けて、番号の付いた引数を参照することができます。  この場合、すべての書式に番号が振られているのがベストです。番号が振られていない書式は、引数を順番に処理します。  この表記法では、引数を複数回使用することができますが、その場合は同じ型（整数、double、文字）として使用しなければなりません。  負のフィールド幅は，'-'フラグの後に正のフィールド幅が続くものとして扱われる。  負の精度は、精度が省略されたものとして扱われる。  s変換のフィールド幅と精度は、C標準に記述されているように、文字ではなくバイトとして 解釈されます。R数値ベクトルに使用されるCの倍数は符号付きゼロを持ち、sprintfは -0, -0.000 ...として出力することができます。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。  abs(x)は、xが整数または論理の場合、整数ベクトルを返します。
この関数の目的は、Rの出力、例えば警告やエラーメッセージで使用するテキストを引用するための簡単なマークアップ手段を提供することです。適切な引用符の選択は、ロケールと使用可能な文字セットの両方に依存します。  古いUnix/X11フォントでは、グレイブ・アクセント（ASCIIコード0x60）とアポストロフィ（0x27）が、マッチする開閉単一引用符としても使用できるように表示されます。  最近のフォントやUnix以外のシステムでは、これらの文字はもはや一致するグリフを生成しません。  Unicodeは左右のシングルクォーテーション・マーク・キャラクタ（U+2018とU+2019）を提供しています。Unicodeのマークアップが利用可能であると仮定できない場合、アポストロフィを非方向シングルクォーテーション・マークとして使用するのが良い方法と思われます。同様に、Unicodeには左右のダブルクォーテーション・マーク文字(U+201CとU+201D)があります。ASCIIのタイプライターの特性しか使えない場合は、ASCIIのクォーテーション・マーク(0x22)を左右両方のダブルクォーテーション・マークとして使うべきです。  TeXはグレイヴとアポストロフィを方向シングルクォーテーションに使用し、ダブルグレイヴとダブルアポストロフィを方向ダブルクォーテーションに使用します。どのレンダリングが使用されるかはqに依存し、デフォルトではuseFancyQuotesのオプション設定に依存します。  これがFALSEの場合、無指向性のASCII引用符スタイルが使用されます。  UTF-8 "に設定すると、UTF-8マークアップが使用されます（現在のロケールが何であれ）。TeX "に設定すると、TeXスタイルのマークアップが使われます。  最後に、これが長さ 4 の文字ベクトルに設定された場合、最初の 2 つのエントリが開始と終了のシングルクォートに、後の 2 つが開始と終了のダブルクォートに使用されます: これは、ギルメットの使用など、英語以外のクォート規則を実装するために使用できます。
srcfile関数は、ソース・コード・ファイルの名前とディレクトリ、およびタイムスタンプを含むsrcfileクラスのオブジェクトを生成し、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーで使用します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含む srcfile クラスのオブジェクトを生成し、ソース・レベルのデバッグ（未実装）やソース・エコーに使用します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーに使用するソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むクラス srcfile のオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーに使用するソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むクラス srcfile のオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについてはfileを、プラットフォームで許可されるエンコーディングの一覧についてはiconvlistを参照してください。srcfilecopy関数は、子孫クラスsrcfilecopyのオブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で印刷された場合、<srcref: ...> レコードが印刷されます。isOpen は内部的な使用を目的としており、srcfile オブジェクトに関連付けられた接続が開いているかどうかをチェックします。
standardGenericは、fという名前のジェネリック関数に対して定義されたメソッドを、呼び出されるフレーム内の実際の引数を使ってディスパッチします。引数fdefは、プリミティブ関数のメソッドをディスパッチする際に（自動的に）挿入されます。  引数fdefはプリミティブ関数のメソッドをディスパッチする時に（自動的に）挿入されます。  この引数を手で挿入しないでください。妥当性チェックがなく、関数定義の指定ミスは失敗の原因になります。
このコードには、接頭辞または接尾辞の長さが1である最も一般的な使用法に対して最適化された分岐があり、ASCII文字列の場合はUTF-8または8バイトのロケールでさらに最適化されます。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに 対応する標準接続である（ファイル・ストリームとは限らない）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれない。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンクのダイバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれない。
stdin()、stdout()、stderr()は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイル・ストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンク・ディバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  これは、GUIコンソールを含む組み込みアプリケーションでは信頼できないかもしれません。
エラーの動作は、実行中のコード内で確立されたエラーハンドラと、options(error=)によって設定された現在のデフォルトのエラーハンドラによって制御される。  エラーはまず、ingsignalCondition() を使用するかのようにシグナルされます。  ハンドラがない場合、またはすべてのハンドラが返された場合、エラー・メッセージが出力され（options("show.error.messages")がtrueの場合）、デフォルトのエラー・ハンドラが使用されます。  対話的な使用におけるデフォルトの動作(NULLerrorハンドラ)は、トップ・レベルのプロンプトまたはトップ・レベルのブラウザに戻ることであり、非対話的な使用では、(効果的に)q("no", status = 1, runLast = FALSE)を呼び出すことである。デフォルト・ハンドラは、エラー・メッセージをバッファに格納する。  エラーは、getOption("warning.length")文字数（デフォルト1000）に切り詰められます。条件オブジェクトが提供された場合、それは唯一の引数でなければならず、それ以上の引数は警告とともに無視されます。
この関数は、特に読みやすくするために、回帰テストや関数の引数チェックで使用することを意図しています。stopifnot(A, B)、または同等のstopifnot(exprs= {A ; B})は、概念的に次のものと同等です。 Rバージョン3.6.0以降、stopifnot()は、各単一の式に対して潜在的なエラーや警告を(tryCatch()などで)処理しなくなり、式がすべてTRUEに評価されなかった場合に意味のある短いエラーメッセージを得るためにsys.call(<n>)を使用することができます。  Rバージョン3.5.0以降、式は逐次的に評価されるため、上記の概念的等価文が示すように、「非TRUE」があるとすぐに評価が停止します。また、Rバージョン3.5.0以降では、stopifnot(exprs = { ... })も代替的に使用でき、複数の式の場合には、対話的に評価する方が便利であるため、好ましいかもしれません（"余計な ," はありません）。Rバージョン3.4.0以降では、（...からの）式が真ではなく、all.equal(*)の呼び出しである場合、エラーメッセージは、all.equal(*)によって報告された差の（最初の部分）を報告します。
modeとstorage.modeはどちらも、オブジェクトの(記憶)モードを文字列で返します-多くの場合同じです-どちらもtypeof(x)の出力に依存します。  これは、適切なas.newmode関数、例えば "logical"、"integer"、"double"、"complex"、"raw"、"character"、"list"、"expression"、"name"、"symbol"、"function "が存在する場合にのみサポートされます。  storage.mode(x)<-"newmode "はmode<-のより効率的なプリミティブバージョンで、内部型（typeofを参照）の一つである "newmode "では機能するが、"single "では機能しない。  ストレージモード "single "はRの擬似モードに過ぎないので、modeやstorage.mode: useattr(object, "Csingle")では報告されない。  しかし、mode<-を使用してモードを "single "に設定することができ、これは実際のモードを "double "に設定し、"Csingle "属性をTRUEに設定します。  他のモードを設定すると、この属性は削除される。（以下の例では）いくつかの呼び出しは、S互換であるmode"("を持つことに注意。
modeとstorage.modeはどちらも、オブジェクトの（ストレージ）モードを文字列で返す。  これは、適切なas.newmode関数、例えば "logical"、"integer"、"double"、"complex"、"raw"、"character"、"list"、"expression"、"name"、"symbol"、"function "が存在する場合にのみサポートされます。  storage.mode(x)<-"newmode "はmode<-のより効率的なプリミティブバージョンで、内部型（typeofを参照）の一つである "newmode "では機能するが、"single "では機能しない。  ストレージモード "single "はRの擬似モードに過ぎないので、modeやstorage.mode: useattr(object, "Csingle")では報告されない。  しかし、mode<-を使用してモードを "single "に設定することができ、これは実際のモードを "double "に設定し、"Csingle "属性をTRUEに設定します。  他のモードを設定すると、この属性は削除される。（以下の例では）S互換のmode"("を持つ呼び出しがあることに注意。
Rのすべてのバージョンは、行末がLF（Unixで使用）、CRLF（DOS/Windowsで使用）、CR（クラシックMac OSで使用）でマークされた接続からの入力を受け付ける。  コンソールから入力を受ける場合、n = NULLはton = 1と等価であり、n < 0はEOF文字が読まれるまで読み込まれる。  (EOF文字はWindowsフロントエンドではCtrl-Zである。) コンソールから読み込む場合、行の長さの上限は4095バイトである(下限が課される場合もある: 'R入門'を参照)。srcfileのデフォルトは以下のように設定されている。  keep.sourceがTRUEでない場合、srcfiledのデフォルトは文字列で、"<text>"またはfileから派生した文字列です。  keep.source が TRUE の場合、text が使用されると、srcfile は text を含む asrcfilecopy に設定されます。  srcfile が文字列の場合、エラーメッセージには名前が含まれますが、ソース参照情報は結果に追加されません。  srcfile が srcfile オブジェクトの場合、ソース参照情報は保持されます。文字ベクトルの場合、str2expression(s) は toparse(text = s, keep.source=FALSE) に対応します。文字列の場合、str2lang(s)は、toparse(text = s, keep.source=FALSE)[[1]]に対応します（さらに、sとparse(*)結果の両方が長さ1であることをチェックします）。  別の言い方をすると、str2lang(.)の値は呼び出しかその一部、要するに "呼び出しかもっと単純なもの "です。現在のところ、エンコーディングはstr2lang()とstr2expression()では扱われていません。
Rのすべてのバージョンは、LF（Unixで使用）、CRLF（DOS/Windowsで使用）またはCR（古典的なMac OSで使用）でマークされた行末を持つ接続からの入力を受け付ける。  コンソールから入力を受ける場合、n = NULLはton = 1と等価であり、n < 0はEOF文字が読まれるまで読み込まれる。  (EOF文字はWindowsフロントエンドではCtrl-Zである。) コンソールから読み込む場合、行の長さの上限は4095バイトである(下限が課される場合もある: 'R入門'を参照)。srcfileのデフォルトは以下のように設定されている。  keep.sourceがTRUEでない場合、srcfiledのデフォルトは文字列で、"<text>"またはfileから派生した文字列です。  keep.source が TRUE の場合、text が使用されると、srcfile は text を含む asrcfilecopy に設定されます。  srcfile が文字列の場合、エラーメッセージには名前が含まれますが、ソース参照情報は結果に追加されません。  srcfile が srcfile オブジェクトの場合、ソース参照情報は保持されます。文字ベクトルの場合、str2expression(s) は toparse(text = s, keep.source=FALSE) に対応します。文字列の場合、str2lang(s)は、toparse(text = s, keep.source=FALSE)[[1]]に対応します（さらに、sとparse(*)結果の両方が長さ1であることをチェックします）。  別の言い方をすると、str2lang(.)の値は呼び出しかその一部、要するに "呼び出しかもっと単純なもの "です。現在、エンコーディングはstr2lang()とstr2expression()では扱われていません。
formatメソッドとas.characterメソッド、そしてstrftimメソッドは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換する。strftimeはformat.POSIXltのラッパーであり、format.POSIXctはまずas.POSIXltを呼び出してクラス "POSIXlt "に変換します（したがって、これらはクラス "Date "でも動作します）。  xとformatには、通常のベクトルの再循環規則が適用されるため、答えはこれらのベクトルのうち長い方の長さになる。  これは、LC_TIMEロケールカテゴリの設定によって、日や月の名前、AM/PMインジケータ（使用されている場合）、%xや%Xなどの出力書式のセパレータに影響します。  説明の'currentlocale'は、Rセッションの開始時またはこれらの関数が最初に使用された時に使用されているロケールを意味する。  (入力の場合、ロケール固有の変換は、LC_TIME (またはLC_ALL)カテゴリでSys.setlocaleを呼び出すことで変更できる。  変換指定は%で導入され、通常はその後に1文字、またはOかE、そして1文字が続く。  変換指定の一部でない書式文字列の文字は、文字通りに解釈されます（そして、%%は%%を与えます）。  広く実装されている変換指定には、このプラットフォームの現在のロケールでの曜日名の省略形があります。  (入力時のフルネームにもマッチする。ロケールによっては、名前の省略形がないものもある。)現在のロケールでの完全な曜日名。  (入力時の省略形名とも一致します。)このプラットフォーム上の現在のロケールにおける月名の省略形。  (入力時のフルネームとも一致する。ロケールによっては省略形がないものもある。)現在のロケールにおける完全な月名。  (入力時には省略形にもマッチする。)日付と時刻。   センチュリー（00-99）：西暦を100で割った整数部分。10進数としての月日（01-31）。%m/%d/%yのような日付書式：C99標準では、この書式に忠実であるべきとされている（ただし、すべてのOSが準拠しているわけではない）。Y-%m-%d（ISO8601の日付書式）に相当する。  (入力時は無視される。)10進数としての週ベースの年(%Vを参照)。  (入力時に無視されますが受け入れられます。)%b.Hours as decimal number (00-23)に相当します。  特別な例外として、ISO 8601では24:00:00のような文字列が許可されているため、入力として受け入れられる：  出力時には改行、入力時には任意の空白文字。  Iとは併用され、%Hとは併用されない。  一部のロケールでは空文字列となる（例えば、一部のOS、ロシアを含む非英語欧州ロケール）。このようなロケールで入力に使用された場合の動作は未定義である。プラットフォームによっては、小文字変換を使用する出力に%Pを受け付けるものもある（%pも小文字を使用することがある）。秒を整数 (00-61) で表し、うるう秒を2つまで許容する (ただし、POSIX準拠の実装ではうるう秒は無視される)。出力時にはタブ、入力時には任意の空白。  1月1日を含む週（月曜始まり）が新年に4日以上ある場合、その週は第1週とみなされる。  そうでない場合は前年の最終週となり、次の週が第1週となる。  (曜日は10進数（0～6、日曜日は0）、週は10進数（00～53）で、月曜日を週の初日とする（通常、その年の最初の月曜日を第1週の第1日目とする）。  英国の慣習。  出力時はロケール固有、入力時は"%y/%m/%d"。  出力時はロケール固有、入力時は"%H:%M:%S"。  入力では、00から68の値の先頭に20が、69から99の値の先頭に19が付きます。これは2018年のPOSIX標準によって指定された動作ですが、「将来のバージョンでは、2桁の年から推測されるデフォルトの世紀が変更されることが予想される」とも書かれています。  元のグレゴリオ暦にはゼロがなかったが、ISO 8601:2004ではゼロが有効であると定義されていることに注意すること（1BCと解釈される）：https://en.wikipedia.org/wiki/0_(year)を参照のこと。  入力については、年0:9999のみが受け入れられる。符号のオフセットはUTCから時分単位で、-0800はUTCから8時間遅れとなる。最大値は+1400。  (標準は出力のみ。  (出力のみ。) タイムゾーンの略称を1文字文字列で指定(利用できない場合は空)。  先頭のゼロが表示されている場合、出力時には使用されるが、入力時にはオプションである。  名前は、入力時には大文字小文字を区別せずにマッチングされる。出力時に大文字になるかどうかは、プラットフォームとロケールに依存する。  略称はプラットフォーム固有であることに注意してください（標準では、Cロケールでは大文字で表記された英語名の最初の3文字でなければならないと規定されていますが：この規約は英語のロケールでは広く使われていますが、例えばフランス語の月の略称はLinux、macOS、Solaris、Windowsのどれでも同じではありません）。入力フォーマットの一部として%a、%b、%hを使いたい場合は、省略形が何であるかを知っておくことが重要です。タイムゾーンが割り当てられているオブジェクトの出力に%zまたは%Zが使われた場合、そのタイムゾーンの値を使おうと試みますが、必ず成功するとは限りません。標準にはなく、あまり広く実装されていないのは、24時間時計の時刻で、1桁の前に空白が入ります。ロケールに依存する可能性がある。出力には、ロケールに依存した別の書式（ローマ数字など）で数字を出力する%O[dHImMUVwWy]や、別の「時代」（別の宗教暦など）を使うことができる%E[cCyYxX]もある。  どれがサポートされるかはOSに依存する。  Rに特有なのは%OSnで、これは出力時に小数点以下0 <= n <= 6桁に切り詰めた秒を与える（そして、%OSの後に桁が続かない場合は、getOption("digits.secs")の設定を使うか、それが未設定の場合はn = 0となる）。  さらに、strptimeの場合、%OSは端数秒を含む秒を入力する。  Sは、出力で端数部分を読まないことに注意してください。他の変換指定の動作は（また、%で始まる他の文字シーケンスが変換指定であっても）システム固有である。  システムによっては、フォーマットでのマルチバイト文字の使用がサポートされていないことを文書化しているものもあります：UTF-8ローカライズが問題になる可能性は低い。
formatメソッドとas.characterメソッド、そしてstrftimメソッドは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換する。strftimeはformat.POSIXltのラッパーであり、format.POSIXctはまずas.POSIXltを呼び出してクラス "POSIXlt "に変換します（したがって、これらはクラス "Date "でも動作します）。  xとformatには、通常のベクトルの再循環規則が適用されるため、答えはこれらのベクトルのうち長い方の長さになる。  これは、LC_TIMEロケールカテゴリの設定によって、日や月の名前、AM/PMインジケータ（使用されている場合）、%xや%Xなどの出力書式のセパレータに影響します。  説明の'currentlocale'は、Rセッションの開始時またはこれらの関数が最初に使用された時に使用されているロケールを意味する。  (入力の場合、ロケール固有の変換は、LC_TIME (またはLC_ALL)カテゴリでSys.setlocaleを呼び出すことで変更できる。  変換指定は%で導入され、通常はその後に1文字、またはOかE、そして1文字が続く。  変換指定の一部でない書式文字列の文字は、文字通りに解釈されます（そして、%%は%%を与えます）。  広く実装されている変換指定には、このプラットフォームの現在のロケールでの曜日名の省略形があります。  (入力時のフルネームにもマッチする。ロケールによっては、名前の省略形がないものもある。)現在のロケールでの完全な曜日名。  (入力時の省略形名とも一致します。)このプラットフォーム上の現在のロケールにおける月名の省略形。  (入力時のフルネームとも一致する。ロケールによっては省略形がないものもある。)現在のロケールにおける完全な月名。  (入力時には省略形にもマッチする。)日付と時刻。   センチュリー（00-99）：西暦を100で割った整数部分。10進数としての月日（01-31）。%m/%d/%yのような日付書式：C99標準では、この書式に忠実であるべきとされている（ただし、すべてのOSが準拠しているわけではない）。Y-%m-%d（ISO8601の日付書式）に相当する。  (入力時は無視される。)10進数としての週ベースの年(%Vを参照)。  (入力時に無視されますが受け入れられます。)%b.Hours as decimal number (00-23)に相当します。  特別な例外として、ISO 8601では24:00:00のような文字列が許可されているため、入力として受け入れられる：  出力時には改行、入力時には任意の空白文字。  Iとは併用され、%Hとは併用されない。  一部のロケールでは空文字列となる（例えば、一部のOS、ロシアを含む非英語欧州ロケール）。このようなロケールで入力に使われた場合の動作は未定義である。いくつかのプラットフォームでは、小文字変換を使う%Pを出力に受け付ける（%pも小文字を使うことがある）。秒を整数 (00-61) で表し、うるう秒を2秒まで許容する (ただし、POSIX準拠の実装ではうるう秒は無視される)。  1月1日を含む週（月曜始まり）が新年に4日以上ある場合、その週は第1週とみなされる。  そうでない場合は前年の最終週となり、次の週が第1週となる。  (曜日は10進数（0～6、日曜日は0）、週は10進数（00～53）で、月曜日を週の初日とする（通常、その年の最初の月曜日を第1週の第1日目とする）。  英国の慣習。  出力時はロケール固有、入力時は"%y/%m/%d"。  出力時はロケール固有、入力時は"%H:%M:%S"。  入力では、00から68の値の先頭に20が、69から99の値の先頭に19が付きます。これは2018年のPOSIX標準によって指定された動作ですが、「将来のバージョンでは、2桁の年から推測されるデフォルトの世紀が変更されることが予想される」とも書かれています。  元のグレゴリオ暦にはゼロがなかったが、ISO 8601:2004ではゼロが有効であると定義されていることに注意すること（1BCと解釈される）：https://en.wikipedia.org/wiki/0_(year)を参照のこと。  入力については、年0:9999のみが受け入れられる。符号のオフセットはUTCから時分単位で、-0800はUTCから8時間遅れとなる。最大値は+1400。  (標準は出力のみ。  (出力のみ。) タイムゾーンの略称を1文字文字列で指定(利用できない場合は空)。  先頭のゼロが表示されている場合、出力時には使用されるが、入力時にはオプションである。  名前は、入力時には大文字小文字を区別せずにマッチングされる。出力時に大文字になるかどうかは、プラットフォームとロケールに依存する。  略称はプラットフォーム固有であることに注意してください（標準では、Cロケールでは大文字で表記された英語名の最初の3文字でなければならないと規定されていますが：この規約は英語のロケールでは広く使われていますが、例えばフランス語の月の略称はLinux、macOS、Solaris、Windowsのどれでも同じではありません）。入力フォーマットの一部として%a、%b、%hを使いたい場合は、省略形が何であるかを知っておくことが重要です。タイムゾーンが割り当てられているオブジェクトの出力に%zまたは%Zが使われた場合、そのタイムゾーンの値を使おうと試みますが、必ず成功するとは限りません。標準にはなく、あまり広く実装されていないのは、24時間時計の時刻で、1桁の前に空白が入ります。ロケールに依存する可能性がある。出力には、ロケールに依存した別の書式（ローマ数字など）で数字を出力する%O[dHImMUVwWy]や、別の「時代」（別の宗教暦など）を使うことができる%E[cCyYxX]もある。  どれがサポートされるかはOSに依存する。  Rに特有なのは%OSnで、これは出力時に小数点以下0 <= n <= 6桁に切り詰めた秒を与える（そして、%OSの後に桁が続かない場合は、getOption("digits.secs")の設定を使うか、それが未設定の場合はn = 0となる）。  さらに、strptimeの場合、%OSは端数秒を含む秒を入力する。  Sは、出力で端数部分を読まないことに注意してください。他の変換指定の動作は（また、%で始まる他の文字シーケンスが変換指定であっても）システム固有である。  システムによっては、フォーマットでのマルチバイト文字の使用がサポートされていないことを文書化しているものもあります：UTF-8のローカライズが問題になる可能性は低い。
xとtimesの要素は必要に応じて再利用される（一方に要素がない場合は、空の文字ベクトルが返される）。  xまたはtimesの要素が欠落すると、返り値の要素も欠落する。
引数splitはcharacterに強制されるため、以下の例を含め、split = character(0)を意味するsplit = NULLが使用されます。  ここでの「文字」の定義はロケールに依存します。シングルバイトロケールではバイトであり、マルチバイトロケールでは「ワイド文字」（ほとんど常にUnicodeコードポイント）で表される単位です。各入力文字列に適用されるアルゴリズムは次のとおりである。これは、(空でない) 文字列の先頭にマッチがある場合、出力の最初の要素は "" であることを意味するが、文字列の末尾にマッチがある場合は、マッチを取り除いたものと同じものが出力されることを意味する。
デフォルトのbase = 0Lの場合、xの要素の文字列表現からベースが選択されるので、異なる要素は異なるベースを持つことができる（最初の例を参照）。  8進数定数（接頭辞0にxまたはXをつけない）と16進数定数（接頭辞0xまたは0X）は基数8と16として解釈され、それ以外の文字列は基数10として解釈される。
Width」は等幅フォントでの表示幅として解釈される。  印字不可能な文字（バックスペースやタブなど）がどうなるかは実装依存であり、ロケールに依存する可能性があります（カウントに含まれる場合もあれば、省略される場合もあります）。文字ベクトルに全角文字（中国語/日本語/韓国語など）が含まれる可能性がある場合は、substrではなくこの関数を使用することが重要です。
クラス "factor "を追加することで、数値コードに整数の記憶モードが与えられることが保証されます。歴史的な理由から（これらの名前はデパース時に使用されます）、属性".Dim"、".Dimnames"、".Names"、".Tsp "および".Label "は、"dim"、"dimnames"、"names"、"tsp "および "level "に名前が変更されます。  属性を割り当てる他の方法と同様に、tag = NULLを使用すると、属性タグが存在する場合は.Dataから削除されます。
入力中の空白文字（スペース、タブ、改行文字）は破棄されます。  ピリオド、クエスチョンマーク、説明マーク（文末を表すと考えられる）の後のダブルスペースは保持されます。現在のところ、改行位置での文末の可能性は特に考慮されていません。
文字列または文字ベクトルであるべき引数は、可能であれば文字に強制されます。これらの関数は、それぞれ3つのモードのいずれかで動作します: fixed = TRUE: 完全一致を使用します。2拡張正規表現(デフォルト)。2つの*sub関数の違いは、subがパターンの最初の出現だけを置き換えるのに対し、gsubはすべての出現を置き換えるという点だけです。  regexpr、gregexpr、regexec、gregexecでは、patternがNAであるとエラーとなり、そうでなければNAが許され、NAマッチとなる。useBytes = TRUEの主な効果は、マルチバイト・ロケールでの無効な入力や偽のマッチに 関するエラーや警告を回避することですが、regexprでは出力の解釈を変更します。  ケースレスマッチングは、マルチバイトのロケールではバイトに対してあまり意味をなさない。非ASCII文字に対するperl = TRUEでのケースレスマッチングは、PCREライブラリが'Unicodepropertyサポート'でコンパイルされているかどうかに依存します。
これは汎用の関数で、行列、データフレーム、ベクトル（リストを含む）用の メソッドが提供されています。  通常のベクトルの場合、結果は単純にx[subset & !is.na(subset)]となります。データフレームの場合、subset引数は行に対して動作します。  データ・フレームでは、subset 引数は行に作用します。subset はデータ・フレームで評価されるので、列は式の変数として (名前で) 参照できます (例を参照)。  select引数は、データフレームと行列のメソッドにのみ存在します。この引数は、まずselection式の列名をデータフレームの対応する列番号に置き換え、次に結果の整数ベクトルを使用して列のインデックスを作成します。  これにより、標準のインデックス作成規約を使用できるようになり、例えば、列の範囲を簡単に指定したり、単一の列を削除したりできます (例を参照してください)。drop 引数は、インデックス作成メソッドのフォーマットである行列とデータ・フレームに渡されます。  データ・フレームからすべての未使用レベルを削除する方法については、droplevels を参照してください。
これは汎用関数で、行列、データ・フレーム、ベクトル（リストを含む）用のメソッドが提供されています。  通常のベクトルの場合、結果は単純にx[subset & !is.na(subset)]です。データフレームの場合、subset引数は行に対して動作します。  データ・フレームでは、subset 引数は行に作用します。subset はデータ・フレームで評価されるので、列は式の変数として (名前で) 参照できます (例を参照)。  select引数は、データフレームと行列のメソッドにのみ存在します。この引数は、まずselection式の列名をデータフレームの対応する列番号に置き換え、次に結果の整数ベクトルを使用して列のインデックスを作成します。  これにより、標準のインデックス作成規約を使用できるようになり、例えば、列の範囲を簡単に指定したり、単一の列を削除したりできます (例を参照してください)。drop 引数は、インデックス作成メソッドのフォーマットである行列とデータ・フレームに渡されます。  データ・フレームからすべての未使用レベルを削除する方法については、droplevels を参照してください。
これは汎用関数で、行列、データ・フレーム、ベクトル（リストを含む）用のメソッドが提供されています。  通常のベクトルの場合、結果は単純にx[subset & !is.na(subset)]です。データフレームの場合、subset引数は行に対して動作します。  データ・フレームでは、subset 引数は行に作用します。subset はデータ・フレームで評価されるので、列は式の変数として (名前で) 参照できます (例を参照)。  select引数は、データフレームと行列のメソッドにのみ存在します。この引数は、まずselection式の列名をデータフレームの対応する列番号に置き換え、次に結果の整数ベクトルを使用して列のインデックスを作成します。  これにより、標準のインデックス作成規約を使用できるようになり、例えば、列の範囲を簡単に指定したり、単一の列を削除したりできます (例を参照してください)。drop 引数は、インデックス作成メソッドのフォーマットである行列とデータ・フレームに渡されます。  データ・フレームからすべての未使用レベルを削除する方法については、droplevels を参照してください。
これは汎用関数で、行列、データ・フレーム、ベクトル（リストを含む）用のメソッドが提供されています。  通常のベクトルの場合、結果は単純にx[subset & !is.na(subset)]です。データフレームの場合、subset引数は行に対して動作します。  データ・フレームでは、subset 引数は行に作用します。subset はデータ・フレームで評価されるので、列は式の変数として (名前で) 参照できます (例を参照)。  select引数は、データフレームと行列のメソッドにのみ存在します。この引数は、まずselection式の列名をデータフレームの対応する列番号に置き換え、次に結果の整数ベクトルを使用して列のインデックスを作成します。  これにより、標準のインデックス作成規約を使用できるようになり、例えば、列の範囲を簡単に指定したり、単一の列を削除したりできます (例を参照してください)。drop 引数は、インデックス作成メソッドのフォーマットである行列とデータ・フレームに渡されます。  データ・フレームからすべての未使用レベルを削除する方法については、droplevels を参照してください。
以下のmyplotの例は、この機能の簡単な使用例を示しています。deparse関数とsubstitute関数を使用して、myplot関数の実際の引数の文字列バージョンであるプロットのラベルを作成します：envのバインドシンボルでなければ、変更される。  もしそれがpromiseオブジェクト、つまり関数の正式な引数であるか、delayedAssign()を使って明示的に作成されたものであれば、promiseの式スロットがシンボルを置き換えます。  envがGlobalEnvの場合はシンボルは変更されません。 quoteとsubstituteはどちらも引数を評価しない「特別な」プリミティブ関数です。
substringはSと互換性があり、startとstopの代わりにfirstとlastが指定されます。ベクトル引数の場合、長さがゼロの引数がなければ、引数を最も長い引数の長さまで循環的に展開します。抽出関数の場合、startが文字列の長さより大きければ""が返されます。  置換される部分が置換文字列よりも長い場合、文字列の長さの部分のみが置換されます。引数のいずれかがNAの要素である場合、答えの対応する要素はNAになります。対応する入力のエンコーディングがLatin-1またはUTF-8と宣言されており、 現在のロケールがLatin-1またはUTF-8である場合、結果の要素は現在のロケールの エンコーディングと宣言されます(Encodingを参照)。
substringはSと互換性があり、startとstopの代わりにfirstとlastを指定します。ベクトル引数の場合、長さがゼロのものがなければ、引数を最も長いものの長さに循環的に展開します。  置換される部分が置換文字列よりも長い場合、文字列の長さの部分のみが置換されます。引数のいずれかがNAの要素である場合、答えの対応する要素はNAになります。対応する入力のエンコーディングがLatin-1またはUTF-8と宣言されており、 現在のロケールがLatin-1またはUTF-8である場合、結果の要素は現在のロケールの エンコーディングと宣言されます(Encodingを参照)。
substringはSと互換性があり、startとstopの代わりにfirstとlastが指定されます。ベクトル引数の場合、長さがゼロのものがなければ、引数を最長引数の長さまで循環的に展開します。抽出の際、startが文字列長より大きければ"""が返されます。抽出関数の場合、xまたはtextがすでに文字列ベクトルでなければ、as.characterによって文字ベクトルに変換されます。  置換される部分が置換文字列よりも長い場合、文字列の長さの部分のみが置換されます。引数のいずれかがNAの要素である場合、答えの対応する要素はNAになります。対応する入力のエンコーディングがLatin-1またはUTF-8と宣言されており、 現在のロケールがLatin-1またはUTF-8である場合、結果の要素は現在のロケールの エンコーディングと宣言されます(Encodingを参照)。
substringはSと互換性があり、startとstopの代わりにfirstとlastが指定されます。ベクトル引数の場合、長さがゼロのものがなければ、引数を最長引数の長さまで循環的に展開します。抽出の際、startが文字列長より大きければ"""が返されます。抽出関数の場合、xまたはtextがすでに文字列ベクトルでなければ、as.characterによって文字ベクトルに変換されます。  置換される部分が置換文字列よりも長い場合、文字列の長さの部分のみが置換されます。引数のいずれかがNAの要素である場合、答えの対応する要素はNAになります。対応する入力のエンコーディングがLatin-1またはUTF-8と宣言されていて、現在のロケールがLatin-1またはUTF-8である場合、結果の要素は現在のロケールのエンコーディングとして宣言されます(Encodingを参照)。
na.rmがFALSEの場合、引数のいずれかにNAまたはNaN値があるとNAまたはNaNの値が返され、そうでなければNAまたはNaNの値は無視される。歴史的な理由から、NULLは受け入れられ、整数(0)であるかのように扱われる。異なる符号の値を合計すると、精度が損なわれることがある。これは、十分に長い整数入力でも、部分和が整数オーバーフローを引き起こす場合に発生することがある。  可能であれば、拡張精度アキュムレータが使用され、典型的にはC99以降でよくサポートされているが、プラットフォームに依存する可能性がある。
関数 summary.lm と summary.glm は、lm と glm によって生成された結果を要約する特定のメソッドの例である。
最初の11の関数は接続を作成します。  デフォルトでは、接続はオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。fileの記述は、オープンするファイルへのパス（チルダ展開が行われる場合）、完全なURL（url呼び出しと同じ場合）、または""（デフォルト）、または "clipboard"（「クリップボード」のセクションを参照）である。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
summary.lmとsummary.glm関数は、summary.lmとsummary.glmによって生成された結果を要約する特定のメソッドの例である。
S3メソッドを書くことができる4つのグループ、すなわち "Math"、"Ops"、"Summary"、"Complex "グループがあります。  これらはベースRのRオブジェクトではありませんが、メソッドを提供することができ、ベースRには最初の3つのグループのためのfactor、data.frame、difftimeメソッドがあります。  (Opsのorderedメソッド、MathとOpsのPOSIXtメソッドとDateメソッド、OpsとSummaryのpackage_versionメソッド、statsパッケージのOpsのtsメソッドもあります)。グループ "Math":abs、sign、sqrt、floor、ceiling、trunc、round、signifexp、log、expm1、log1p、cos、sin、tan、cospi、sinpi、tanpi、acos、asin、atancosh、sinh、tanh、acosh、asinh、atanhlgamma、gamma、digamma、trigammacumsum、cumprod、cummax、cumminこのグループのメンバはxに対してディスパッチします。  ほとんどのメンバは1つの引数しか受け付けないが、log、round、signifは1つまたは2つの引数を受け付け、truncは1つ以上の引数を受け付ける。グループ "Ops": "+", "-", "*", "/", "^", "%%", "%/%""&", "|", "!""==", "!=", "<", "<=", ">=", ">"このグループには、二項演算子と単項演算子（+, -, ！)：単項演算子に遭遇すると、Opsメソッドが1つの引数で呼び出され、e2が欠落します。このグループの任意のメンバーをディスパッチする際に、両方の引数のクラスが考慮されます。  各引数のクラスのベクトルは、一致する特定の（優先される）またはOpsメソッドがあるかどうかを確認するために検査されます。  異なるメソッドが見つかった場合、'互換性のないメソッド'についての警告が表示されます。比較演算子("Compare": ==, <, ...)および論理演算子("Logic": & | and !) のための data.frame メソッドは、利便性とバックコンパチビリティのために、データフレームの代わりに論理行列を返します。このグループのメンバが関数として呼び出される場合、位置マッチングが常に使用されるように、引数名は削除されます。グループ "Summary":all、anysum、prodmin、maxrangeこのグループのメンバは、最初に与えられた引数に対してディスパッチされる、fulfillingグループ "Complex":Arg, Conj, Im, Mod, Reこのグループのメンバーは、zにディスパッチする。内部コードはoldClassにディスパッチし、onclassにはディスパッチしないので、メソッドは、"class "属性に対応する場合のみ、これらのグループの1つまたはそのメンバーの1つに使用されることに注意。  Math "グループ・ジェネリック・メソッドのプリミティブ・メンバに提供された引数の数は、ディスパッチする前にチェックされません。グループ・ジェネリック関数の引数の遅延評価はありません。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。多くのメソッドの中から、いくつかのメソッドが個別にドキュメント化されています。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。また、いくつかのメソッドは個別にドキュメント化されています。
関数 summary.lm および summary.glm は、lm および glm によって生成された結果を要約する特定のメソッドの例です。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対して、round、 signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもある。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
関数 summary.lm および summary.glm は、lm および glm によって生成された結果を要約する特定のメソッドの例です。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、要素のレベル集合にレベルが出現する順序で、要素のレベル集合の和のレベルを持つ因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
因子の場合、最初の maxsum - 1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは"(Others) "で要約されます（最大でmaxsumの頻度になります）。関数summary.lmとsummary.glmは、lmとglmによって生成された結果を要約する特定のメソッドの例です。
数値バージョンは1つ以上の非負整数のシーケンスで、通常は（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使います。
ベクトル x の型は制限されません。as.character メソッドを持ち、ソート可能（byorder）である必要があります。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。R 4.1.0以降では、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、レベルが要素のレベル集合に出現する順序で、要素のレベル集合の和を持つ因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が間違っている場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：不明な場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が間違っている場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
proc.timeは後方互換性のために5つの要素を返しますが、そのprintメソッドは長さ3の名前付きベクトルを表示します。最初の2つのエントリは、現在のRプロセスと待機している子プロセスの合計ユーザーCPU時間とシステムCPU時間であり、3番目のエントリはプロセスが開始されてからの「実際の」経過時間です。
srcfile関数は、ソース・コード・ファイルの名前とディレクトリ、およびタイムスタンプを含むsrcfileクラスのオブジェクトを生成し、ソース・レベル・デバッグ（未実装）やソース・エコーで使用します。  ファイルのエンコーディングが保存されます。エンコーディングについてはfileを、プラットフォームで許可されるエンコーディングの一覧についてはiconvlistを参照してください。srcfilecopy関数は、子孫クラスsrcfilecopyのオブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close の各メソッドが定義されています。open メソッドは、特定の行の内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...> レコードが出力されます。
srcfile 関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーに使用するソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むクラス srcfile のオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)と解析された行(要素7, 8)は、 #lineディレクティブがコード内で使用されている場合、異なるかもしれません: 前者はディレクティブを尊重し、後者は単に行数をカウントします。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
引数 dnn が与えられない場合、内部関数 list.names が呼び出され、'dimname names' が計算されます。  ...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、除外された値をカウントしないように注意されています（以前はNAcountに含まれていました）。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(warningが生成される時点)の最大値であり、デフォルトでは50であることに注意。  たとえば、options(warn)が変更された場合や、致命的なエラーが発生した場合などです。
messageは、警告でもエラーでもない、「単純な」診断メッセージを生成するために使われます。  デフォルトのハンドラは、メッセージをstderr()接続に送ります。messageに条件オブジェクトを与える場合、引数はそれだけであるべきで、それ以上の引数は無視され、警告が表示されます。packageStartupMessageはその変種で、suppressPackageStartupMessagesによって個別にメッセージを抑制することができます。  (makeMessageはmessage、warning、stopで使われるユーティリティで、 ...引数からテキストメッセージを生成します。
messageは、警告でもエラーでもない「単純な」診断メッセージを生成するために使われます。  デフォルトのハンドラは、メッセージをstderr()接続に送ります。messageに条件オブジェクトを与える場合、引数はそれだけであるべきで、それ以上の引数は無視され、警告が表示されます。packageStartupMessageはその変種で、suppressPackageStartupMessagesによって個別にメッセージを抑制することができます。  (makeMessageはmessage、warning、stopで使われるユーティリティで、 ...引数から可能な翻訳（gettextを参照）と連結（セパレータなし）でテキストメッセージを生成します。）
結果は、options("warn")の値と、実行コードで確立されたハンドラに依存します。conditionオブジェクトが提供された場合、それは唯一の引数でなければならず、それ以上の引数は無視され、message.warningは、（事実上）ignalConditionを呼び出すことによって警告条件を通知します。  ハンドラがない場合、またはすべてのハンドラが返された場合、warn = getOption("warn")の値が適切なアクションを決定するために使用されます。  warnが負の場合、警告は無視され、0の場合、警告は保存され、トップレベル関数が終了した後に表示されます。1の場合、警告が発生したときに表示され、2（またはそれ以上）の場合、警告はエラーに変わります。warning(immediate.=TRUE)を呼び出すと、warn <= 0がwarn = 1に変換されます。warnが0（デフォルト）の場合、読み取り専用の変数last.warningが作成されます。  警告は、getOption("warning.length")文字数（デフォルト1000）に切り詰められ、[...truncated]で示されます。警告が処理されている間、muffleWarning restartが利用できます。  このリスタートがinvokeRestartで呼び出された場合、warningは即座に戻る。warningへの他のタイプの入力を文字ベクトルに強制する試みが行われる。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出さないでください。
特異値分解は多くの統計的手法で重要な役割を果たす。svdとLa.svdは戻り値が異なる2つのインターフェイスを提供する。特異ベクトルの計算は、大きな行列では遅い部分である。基礎となるLAPACKコードからうまくいかない結果は、正のエラーコード(多くの場合1)を与えるエラーとなる：これらはFORTRANコードの詳細な研究によって解釈することができるが、アルゴリズムが収束に失敗したことを意味する。
FUNは、match.funの呼び出しによって発見される。  FUNは2つの引数の関数であるべきです：それは引数xとapermによってSTATSから生成された同じ次元の配列で呼び出されます。STATS、MARGIN及びxの間の整合性検査は、STATSがベクトルである場合よりも配列である場合の方が厳しくなります。  STATSがベクトルで、再利用が発生した場合に警告を出したい場合は、sweep(x, MARGIN, as.array(STATS))を使用してください。
EXPRの値が文字列でない場合、それは整数に強制されます。  EXPRの値が文字列でない場合、強制的に整数に変換される。これは、通常、文字レベルを意味するため、警告を伴って因数の場合にも起こることに注意。  EXPRが文字列として評価された場合、その文字列は...の要素名と(正確に)マッチします。  一致した場合は、その要素が評価されます。ただし、その要素が欠落している場合は、欠落していない次の要素が評価されます。例えば、switch("cc", a = 1, cc =, cd =, d = 2)は2と評価されます。  一致する要素が複数ある場合は、最初に一致した要素が使用される。  マッチしない場合、...の名前のない要素があれば、その値が返される。  (そのような引数が複数ある場合は、エラーが通知されます。)最初の引数は、常にEXPRとみなされます: 名前が付けられている場合、その名前は(部分的に)一致しなければなりません。これは通常コーディングエラーであるため、代替案が提供されていない場合は警告が通知されます。
sys.call、sys.function、sys.frameは引数whichに整数値を受け付けます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックは1ずつ増加します。呼び出し、関数定義、およびその関数の評価環境は、sys.call、sys.function、sys.frameによって適切なインデックスとともに返されます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)はsys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
dir.existsは、(file.existsと同じ意味で)パスが存在し、ディレクトリであることをチェックします。dir.createは、recursive = TRUEでない限り、パスの最後の要素を作成します。  モードは、システム関数mkdirと同じように、umaskの設定によって変更される。  どのようなモードが設定できるかはOS依存であり、3桁以上のオクタルディジットが使用されると仮定するのは危険である。  Windowsの特異性のひとつに、ディレクトリの作成が成功したと報告しても、別の名前のディレクトリが作成されることがある（例：dir.create("G.S.")は'"G.S"'を作成する）。  これは文書化されており、正確な状況は不明である（Windowsのバージョンに依存するかもしれない）。  Sys.chmodは、1つまたは複数のファイルのパーミッションを設定する。システムによってはサポートされていない場合がある（警告が出る場合）。モードがどのように解釈されるかについては、dir.createのコメントを参照のこと。  シンボリックリンクでモードを変更することは（必要でも）ないでしょう。詳細については、システムコールのchmodに関するOSのドキュメント、例えばman 2 chmodを参照してください（この名前のコマンドラインユーティリティのものではありません）。  シンボリックリンクのパーミッションを変更するか、ターゲットを変更するかはOSに依存します（ターゲットを変更する方が一般的ですが、POSIXはシンボリックリンクのモードをサポートしていません）：Sys.umaskはumaskを設定し、以前の値を返す。特殊なケースとして、mode = NAは現在の値を返すだけである。  詳細については、システムコールのumaskに関するOSのドキュメント、例えばman 2 umaskを参照のこと。モードがどのように扱われるかは、Unix系であってもファイルシステムによって異なる（ただし、それらのドキュメントはPOSIXファイルシステムを想定して書かれていることが多い）。  そのため、例えばFAT/FAT32やネットワークマウントされたファイルシステムを使用している場合は、ドキュメントを慎重に扱ってください。マークされたエンコーディングのファイルパスがどのように解釈されるかは、ファイルを参照してください。  
Sys.timeは、様々なタイムゾーンに変換することができ、異なる日を返すかもしれない絶対日付時刻値を返します。
sys.call、sys.function、およびsys.frameは、引数whichに整数値を受け入れます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックは1ずつ増加します。呼び出し、関数定義、およびその関数の評価環境は、sys.call、sys.function、sys.frameによって適切なインデックスとともに返されます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックは1ずつ増加します。呼び出し、関数定義、およびその関数の評価環境は、sys.call、sys.function、sys.frameによって適切なインデックスとともに返されます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
unset=NAに設定すると、OSが設定されていない変数と""に設定された変数を区別できるようになります。  POSIXはOSに区別を要求しており、現在知られているRプラットフォームはすべて区別している。
初期状態では、Rのロケールのほとんどの部分は "C "に設定されている（これはC言語のデフォルトであり、北米の慣習を反映したもので、"POSIX "としても知られている）。  Rは "LC_CTYPE "と "LC_COLLATE "を設定する。"LC_CTYPE "と "LC_COLLATE "は、異なる文字セットの使用と、その文字セットでのアルファベット比較（ソートの使用を含む）を許可する。"LC_MONETARY"（Sys.localeconvで使用）と "LC_TIME "は、as.POSIXltとstrptime、およびそれらを使用する関数の動作に影響を与える可能性がある（dateは影響しない）。  「LC_MESSAGES "は、メッセージ変換をサポートしていないシステムでは "C "となり、Windowsではサポートされていない。  カテゴリー "LC_ALL "を設定すると、カテゴリー "LC_COLLATE"、"LC_CTYPE"、"LC_MONETARY "および "LC_TIME "のみが設定されることに注意。  OSによって、警告が表示される場合とされない場合がある。セッション中に文字セットを変更しようとしても（異なる文字セットを意味する場合は、Sys.setlocale("LC_CTYPE")によって）うまくいかないことがあり、混乱を招く可能性が高い。ほとんどのRプラットフォームでは、メッセージ変換の言語を選択する際に、環境変数LANGUAGEが "LC_MESSAGES "より優先されることに注意。  Windowsを除き、初期設定は "LC_COLLATE "カテゴリから取得され、Sys.setlocaleの呼び出しによって変更されるとリセットされる。
NA
ファイルパス中のチルダ（チルダ展開参照）とワイルドカードを展開する。ワイルドカード展開の正確な詳細については、 globシステム・コールに関するyoursystemのドキュメントを参照のこと。  POSIX 1003.2標準（https://pubs.opengroup.org/onlinepubs/9699919799/functions/glob.html を参照）があるが、OSによってはこれを超えるものもある。すべてのシステムは、*（0文字以上にマッチ）、? （1文字にマッチ）、（おそらく）[ （文字のクラスまたは範囲を開始）を解釈すべきである。  区切り文字を含むパス送りの扱いは、システムに依存する。  POSIX-2008準拠のOSでは、セパレータは(ディレクトリにのみ)マッチするが、 Windowsでは有効なファイルパスではないので、何もマッチしない。  (.で始まるファイル名の場合、明示的にマッチさせる必要がある場合があります。例えば、Sys.glob("*.RData")は'.RData'にマッチする場合としない場合がありますが、通常は'.aa.RData'にはマッチしません。  例えばSolarisでは、Sys.glob("*.*") は '.' と '..' にマッチします。  ...]の最初の文字が!]でない場合、これは文字クラスで、指定された文字のいずれかと1文字をマッチさせます。  クラスが空であることは許されないので、[...]が最初の文字であ れば、[...]を含めることができる。  最初の文字が ! の場合、文字クラスは指定された文字のどれでもない1文字にマッチします。  文字クラスの.がファイル名の先頭の.とマッチするかどうかはOSに依存します。文字クラスは[A-Z]のような範囲を含むことができます。  (範囲の解釈はロケールに固有であるべきなので、この例はエストニアのロケールでは良いアイデアではない。) ?, *,[ の前にバックスラッシュを置くことで、特別な意味を取り除くことができる(文字クラス内を除く)。
これはPOSIXまたはWindowsのシステムコールを使用する。  Sys.info()はRが実行されているプラットフォームの詳細を返し、R.versionはRが構築されたプラットフォームの詳細を返す。
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、基本的に[[ 演算子と同等です。  これは、オブジェクトにデフォルト・メソッドを適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  getRequiredPackages2は、Dependsフィールドで言及されたすべてのパッケージをアタッチします。  .getRequiredPackagesは、'DESCRIPTION'ファイルを使用した.getRequiredPackages2のラッパーです。.isMethodsDispatchOn()関数は、S4メソッドディスパッチが(通常はパッケージメソッドをロードすることによって)評価器でオンになっている場合にTRUEを返します。  sys.save.imageはq()とそのGUIアナログから呼び出されるシステム関数です。sys.load.imageはスタートアップ・コードから呼び出されます。これらの関数は直接呼び出されるべきではなく、変更される可能性があります。  .set_row_names(n)は、attr(<a data frame>, "row.names")に代入される、長さnの自動的な行名を生成します。  .row_names_infoは、データフレームの行名の内部形式に関する情報を与えます。どのような情報かについては、引数の型を参照してください。.GenericArgsEnvと.ArgsEnvは、プリミティブがクロージャであった場合の引数リストを持つクロージャを含む環境です。  内部S3ジェネリックである全てのプリミティブは.GenericArgsEnvの対応するメンバーを持っており、残りの非言語要素プリミティブは.ArgsEnvに対応しています。  詳細は'R Internals'マニュアルを参照してください。  これらはargsとprint.defaultとQC関数codocとcheckS3methodsで使用されます。.findPackageEnvはunserializeコードで呼び出され、可能であれば保存された環境を設定します。.TAOCP1997initは "Knuth-TAOCP "RNGの初期化コードです。.gtと.gtnはrankとisからのコールバックです。.primTraceと.primUntraceは、それぞれtraceとuntraceの基礎となるプリミティブ関数です。.Date、.POSIXct、.POSIXlt、.difftimeは、クラスジェネレーターです。.cache_classは、S3メソッドディスパッチで使用するために、S4クラスの継承をキャッシュします。  .popathは起動時に生成される変数で、使用中の翻訳パッケージがどこにあるかを記録します。.detachは、他のRパッケージで使用するためのdetachの「ベアボーン」バージョンです。.maskedMsgは、警告メッセージを生成するための一貫性を保つためにattach()とlibrary()の両方から呼び出されるユーティリティです。.C_および.F_で始まるオブジェクトは、登録されたCおよびFortranエントリ・ポイントへの参照です。Windowsのみ:.fixupGFortranStdoutおよび.fixupGFortranStderrは、systemおよびsystem2経由で外部コードを実行する際に、gfortranの標準出力および標準エラー・ユニットを有効にするヘルパー関数です。デフォルトでは、RGui内部で実行される場合、これらのユニットはWindowsプロファイルによって無効化されます。
通常、RはLC_NUMERICの値を見ずに実行されるので、小数点は'.'のままです。  そのため、これらのコンポーネントのうち最初の3つは、現在のRセッションでSys.setlocaleを使用してロケールカテゴリLC_NUMERICを設定した場合（Rが正しく動作しない可能性がある）にのみ有効です。通貨コンポーネントは、LC_MONETARYカテゴリが設定されている場合にのみ、デフォルト以外の値に設定されます（「例」セクションを参照）。  LC_MONETARYカテゴリが設定されている場合のみ、金額コンポーネントはデフォルト以外の値に設定される（「例」のセクションを参照）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の各関数評価はフレームスタックを1ずつ増やします。その関数の呼び出し、関数定義、評価環境はsys.call、sys.function、sys.frameによって適切なインデックスで返されます。sys.call、sys.function、sys.frameは引数whichに整数値を受け付けます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックは1ずつ増加します。呼び出し、関数定義、およびその関数の評価環境は、sys.call、sys.function、sys.frameによって適切なインデックスとともに返されます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックは1ずつ増加します。呼び出し、関数定義、およびその関数の評価環境は、sys.call、sys.function、sys.frameによって適切なインデックスとともに返されます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
.GlobalEnvはフレームのリストで0番を与えられます。後続の関数評価ごとにフレームスタックは1ずつ増加します。呼び出し、関数定義、およびその関数の評価環境は、sys.call、sys.function、sys.frameによって適切なインデックスとともに返されます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)はsys.frame(sys.parent(n))の便利な省略形です（少し効率的に実装されています）。
NA
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、本質的に[[ 演算子と等価です。  これは、デフォルト・メソッドをオブジェクトに適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  getRequiredPackages2は、Dependsフィールドで言及されたすべてのパッケージをアタッチします。  .getRequiredPackagesは、'DESCRIPTION'ファイルを使用した.getRequiredPackages2のラッパーです。.isMethodsDispatchOn()関数は、S4メソッドのディスパッチが(通常はパッケージメソッドをロードすることによって)評価側でオンになっている場合にTRUEを返します。  sys.save.imageはq()とそのGUIアナログから呼び出されるシステム関数です。sys.load.imageはスタートアップ・コードから呼び出されます。これらの関数は直接呼び出されるべきではなく、変更される可能性があります。  .set_row_names(n)は、attr(<a data frame>, "row.names")に代入される、長さnの自動的な行名を生成します。  .row_names_infoは、データフレームの行名の内部形式に関する情報を与えます。どのような情報かについては、引数の型を参照してください。.GenericArgsEnvと.ArgsEnvは、プリミティブがクロージャであった場合の引数リストを持つクロージャを含む環境です。  内部S3ジェネリックである全てのプリミティブは.GenericArgsEnvの対応するメンバーを持っており、残りの非言語要素プリミティブは.ArgsEnvに対応しています。  詳細は'R Internals'マニュアルを参照してください。  これらはargsとprint.defaultとQC関数codocとcheckS3methodsで使用されます。.findPackageEnvはunserializeコードで呼び出され、可能であれば保存された環境を設定します。.TAOCP1997initは "Knuth-TAOCP "RNGの初期化コードです。.gtと.gtnはrankとisからのコールバックです。.primTraceと.primUntraceは、それぞれtraceとuntraceの基礎となるプリミティブ関数です。.Date、.POSIXct、.POSIXlt、.difftimeは、クラスジェネレーターです。.cache_classは、S3メソッドディスパッチで使用するために、S4クラスの継承をキャッシュします。  .popathは起動時に生成される変数で、使用中の翻訳パッケージがどこにあるかを記録します。.detachは、他のRパッケージで使用するためのdetachの「ベアボーン」バージョンです。.maskedMsgは、警告メッセージを生成するための一貫性を保つためにattach()とlibrary()の両方から呼び出されるユーティリティです。.C_および.F_で始まるオブジェクトは、登録されたCおよびFortranエントリ・ポイントへの参照です。Windowsのみ:.fixupGFortranStdoutおよび.fixupGFortranStderrは、systemおよびsystem2経由で外部コードを実行する際に、gfortranの標準出力および標準エラー・ユニットを有効にするヘルパー関数です。デフォルトでは、RGui内部で実行される場合、これらのユニットはWindowsプロファイルによって無効化されます。
非標準のR名は、Sys.setenvで引用符で囲む必要があります。  ほとんどのプラットフォーム（およびPOSIX）では、"="を含む名前を許可していません。  Windowsでは可能だが、Rが提供する機能ではこれらを正しく扱えない場合があるので、避けるべきである。  ほとんどのプラットフォームは、環境変数を""に設定することを許可しているが、Windowsは許可しておらず、Sys.setenv(FOO = "") はFOOの設定を解除する。個々の環境変数の値の最大長、または名前とすべての環境変数の値の最大長には、システム固有の制限があるかもしれない。最近のバージョンのWindowsは、環境変数の最大長を32767文字としているが、cmd.exeはコマンドラインに8192文字の制限があるため、setは8188文字しか設定できない。
この試行では、ファイル時刻を指定された値に設定する。Unixライクなファイルシステムでは、システムコールutimensatが利用可能であればそれを使用し、そうでなければutimesまたはutimeを使用する。  POSIXファイルシステムでは、最終アクセス時刻と変更時刻の両方を設定する。Windowsでは、システムコールSetFileTimeを使って「最終書き込み時刻」を設定する。  Sys.setFileTimeはR 3.6.0でベクトル化された。  以前のバージョンのRでは、pathとtimeは長さ1のベクトルである必要があった。
ロケールは、プログラムの国際化の側面を記述する。初期状態では、Rのロケールのほとんどの側面は "C "に設定されている（これはC言語のデフォルトであり、北米の慣習を反映したもので、"POSIX "としても知られている）。  Rは "LC_CTYPE "と "LC_COLLATE "を設定する。"LC_CTYPE "と "LC_COLLATE "は、異なる文字セットの使用と、その文字セットでのアルファベット比較（ソートの使用を含む）を許可する。"LC_MONETARY"（Sys.localeconvで使用）と "LC_TIME "は、as.POSIXltとstrptime、およびそれらを使用する関数の動作に影響を与える可能性がある（dateは影響しない）。  「LC_MESSAGES "は、メッセージ変換をサポートしていないシステムでは "C "となり、Windowsではサポートされていない。  カテゴリー "LC_ALL "を設定すると、カテゴリー "LC_COLLATE"、"LC_CTYPE"、"LC_MONETARY "および "LC_TIME "のみが設定されることに注意。  OSによって、警告が表示される場合とされない場合がある。セッション中に文字セットを変更しようとしても（異なる文字セットを意味する場合は、Sys.setlocale("LC_CTYPE")によって）うまくいかないことがあり、混乱を招く可能性が高い。ほとんどのRプラットフォームでは、メッセージ変換の言語を選択する際に、環境変数LANGUAGEが "LC_MESSAGES "より優先されることに注意。  Windowsを除き、初期設定は "LC_COLLATE "カテゴリから取得され、Sys.setlocaleの呼び出しによって変更されるとリセットされる。
この関数を使用すると、Rに一時的に非常に低い優先度を与えることができるため、より重要なフォアグラウンド・タスクの邪魔にならない。  典型的な使用方法は、Rから起動されたプロセスがRの実行を再開する前に、自分自身をセットアップし、入力ファイルを読み込むようにすることです。この関数は、Rexpressionsの実行を一時停止しますが、GUIイベントに応答するのに十分な頻度（通常は0.5秒ごと）でプロセスを起動させることを意図しています。  timeは非負でなければならない(NAでもNaNでもない):Infは許される(割り込みのために無期限に待つことを意図している場合には適切かもしれない)。  時間間隔の分解能はシステムに依存するが、通常は20ms以上である(最近のUnix系では1ms以上である)。
大きなファイルの場合、keep.source = FALSEにするとかなりメモリを節約できる。keep.parse.data=FALSEによって解析データだけを無効にすることで、すでにかなりのメモリを節約できます。評価されるコードが正しい環境を使用するようにするために（たとえばグローバルな割り当てで）、パッケージのソースコードはtopenv()を呼び出す必要があります。topenv()は、名前空間がある場合はその名前空間、sys.sourceによって設定された環境、保存されたイメージが使用されている場合はグローバル環境を返します。
sys.call、sys.function、sys.frameは、引数whichに整数値を指定できます。  whichの非負の値は.GlobalEnvから始まるフレーム番号で、負の値は現在の評価のフレーム番号からさかのぼってカウントされます。関数評価の親フレームは関数が呼び出された環境です。  sys.parentはnが1(デフォルト)であれば親フレームの番号を返し、nが2であればgrandparentを返します。  sys.callsとsys.framesはそれぞれ、すべてのアクティブなコールとフレームのペアリストを返し、sys.parentsはそれらのフレームの親フレームのインデックスの整数ベクトルを返します。sys.xxx関数（sys.statusを除く）が解釈されても、それらのコンテキストはカウントされず、報告もされないことに注意してください。  sys.status()は、構成要素であるsys.calls、sys.parents、sys.frames、これら3つの関数の呼び出し結果（sys.statusへの呼び出しが含まれます：最初の例を参照してください）を持つリストを返します。parent.frame(n)は、sys.frame(sys.parent(n))の便利な省略形です（若干効率的に実装されています）。
Sys.timeは、様々なタイムゾーンに変換することができ、異なる日を返すかもしれない絶対日付時刻値を返します。
タイムゾーンはシステム固有のトピックであるが、最近ではほとんどすべてのRplatformsが同様の基礎コードを使用しており、Linux、macOS、Solaris、AIX、FreeBSDで使用され、WindowsではRと一緒にインストールされる。  (残念ながら、実装にはシステム固有のエラーが多くあります。) Windowsだけでなく、Unix系でもRソースのバージョンのコードを使用することが可能です: macOSではこれがデフォルトで、Solarisではこれが推奨されています。  Sys.timezone()は、TZが初期に設定されていればその値を返し（OSによっては常に設定されている）、そうでなければ、TZが設定されていれば初期タイムゾーンを示す値をOSから取得しようとする。(TZが設定されているが無効な場合、ほとんどのプラットフォームではUTCがデフォルトとなり、俗にGMTと呼ばれるタイムゾーンとなる（https://en.wikipedia.org/wiki/Coordinated_Universal_Time）。(タイムゾーンが使われるようになったのは19世紀半ばで、20世紀になってから広く採用されるようになった。サマータイムは20世紀初頭に導入され、最も広く使われたのは1916年だった。  過去100年の間に、地域は主要なタイムゾーン間の所属を変更し、様々な年にサマータイムを選択したり（または参加したり）、サマータイムルールの変更を遅く採用したり、まったく採用しなかったりした。  (一部の国（アイルランド共和国はそのひとつ）では、夏時間が「標準」時間であり、冬には別の名称が使用される。  POSIXctのごく一般的なシステム実装は符号付き32ビット整数であるため、1901年末までしか遡れない。このようなシステムでは、Rはそれ以前の日付が1902年と同じタイムゾーンにあると仮定する。  世界の大半は1902年までタイムゾーンを採用していなかったが（そのため、経度に基づくローカルな「平均時」を使用していた）、いくつかの場所ではそれ以前にタイムゾーンが変更されていた。  64ビット表示が一般的になりつつあるが、残念ながら64ビットOSでは、データベース情報が32ビットであるため、1901年から2038年の範囲しか利用できず、終了年については不完全である。R 3.5.0から、タイムゾーンの位置がセッションで最初に見つかると、その値はbase環境のオブジェクト.sys.timezoneにキャッシュされる。
dir.existsは、（file.existsと同じ意味で）パスが存在し、ディレクトリであることをチェックします。dir.createは、recursive = TRUEでない限り、パスの最後の要素を作成します。  モードは、システム関数mkdirと同じように、umaskの設定によって変更される。  どのようなモードが設定できるかはOS依存であり、3桁以上のオクタルディジットが使用されると仮定するのは危険である。  Windowsの特異性のひとつに、ディレクトリの作成が成功したと報告しても、別の名前のディレクトリが作成されることがある（例：dir.create("G.S.")は'"G.S"'を作成する）。  これは文書化されており、正確な状況は不明である（Windowsのバージョンに依存するかもしれない）。  Sys.chmodは、1つまたは複数のファイルのパーミッションを設定する。システムによってはサポートされていない場合がある（警告が出る場合）。モードがどのように解釈されるかについては、dir.createのコメントを参照のこと。  シンボリックリンクでモードを変更することは（必要でも）ないでしょう。詳細については、システムコールのchmodに関するOSのドキュメント、例えばman 2 chmodを参照してください（この名前のコマンドラインユーティリティのものではありません）。  シンボリックリンクのパーミッションを変更するか、ターゲットを変更するかはOSに依存します（ターゲットを変更する方が一般的ですが、POSIXはシンボリックリンクのモードをサポートしていません）：Sys.umaskはumaskを設定し、以前の値を返す。特殊なケースとして、mode = NAは現在の値を返すだけである。  詳細については、システムコールのumaskに関するOSのドキュメント、例えばman 2 umaskを参照のこと。モードがどのように扱われるかは、Unix系であってもファイルシステムによって異なる（ただし、それらのドキュメントはPOSIXファイルシステムを想定して書かれていることが多い）。  そのため、例えばFAT/FAT32やネットワークマウントされたファイルシステムを使用している場合は、ドキュメントを慎重に扱ってください。マークされたエンコーディングのファイルパスがどのように解釈されるかは、ファイルを参照してください。  
非標準のR名は、Sys.setenvで引用符で囲む必要がある。  ほとんどのプラットフォーム（およびPOSIX）では、"="を含む名前を許さない。  Windowsでは可能だが、Rが提供する機能ではこれらを正しく扱えない場合があるので、避けるべきである。  ほとんどのプラットフォームは、環境変数を""に設定することを許可しているが、Windowsは許可しておらず、Sys.setenv(FOO = "") はFOOの設定を解除する。個々の環境変数の値の最大長、または名前とすべての環境変数の値の最大長には、システム固有の制限があるかもしれない。最近のバージョンのWindowsでは、環境変数の最大長は32767文字であるが、cmd.exeのコマンドラインの文字数は8192文字に制限されているため、setは8188文字しか設定できない。
Windowsでは、「実行可能ファイル」は拡張子'.exe', '.com', '.cmd' または '.bat'を持つファイルである。  このようなファイルは実際に実行可能である必要はないが、システムが試行するものである。Unix-alikeでは、Rがインストールされたときにwhichへのフルパス（通常は「/usr/bin/which」）が見つかる。
このインターフェイスは、長年にわたってかなり複雑になっています。新しいコードに推奨される、より移植性が高く柔軟なインターフェイスについては、system2を参照してください。コマンドは、コマンドとスペースで区切られた引数として解析されます。  そのため、コマンドへのパス（またはファイル・パスのような単一の引数）にスペースが含まれている場合は、shQuoteなどで引用しなければなりません。Unix系ではコマンド・ラインをシェル（通常は'/bin/sh'で、POSIXではそのシェルが必要です）に渡すため、コマンドはシェルが実行可能であるとみなすものであれば何でもよく、シェル・スクリプトを含め、;で区切られた複数のコマンドを含むことができます。Windowsでは、システムはシェルを使用せず、コマンドラインをシェルに渡す独立した関数shellがあります。internがTRUEの場合、popenがコマンドを起動するために使用され、出力は行ごとにR文字ベクトルに収集されます。  waitはコマンドに&を付加することで実装されます。これは原則的にシェルに依存しますが、POSIXでは必須であり、広くサポートされています。timeoutが0以外の場合、コマンドは指定された秒数後に終了します。  タイムアウトが0でない場合、コマンドは指定された秒数後に終了する。この終了は典型的なコマンドでは機能するが、保証されるものではない。  タイムアウトは、wait = TRUEでのみ設定できます。タイムアウトは、対話型コマンドでは使用できません。コマンドは、/dev/nullからリダイレクトされた入力に耐えて実行され、端末の設定を変更してはなりません。  tty tostopオプションが無効になっている限り（通常はデフォルト）、実行されたコマンドは標準出力と標準エラーに書き込まれる可能性がある。  子プロセスの実行時間が、proc.timeが返すproc_timeのuser.childとsys.child要素に含まれるかどうかは、当てにならない。最初の2つの引数の後の順序は、timeからtimeに変更されました：最初の引数の後にすべての引数の名前を付けることが推奨されます。コマンドが実行できるかどうかを確認するためにsystemを使用するには多くの落とし穴があります - Sys.whichがより適しています。
これは、file.existsで指定されたファイルの存在をチェックする。  したがって、ファイル・パスは、その存在を確認するのに十分なパーミッションがある場合にのみ返されます。...の名前のない引数は、通常は文字列ですが、文字ベクトルの場合は、同じ長さにリサイクルされます。これは、パッケージを見つけるためにfind.packageを使用します。したがって、デフォルトのlib.loc = NULLでは、最初にアタッチされているパッケージを探し、次に.libPaths()にリストされている各ライブラリを探します。名前空間がロードされているが、パッケージがアタッチされていない場合は、.libPaths()だけを探すことに注意してください。
system.timeは、関数proc.timeを呼び出し、exprを評価し、もう一度proc.timeを呼び出し、2つのproc.time呼び出しの差を返す。unix.timeは、Sとの互換性のためにsystem.timeのエイリアスであったが、2016年についに非推奨となった。  gcFirstがTRUEの場合、ガベージコレクション（gc）はexprの評価の直前に実行される。
systemとは異なり、commandは常にshshQuoteで引用されるので、引数のない単一のコマンドでなければなりません。commandがどのように見つかるかの詳細については、systemを参照してください。いくつかのUnixコマンド（lsのいくつかの実装など）は、パイプまたはリダイレクトされると判断した場合、出力を変更します：stdout = TRUEはパイプを使用するのに対し、stdout = "some_file_name "はリダイレクトを使用します。この実装方法のため、Unixに類似したコマンドでは、stderr = TRUEはstdout = TRUEを意味します。  この終了は典型的なコマンドでは機能しますが、保証されるものではありません。タイムアウト後も実行し続けるようなプログラムを書くことは可能です。  タイムアウトは、wait = TRUEでのみ設定できます。タイムアウトは、対話型コマンドでは使用できません。コマンドは、/dev/nullからリダイレクトされた入力に耐えて実行され、端末の設定を変更してはなりません。  tty tostopオプションが無効になっている限り（通常はデフォルト）、実行されたコマンドは標準出力と標準エラーに書き込むことができる。
これは、メソッドを書くことができる汎用関数である。  データフレームは、まず行列に強制されます： as.matrixを参照してください。xがベクトルの場合、列として扱われ、結果は1行の行列になります。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  TRUEは1Lに、FALSEは0Lに、NAはNA_integer_にマッピングされる。
これはメソッドを書くことができる汎用関数です。  データフレームは、まず行列に強制されます： as.matrixを参照してください。xがベクトルの場合、それは列として扱われ、すなわち、結果は1行の行列になります。
これはメソッドを書くことができる汎用関数です。  データフレームは、まず行列に強制されます： as.matrixを参照してください。xがベクトルの場合、それは列として扱われ、すなわち、結果は1行の行列になります。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname name'が計算される。  もし...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、（以前はNAcountに含まれていた）除外された値をカウントしないように注意されています。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
binが因子の場合、その内部整数表現が集計されます。 binの要素が数値であって整数でない場合、それらはas.integerで切り捨てられます。
2つの引数atan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)となります、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
ブランチカットは逆三角関数asinらと一致しており、AbramowitzとStegunの図4.7、86ページで定義されているものと一致しています。   カットの実際の振る舞いは、端点を反時計回りに回ってくる連続性を要求するC99標準に従っている。
2つの引数atan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)です、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。これらはすべて、利用可能な場合、同じ名前のシステム・コール（複素引数には接頭辞cをつける）へのラッパーです。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合は、cosなどの呼び出しが使用され、2分の1の倍数の場合は特別なケースがあります)。
FUNがNULLでない場合、それはmatch.funに渡されるため、関数、または関数を示すシンボルや文字列となる。
NA
NA
結果の長さは3つの引数の長さの最大値であり、短い引数の値は再利用される。（stmpdirが指定されていない限り）ファイル名は、Rセッション内および同時のRセッション間でtempfileを呼び出した場合に一意になる可能性が非常に高い。  ファイル名は、tmpdirで指定されたパス、パターン文字列、16進数のランダムな文字列、およびfileextの接尾辞を連結して作成される。  デフォルトでは、tmpdirはtempdir()で指定されたディレクトリになる。このディレクトリは、Rセッションが開始されたときに、以下のルールによって見つけられるセッションごとの一時ディレクトリのサブディレクトリになる。  環境変数TMPDIR、TMP、TEMPが順番にチェックされ、書き込み可能なディレク トリを指すものが最初に見つかったものが使用される。  Rセッションでこれらの環境変数を設定しても、tempdir()には影響しないことに注意： セッションごとの一時ディレクトリは、インタプリタが起動する前に作成される。
結果の長さは3つの引数の長さの最大値であり、それより短い引数の値はリサイクルされる。  ファイル名は、tmpdirで指定されたパス、パターン文字列、16進数のランダムな文字列、およびfileextの接尾辞を連結して作成される。  デフォルトでは、tmpdirはtempdir()で指定されたディレクトリになる。このディレクトリは、Rセッションが開始されたときに、以下のルールによって見つけられるセッションごとの一時ディレクトリのサブディレクトリになる。  環境変数TMPDIR、TMP、TEMPが順番にチェックされ、書き込み可能なディレクトリを指すものが最初に見つかればそれが使用され、見つからなければ'/tmp'が使用される。  Rセッションでこれらの環境変数を設定しても、tempdir()には影響しないことに注意： セッションごとのテンポラリ・ディレクトリは、インタプリタが起動する前に作成される。
入力テキスト接続がオープンされ、接続オブジェクトが生成される時に文字ベクトルがコピーされ、 closeするとコピーが破棄される。  このオブジェクトは、常に接続への出力が完了した行を保持し、isIncomplete は最終行が不完全であることを示します。  接続を閉じると、最終行が出力される。  (Rでは"˶n "で表されるend-of-lineで終了すると、行は完了する)。   出力された文字ベクトルは、接続でcloseが呼び出されるまでロックされたバインディング（lockBindingを参照）を持ちます。  文字ベクトルは、textConnectionValueを介して取得することもできます。  現在のロケールがLatin-1またはUTF-8として検出された場合、文字ベクトルの非ASCII要素はそれに応じてマークされます（「エンコード」を参照）。mode = "a "でテキスト接続を開くと、ユーザのワークスペースまたは呼び出し環境にある、指定された名前の既存の文字ベクトルへの追加が試みられます。  テキスト接続をシークすることはできず、seek は常にゼロを位置として返します。テキスト接続には少し変わったセマンティクスがあります：それらは常にオープンであり、入力テキスト接続を閉じずに捨てても（ガベージコレクションされるので）警告は表示されません。
入力テキスト接続がオープンされ、接続オブジェクトが作成されるときに文字ベクトルがコピーされ、closeするとコピーが破棄されます。オブジェクトは文字ベクトルの名前でなければなりませんが、60バイト以下であれば短い式でもかまいません。  このオブジェクトは、常に接続への出力が完了した行を保持し、isIncomplete は最終行が不完全であることを示します。  接続を閉じると、最終行が出力される。  (Rでは"˶n "で表されるend-of-lineで終了すると、行は完了する)。   出力された文字ベクトルは、接続でcloseが呼び出されるまでロックされたバインディング（lockBindingを参照）を持ちます。  文字ベクトルは、textConnectionValueを介して取得することもできます。  現在のロケールがLatin-1またはUTF-8として検出された場合、文字ベクトルの非ASCII要素はそれに応じてマークされます（「エンコード」を参照）。mode = "a "でテキスト接続を開くと、ユーザのワークスペースまたは呼び出し環境にある、指定された名前の既存の文字ベクトルへの追加が試みられます。  テキスト接続をシークすることはできず、シークは常に位置としてゼロを返します。テキスト接続は少し変わったセマンティクスを持っています: それらは常に開いており、入力されたテキスト接続を閉じずに捨てても(ガベージコレクションされるように)警告を出しません。
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換します。範囲指定はサポートされていますが、文字クラスと繰り返し文字はサポートされていません。  tolowerとtoupperは、文字ベクトル内の大文字を小文字に、またはその逆に変換する。  アルファベット以外の文字は変更されない。  casefoldは、S-PLUSとの互換性のために用意されたtolowerとtoupperのラッパーです。
toppenvは、envirとそれを囲む環境を検索したときに最初に見つかったトップレベル環境を返します。トップレベル環境が見つからない場合は、.GlobalEnvが返されます。  環境は、名前空間の内部環境、検索パスのパッケージ環境、または .GlobalEnv である場合にトップレベルと見なされます。
これはメソッドを記述できる汎用関数です。ここでは既定のメソッドのみを説明します。  ほとんどのメソッドは、結果の最大表示幅 (nchar(type = "width") によって測定される) を指定するために引数widthを尊重する必要があります。デフォルト・メソッドは、まずxを文字に変換し、", " で区切られた要素を連結します。widthが指定され、NULLでない場合、デフォルト・メソッドは、完全な結果がwidth文字を超える場合は、結果の最初のwidth - 4文字に...を付加して返します。
これは、メソッドを書くことができる汎用的な関数です。  ほとんどのメソッドは、結果の最大表示幅（nchar(type = "width")によって測定される）を指定するために引数widthを尊重する必要があります。デフォルトのメソッドは、まずxを文字に変換し、", "で区切られた要素を連結します。widthが指定され、NULLでない場合、デフォルトのメソッドは、完全な結果がwidth文字以上を使用する場合は、結果の最初のwidth - 4文字に...を追加したものを返します。
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換します。範囲指定はサポートされていますが、文字クラスと繰り返し文字はサポートされていません。  tolowerとtoupperは、文字ベクトル内の大文字を小文字に、またはその逆に変換する。  アルファベット以外の文字は変更されない。  casefoldは、S-PLUSとの互換性のために用意されたtolowerとtoupperのラッパーです。
trace関数は、関数（シグネチャが与えられている場合は、メソッド）の改訂版を構築し、新しいオブジェクトを元のオブジェクトが見つかった場所に割り当てることによって動作します。traceによって構築されるオブジェクトは、"function "を継承したクラスであり、オリジナルの、トレースされていないバージョンを含んでいます。untraceの呼び出しは、このバージョンを再割り当てします。引数tracerまたはexitが関数の名前である場合、トレース式は、引数なしで、その関数の呼び出しになります。  これは最も簡単で一般的なケースで、browser関数とrecover関数が最も有力な候補です。前者はトレースされる関数のフレームをブラウズし、後者は現在アクティブな呼び出しのどれでもブラウズできます。引数tracerとexitは、それらが関数であるかどうかを確認するために評価されますが、それらの名前だけがトレース式で使用されます。  tracerまたはexitの引数は、評価されない式（quoteまたはsubstituteの呼び出しによって返されるような）であることもできます。  この式自体はトレースされる関数に挿入されるため、通常はトレースされる関数の引数やローカルオブジェクトを含むことになります。  この形式の式は、特定の条件が適用された場合にのみ対話したい場合に便利です（この場合、おそらくtraceの呼び出しでもprint = FALSEを指定したいでしょう）。at引数が指定された場合、関数本体のサブステップを参照する整数のベクトルにすることができます（これは、関数本体が{ ...}で囲まれている場合にのみ機能します）。  この場合、トレーサーは入力時に呼び出されるのではなく、at.でリストされた各ステップを評価する直前に呼び出されます。  (ヒント:印刷されたバージョンの関数のステップを数えようとしないでください。代わりに、as.list(body(f))を見て、関数fのステップに関連する数字を取得してください。)at引数は、整数ベクトルのリストであることもできます。  この場合、各ベクトルは関数の別のステップに入れ子になっているステップを指します。  例えば、at = list(c(3,4))は、関数の第3ステップの第4ステップの直前にトレーサーを呼び出します。  exit引数はon.exit処理中に呼び出されます。  on.exit式では、関数が返そうとしている値を得るために、実験的なreturnValue()関数を呼び出すことができる。exit引数の本質的な制限は、関数自体がon.exitをadd= FALSE（デフォルト）で使用している場合、既存の呼び出しがtraceによって提供されたものを上書きするため、機能しないということです。  トレースはネストしません。トレースを呼び出すと、その関数やメソッドの以前にトレースされたバージョンが置き換えられます（後述の編集バージョンを除く）。  (ネストされたトレースを許すと、混乱や誤ってトレースされたバージョンを残してしまう可能性が高すぎます。)edit引数が繰り返し使用され、その間に同じ関数やメソッドでtountraceが呼び出されない場合、以前に編集されたバージョンが保持されます。  以前のトレースをすべて捨ててから編集したい場合は、次にtraceを呼び出す前にuntraceを呼び出してください。  編集は自動トレースと組み合わせることができます。tracerなどの他の引数とedit引数を指定するだけです。  edit = TRUE引数はデフォルトのエディタを使用します(editを参照)。ベースパッケージからのプリミティブ関数(組み込み関数と特殊関数)のトレースは機能しますが、特別なメカニズムによってのみ機能し、あまり有益ではありません。  プリミティブをトレースすると、プリミティブは引数...（だけ）を持つ関数で置き換えられます。  少しは情報が得られますが、それほど多くはありません。  トレースされた関数は、セッションイメージに保存されている場合、トレースされた関数のトレースされたバージョンは、セッションから別のセッションに引き継がれます。  (次のセッションでは、untraceでトレースが削除されます。) 一方、グローバル環境ではなく、パッケージ内にあった関数は、イメージに保存されません。S4メソッドのトレースは基本的に関数のトレースと同じですが、トレースされたバージョンは直接の代入ではなくsetMethodの呼び出しによって保存され、untraceの呼び出しの後にはトレースされないバージョンになるという例外があります。  S-Plusのトレースはセッション・フレームを使用し、その結果、トレースはあるセッションから別のセッションに引き継がれることはない（Rdはセッション・フレームを持たない）。  もう一つの違いは、トレースとは直接関係ありません：  S-Plusのブラウザは、ブラウズしているフレームに変更を加えることができ、ブラウザを終了しても変更は持続します。  Rブラウザーは変更が可能だが、ブラウザーが終了すると消えてしまう。  このことは、S-Plus版ではコードの変更をインタラクティブに試すことができるが、R版ではできないことに関係していると思われる。  (将来のリビジョンでは、R用の「破壊的」ブラウザが追加されるかもしれない)。
デフォルトの表示は、.Tracebackに呼び出しのリストとして格納されている最後の捕捉されなかったエラーのスタックです。  呼び出しのスタックには、常にすべての関数呼び出しとすべての外部関数呼び出し（.Callなど）が含まれます。プロファイリングが進行中であれば、いくつかのプリミティブ関数の呼び出しも含まれます。  (組み込み関数への呼び出しは含まれますが、特殊関数への呼び出しは含まれません。)tryまたはtryCatchで捕捉されたエラーはトレースバックを生成しないので、出力されるのは最後の捕捉されなかったエラーに対する呼び出しシーケンスであり、必ずしも最後のエラーに対するものではありません。xが数値の場合、現在のスタックが出力され、スタックの先頭のx個のエントリはスキップされます。  例えば、options(error = function() traceback(3))は、traceback()と.traceback()の呼び出しと、それを呼び出したエラー関数をスキップして、エラーが発生した時点のスタックを表示する。  これは、大きな呼び出しに対して高価な処理であるため、そのような呼び出しがコールスタック上にある場合は、max.linestを妥当な値に設定することをお勧めします。
tracememとuntracememは、Rがメモリ・プロファイリング付きでコンパイルされていない場合にエラーを出しますが、retracememはエラーを出しません（そのため、開発中のコードに残すことができます）。C関数duplicateによるオブジェクトのコピーがトレースされると、.Cまたは.Fortranに引数を渡すときの型強制やコピーと同様に、標準出力にメッセージが出力される。メッセージは、文字列tracemem、コピーされるオブジェクトと作成される新しいオブジェクトの識別文字列、および複製が発生した場所を示すスタックトレースで構成される、関数をトレースすることはできません。これは trace と競合するためで、NULL、環境、約束、弱い参照、外部ポインタ・オブジェクトをトレースすることは役に立ちません。
trace関数は、関数（シグネチャが指定された場合はメソッド）の改訂版を作成し、元のオブジェクトが見つかった場所に新しいオブジェクトを代入することで動作します。what引数だけが指定された場合、関数が呼び出されるたびに1行のトレース出力が生成されます（以前のバージョンのtraceと互換性があります）。traceによって構築されるオブジェクトは、"function "を継承したクラスであり、オリジナルの、トレースされていないバージョンを含んでいます。untraceの呼び出しは、このバージョンを再割り当てします。引数tracerまたはexitが関数の名前である場合、トレース式は、引数なしで、その関数の呼び出しになります。  前者はトレースされる関数のフレームをブラウズし、後者は現在アクティブな呼び出しのいずれかをブラウズすることができます。引数tracerとexitは、それらが関数であるかどうかを確認するために評価されますが、それらの名前だけがトレース式で使用されます。  tracerまたはexitの引数は、評価されない式（quoteまたはsubstituteの呼び出しによって返されるような）であることもできます。  この式自体はトレースされる関数に挿入されるため、通常はトレースされる関数の引数やローカルオブジェクトを含むことになります。  この形式の式は、特定の条件が適用された場合にのみ対話したい場合に便利です（この場合、おそらくtraceの呼び出しでもprint = FALSEを指定したいでしょう）。at引数が指定された場合、関数本体のサブステップを参照する整数のベクトルにすることができます（これは、関数本体が{ ...}で囲まれている場合にのみ機能します）。  この場合、トレーサーは入力時に呼び出されるのではなく、at.でリストされた各ステップを評価する直前に呼び出されます。  (ヒント:印刷されたバージョンの関数のステップを数えようとしないでください。代わりに、as.list(body(f))を見て、関数fのステップに関連する数値を取得してください。)at引数は、整数ベクトルのリストであることもできます。  この場合、各ベクトルは関数の別のステップに入れ子になっているステップを指します。  例えば、at = list(c(3,4))は、関数の第3ステップの第4ステップの直前にトレーサーを呼び出します。  exit引数はon.exit処理中に呼び出されます。  on.exit式では、関数が返そうとしている値を得るために、実験的なreturnValue()関数を呼び出すことができる。exit引数の本質的な制限は、関数自体がon.exitをadd= FALSE（デフォルト）で使用している場合、既存の呼び出しがtraceによって提供されたものを上書きしてしまうため、機能しないということです。  トレースはネストしません。トレースを呼び出すと、その関数やメソッドの以前にトレースされたバージョンが置き換えられます（後述の編集バージョンを除く）。  (ネストされたトレースを許すと、混乱や誤ってトレースされたバージョンを残してしまう可能性が高すぎます。)edit引数が繰り返し使用され、その間に同じ関数やメソッドでtountraceが呼び出されない場合、以前に編集されたバージョンが保持されます。  以前のトレースをすべて捨ててから編集したい場合は、次にtraceを呼び出す前にuntraceを呼び出してください。  編集は自動トレースと組み合わせることができます。tracerなどの他の引数とedit引数を指定するだけです。  edit = TRUE引数はデフォルトのエディタを使用します(editを参照)。ベースパッケージからのプリミティブ関数(組み込み関数と特殊関数)のトレースは機能しますが、特別なメカニズムによってのみ機能し、あまり有益ではありません。  プリミティブをトレースすると、プリミティブは引数...（だけ）を持つ関数で置き換えられます。  少しは情報が得られますが、それほど多くはありません。  トレースされた関数は、セッションイメージに保存されている場合、トレースされた関数のトレースされたバージョンは、セッションから別のセッションに引き継がれます。  (次のセッションでは、untraceによってトレースが削除されます。) 一方、グローバル環境ではなく、パッケージ内にあった関数は、イメージに保存されません。S4メソッドのトレースは基本的に関数のトレースと同じですが、トレースされたバージョンは直接の代入ではなくsetMethodの呼び出しによって保存され、untraceの呼び出しの後にはトレースされないバージョンになるという例外があります。  S-Plusのトレースはセッション・フレームを使用し、その結果、トレースはあるセッションから別のセッションに引き継がれることはない（Rdはセッション・フレームを持たない）。  もう一つの違いは、トレースとは直接関係ありません：  S-Plusのブラウザは、ブラウズしているフレームに変更を加えることができ、ブラウザを終了しても変更は持続します。  Rブラウザーは変更が可能だが、ブラウザーが終了すると消えてしまう。  このことは、S-Plus版ではコードの変更をインタラクティブに試すことができるが、R版ではできないことに関係していると思われる。  (将来のリビジョンでは、R用の「破壊的」ブラウザが追加されるかもしれない)。
transform.data.frameの...引数はタグ付きベクトル式で、データフレーム_dataで評価される。  タグはnames(_data)と照合され、一致したものは_dataの対応する変数に置き換えられ、それ以外は_dataに追加される。
transform.data.frameの...引数はタグ付きベクトル式であり、データフレーム_dataで評価される。  タグはnames(_data)と照合され、一致したものは_dataの対応する変数に置き換えられ、それ以外は_dataに追加される。
transform.data.frameの...引数はタグ付きベクトル式であり、データフレーム_dataで評価される。  タグはnames(_data)と照合され、一致したものは_dataの対応する変数に置き換えられ、それ以外は_dataに追加される。
正式な定義は、integral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lγ関数、digamma関数、trigamm関数は内部ジェネリックプリミティブ関数です。
内部では、sub(re, "", *, perl = TRUE)、すなわちPCRElibrary正規表現が使用される。移植性のため、デフォルトの「空白」は文字クラス[ \t\r n]（スペース、水平タブ、キャリッジリターン、改行）である。  あるいは、[˶h ˶v]は、すべてのUnicodeの水平と垂直の空白文字にマッチする良い(PCRE)一般化である。
5を四捨五入する場合、IEC 60559標準（'IEEE 754'も参照）が使用され、'偶数桁に行く'ことが期待されていることに注意してください。  ただし、これはOSのサービスや表示誤差に依存する（例えば0.15は正確に表現されていないため、丸めルールは表現された数字に適用され、印刷された数字には適用されないため、round(0.15, 1)は0.1にも0.2にもなりうる）。例えば、 round(x, digits = -2) は、最も近い100に丸められます。signifの場合、digitsの認識値は1...22であり、欠落していない値は、その範囲の最も近い整数に丸められます。  複素数は、指定された桁数を保持するように、成分の大きいほうに丸められます。  これらはすべてプリミティブ関数です。
時刻は、秒、分、時、日、月、年のいずれかに丸められたり切り捨てられたりします。  タイムゾーンは、現在のタイムゾーンの真夜中が使用される場合、日以上にのみ関連しています。クラス "Date "のメソッドは、端数の日を削除する以外にはほとんど使用されません。
時刻は、秒、分、時、日、月、年の単位で丸められたり、切り捨てられたりします。  タイムゾーンは、現在のタイムゾーンの真夜中が使用される場合、日以上にのみ関連します。クラス "Date" のメソッドは、端数日を削除する以外にはほとんど使用しません。
isSeekable は、接続が原則としてシークをサポートしているかどうかを返します。現在のところ、シークをサポートしているのは (おそらく gz 圧縮された) ファイル接続だけです。  可能な値は、64ビットビルドや一部の32ビットビルドでは、Rintegerで表現可能な最大の数値を超える可能性があることに注意してください。ファイル接続は、書き込み/追加の両方でオープンすることができます。  どちらのシークを参照するかは、rw引数で設定できる。デフォルトは、最後に使用されたモード（読み込みまたは書き込み）である。  ほとんどのファイルは読み書きのためだけにオープンされているので、デフォルトはその状態である。  読み書きの初期位置は常にファイルの先頭である。書き込みの初期位置は、"r+"モードと "r+b "モードではファイルの先頭であり、そうでなければファイルの末尾である。  プラットフォームによっては、追記モードではファイルの末尾にしか書き込めないものもある。  (アペンドモードでオープンされたファイルの報告される書き込み位置は、 通常、ファイルが書き込まれるまで信頼できない。)gzfile接続は、いくつかの制限付きでシークをサポートしており、 展開されたファイルのファイル位置を使用する。  seekがwhereの非NA値で呼び出された場合、テキストモード接続でのプッシュバックはすべて破棄される。  これは、ファイル接続でのみ動作し、すべてのプラットフォームで実装されているわけではありません。他のプラットフォーム（Windowsを含む）では、大きなファイル（> 2Gb）では動作しません。
isSeekable は、接続が原則としてシークをサポートしているかどうかを返します: 現時点では (おそらく gz 圧縮された) ファイル接続のみがサポートしています。  可能な値は、64ビットビルドや一部の32ビットビルドでは、Rintegerで表現可能な最大の数値を超える可能性があることに注意してください。ファイル接続は、書き込み/追加の両方でオープンすることができます。  どちらのシークを参照するかは、rw引数で設定できる。デフォルトは、最後に使用されたモード（読み込みまたは書き込み）である。  ほとんどのファイルは読み書きのためだけにオープンされているので、デフォルトはその状態である。  読み書きの初期位置は常にファイルの先頭である。書き込みの初期位置は、"r+"モードと "r+b "モードではファイルの先頭であり、そうでなければファイルの末尾である。  プラットフォームによっては、追記モードではファイルの末尾にしか書き込めないものもある。  (アペンドモードでオープンされたファイルの報告される書き込み位置は、 通常、ファイルが書き込まれるまで信頼できない。)gzfile接続は、いくつかの制限付きでシークをサポートしており、 展開されたファイルのファイル位置を使用する。  seekがwhereの非NA値で呼び出された場合、テキストモード接続でのプッシュバックはすべて破棄される。  これはファイル接続でのみ動作し、すべてのプラットフォームで実装されているわけではありません: (Windowsを含む)他のプラットフォームでは、大きな(> 2Gb)ファイルでは動作しません。
tryは式を評価し、評価中に発生したエラーをトラップします。  エラーが発生した場合、options("show.error.messages")がfalseであるか、silent = TRUEが指定されていない限り、エラーメッセージが標準エラー出力に出力されます。  エラーメッセージはバッファにも保存され、geterrmessageで取得できる。(tryはtryCatchを使って実装されている。プログラミングでは、try(expr, silent = TRUE)の代わりに、tryCatch(expr, error = function(e) e)(または他の単純なエラーハンドラ関数)のようなものを使うと、より効率的で柔軟かもしれない、特に、try()がSweaveのコード・チャンクの内部で使用され、エラー・メッセージが 結果のドキュメントに表示される場合です。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最近確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートで不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出さないでください。
NA
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明します。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトはclass属性を持っており、これはオブジェクトが継承するクラスの名前を示す文字ベクトルです（関数oldClassおよびoldClass<-はこの属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性の設定と同様に、class属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトであれば is を使用し、そうでなければ、class(x) のすべての要素が what に含まれていれば TRUE を返します。inherits と isa 以外はすべてプリミティブ関数です。
デバッグ用のフラグが付けられた関数が入力されると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  デバッグ・プロンプトでは、コマンドまたはR式を入力することができ、その後に改行が続きます。  別の関数の内部で定義されている関数をデバッグするには、その定義の最後までシングルステップで進み、その関数の名前に対してdebugをコールします。デバッグの使用は永続的で、デバッグがオフにされない限り、デバッガはすべての呼び出しで入力されます（関数が削除され、置き換えられた場合、デバッグ状態は保存されないことに注意してください）。明示的なシグネチャでS4メソッドをデバッグするには、シグネチャを使用します。シグネチャを指定すると、デバッグ対象のメソッドを示す。この場合のデバッグは、デバッグ・ビットではなくトレース・マシンを使用するため、若干異なる実装になっていることに注意してください。そのため、テキストと条件を非NULLシグネチャと組み合わせて指定することはできません。isdebuggedは、a)シグネチャがNULLでクロージャfunがデバッグされた場合、またはb)シグネチャがNULLでなく、funがS4ジェネリックで、そのシグネチャのfunのメソッドがデバッグされた場合にTRUEを返します。バイトコンパイルされた関数でデバッグが有効になっている場合、デバッグが無効になるまで、その関数の解釈されたバージョンが使用されます。
union,intersect,setdiff,setequalのそれぞれは、引数の中の重複する値を捨て、引数にas.vectorを適用します（特に文字ベクトルにはcoerce係数を適用します）。is.element(x, y)はx %in% yと同じです。
配列のメソッドは、MARGINで指定された次元の各要素について、残りの次元がそれ以前の要素と同じかどうかを計算します（行長順）。  Unixのuniqコマンドとは異なり、これは重複する要素や行を省略するものであり、単に繰り返される要素や行を省略するものではないことに注意。  つまり、ある要素が直前の要素と等しい場合だけでなく、直前の要素と等しい場合にも省略される。  (欠損値("NA")は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch (およびduplicated)を参照してください。これは、かなり小さな値の集合に対して使用されることを意図しており、非常に大きな集合に対しては効率的ではありません。複数の列を持つデータフレームや、1以上の長さの次元を比較する配列や行列に対して使用される場合、文字表現の同一性をテストします。  これは、浮動小数点数の厳密な等値性を妄信する人を捕えることになる！
配列メソッドは、MARGINで指定された次元の各要素について、残りの次元が（行の長さの順に）前の要素と同じかどうかを計算します。  Unixのuniqコマンドとは異なり、これは重複する要素や行を省略するものであり、単に繰り返される要素や行を省略するものではないことに注意。  つまり、ある要素が直前の要素と等しい場合だけでなく、直前の要素と等しい場合にも省略される。  (欠損値("NA")は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch (およびduplicated)を参照してください。これは、かなり小さな値の集合に対して使用されることを意図しており、非常に大きな集合に対しては効率的ではありません。複数の列を持つデータフレームや、1以上の長さの次元を比較する配列や行列に対して使用される場合、文字表現の同一性をテストします。  これは、浮動小数点数の厳密な等値性を妄信する人を捕えることになる！
配列メソッドは、MARGINで指定された次元の各要素について、残りの次元が（行の長さの順に）前の要素と同じかどうかを計算します。  Unixのuniqコマンドとは異なり、これは重複する要素や行を省略するものであり、単に繰り返される要素や行を省略するものではないことに注意。  つまり、ある要素が直前の要素と等しい場合だけでなく、直前の要素と等しい場合にも省略される。  (欠損値("NA")は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch (およびduplicated)を参照してください。これは、かなり小さな値の集合に対して使用されることを意図しており、非常に大きな集合に対しては効率的ではありません。複数の列を持つデータフレームや、1以上の長さの次元を比較する配列や行列に対して使用される場合、文字表現の同一性をテストします。  これは、浮動小数点数の厳密な等値性を妄信する人を捕えることになる！
配列メソッドは、MARGINで指定された次元の各要素について、残りの次元が（行の長さの順に）前の要素と同じかどうかを計算します。  Unixのuniqコマンドとは異なり、これは重複する要素や行を省略するものであり、単に繰り返される要素や行を省略するものではないことに注意。  つまり、ある要素が直前の要素と等しい場合だけでなく、直前の要素と等しい場合にも省略される。  (欠損値("NA")は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch (およびduplicated)を参照してください。これは、かなり小さな値の集合に対して使用されることを意図しており、非常に大きな集合に対しては効率的ではありません。複数の列を持つデータフレームや、1以上の長さの次元を比較する配列や行列に対して使用される場合、文字表現の同一性をテストします。  これは、浮動小数点数の厳密な等値性を妄信する人を捕えることになる！
配列メソッドは、MARGINで指定された次元の各要素について、残りの次元が（行の長さの順に）前の要素と同じかどうかを計算します。  Unixのuniqコマンドとは異なり、これは重複する要素や行を省略するものであり、単に繰り返される要素や行を省略するものではないことに注意。  つまり、ある要素が直前の要素と等しい場合だけでなく、直前の要素と等しい場合にも省略される。  (欠損値("NA")は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch (およびduplicated)を参照してください。これは、かなり小さな値の集合に対して使用されることを意図しており、非常に大きな集合に対しては効率的ではありません。複数の列を持つデータフレームや、1以上の長さの次元を比較する配列や行列に対して使用される場合、文字表現の同一性をテストします。  これは、浮動小数点数の厳密な等値性を妄信する人を捕えることになる！
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(警告が生成される時点)で最大となり、デフォルトでは50であることに注意。  例えば、options(warn)が変更された場合や、致命的なエラーが発生した場合などです。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
difftime関数は、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime "クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
difftime関数は、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime "クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
difftime関数は、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つ "difftime "クラスのオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
ベース・パッケージ以外の標準パッケージの関数は、help("pkg-deprecated") にリストされています。
unlink(x,recursive=TRUE)は、シンボリックリンクのターゲットがディレクトリである場合、そのシンボリックリンクだけを削除します。ワイルドカード展開（通常は'*'と'?'が許可されます）は、Sys.globの内部コードによって行われます。  ワイルドカードは、システムがサポートしている場合にのみ展開されます。  ほとんどのシステムでは、'*'や'?'だけでなく、'[a-z]'などの文字クラスもサポートしている（OSのsystemcallグロブのマニュアル・ページを参照）。  メタキャラクタ * ?[このため、unlinkを使用してそのようなファイルを削除するのは困難です（file.removeを参照）。  recursive = TRUEは、すべてのプラットフォームでサポートされているわけではありません。
unlistは汎用的です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。InternalMethodsを参照してください。  xのリスト以外の要素がすべて因子（または順序付き因子）オブジェクトである場合、結果は、要素のレベル集合に出現するレベルの順序で、要素のレベル集合の和をレベルとする因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合になることを意味します）。デフォルトでは、unlistはxに存在する名前情報を保持しようとします。use.names = FALSEの場合、すべての名前情報が削除されます。可能な場合、リスト要素はリスト解除中に共通モードに強制されるため、結果は文字ベクトルになることがよくあります。  リストは(一般的な)ベクトルであり、単純化されたベクトルもリストであるかもしれません(そして変更されないかもしれません)。  リストの非ベクトル要素（例えば、名前、数式、呼び出しなどの言語要素）は強制されないので、これらの1つ以上を含むリストはリストのままです。  (lmフィットのリスト解除の効果は、個々の残差を構成要素として持つリストです。)unlist(x)は、ベクトルでないxに対しても、エラーを通知する代わりに、xを変更せずに返すようになったことに注意してください。
関数loadNamespaceとattachNamespaceは通常、libraryが名前空間と必要なインポートをロードするために使用されるときに暗黙的に呼び出されます。  loadNamespaceは、指定された名前空間をロードし、内部データベースに登録します。  指定された名前空間がすでにロードされているときに、その名前空間をロードするように要求しても、何の効果もありません。  引数は、libraryへの対応する引数と同じ意味を持っています。libraryのヘルプ・ページでは、特定のインストール済みパッケージがどのように選択されるかの詳細が説明されています。  ロード後、loadNamespaceは.onLoadという名前のフック関数を名前空間の内部変数として探します（これはエクスポートされるべきではありません）。  loadNamespaceは読み込んだ名前空間を検索パスにアタッチしません。attachNamespaceを使用すると、名前空間のエクスポートされた値を含むフレームを検索パスにアタッチできます（ただし、これはほとんどの場合ライブラリ経由で実行されます）。  isNamespaceLoaded(pkg)はpkg %in%loadedNamespaces()と同等ですが、pkg %in%loadedNamespaces()よりも効率的です。unloadNamespaceを使用すると、名前空間を強制的にアンロードすることができます。  名前空間がアタッチされている場合、最初にその名前空間がデタッチされ、それによって、名前空間に.onDetach関数または.Last.lib関数がエクスポートされている場合はその関数が実行されます。  名前空間が他のロードされた名前空間によってインポートされた場合、エラーがシグナルされ、名前空間はアンロードされない。  定義されている場合、内部レジストリから名前空間を削除する前にフック関数.onUnloadが実行されます。名前空間のアンロードと再ロードに関するいくつかの問題については、detachのヘルプのコメントを参照してください。
環境をロックすることで、環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時に保存されませんが、.onLoadで作成することができます。
NA
関数serializeは、オブジェクトを指定されたconnectionにシリアライズします。  参照オブジェクトの共有はオブジェクト内で保持されますが、serializeの個別の呼び出し間では保持されません。unserializeは、オブジェクト（serializeによって書き込まれたもの）をconnectionまたはraw vectorから読み込みます。refhook関数を使用すると、システム以外の参照オブジェクト（すべての外部ポインタと弱参照、および名前空間とパッケージ環境と.GlobalEnv以外のすべての環境）の処理をカスタマイズできます。  serializeのフック関数は、扱いたい参照の文字ベクトルを返すべきです。  unserializeのフックは、serializeに供給された文字ベクトルで呼び出され、適切なオブジェクトを返す必要があります。テキストモード接続の場合、asciiのデフォルト値はTRUEに設定されています：ASCII表現のみがテキストモデック接続に書き込むことができ、ascii = FALSEを使用しようとするとエラーがスローされます：最初の行は、バイナリー・シリアライゼーションの場合はX、ASCIIシリアライゼーションの場合はAという1文字を含み、その後に改行が続く。  (使用されるフォーマットは、readRDSで使用されるものと同じである。)現在使用されているほとんどすべてのシステムがリトルエンディアンであるため、xdr = FALSEを使用すると、あるリトルエンディアン・マシンから別のマシンへ(または同じマシン上のプロセス間で)データを転送する際に、両端でのバイトシャッフルを避けることができる。  システムにもよるが、これによりシリアライズとアンシリアライズを最大3倍高速化できる。
splitとsplit<-は、defaultメソッドとdata.frameメソッドを持つ汎用関数です。  unsplit は，ベクトルまたはデータフレームのリスト（split で作成されたものと同じように，互換性のある構造を持っていると仮定されます）で動作します．  データフレームの場合、行名はvalueの要素から行名ベクトルを分割解除することで得られます。fは必要に応じてリサイクルされ、xの長さがfの長さの倍数でない場合は警告が出力されます。  因子のレベルに.が含まれる場合、sepが因子のレベルに存在しない文字列に設定されない限り、因子は期待どおりに分割されない可能性があります。
what引数だけが与えられた場合、関数が呼び出される度に1行のトレース印刷が生成されます（以前のバージョンのtraceと互換性があります）。traceによって構築されるオブジェクトは、"function "を継承したクラスであり、オリジナルの、トレースされていないバージョンを含んでいます。untraceの呼び出しは、このバージョンを再割り当てします。引数tracerまたはexitが関数の名前である場合、トレース式は、引数なしで、その関数の呼び出しになります。  前者はトレースされる関数のフレームをブラウズし、後者は現在アクティブな呼び出しのいずれかをブラウズすることができます。引数tracerとexitは、それらが関数であるかどうかを確認するために評価されますが、それらの名前だけがトレース式で使用されます。  tracerまたはexitの引数は、評価されない式（quoteまたはsubstituteの呼び出しによって返されるような）であることもできます。  この式自体はトレースされる関数に挿入されるため、通常はトレースされる関数の引数やローカルオブジェクトを含むことになります。  この形式の式は、特定の条件が適用された場合にのみ対話したい場合に便利です（この場合、おそらくtraceの呼び出しでもprint = FALSEを指定したいでしょう）。at引数が指定された場合、関数本体のサブステップを参照する整数のベクトルにすることができます（これは、関数本体が{ ...}で囲まれている場合にのみ機能します）。  この場合、トレーサーは入力時に呼び出されるのではなく、at.でリストされた各ステップを評価する直前に呼び出されます。  (ヒント:印刷されたバージョンの関数のステップを数えようとしないでください。代わりに、as.list(body(f))を見て、関数fのステップに関連する数字を取得してください。)at引数は、整数ベクトルのリストであることもできます。  この場合、各ベクトルは関数の別のステップに入れ子になっているステップを指します。  例えば、at = list(c(3,4))は、関数の第3ステップの第4ステップの直前にトレーサーを呼び出します。  exit引数はon.exit処理中に呼び出されます。  on.exit式では、関数が返そうとしている値を得るために、実験的なreturnValue()関数を呼び出すことができる。exit引数の本質的な制限は、関数自体がon.exitをadd= FALSE（デフォルト）で使用している場合、既存の呼び出しがtraceによって提供されたものを上書きするため、機能しないということです。  トレースはネストしません。トレースを呼び出すと、その関数やメソッドの以前にトレースされたバージョンが置き換えられます（後述する編集バージョンを除く）。  (ネストされたトレースを許すと、混乱や誤ってトレースされたバージョンを残してしまう可能性が高すぎます。)edit引数が繰り返し使用され、その間に同じ関数やメソッドでtountraceが呼び出されない場合、以前に編集されたバージョンが保持されます。  以前のトレースをすべて捨ててから編集したい場合は、次にtraceを呼び出す前にuntraceを呼び出してください。  編集は自動トレースと組み合わせることができます。tracerなどの他の引数とedit引数を指定するだけです。  edit = TRUE引数はデフォルトのエディタを使用します(editを参照)。ベースパッケージからのプリミティブ関数(組み込み関数と特殊関数)のトレースは機能しますが、特別なメカニズムによってのみ機能し、あまり有益ではありません。  プリミティブをトレースすると、プリミティブは引数...（だけ）を持つ関数で置き換えられます。  少しは情報が得られますが、それほど多くはありません。  トレースされた関数は、セッションイメージに保存されている場合、トレースされた関数のトレースされたバージョンは、セッションから別のセッションに引き継がれます。  (次のセッションでは、untraceでトレースが削除されます。) 一方、グローバル環境ではなく、パッケージ内にあった関数は、イメージに保存されません。S4メソッドのトレースは基本的に関数のトレースと同じですが、トレースされたバージョンは直接の代入ではなくsetMethodの呼び出しによって保存され、untraceの呼び出しの後にはトレースされないバージョンになるという例外があります。  S-Plusのトレースはセッション・フレームを使用し、その結果、トレースはあるセッションから別のセッションに引き継がれることはない（Rdはセッション・フレームを持たない）。  もう一つの違いは、トレースとは直接関係ありません：  S-Plusのブラウザは、ブラウズしているフレームに変更を加えることができ、ブラウザを終了しても変更は持続します。  Rブラウザーは変更が可能だが、ブラウザーが終了すると消えてしまう。  このことは、S-Plus版ではコードの変更をインタラクティブに試すことができるが、R版ではできないことに関係していると思われる。  (将来のリビジョンでは、R用の「破壊的」ブラウザが追加されるかもしれません)。
tracememとuntracememは、Rがメモリ・プロファイリング付きでコンパイルされていない場合にエラーを出しますが、retracememはエラーを出しません（そのため、開発中のコードに残しておくことができます）。C関数duplicateによるオブジェクトのコピーがトレースされると、.Cまたは.Fortranに引数を渡すときの型強制やコピーと同様に、標準出力にメッセージが出力される。メッセージは、文字列tracemem、コピーされるオブジェクトと作成される新しいオブジェクトの識別文字列、および複製が発生した場所を示すスタックトレースで構成される、また、NULL、環境、約束、弱い参照、外部ポインタ・オブジェクトは複製されないため、これらの関数をトレースすることは有益ではありません。
最初の11の関数はコネクションを作成します。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる可能性がある。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzはバイナリモードで、zipファイル内の(単一ファイルのみを)読み込む。説明にはzipファイルへのフルパスを指定し、必要であれば'.zip'拡張子を付ける。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
NA
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ利用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
クラス属性は、オブジェクトが継承するクラス名を示す文字ベクトルである。オブジェクトがクラス属性を持たない場合、そのオブジェクトは暗黙のクラスを持つ。  ほとんどのベクトルはmode(x)の結果がclassになります。ただし、整数ベクトルはclass c("整数", "数値")、実数ベクトルはclass c("double", "数値")です。UseMethod("fun")を呼び出す関数がクラス属性c("first", "second")を持つオブジェクトに適用されると、システムはfun.firstと呼ばれる関数を検索し、見つかればそれをオブジェクトに適用します。  もしそのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  関数メソッドは、特定のジェネリック関数またはクラスのメソッドについて調べるために使用できます。UseMethodはプリミティブ関数ですが、標準的な引数マッチングを使用します。  UseMethodはプリミティブ関数ですが、標準的な引数マッチングを使用します。UseMethodは現在、オブジェクトでない引数でも暗黙のクラスでディスパッチしますが、他のディスパッチ手段ではディスパッチしません。NextMethodは次のメソッドを呼び出します（ジェネリックに供給されたオブジェクトのクラスベクタ、またはメソッドが直接呼び出された場合はNextMethodを含む関数の最初の引数によって決定されます）。  NextMethodはUseMethodによって呼び出されるメソッドか、内部ジェネリック（InternalGenericsを参照）から呼び出されるメソッド以外では呼び出されるべきではありません。  特に、匿名呼び出し関数（例えば、get("print.ts")(AirPassengers)）の中では動作しません。名前空間は、ジェネリック関数のメソッドを登録できます。  これをサポートするために、UseMethodとNextMethodはジェネリック関数が呼び出される環境と、ジェネリックが定義される環境(通常は名前空間)の登録データベースの2つの場所でメソッドを検索します。  R 3.5.0から、登録データベースは呼び出し環境のトップレベル環境(seetopenv)の後(トップレベル環境の親の前)に検索されます。
intToUtf8はデフォルトではサロゲートペアを扱いません: サロゲート範囲内の入力はNAにマップされます。  UTF-16バイトのストリームが2バイト整数として(正しいバイト順で)読み込まれた場合に発生する可能性があり、その場合は allow_surrogate_pairs = TRUE で解釈しようとします(一致しないサロゲート値はNAとして扱われます)。
validUTF8は、マークされたエンコーディング（Encodingを参照）を無視し、各文字列のバイトが有効なUTF-8であるかどうかを直接調べます。  (「非文字」の有効性については、intToUtf8のヘルプを参照のこと。)validEncは、文字列のエンコーディングがUTF-8としてマークされているか、マークされておらず、セッションがUTF-8または他のマルチバイトロケールにある場合を除き、文字列が有効にエンコードされているとみなす。  (その他のマルチバイトロケールでのチェックはOSに依存し、iconvと同様に無効な入力がすべて検出されるとは限らない)。
これらは、asgrep.validUTF8などの関数で使用されるものと同様のチェックを使用する。validUTF8は、マークされたエンコーディング（Encodingを参照）を無視するため、各文字列のバイトが有効なUTF-8であるかどうかを直接調べる。  (「非文字」の有効性については、intToUtf8のヘルプを参照のこと。)validEncは、文字列のエンコーディングがUTF-8としてマークされているか、マークされておらず、セッションがUTF-8または他のマルチバイトロケールにある場合を除き、文字列が有効にエンコードされているとみなす。  (他のマルチバイトロケールでのチェックはOSに依存し、iconvと同様に、無効な入力がすべて検出されるとは限らない)。
FUNは、match.funの呼び出しによって検出され、通常、関数またはシンボル(例えば、バッククォートされた名前)として指定される、FUNはmatch.funの呼び出しによって見つかり、通常、関数、シンボル（バッククオート名など）、またはlapplyの呼び出しの環境から検索される関数を指定する文字列として指定されます。関数FUNは、Xの要素のいずれかを入力として受け入れることができなければなりません。後者がアトミックベクトルの場合、FUNは常にXと同じ型の長さ1のベクトルを渡されます。  汎用的なコードでは、...を通過させる場合、最初の2つの引数にXとFUNという名前を付けるのが良い方法である。これにより、FUNへの部分一致を避けることができ、XまたはFUNという名前の引数が...を通過した場合、賢明なエラーメッセージが表示されるようになる。  共通の長さが 1 の場合、結果はベクトルになり、1 より大きい場合は X の各要素に対応する列を持つ行列になります。  この関数は、FUNの全ての値がFUN.VALUEと互換性があり、長さと型が同じでなければならないことをチェックします(型は、logical< integer < double < complexの順序で上位の型に昇格することができますが、降格することはできません)。S4クラスのユーザは、lapplyとvapplyにリストを渡す必要があります: 内部的な強制は、基本名前空間内のas.listによって行われ、ユーザによって定義されるものではありません(例えば、基本関数にS4methodsを設定することによって)。
アトミックモードは、"logical"、"integer"、"numeric"（同義語の "double"）、"complex"、"character"、"raw "です。mode = "any "の場合、is.vectorはアトミックモード、リスト、式に対してTRUEを返します。  (一方、as.vectorは、atomicモードの結果（ただし、"list "モードや "expression "モードの結果は除く）について、nameを含むすべての属性を除去します。is.vectorはFALSEを返し、as.vectorはmode = "any "の場合、因子を文字ベクトルに変換します。
Vectorizeの引数vectorize.argsに指定された引数は、applyの...リストに渡された引数です。  実際に渡されたものだけがベクトル化され、デフォルト値はベクトル化されません。  また、FUN、vectorize.args、SIMPLIFY、またはUSE.NAMESという名前の引数を持つ関数と一緒に使うこともできません。  回避策としては以下のcombnの例を参照してください。  
例えばmacOSMavericks 10.9.4はdarwin13.3.0、Linuxは通常linux-gnu、Solaris 10はsolaris2.10である。
結果は、options("warn")の値と、実行コードで確立されたハンドラに依存する。conditionオブジェクトが提供された場合、それは唯一の引数でなければならず、それ以上の引数はメッセージとともに無視される。warningは、(事実上)ignalConditionを呼び出すことによって警告条件を通知する。  ハンドラがない場合、またはすべてのハンドラが返される場合、warn = getOption("warn")の値が適切なアクションを決定するために使用されます。  warnが負の場合、警告は無視され、0の場合、警告は保存され、トップレベル関数が終了した後に表示されます。1の場合、警告が発生したときに表示され、2（またはそれ以上）の場合、警告はエラーに変わります。warning(immediate.=TRUE)を呼び出すと、warn <= 0がwarn = 1に変換されます。warnが0（デフォルト）の場合、読み取り専用の変数last.warningが作成されます。  警告は、getOption("warning.length")文字数（デフォルト1000）に切り詰められ、[...truncated]で示されます。警告が処理されている間、muffleWarning restartが利用できます。  このリスタートがinvokeRestartで呼び出された場合、warningは即座に戻る。warningへの他のタイプの入力を文字ベクトルに強制する試みが行われる。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(警告が生成される時点)の最大値であり、デフォルトでは50であることに注意。  例えば、options(warn)が変更された場合や、壊滅的なエラーが発生した場合などです。
NA
NA
NA
NA
NA
NA
breakはfor、while、またはrepeatループから抜け出し、制御はループの最内部の外側の最初の文に移る。  breakもnextも、入れ子になったループの一番内側だけに適用される。よくある間違いだが、ステートメントを中括弧（{ .. }）で囲むのを忘れることがある、特に、キーボードやソースからif...else構文を入力する際の構文エラーを避けるために、}とelseの間に改行を入れるべきではありません。そのため、防御的プログラミングの（やや極端な）姿勢の1つとして、if句などには常に中括弧を使用することが挙げられます。  seqの長さがゼロの場合、ループ本体はスキップされる。そうでなければ、変数varにseqの各要素の値が順番に代入される。ループ本体内でvarに代入することもできるが、次の繰り返しには影響しない。  ループが終了しても、varは最新の値を含む変数として残ります。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを単純化するのに便利である。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます。)expr内の代入は、構築された環境で行われ、ユーザーのワークスペースでは行われないことに注意してください。withinも同様ですが、exprの評価後に環境を調べ、データのコピーに対応する修正を行い(データフレームの場合、データフレームに格納できないオブジェクトが作成されると失敗することがあります)、それを返します。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを簡略化するのに便利です。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます。) expr内の代入は、ユーザーのワークスペースではなく、構築された環境で行われることに注意してください。
ソースからコードを実行する場合、R のコマンドラインから入力する場合と異なる点がいくつかあることに注意してください。  式はトップ・レベルでは実行されないため、自動印刷は行われません。  そのため、印刷させたいものについては、明示的にprintを呼び出す必要があります（これには格子によるプロットも含まれることを忘れないでください、FAQ Q7.22）。  ファイル全体が実行される前に解析されるため、構文エラーはどのコードも実行されないことになります。  Rのすべてのバージョンは、LF（Unixで使用）、CRLF（DOS/Windowsで使用）またはCR（クラシックMac OSで使用）でマークされた行末を持つ接続からの入力を受け付け、これを改行にマップします。  最終行は、行末マーカーを欠いた不完全な行になる可能性があります。keep.sourceがtrueの場合（対話的に使用する場合のデフォルト）、関数のソースが保持されるため、入力として正確にリストすることができます。コンソールからの入力とは異なり、ファイル内または接続上の行には、無制限の文字数を含めることができます。skip.echo > 0の場合、ファイルの先頭にあるコメント行の数はエコーされません。  これは、コードの実行にはまったく影響しません。  echoがtrueで、deparsed式がsmax.deparse.lengthを超えた場合、その文字数だけ出力され、その後に ... が続きます。[TRUNCATED] .
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができ、その場合はfindRestartを使用してrestartを見つけます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを簡略化するのに便利である。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます。)expr内の代入は、構築された環境で行われ、ユーザーのワークスペースでは行われないことに注意してください。withinも同様ですが、exprの評価後に環境を調べ、データのコピーに対応する修正を行い(データフレームの場合、データフレームに格納できないオブジェクトが作成されると失敗することがあります)、それを返します。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを単純化するのに便利です。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます。)expr内の代入は、構築された環境で行われ、ユーザーのワークスペースでは行われないことに注意してください。withinも同様ですが、exprの評価後に環境を調べ、データのコピーに対応する修正を行い(データフレームの場合、データフレームに格納できないオブジェクトが作成されると失敗することがあります)、それを返します。
withは、データから構築されたローカル環境でexprを評価する汎用関数です。  この環境は呼び出し元の環境を親として持つ。  これはモデリング関数の呼び出しを単純化するのに便利です。  (注意: データがすでに環境である場合、これは既存の親と一緒に使用されます。)expr内の代入は、構築された環境で行われ、ユーザーのワークスペースでは行われないことに注意してください。withinも同様ですが、exprの評価後に環境を調べ、データのコピーに対応する修正を行い(データフレームの場合、データフレームに格納できないオブジェクトが作成されると失敗することがあります)、それを返します。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最近確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによって不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みを有効にしている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
これはプリミティブ関数である。
NA
DCFは、データベースを人間が直接読み書きしやすいプレーンテキストファイルに格納するための単純な形式である。  DCFは、パッケージの説明や内容など、Rのシステム情報を格納するためにさまざまな場所で使用されています：データベースは1つ以上のレコードから構成され、各レコードは1つ以上の名前付きフィールドを持つ。  すべてのレコードに各フィールドが含まれている必要はない。規則的な行は空白以外の文字で始まる。すなわち、フィールドの名前タグと値を:で区切って持つ（最初の:だけがカウントされる）。  値は空でもよい（つまり空白のみ）。空白で始まる行は、その行の少なくとも1文字が空白でない場合、（前のフィールドへの）継続行となる。  空白でない文字が.のみである継続行は空行とみなされる（複数段落のフィールド値が可能）。レコードは1行以上の空行（すなわち空白のみ）で区切られる。R3.0.2以前では、1行の長さの限界は約8191バイトであった。read.dcf(all = FALSE)は、ファイルをバイト単位で読み込むことに注意する。
conが文字列の場合、関数はfileを呼び出してバイナリモードのファイル接続を取得し、その接続は関数呼び出しの間オープンされる。  接続がオープンされている場合、現在の位置から読み取り/書き込みが行われます。 接続がオープンされていない場合、適切なモード（バイナリ読み取りまたは書き込み）で呼び出しの間オープンされ、その後再びクローズされます。  オープンされている接続は、バイナリ・モードでなければなりません。readBin が生のベクタ con で呼び出された場合、ベクタ内のデータが入力として使用されます。  size が指定され、オブジェクトの自然なサイズでない場合、ベクタの各要素は、書き込む前または読み込む前に適切な型に強制されます。  可能なサイズは、整数または論理ベクトルでは1、2、4、場合によっては8、数値ベクトルでは4、8、場合によっては12/16です。  (サイズ1と2の整数を読み込むときにsigned = FALSEの場合を除き、符号付き型として強制演算が行われることに注意。)サイズを変更してもNAが保持される可能性は低く、拡張精度のサイズはプラットフォーム間で移植性が低い。  readCharとwriteCharは、固定長文字列の読み書きに使用できる。  文字列が現在のロケールのエンコーディングで有効であるかどうかのチェックは行われません。Rの欠損値や特殊値（Inf、-Inf、NaN）の取り扱いについては、「Rデータのインポート/エクスポート」マニュアルで説明されています。
これらの関数は、Cスタイルのゼロ終端文字列を読み書きするreadBinとwriteBinを補完するものです。  これらの関数は、長さが既知の文字列を対象としており、オプションで文字列の終端マークを書き込むことができる。  conが文字列の場合、関数はfileを呼び出してバイナリモードのファイル接続を取得し、その接続は関数呼び出しの間オープンされる。  接続がオープンされている場合、現在の位置から読み取り/書き込みが行われます。 接続がオープンされていない場合、適切なモード（バイナリ読み取りまたは書き込み）で呼び出しの間オープンされ、その後再びクローズされます。  オープンされている接続は、バイナリ・モードでなければなりません。readCharがcon rawベクトルで呼び出された場合、ベクトル内のデータが入力として使用されます。  ASCIIのnul(s)を含む文字列は、readCharによって正しく読み込まれますが、最初のnulで切り捨てられ、警告が表示されます。readCharで要求された文字長が、接続で利用可能なデータよりも長い場合、利用可能なものが返されます。  writeCharでは、要求された文字数が多すぎる場合、出力はゼロパディングされ、警告が表示される。
conが文字列の場合、関数はfileを呼び出してファイル接続を取得し、その接続は関数呼び出しの間オープンされる（ファイルパスのチルダ展開はfileによって行われる）。  さらに制御を強化するには、バイナリ接続を開き、ファイルに書き込む正確な値をsepに指定します。 さらに制御を強化するには、バイナリ接続でewriteCharを使用します。  useBytes = TRUEは、マークされた文字列の再エンコードを抑制し、接続にバイト単位で 渡すようにします。これは、iconvなどで文字列が既に再エンコードされている場合に便利です。
と&&は論理ANDを、｜と｜｜は論理ORを示す。  短縮形は、算術演算子とほぼ同じ方法で要素間の比較を行います。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、ゼロは偽、ゼロ以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (ディスパッチの計算方法についてはOpsを参照してください。)NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については、構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
xpdrows.data.frameはデータフレームの行を展開する補助関数です。  これは、[<-と[[<-のデータフレームメソッド（データフレームの添え字代入を実行する）で使用され、直接呼び出されることは意図されていません。
これはランキングの特殊なケースですが、rank よりも汎用性の低い関数であるため、汎用化する方が適しています。  デフォルトのメソッドはrank(x, ties.method = "min", na.last = "keep")に似ており、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラスは解除されるが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使います。
これはランキングの特殊なケースですが、rank よりも汎用性の低い関数であるため、汎用化するのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ており、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラス分けを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
これはランキングの特殊なケースですが、rankよりも一般的でない関数なので、ジェネリックにするのに適しています。  defaultメソッドはrank(x, ties.method = "min", na.last = "keep")に似ているので、NAの値にはランクNAが与えられ、すべての同値には等しい整数ランクが与えられます。numeric(x)がtrueであればオブジェクトのクラスを解除するが、そうでなければx[i]のクラス（整数iの場合）には==メソッドと>メソッドを、xのクラスにはis.naメソッドを使用する。
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ利用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
NA
典型的な使用法は以下の通りである。最初の形式は、切片/切片の形式で直線を指定する（あるいは、aを単独で指定し、ベクトル形式で勾配と切片を含むようにすることもできる）。untfがtrueで、片方または両方の軸が対数変換されている場合、元の座標系での直線に対応する曲線が描かれ、そうでない場合は変換後の座標系での直線が描かれます。グラフィカルパラメータ col, lty, lwd を指定することができる。  クリッピングのために xpd 引数を指定すると、それ以外の場合に使用されるグローバルな par("xpd") 設定を上書きします。
各 i に対して、点(x0[i], y0[i])と点(x1[i], y1[i])の間に矢印が引かれます。  code=1の場合、矢尻は(x0[i], y0[i])に描かれ、code=2の場合、矢尻は(x1[i], y1[i])に描かれる。  もしcode = 3なら矢印の両端に頭が描かれる。  グラフィカルパラメータcol、lty、lwdは、1以上の長さのベクトルであることができ、必要に応じてリサイクルされます。長さ0の矢印の方向は不確定であり、したがって、矢じりの方向も不確定です。  丸め誤差を許容するために、長さが1/1000インチ以下の矢印では矢じりは（警告とともに）省略される。
二元分割表では、セルi, jのPearson'schi^2への符号付き寄与はd_{ij} = (f_{ij} - e_{ij}) / sqrt(e_{ij})であり、f_{ij}とe_{ij}はセルに対応する観察数と期待数である。  Cohen-Friendly連想プロットでは、各セルは、高さがd_{ij}に比例し、幅がsqrt(e_{ij})に比例する（符号付き）長方形で表現され、ボックスの面積は、観察された頻度と期待される頻度の差に比例する。各行の長方形は、独立性（d_{ij} = 0）を示すベースラインに対して配置される。  あるセルの観測された頻度が期待された頻度より大きい場合、ボックスはベースラインより上に上がり、colの1番目の要素で指定された色（デフォルトは黒）で陰影が付けられます。そうでない場合、ボックスはベースラインより下に下がり、colの2番目の要素で指定された色（デフォルトは赤）で陰影が付けられます。グリッド・グラフィックス・システムで書かれた連想プロットのより柔軟で拡張可能な実装は、寄贈パッケージvcd(Meyer, Zeileis and Hornik, 2006)の関数assocで提供されています。
軸線はatの最小値から最大値まで引かれますが、プロット領域で切り取られます。  デフォルトでは、（丸め誤差の許容範囲内で）プロット領域内の点から描画された目盛りのみがプロットされるが、目盛りとそのラベルはプロット領域の外にはみ出す可能性がある。  at = NULLの場合、目盛りの位置はpar("xaxp")または "yaxp" とpar("xlog")(または "ylog")から内部的に計算されます(axTicks(side)と同じです)。  labelsが指定されない場合、atに供給されるか計算された数値は、print.default(digits = 7)によって印刷される数値ベクトルであるかのように文字列に変換されます。目盛りは左から右、または下から上に描かれ、ラベルとラベルの間には少なくとも'm'の大きさにgap.axisを掛けたスペースが空きます。  以前のRバージョンでは、これは軸方向に平行に書かれたラベルにのみ適用され、例えばlas = 2には適用されませんでした。  gap.axis=-1を使用すると、（バギーな）以前の動作（垂直の場合）が復元されます。lineまたはposのいずれかが設定されている場合、それら（par("mgp")[3]ではなく）が軸線と目盛りの位置を決定し、目盛りのラベルはpar("mgp")[2]の余白のさらに内側（またはposの方向）に配置されます。軸と目盛りラベルの垂直方向（辺1と辺3に対して）の位置はmgp[2:3]とmexによって制御され、目盛りの大きさと方向はtckとtclによって制御され、目盛りラベルの外観はcex.axis、col.axis、font.axisによって制御され、方向はlasによって制御されます（ただし、srtは使用しません。Sは、発行時にsrtが適用されていればそれを使用し、適用されていなければlasを使用します）。  adjはサポートされておらず、ラベルは常に中央に配置されることに注意してください。  詳細はparを参照。
これは汎用関数です。  xが与えられ、かつ、NULLでない場合、xに対してディスパッチされ、atが与えられ、かつ、NULLでない場合、atに対してディスパッチされます。contour,pairs,plot.default,rug,stripchartを含む)はユーザー座標を設定し、Axisはそれらを適切にラベル付けするために呼び出されます。適切な軸メソッドに引数形式を渡すことができる "Date "メソッドと "POSIXt "メソッドがあります(axis.POSIXctを参照)。
axis.POSIXctとaxis.Dateは、適切な時間単位（年、月、日、時、分、または秒）と賢明な出力形式を選択するために非常に懸命に働きますが、これは形式指定を指定することで上書きできます。atが指定された場合は目盛りとラベルの位置が指定され、xが指定された場合はラベルの適切なグリッドが選択されます。POSIXct "入力の日付時刻は、"tzone "属性で指定されたタイムゾーンがある場合はそのタイムゾーンで解釈され、そうでない場合は現在のタイムゾーンで解釈される。日付時刻の表示方法（特に月名）は、カテゴリー "LC_TIME "のロケール設定（Sys.setlocaleを参照）によって制御される。
axis.POSIXctとaxis.Dateは、適切な時間単位（年、月、日、時、分、または秒）と賢明な出力形式を選択するために非常に懸命に働きますが、これは形式指定を指定することで上書きできます。atが指定された場合は、目盛りとラベルの位置が指定され、xが指定された場合は、ラベルの適切なグリッドが選択されます。POSIXct "入力の日付-時刻は、"tzone "属性で指定されたタイムゾーンがあればそのタイムゾーンで解釈され、なければ現在のタイムゾーンで解釈される。
axp、usr、logの各引数は、デフォルト値（par(...)の結果）と同じように一貫していなければならない。  この3つすべてを（NULL以外で）指定した場合、グラフィックス環境はまったく使用されない。  par(xaxp=.)のドキュメントを参照して下さい。axTicks()は、axis(plot.c)で呼び出されるC関数CreateAtVector()のRでの実装と見なすことができます。この関数は、引数atが指定されていない場合、axis(side, *)によって呼び出されるか、axisTicks() (packagegrDevices内)によって直接呼び出されます。微妙なケースであるlog = TRUEでは、バックコンパチビリティのために存在するnintLog = Infでない限り、axisTicksが使用されます。
NA
NA
色の選択は複雑である。  colが供給され、NAでなければ、それが使われる。  そうでなければ、fgが供給され、NAでなければ、それが使われる。  最終的なデフォルトはpar("col")である。
ジェネリック関数boxplotには現在、デフォルトメソッド(boxplot.default)と数式インターフェース(boxplot.formula)があります。複数のグループが複数の引数として、または数式を介して提供された場合、引数の順序または因子のレベルの順序で、平行なボックスプロットがプロットされます(factorを参照)。
ジェネリック関数boxplotには現在、デフォルトメソッド(boxplot.default)と数式インターフェース(boxplot.formula)があります。複数のグループが複数の引数として、または数式を介して提供された場合、平行箱ひげ図が引数の順番、または因子(factorを参照)のレベルの順番でプロットされます。
NA
NA
cdplotは、yの周辺分布によって重み付けされたyの水準に対するxの条件付き密度を計算します。この密度は、yの水準にわたって累積的に導出されます。この可視化手法は、スピノグラム（spinplotを参照）に似ており、xに対してP(y | x)をプロットします。条件付き確率は、（スピノグラムのように）離散化によって導出されるのではなく、密度による平滑化アプローチを用いて導出される。条件付き密度の推定は、xの高密度領域に対してより信頼できることに注意。
クリッピング矩形がどのように設定されるかは、par("xpd")の設定に依存します。この関数は、次の高レベルのプロット・コマンドがそれをリセットするまで、現在の設定を変更します。線、矩形、多角形のクリッピングはグラフィック・エンジンで行われますが、テキストのクリッピングは可能であればデバイスで行われるため、テキストのクリッピングの効果はデバイスに依存します（クリッピング領域内にないテキストが完全に省略されることもあります）。lineやtextのような関数はpar("xpd")が変更された場合のみリセットします。  しかし、box、mtext、title、plot.dendrogramなどの関数はxpdの設定を操作することができます。
split.screenを最初に呼び出すと、Rは画面分割モードになる。  他の分割画面関数は、このモードでのみ動作する。このモードでは、他の特定のコマンドを使用しないようにする必要がある（以下の警告セクションを参照）。  現在のスクリーンが閉じられている場合、close.screenは現在のスクリーンを次の大きなスクリーン番号に設定する。
単一の条件変数aの場合、行と列の両方が指定されていないときは、列≧行の「正方形に近い」レイアウトが選択される。複数の行の場合、パネル図の順序は下から左（通常、aの増加に対応する）になる。したがって、plotとboxplotはパネル関数ではありません。引数xlabとlabのレンダリングは、それらがタイトルではなくテキストでプロットされるとしても、par引数cex.labとfont.labによって制御されません。
等高線上のラベルを配置する方法は、"simple"(等高線に重なるようにプロットの端に描画)、"edge"(等高線に重ならないようにプロットの端に描画)、"flattest"(等高線に重ならないように等高線の最も平坦な部分に描画)があります。  contourはz行列を(x[i], y[j])値からなる表として解釈し、x軸が行番号、y軸が列番号に対応し、列1が一番下になるように、つまり従来のtextuallayoutを反時計回りに90度回転させることに注意。ベクトル（長さ1以上）col, lty, lwdはレベルとリサイクルに沿って適用される。  もっとコントロールしたい場合は、プロットに等高線を追加するか、等高線プロットに軸とフレームを追加してください。
等高線上のラベルを配置する方法は、"simple"(等高線に重なるようにプロットの端に描画)、"edge"(等高線に重ならないようにプロットの端に描画)、"flattest"(等高線に重ならないように等高線の最も平坦な部分に描画)がある。  contourはz行列を(x[i], y[j])値からなる表として解釈し、x軸が行番号、y軸が列番号に対応し、列1が一番下になるように、つまり従来のtextuallayoutを反時計回りに90度回転させることに注意。ベクトル（長さ1以上）col, lty, lwdはレベルとリサイクルに沿って適用される。  もっとコントロールしたい場合は、プロットに等高線を追加するか、等高線プロットに軸とフレームを追加してください。
単一の条件変数aの場合、行と列の両方が指定されていないときは、列 >=行の「正方形に近い」レイアウトが選択されます。複数の行の場合、パネルプロットの順序は、下から、そして左からになります（通常、aの増加に対応します）。したがって、plotとboxplotはパネル関数ではありません。引数xlabとlabのレンダリングは、それらがタイトルではなくテキストでプロットされるとしても、par引数cex.labとfont.labによって制御されません。
関数または式 expr（曲線の場合）または関数x（プロットの場合）は、範囲[from, to]に等間隔で配置されたn点で評価されます。  このようにして決定された点がプロットされます.fromかtoのどちらかがNULLの場合, xlimの対応する要素がNULLでなければそれがデフォルトになります.from/toもxlimも両方のx-limitsを指定しない場合に何が起こるかは複雑な話です.  plot(<function>)とcurve(add = FALSE)のデフォルトは(0, 1)です。  curve(add = NA)とcurve(add = TRUE)の場合、デフォルトは前のplotで使われたx-limitsから取られます。  (これはRの2.14.0より前のバージョンとは異なります。)logの値は、(add = TRUEでない限り)プロットの軸を指定するためと、'等間隔'がどのように解釈されるかの両方に使用されます: x成分が対数スケーリングを示す場合、式または関数がプロットされる点は対数スケールで等間隔になります。add = TRUEの場合、logのデフォルト値は現在のプロットから取得されますが、add = NAの場合、x成分は既存のプロット(もしあれば)から取得され、y成分のデフォルトは線形になります。  add = FALSEの場合、デフォルトは""です。これは以前は手っ取り早いハックでしたが、現在では便利な目的にかなっているようです。  この場合、exprは関数の名前とみなされ、xnameで指定された名前の単一引数を持つexprの呼び出しに置き換えられる。  それ以外の場合は、exprが呼び出しか式であるか、xnameで与えられた変数への参照を含んでいるか（all.varsを使用）をチェックする。  これは、curve(x, ...)がxという名前の関数をプロットする要求として受け取られることを意味することに注意してください（そして、それはplotのfunctionメソッドでそのように使用されます）。
NA
split.screenを最初に呼び出すと、Rは画面分割モードになります。  他の分割画面関数は、このモードでのみ動作する。このモードでは、他の特定のコマンドは使用しないこと（以下の警告セクションを参照）。  現在のスクリーンが閉じている場合、close.screenは現在のスクリーンを次の大きいスクリーン番号に設定する。
プロットされる値にはNAを含めることができる。  プロットされる値は無限大にすることができます: その効果は、NA値について説明したものと同様です。filled.contourは、すでに設定されているプロット領域に等高線プロットを追加するための'素の'インターフェイスです。  プログラマが引数の条件をチェックする責任があります。
適切な標準化に従って、各2×2表のセル度数f[i,j]は、半径がsqrt(f[i,j])に比例する四分円として表示され、その面積はセル度数に比例する。  2値の行変数と列変数の間の関連（1とは異なるオッズ比）は，ある方向の対角線上の対向するセルが他の方向のセルと大きさが異なる傾向によって示される; この方向を示すために色が使用される．  オッズ比の信頼度リングは、関連がないという帰無の視覚的検定を可能にします；観察されたカウントが帰無仮説と一致する場合のみ、隣接する象限のリングが重なります。通常、数 k は、層化変数の水準数に対応し、関連が層間で均質であるかどうかを見ることが興味です。  4重表示は、関連性のパターンを可視化します。  個々のオッズ比の信頼リングは、多重検定で調整されていないことに注意。
新しいページは背景色(par("bg"))で描かれ，多くの場合透明である．  キャンバスカラーを持つデバイス（オンスクリーンデバイスのX11、windows、quartz）では、ウィンドウはまずキャンバスカラーで塗られ、次に背景色で塗られる。フレームを進める直前と直後に呼ばれる "before.plot.new "と "plot.new"（setHookを参照）という2つのフックがある。後者は、新しいページに注釈を付けるためにテストコードで使用されます。フック関数は引数なしで呼び出されます。  (値が文字列の場合は、graphics名前空間内からgetが呼び出されます)。
座標系は、ユーザー座標系.インチ座標系.デバイス座標系.正規化デバイス座標系.正規化図形座標系.正規化プロット座標系.正規化内部領域座標系である。  (「内部領域」とは、外側の余白の内側を指します。)余白行(mexに基づく).テキスト行(cexに基づく)(これらの名前は部分的に一致させることができます。)「正規化」座標系では、左下は値0、右上は値1です。デバイス座標系とは、デバイスが動作する座標系です。通常、意味がある場合はピクセル単位で、そうでない場合は大きなポイント(1/72インチ)単位になります(pdfやpostscriptなど)。
座標系は、ユーザー座標.インチ.デバイス座標系.正規化されたデバイス座標.正規化された図形座標.正規化されたプロット座標.正規化された内部領域座標。  (「内側領域」とは、外側の余白の内側のことである。)余白行(mexに基づく).テキスト行(cexに基づく)(これらの名前は部分的に一致させることができる。)「正規化」座標系では、左下は値0、右上は値1である。デバイス座標とは、デバイスが動作する座標のことである。通常、意味がある場合はピクセル単位であり、そうでない場合は大きなポイント(1/72インチ)単位である(pdfやpostscriptなど)。
NA
ヒストグラムの定義はソースによって異なります（国特有の偏りがあります）。  Rのデフォルトでは、等間隔に区切りがある場合（これもデフォルト）、区切りで定義されたセルにカウントがプロットされる。  したがって、長方形の高さは、区切りが等間隔である場合の面積と同様に、セルに入る点の数に比例します。等間隔でない区切りのデフォルトは、面積1のプロットを与え、長方形の面積は、セルに入るデータ点の割合になります、right=FALSEの場合，区間は[a, b]の形式となり，include.lowestは「最高値を含む」を意味する．ビンの端のエントリをカウントする場合，ビンの中央値の1e-7の数値許容誤差（4ビン以上の場合，そうでない場合は中央値で代用される）が適用される．  breakのデフォルトは "Sturges": seenclass.Sturgesである。  大文字小文字は無視され、部分マッチングが使用されます。また、意図されたブレーク数または実際のブレークポイントをxの関数として計算する関数を与えることもできます。
ヒストグラムの定義はソースによって異なります（国特有のバイアスがあります）。  Rのデフォルトでは、等間隔に区切りがある場合（これもデフォルト）、区切りで定義されたセルにカウントがプロットされます。  したがって、長方形の高さは、区切りが等間隔である場合の面積と同様に、セルに入る点の数に比例します。等間隔でない区切りのデフォルトは、面積1のプロットを与え、長方形の面積は、セルに入るデータ点の割合になります、right=FALSEの場合，区間は[a, b]の形式となり，include.lowestは「最高値を含む」を意味する．ビンの端のエントリをカウントする場合，ビンの中央値の1e-7の数値許容誤差（4ビン以上の場合，そうでない場合は中央値が代入される）が適用される．  breakのデフォルトは "Sturges": seenclass.Sturgesである。  大文字小文字は無視され、部分マッチングが使用されます。また、意図されたブレーク回数または実際のブレークポイントをxの関数として計算する関数を指定することもできます。
identifyは汎用の関数であり、ここではデフォルトの方法のみを説明します。identifyはX11、windows、quartzのようなスクリーンデバイスでのみサポートされています。  他のデバイスでは、呼び出しは何もしません。点の近く（許容誤差で定義される）をクリックすると、その点が識別された点のリストに追加されます。  点の識別は一度だけ可能で、点がすでに識別されていたり、クリックがどの点にも近接していない場合は、直ちにRコンソールにメッセージが出力されます。plotがTRUEの場合、点にはlabelsの対応する要素がラベル付けされます。  atpenがfalse（デフォルト）の場合、ラベルは、ポインタがポイントに対してどの位置にあったかに応じて、特定されたポイントの下、左、上、または右に配置されます。  atpenがtrueの場合、ラベルは、文字列のボックスの左下がポインタになるように配置される。通常のX11デバイスの場合、識別プロセスは、最初のマウスボタン以外のマウスボタンを押すと終了する。identifyをサポートしているほとんどのデバイスでは、options(locatorBell = FALSE)が設定されていない限り、ポイントの選択が成功するとベル音で示される。identifyプロセスが終了する前にウィンドウのサイズを変更したり、ウィンドウを非表示にしてから表示したりすると、identifyによって描かれたラベルはすべて消えてしまう。  これは、identifyによって描画されたラベルが、identifyプロセスが終了するまでデバイスの表示リストに記録されないためです。identifyの呼び出しを中断すると、グラフィック・デバイスは未定義の状態になり、ポイントにラベルが付けられますが、ラベルは表示リストに記録されません。  その状態でデバイスをコピーすると、予測できない結果が得られます。
xの長さは、nrow(z)+1 ornrow(z)に等しくなければならない。  最初の場合、xはセル間の境界を指定し、2番目の場合、xはセルの中点を指定する。  同じような理屈がyにも当てはまる。おそらく、等間隔に配置されたグリッドの中点を指定することだけが理にかなっている。  行または列を1つだけ指定し、xまたはyの長さを1つにすると、対応する方向のユーザー領域全体が満たされる。欠損値に対応する矩形はプロットされません（したがって透明であり、（add = TRUEでない限り）par("bg")で描画されたデフォルトの背景が透けて見えます。imageはz行列を(x[i], y[j])値の表として解釈するので、x軸は列番号に対応し、y軸は列番号に対応する。規則的なグリッド上の大きな z の画像は、 useRaster = TRUE を指定することでより効率的にレンダリングされ、まれに発生するアンチエイリアシングのアーチファクトを防ぐことができますが、すべてのグラフィックデバイスでサポートされているわけではありません。  半透過色をサポートしていないデバイス (postscript や X11(type = "Xlib") など) では、欠落した値が透明ではなく白として出力されることがあり、ラスター画像のサイズに制限があるかもしれません。  (useRaster が指定されていない場合、ラスター画像は、getOption("preferRaster")が真で、グリッドが規則的で、dev.capabilities("rasterImage")$rasterImage が "yes "か、"non-missing "で、欠損値がない場合に使用されます。
x の長さは nrow(z)+1 ornrow(z) に等しくなければならない。  最初の場合 x はセル間の境界を指定し、2番目の場合 x はセルの中点を指定する。  同じような理屈がyにも当てはまる。おそらく、等間隔に配置されたグリッドの中点を指定することだけが理にかなっている。  行または列を1つだけ指定し、xまたはyの長さを1つにすると、対応する方向のユーザー領域全体が満たされる。欠損値に対応する矩形はプロットされません（したがって透明であり、（add = TRUEでない限り）par("bg")で描画されたデフォルトの背景が透けて見えます。imageはz行列を(x[i], y[j])値の表として解釈するので、x軸は列番号に対応し、y軸は列番号に対応する。規則的なグリッド上の大きな z の画像は、 useRaster = TRUE を指定することでより効率的にレンダリングされ、まれに発生するアンチエイリアシングのアーチファクトを防ぐことができますが、すべてのグラフィックデバイスでサポートされているわけではありません。  半透過色をサポートしていないデバイス (postscript や X11(type = "Xlib") など) では、欠落した値が透明ではなく白として出力されることがあり、ラスター画像のサイズに制限があるかもしれません。  (useRaster が指定されていない場合、ラスター画像は、getOption("preferRaster")が真で、グリッドが規則的で、dev.capabilities("rasterImage")$rasterImage が "yes "か、"non-missing "で欠損値がない場合に使用されます。
respect 引数は、単位列幅が単位行高さとデバイス上で同じ物理的測定値であるかどうかを制御する。layout.show(n)は、現在のレイアウト（の一部）、つまり次のn個の図のアウトラインをプロットする。lcmは些細な関数で、layout()のwidthsとheights引数の絶対寸法を指定するインターフェースとして使用される。
respect引数は、単位列幅が単位行高さとデバイス上で同じ物理的測定値であるかどうかを制御する。layout.show(n)は、現在のレイアウト（の一部）、つまり次のn個の図のアウトラインをプロットする。lcmは些細な関数で、layout()のwidthsとheights引数の絶対寸法を指定するインターフェースとして使用される。
respect引数は、単位列幅が単位行高さとデバイス上で同じ物理的測定値であるかどうかを制御する。layout.show(n)は、現在のレイアウト（の一部）、つまり次のn個の図のアウトラインをプロットする。lcmは、layout()のwidthsとheightsの引数の絶対寸法を指定するインターフェースとして使用される些細な関数である。
引数x, y, legendは、座標を1つまたは2つの引数で指定できるように、非標準的な方法で解釈される。  凡例がなく、yが数値でない場合、第2引数は凡例であり、第1引数は座標を指定するものであると仮定される。座標は、xy.coordsが受け付ける任意の方法で指定できる。  これが1点の座標を与える場合、それはlegendを含む矩形の左上座標として使われる。  2つの点の座標を指定する場合は、矩形の対向する角の座標を指定することになる（角の組の順序は問わない）。xを "bottomright"、"bottom"、"bottomleft"、"left"、"topleft"、"top"、"topright"、"right"、"center "の中から1つのキーワードに設定することによっても位置を指定することができる。これは、与えられた位置の plotframe の内側に凡例を配置する。部分的な引数のマッチングが使用される。  オプションの inset 引数は、凡例がプロットのマージンからどの程度挿入されるかを指定する。  col, pch, lty などの属性引数は、必要であればリサイクルされる。  ラベルを右寄せにする方法については、例を参照してください。Unicode コードポイントには使用されないので、値 -31:-1 は、NA や "" 値と同様に、黙って省略されます。
座標は、プロット構造体（x成分とy成分を持つリスト）、2列の行列、時系列、...で渡すことができます。  xy.coordsを参照。  別々に渡される場合、それらは同じ長さでなければなりません。点がxまたはyの値のどちらかにNAを含む場合、その点はプロットから省略され、そのような点との間に線は引かれない。  type="h "の場合、colはベクトルであり、必要に応じて再利用される。lwdはベクトルであり、その最初の要素は線に適用されるが、ベクトル全体は記号に適用される（必要に応じて再利用される）。
座標は、プロット構造体(x成分とy成分を持つリスト)、2列の行列、時系列、...で渡すことができます。  xy.coordsを参照。  別々に渡される場合、それらは同じ長さでなければなりません。点がxまたはyの値のどちらかにNAを含む場合、その点はプロットから省略され、そのような点との間に線は引かれない。  type="h "の場合、colはベクトルにすることができ、必要に応じて再利用される。lwdはベクトルにすることができ、その最初の要素は線に適用されるが、ベクトル全体は記号に適用される（必要に応じて再利用される）。
locatorは、X11、windows、quartzのようなスクリーン・デバイスでのみサポートされています。  通常のX11デバイスの場合、同定処理は最初のボタン以外のマウスボタンを押すことで終了します。ロケータをサポートしているほとんどのデバイスでは、options(locatorBell = FALSE)が設定されていない限り、点の選択が成功するとベル音で示される。入力プロセスが終了する前にウィンドウのサイズを変更したり、ウィンドウを非表示にしてから表示したりすると、ロケータによって描画された線や点は消えてしまう。  これは、ロケータによって描かれた点と線が、入力プロセスが終了するまでデバイスの表示リストに記録されないためである。
matplot(x,y,...)は基本的に(汎用関数) plot(x[,1], y[,1], ...)を最初の列(add = TRUEの場合のみ)に対して呼び出し、(汎用関数) lines(x[,j], y[,j], ...)をそれ以降の列に対して呼び出すためのラッパーです。xの1列目はyの1列目に対してプロットされ、xの2列目はyの2列目に対してプロットされる。  一方の行列の列数が少ない場合、プロットは再び列を循環する。  (特に、xまたはyのどちらかがベクトルであり、もう一方の引数のすべての列に対してプロットされます。)col, cex, lty, lwdの最初の要素は、最初の線と同様に軸をプロットするために使用されます。プロットシンボルは線で描画され、これらの関数は線のスタイルを変更する可能性があるため、プロットシンボルを使用する場合は、おそらくlty = 1を指定する必要があります。
matplot(x,y,...)は、基本的には、最初の列（add = TRUEの場合のみ）に対して（ジェネリック関数）plot(x[,1], y[,1], ...)を呼び出し、それ以降の列に対して（ジェネリック関数）lines(x[,j], y[,j], ...)を呼び出すためのラッパーです。xの1列目はyの1列目に対してプロットされ、xの2列目はyの2列目に対してプロットされる。  一方の行列の列数が少ない場合、プロットは再び列を循環する。  (特に、xまたはyのどちらかがベクトルであり、もう一方の引数のすべての列に対してプロットされます。)col, cex, lty, lwdの最初の要素は、最初の線と同様に軸をプロットするために使用されます。プロットシンボルは線で描画され、これらの関数は線のスタイルを変更する可能性があるため、プロットシンボルを使用する場合は、おそらくlty = 1を指定する必要があります。
matplot(x,y,...)は、基本的には、最初の列（add = TRUEの場合のみ）に対して（ジェネリック関数）plot(x[,1], y[,1], ...)を呼び出し、それ以降の列に対して（ジェネリック関数）lines(x[,j], y[,j], ...)を呼び出すためのラッパーです。xの1列目はyの1列目に対してプロットされ、xの2列目はyの2列目に対してプロットされる。  一方の行列の列数が少ない場合、プロットは再び列を循環する。  (特に,xまたはyのどちらかがベクトルであり,もう一方の引数のすべての列に対してプロットされます)col, cex, lty, lwdの最初の要素は,最初の線と同様に軸をプロットするために使用されます.プロットシンボルは線で描画され,これらの関数は線のスタイルを変更する可能性があるため,プロットシンボルを使用する場合は,おそらくlty = 1を指定する必要があります.
これは汎用関数です。  拡張モザイク表示は、表の対数線形モデルの標準化残差をモザイクの色と山形の輪郭で可視化します。  (標準化残差は、しばしば標準正規分布と呼ばれる) 負の残差を表すセルは、赤の斜線で描画され、境界線は破線で描画され、正の残差は青で描画され、境界線は実線で描画される。数式メソッドでは、データがクラス "table "またはクラス "ftable "を継承するオブジェクトであるか、2次元以上の配列である場合、分割表とみなされ、したがって、すべてのエントリは非負でなければならない。  この場合、式の左辺は空でなければならず、右辺の変数は分割表の dimnames 属性の名前から取られなければならない。  これらの変数のマージナル表が計算され、その表のモザイク・プロットが作成される。そうでない場合は、データはクロス集計する変数を含むデータ・フレームまたは行列、リストまたは環境でなければならない。  この場合、subset引数で指定されたデータのサブセットを選択した後、式で指定された変数から分割表が計算され、そこからモザイクが作成されます。詳細とNielsen Media Researchのテレビ視聴者データを使ったケーススタディについては、Emerson (1998)を参照してください。グリッドグラフィックスシステムで書かれたモザイクプロットのより柔軟で拡張可能な実装は、寄贈パッケージvcd(Meyer, Zeileis and Hornik, 2006)の関数mosaicで提供されています。
外側の余白のユーザー座標は、常に0から1の範囲であり、図領域のユーザー座標の影響を受けません。adj = 0.5は文字列を中央に配置するが、outer = TRUEの場合は、プロット領域ではなくデバイス領域に配置される。パラメータlasは文字列の向きを決定する。  (これは、Sとは異なることに注意。Sは、atが指定された場合はsrtを使用し、指定されなかった場合はlasを使用する。  パラメータrtはRでは無視される)テキストが軸に垂直にプロットされる場合は、atが指定されない限り、adjが文字列の両端揃えと軸に沿った位置を決定することに注意してください。グラフィックパラメータ "ylbias"(parを参照)は、テキストのベースラインを基準線に対してどのように配置するかを決定します。
ij番目の散布図には、x[,j]に対してプロットされたx[,i]が含まれます。  散布図は、パネル関数を設定することにより、全く異なるものとして表示されるようにカスタマイズすることができます。非対角パネル関数にはxとyとしてxの適切な列が渡されます。対角パネル関数（もしあれば）には1つの列が渡され、text.panel関数には1つの(x, y)の位置と列名が渡されます。デフォルトでは、欠損値はパネル関数に渡され、パネル内では無視されることが多い。  horIndとverIndはR3.2.0から導入された引数で、同じ値が与えられた場合、変数の選択や順序の変更に使用することができます。連続する値の範囲が異なる場合、フルペアプロットの長方形のウィンドウをプロットするために使用することができます。
ij番目の散布図は、x[,j]に対してプロットされたx[,i]を含みます。  この散布図は、パネル関数を設定することでカスタマイズすることができます。非対角パネル関数にはxとyとしてxの適切な列が渡されます。対角パネル関数（もしあれば）には1つの列が渡され、text.panel関数には1つの(x, y)の位置と列名が渡されます。デフォルトでは、欠損値はパネル関数に渡され、パネル内では無視されることが多い。  horIndとverIndはR3.2.0から導入された引数で、同じ値が与えられた場合、変数の選択や順序の変更に使用することができます。異なる連続値の範囲では、フルペアプロットの長方形のウィンドウをプロットするために使用することができます。
NA
各デバイスは、それ自身のグラフィカルパラメータのセットを持っています。  現在のdeviceがnull deviceの場合、parはパラメータを照会/設定する前に新しいdeviceを開きます。  (どのデバイスかはoptions("device")によって制御されます。)パラメータは、パラメータ名の1つ以上の文字ベクトルをpar.par()(引数なし)またはpar(no.readonly = TRUE)に与えることによって、すべてのグラフィカルパラメータを(名前付きリストとして)問い合わせます。  これらの名前は現在、未エキスポート変数graphics::.Pars.R.O.から取られています：これらはクエリーでのみ使用でき、設定することはできません。  ("cin"、"cra"、"csi"、"cxy"、"din"、"page "は常に読み取り専用です。)いくつかのパラメータは、par()の呼び出しによってのみ設定できる："ask"、"fig"、"fin"、"lheight"、"mai"、"mar"、"mex"、"mfcol"、"mfrow"、"mfg"、"new"、"oma"、"omd"、"omi"、"pin"、"plt"、"ps"、"pty"、"usr"、"xlog"、"ylog"、"ylbias "残りのパラメータは、(多くの場合、.残りのパラメータは、plot.default、plot.window、points、lines、abline、axis、title、text、mtext、segments、symbols、arrows、polygon、rect、box、contour、filled.contour、imageのような高レベルのプロット関数の引数として設定することもできます。  これらの設定は、関数の実行中にのみ有効になります。  ただし、bg、cex、col、lty、lwd、pchについては、グラフィカルパラメータとしてではなく、ある種のプロット関数の引数として取られることがある、というコメントを参照。  内部的には、対応するパース(cra, cin, cxy, csi)は、marとomatoの物理的マージンを変換するために使用される行間を設定するためだけに使用されます。  (textとstrheightの複数行文字列には、同じ行間にheightを掛けたものが使用されます。)グラフィカルパラメータは提案であることに注意してください: プロット関数とデバイスは、それらを使用する必要はありません(これは、plotなどのデフォルト以外のメソッドに特に当てはまります)。
プロットは(x,y,z)座標を[0,1]区間に変換することにより作成されます。  そして、θとφで定義された方向から原点を見ることによってサーフェスが表示されます。  θとφがともに0の場合、見る方向は負のy軸の真下になります。θを変えると方位角が変化し、φを変えるとコロチチュードが変化します。プロットが完了した後に呼び出される "persp" (setHookを参照)というフックがあり、これはプロットページに注釈を付けるためにテストコードで使用されます。  perspは、z行列を(x[i], y[j])値の表として解釈し、x軸は列番号に、y軸は列番号に対応することに注意してください。標準的な回転角度では、行列の左上隅がユーザーに最も近い左側に表示されます。軸ラベルと "detailed "の注釈のサイズとフォントは、それぞれグラフィックスパラメータ "cex.lab"/"font.lab "と "cex.axis"/"font.axis "によって制御されます。バウンディングボックスは、面のエッジがビューアから背面（つまり、ボックスの背面）を向いて描画され、実線と他のエッジは破線で面の上に描画されます。  これは（そして軸のプロットも）、サーフェスがボックス内に収まるように軸のリミットが選択されていることを前提としており、そうでない場合は警告が表示されます。
NA
よく使われるグラフパラメータは:線と点の色です。  複数の色を指定することができ、各点に独自の色を与えることができます。  色の数が点の数より少ない場合は、標準的な方法で再利用されます。  線はすべて最初に指定された色でプロットされます。オープン・プロット・シンボル、シーポイントの背景色のベクトル。  注意：これはpar("bg")と同じ設定ではありません。プロット文字または記号のベクトル：pointsを参照。プロット文字および記号をデフォルトに対してスケーリングする量を指定する数値ベクトル。  NULLとNAは1.0と等価です。  これは注釈には影響しないことに注意してください：以下を参照してください。線種のベクトル、parを参照してください。メインおよびサブタイトルと軸の注釈の設定、parを参照してください。
一般的に使用されるグラフィック・パラメータは次のとおりです：線と点の色。  複数の色を指定することができ、各点に独自の色を与えることができる。  色の数が点の数より少ない場合は、標準的な方法で再利用される。  線はすべて最初に指定された色でプロットされます。オープン・プロット・シンボル、シーポイントの背景色のベクトル。  注意：これはpar("bg")と同じ設定ではありません。プロット文字または記号のベクトル：pointsを参照。プロット文字および記号をデフォルトに対してスケーリングする量を指定する数値ベクトル。  NULLとNAは1.0と等価です。  これは注釈には影響しないことに注意してください：以下を参照してください。線種のベクトル、parを参照してください。メインおよびサブタイトルと軸注釈の設定、parとparを参照してください。
提供された関数は、デザイン内の各要因のレベルごとに1回呼び出され、プロットはこれらの要約値を表示します。  特定の因子の水準は縦線で表示され、応答のfun()の全体値は横線で描画されます。
関数または式 expr (曲線の場合)または関数x (プロットの場合)は，範囲 [from, to]に等間隔に置かれたn 個の点で評価される．  このようにして決定された点がプロットされます.fromかtoのどちらかがNULLの場合, xlimの対応する要素がNULLでなければ, それがデフォルトになります.from/toもxlimも両方のx-limitsを指定しない場合に何が起こるかは複雑な話です.  plot(<function>)とcurve(add = FALSE)のデフォルトは(0, 1)です。  curve(add = NA)とcurve(add = TRUE)の場合、デフォルトは前のplotで使われたx-limitsから取られます。  (これはRの2.14.0より前のバージョンとは異なります。)logの値は、(add = TRUEでない限り)プロットの軸を指定するためと、'等間隔'がどのように解釈されるかの両方に使用されます: x成分が対数スケーリングを示す場合、式または関数がプロットされる点は対数スケールで等間隔になります。  add = FALSEの場合、デフォルトは""です。これは以前は手っ取り早いハックでしたが、現在では便利な目的にかなっているようです。  この場合、exprは関数の名前とみなされ、xnameで指定された名前の単一引数を持つexprの呼び出しに置き換えられる。  それ以外の場合は、exprが呼び出しか式であるか、xnameで与えられた変数への参照を含んでいるか（all.varsを使用）をチェックする。  これは、curve(x, ...)がxという名前の関数をプロットする要求として受け取られることを意味することに注意してください（そして、それはplotのfunctionメソッドでそのように使用されます）。
新しいページは背景色(par("bg"))で描かれます。  キャンバスカラーを持つデバイス(オンスクリーンデバイスのX11、windows、quartz)では、ウィンドウはまずキャンバスカラーで塗られ、次に背景色で塗られます。フレームを進める直前と直後に呼ばれる "before.plot.new "と "plot.new"(setHook参照)という2つのフックがあります。後者は、新しいページに注釈を付けるためにテストコードで使用されます。フック関数は引数なしで呼び出されます。  (値が文字列の場合、graphics名前空間内からgetが呼び出されます)。
この場合、par("usr")はもはや、例えばpar("xaxs")によって決定されるのではなく、aspとデバイスのアスペクト比によって決定されることに注意してください。  (下の例を実行した後、プロットデバイスをインタラクティブにリサイズするとどうなるか見てください！)特殊なケースasp == 1は、点間の距離が画面上で正確に表現されるプロットを作成します。  asp>1の値は、緯度と経度を使用する場合、より正確な地図を作成するために使用できます。適切なグラフィカルパラメータxaxsまたはyaxsが値 "r"（これはデフォルトです）である場合、座標範囲は4％拡張されることに注意してください。軸を逆にするには、c(hi, lo)形式のxlimまたはylimを使用します。この関数は、xlimとymlの両方の長さが1であるか、与えられた2つの値が同一である場合、もっともらしいスケールの集合を生成しようとしますが、そのようなケースは避けた方が良いでしょう。通常、代わりにplot、hist、image、...のような高レベルの関数を使用し、引数の説明については、それらのヘルプページを参照するべきです。この呼び出しの副作用として、グラフィックパラメータusr、xaxp、yaxpが設定されます。  (labが使われるのは後者の2つである）。
引数pch,col,bg,cex,lwdはベクトルであり、タイプによってはリサイクルされる。  cex は、par("cex")に加えて数値係数であり、"p"、"o"、"b"、"c "型で描画される記号や文字に影響を与える。
座標は、プロット構造体(x成分とy成分を持つリスト)、2列の行列、時系列、...で渡すことができます。  xy.coordsを参照。  一般的に使用されるグラフィカルパラメータは、プロットの'character'、すなわち使用するシンボルです。  S記号の全セットはpch = 0:18で利用可能で、以下の例を参照のこと(NB: RはSで使われる八角形の代わりに円を使う)。  これは一辺が0.01インチの長方形である（cexでスケーリングされる）。  また、cex = 1（デフォルト）の場合、各辺は少なくとも1ピクセル（pdf,postscript,xfigデバイスでは1/72インチ）になります。他のテキストシンボルでは、cex = 1はデバイスのデフォルトフォントサイズに対応し、しばしば引数pointsizeで指定されます。  pchが0:25の場合、デフォルトのサイズは文字の高さの約75%です（par("cin")を参照）。pch = 21:25.文字（またはシンボル）展開：数値ベクトル。記号を描画するための線幅はparを参照。その他、あまり一般的に使用されないが、"b "や "l "のようなtypesのltyやlwdがある。グラフィカル・パラメータpch、col、bg、cex、lwdは、プロットされた各点の値を与えるベクトル（必要に応じてリサイクルされる）にすることができる。  x,y,pch,col,cexの値がNAの点はプロットから省略される。
座標は、プロット構造体(x成分とy成分を持つリスト)、2列の行列、時系列、...で渡すことができます。  xy.coordsを参照。  一般的に使用されるグラフィカルパラメータは、プロットの'character'、すなわち使用するシンボルです。  S記号の全セットはpch = 0:18で利用可能で、以下の例を参照のこと(NB: RはSで使われる八角形の代わりに円を使う)。  これは一辺が0.01インチの長方形である（cexでスケーリングされる）。  また、cex = 1（デフォルト）の場合、各辺は少なくとも1ピクセル（pdf,postscript,xfigデバイスでは1/72インチ）になります。他のテキストシンボルでは、cex = 1はデバイスのデフォルトフォントサイズに対応し、しばしば引数pointsizeで指定されます。  pchが0:25の場合、デフォルトのサイズは文字の高さの約75%です（par("cin")を参照）。pch = 21:25.文字（またはシンボル）展開：数値ベクトル。記号を描画するための線幅はparを参照。その他、あまり一般的に使用されないが、"b "や "l "のようなtypesのltyやlwdがある。グラフィカル・パラメータpch、col、bg、cex、lwdは、プロットされた各点の値を与えるベクトル（必要に応じてリサイクルされる）にすることができる。  x,y,pch,col,cexの値がNAの点はプロットから省略される。
座標は、プロット構造体(x成分とy成分を持つリスト)、2列の行列...で渡すことができます。  座標は欠損値を含むことができます。  座標は欠損値を含むことができます。動作は直線の場合と似ていますが、直線を複数の直線に分割する代わりに、欠損値は多角形を複数の完全な多角形に分割します（最後の点と最初の点を閉じることを含む）。  複数の多角形が生成される場合、density, angle, col, border, ltyの値は、通常の方法で再利用される。多角形の陰影付けは、線形プロットに対してのみ実装されている。いずれかの軸が対数スケールである場合、陰影付けは警告とともに省略される。
座標はプロット構造体(x成分とy成分を持つリスト)、2列の行列...で渡すことができます。  座標は欠損値を含むことができます。  ただし、多角形を複数の多角形に分割する代わりに、NAの値はパスを複数のサブパスに分割します（各サブパスの最初のポイントに最後のポイントを閉じることを含む）。  パスと多角形の違いは、前者が塗りつぶしルールによって解釈される穴を含むことができるということです。ハッチングシェーディング (polygon() で実装されているもの) は (現在のところ) サポートされていません。すべてのグラフィックデバイスがこの機能をサポートしているわけではありません: たとえば、xfig と pictex はサポートしていません。
与えられた位置、すなわち xleft, ...は、現在の描画領域からの相対位置です。  x 軸が 100 から 200 までの範囲にある場合, xleft は 100 より大きく, xrightsh は 200 より小さくなければなりません.  位置ベクトルは、最も長い長さにリサイクルされる。ラスター画像のプロットは、すべてのデバイスでサポートされているわけではなく、サポートされている場合でも制限があるかもしれない、ラスター画像のプロットはすべてのデバイスでサポートされているわけではなく、例えばサポートされている場合でも制限があるかもしれません（例えば、PostScriptやX11(type = "Xlib")の場合は不透明色に制限されます）。ラスター画像のレンダリングに関する問題は、リモートデスクトップでwindows()デバイスを使用しているユーザーから、少なくともデフォルトの設定では報告されています。
xleft、...と指定された位置は、現在の描画領域からの相対位置である。  x軸が100から200までなら、xleftは100より大きく、xrightは200より小さくなければならない。  これは，ヒスト，バープロット，凡例などで利用されるグラフィックス・プリミティブです．
rugの実装方法のため, プロット領域内にあるxの値のみが含まれます.  有限の値が省略された場合は警告が出ますが、有限でない値は黙って省略されます。
split.screenを最初に呼び出すと、Rは画面分割モードになる。  他の分割画面関数は、このモードでのみ動作する。このモードでは、他の特定のコマンドは使用しないこと（後述の警告セクションを参照）。  現在のスクリーンが閉じられている場合、close.screen は現在のスクリーンを次の大きなスクリーン番号に設定する。
各iについて、点(x0[i], y0[i])と点(x1[i], y1[i])の間に線分が引かれる。  座標ベクトルは、最も長い長さに再利用されます。グラフィカルパラメータcol、lty、lwdは、1以上の長さのベクトルであることができ、必要に応じて再利用されます。
smoothScatterは、散布図の平滑化バージョンを作成します。2次元（カーネル密度）平滑化は、KernSmoothパッケージのbkde2Dによって実行されます。この関数をpairsと一緒に使用する方法については、例を参照してください。
spineplot はスピノグラムまたはスパインプロットを作成します。  spineplot(x,y)または spineplot(y ~ x)で呼び出すことができ、yは従属変数（そしてカテゴリ変数でなければならない）、xは説明変数であると解釈されます。  さらに、spineplotは1つの引数のみで呼び出すこともでき、その場合は、table(x, y)に対応するように解釈される2元表でなければなりません。  概念的には、これらはP(x)に対してP(y | x)をプロットする。  スパイン・プロット（xとyの両方がカテゴリー）の場合、両方の量は、対応する経験的相対度数で近似される。  したがって、スパイン・プロットは積み上げ棒グラフの一般化として見ることもでき、棒グラフの高さではなく幅がxの相対度数に対応し、棒グラフの高さはすべてのxグループにおけるyの条件付き相対度数に対応します。同様に、スピノグラムは積み重ねられたヒストグラムを拡張します。
split.screenを最初に呼び出すと、Rは分割画面になります。  このモードでは、他の特定のコマンドは使用しないようにする必要があります（下記の警告セクションを参照）。  現在のスクリーンが閉じられている場合、close.screenは現在のスクリーンを次の大きなスクリーン番号に設定する。
各スタープロットまたはセグメント図は、inputxの1行を表す。  変数（列）は右から始まり、円の周りを反時計回りに回る。  (スケーリングされた)列のサイズは、中心から星上の点までの距離、または変数を表すセグメントの半径で示される。
出力は1ページのみ作成される。xの無限大および欠損値は捨てられる。
文字列の「高さ」は、その文字列が含む改行数("˶")によってのみ決定されることに注意。  式の場合は、plotmathによって計算されたバウンディング・ボックスの高さである。  したがって、どちらの場合も、これは組版オブジェクトが最終ベースラインからどのくらい上まで伸びているかの推定値である。  (行間はcex,par("lheight")と'ポイントサイズ'(実際の使用フォントではありません)によって制御されます。"ユーザー "単位(デフォルト)での測定はplot.newが呼ばれた後にのみ可能です。
dlabは連続データ軸（verticalがTRUEでない限りX軸）に適用され、glabはグループ軸に適用されます。
文字列の'高さ'は、その文字列が含む改行数(" \n") によってのみ決定されることに注意してください：それは、(改行数 - 1) 倍の行間隔に、選択されたフォント内の "M "の高さを加えたものです。  式の場合は、plotmathによって計算されたバウンディング・ボックスの高さである。  したがって、どちらの場合も、これは組版オブジェクトが最終ベースラインからどのくらい上まで伸びているかの推定値である。  (行間はcex,par("lheight")と'ポイントサイズ'(使用されている実際のフォントではありません)によって制御されます。"ユーザー "単位(デフォルト)での測定はplot.newが呼び出された後にのみ可能です。
number[i] == 1の場合、通常のプロットシンボル(pch)が(少し拡大されて)描画されます。  number[i] > 1 の場合、小さなプロットシンボルが描かれ、そこから number[i] 等角の「光線」が放射される。rotate = TRUE かつ number[i] >= 2 の場合、最初の光線には (y 軸ではなく) ランダムな方向が選ばれる。  その目的は、視覚的な印象の不自然さを防ぐために、ひまわりの向きをばらつかせることである。
座標が欠落していたり、サイズパラメータが欠落している観測はプロットされない。  この場合、NAのレイの長さはゼロにリセットされます。Argument inchesはシンボルのサイズをコントロールします。  TRUE（デフォルト）の場合、シンボルの最大寸法が1インチになるようにスケーリングされる。  正の数が与えられた場合、シンボルは、インチでこのサイズの最大の寸法になるようにスケーリングされます（したがって、TRUEと1は等価です）。  inchesがFALSEの場合、単位は適切なaxesの単位とされる。  (円、正方形、および星については、X軸の単位が使用されます。  箱ひげ図では、ひげの長さは、インチで拡大縮小される場合、幅と高さと並ぶ寸法とみなされ、それ以外はy軸の単位で解釈されます)。半径ゼロの円は、半径1ピクセルでプロットされます(これはデバイス依存です)。  半径がゼロでない非常に小さな円は表示される場合とされない場合があり、半径ゼロの円よりも小さくなることがあります。  Windowsデバイスでは、円は少なくとも半径1ピクセルでプロットされる。
adjは(x, y)に対するテキストの位置を調整することができます。0, 0.5, 1の値は、それぞれ(x, y)をテキストの左/下、中央、右/上に揃えることを指定します。  デフォルトは中央揃え、つまり adj = c(0.5, NA)。  正確な垂直方向のセンタリングには、個々の文字に関する文字メトリクス情報が必要であり、これは一部のデバイスでのみ利用可能である。  これは垂直方向のセンタリングにも影響します: 文字列のセンタリングはディセンダを除きますが、式のセンタリングはディセンダを含みます。posとoffset引数は、identifyが返す値と組み合わせて使用することで、インタラクティブにラベル付けされたプロットを再現することができます。グラフィカルパラメータsrt（parを参照）を使用することで、テキストを回転させることができます。  adjが指定された場合、0でないsrtはラベルを(x, y)を中心に回転させます。  posが指定された場合、srtは、(x, y)に最も近いバウンディングボックス上の点を中心にテキストを回転させます：pos = 1の場合は中央上、pos = 2の場合は中央右、pos = 3の場合は中央下、pos = 4の場合は中央左です。  pos インターフェースは、テキストを回転させた場合、(x, y) に対して垂直方向と水平方向の中心がずれてしまうため、あまり役に立ちません。  現在のところ、グラフィックス・パッケージには、テキストをその中心に対して直接回転させるためのインターフェイスはありませんが、adjとsrtを同時にいじれば実現できます。グラフィカル・パラメータcol、cex、fontはベクトルにすることができ、ラベルに循環的に適用されます（余分な値は無視されます）。  fontのNA値はpar("font")で置き換えられ、colも同様です。x、y、labelsの値がNAであるラベルは、プロットから省略されます。font = 5（シンボルフォント）が選択されたときに何が起こるかは、デバイスとロケールの両方に依存します。  例えば、"d "はデルタ、"˶300 "はアレフである。
後者の場合、下付き文字や上付き文字、ギリシャ文字、分数など、かなり多くの数学的表記が利用可能です。adjは、(x, y)に対するテキストの位置を調整することができます。  デフォルトは中央揃え、つまり adj = c(0.5, NA)。  正確な垂直方向のセンタリングには、個々の文字に関する文字メトリクス情報が必要であり、これは一部のデバイスでのみ利用可能である。  これは垂直方向のセンタリングにも影響します: 文字列のセンタリングはディセンダを除きますが、式のセンタリングはディセンダを含みます。posとoffset引数は、identifyが返す値と組み合わせて使用することで、インタラクティブにラベル付けされたプロットを再現することができます。グラフィカルパラメータsrt（parを参照）を使用することで、テキストを回転させることができます。  adjが指定された場合、0でないsrtはラベルを(x, y)を中心に回転させます。  posが指定された場合、srtは、(x, y)に最も近いバウンディングボックス上の点を中心にテキストを回転させます：pos = 1の場合は中央上、pos = 2の場合は中央右、pos = 3の場合は中央下、pos = 4の場合は中央左です。  pos インターフェースは、テキストを回転させた場合、(x, y) に対して垂直方向と水平方向の中心がずれてしまうため、あまり役に立ちません。  現在のところ、グラフィックス・パッケージには、テキストをその中心に対して直接回転させるためのインターフェイスはありませんが、adjとsrtを同時にいじれば実現できます。グラフィカル・パラメータcol、cex、fontはベクトルにすることができ、ラベルに循環的に適用されます（余分な値は無視されます）。  fontのNA値はpar("font")で置き換えられ、colも同様です。x、y、labelsの値がNAであるラベルは、プロットから省略されます。font = 5（シンボルフォント）が選択されたときに何が起こるかは、デバイスとロケールの両方に依存します。  例えば、"d "はデルタ、"˶300 "はアレフである。
titleに渡されるラベルは、文字列、言語オブジェクト（名前、呼び出し、式）、またはプロットされる文字列を含むリスト、およびオプションのグラフィカルパラメータを変更するcex=、col=、font=の選択になります。その他のオブジェクトは、as.graphicsAnnotによって強制されます。xlab、ylab、subの位置は、line（xlabとylabのデフォルトはpar("mgp")[1]で、subの場合は1増加）行（高さはpar("mex")）で、適切なマージンに配置され、プロット/デバイス領域のpar("adj")に従ってテキスト方向に両端揃えされます。
NA
X スプラインは、制御点に対して相対的に引かれた線です。  各制御点に対して, 線は制御点を通過する(補間する)か, または制御点に近づく(近似する)だけである.  shapeパラメータが0より小さい場合, スプラインは制御点を補間します(shapeが-1の場合, Catmull-Romsplineに非常に似ています)。  shapeパラメータが0の場合、スプラインはその制御点で鋭いコーナーを形成します。オープンXスプラインの場合、始点と終点の制御点のshapeは0でなければなりません（0以外の値は静かに0に変換されます）。  曲線は、各制御点の2番目と3番目の間で（補間または近似して）描かれるので、このデフォルトの動作は、指定した最初の制御点から始まり、最後の制御点で終わることを保証します。  このデフォルトの動作は、repEnds引数でオフにすることができます。
NA
NA
サーストンスケーリングなどの問題で使用されます。  技術的には行列の加算ではありませんが、Krusが指摘したように、2つのベクトルや行列の和や差が有用な演算となるアプリケーションは数多くあります。  ベクトルに対する代替演算は outer(x ,y , FUN="+")であるが、これは行列に対しては機能しない。  
lowerCor は，対角行列の下側を丸め，列名を桁数 + 3 文字に省略したものを出力します．  デフォルトでは、変数の対削除が使用される。  この行列は、きれいな印刷を行うlowerMatを呼び出します。  必要なのはlowerMatだけなのにlowerCorを呼び出さないことを覚えておくことが重要です！ csはFrank HarrellによるHmiscパッケージのCs関数をそのままコピーしたものです。  Hmiscパッケージのオーバーヘッドを避けるためにpsychに追加された。
驚くべきことに、Spearman (1904)が信頼性の概念を心理学者に紹介してから100年以上経った今でも、信頼性を測定するための複数のアプローチが存在する。クロンバックのα（Cronbach's α, 1951）は、非常にポピュラーですが、テストの信頼性を過小評価し、第1因子の飽和を過大評価します。α (Cronbach, 1951)はGuttmanのλ3 (Guttman, 1945)と同じで、Lambda 3 = (n)/(n-1)(1-tr(Vx)/(Vx) = (n)/(n-1)(Vx-tr(Vx)/Vx = α計算がとても簡単で、ほとんどの市販プログラムで利用できるためか、αは間違いなく最も頻繁に報告されている内部一貫性の信頼性の尺度です。アルファは、すべての可能なスピット・ハーフ信頼度（テストの長さで補正）の平均です。  単因子検査の場合、これは第1因子飽和度の妥当な推定値ですが、検査に微細構造がある場合（すなわち、"塊状 "の場合）は、係数β (Revelle, 1979; ICLUST参照)とomega_hierchical (omega参照)が一般因子飽和度のより適切な推定値です。  Guttmanのラムダ 6 (G6) は，他のすべての項目の線形回帰（2乗重相関または smc），より正確には誤差の分散 e_j^2 を説明できる各項目の分散量を考慮し， islambda 6 = 1 - sum(e^2)/Vx = 1-sum(1-r^2(smc))/Vx.2乗重相関は、項目の共同性の下界であり、項目数が増えるほど、よりよい推定になります。G6は、テストの塊性にも敏感であり、単一要因構造の尺度として取られるべきではありません。  塊状のテストでは、アルファより大きくなる。  項目負荷量が等しいテストでは、alpha > G6であるが、負荷量が不均等であったり、一般的な因子がある場合は、G6 > alphaである。 alphaは、KR20として知られるKuderとRichardsonによって開発された二項対立項目を持つテストに対する信頼性の以前の推定値、およびショートカット近似であるKR21の一般化である。(Revelle,準備中参照).AlphaとG6は、両方ともテスト中の項目の数とテスト中の項目の平均相互相関の正の関数である。  ここでのように、項目の分散とテスト全体の分散から計算される場合、生のアルファは項目の分散の違いに敏感である。標準化アルファは、共分散ではなく相関に基づいている。  項目数と平均相関に比例するテストの質の有用な指標は、シグナル/ノイズ比であり、ここで s/n = n r/(1-r) (Cronbach and Gleser, 1964; Revelle and Condon (in press))です。単一の尺度のより完全な信頼性分析は、階層的因子分析に基づいてomega_hierchicalとomega_totalを求めるomega関数を使用して行うことができます。  別の関数score.itemsとcluster.corは、複数の尺度をスコア化し、より有用な統計量を報告します。"標準化 "アルファは項目間相関から計算され、生のアルファとは異なります。raw.rは項目と尺度全体の相関で、項目の重複を補正していません。std.rは項目と尺度全体の相関で、各項目が標準化されている場合です。  これらはそれぞれ従来の統計量ですが、a) 項目の重なりが1つ目を膨らませ、b) 項目が削除されると各項目で尺度が異なるという欠点があります。したがって，4番目の選択肢r.corは，項目分散を差し引くことによって項目の重複を補正するが，これを共通分散の最良の推定値であるsmcに置き換える．これはCureton (1966)の提案に似ています。いくつかの項目がリバース・キーされる場合、項目名か項目の位置のどちらかで指定できます。  (3番目と4番目の例を見てください。) 自動反転もできて、これは第1主成分の負荷量の符号に基づきます（例5）。  これには、check.keysオプションをTRUEにする必要がある。  以前のバージョンでは、check.keys=TRUEがデフォルトでしたが、これでは、いくつかの項目が反転していることに気づかずに（警告が発せられているにもかかわらず！）、アルファを見つけるのが簡単すぎるという不満の声もありました。  そこで、デフォルトをcheck.keys=FALSEとし、いくつかの項目は（もしそうなら）反転させる必要があるという警告を表示するようにしました。  これらの警告を表示しないようにするには、warnings=FALSEを設定してください。  得点は、得点された項目の単純平均（または合計）に基づいています。したがって、いくつかの項目が欠落している場合、得点は回答された項目だけを反映します。  これは（cumulative=TRUEオプションで）合計得点を使用する場合に特に問題となります。  平均値または中央値を使用して欠損データをインプットするには、scoreItems関数を使用します。   生データを使用する場合、生アルファの標準誤差は、Duhhachek and Iacobucci (2004)の式 2 および 3 を使用して計算されます。  いくつかのシミュレーションでは、これらの値が小さすぎることが示唆されているので、これは問題である。  おそらく、ブートストラップ値.alpha.ciを使用する方が、Feldtら(1987)の手順を使用して信頼区間を見つけることができます。  この手続きは、Duhachek and Iacobucci (2004) の手続きのように検定の内部構造を考慮しません。  つまり、後者は共分散の分散を考慮するが、Feldt 手順は平均共分散だけに基づいている。  2022年3月、alpha.ciは最終的にFeldt手順に従うように修正された。alphaが報告する信頼区間は、FeldとDuhaceckとIabocucciの両方の先行法を使用しています。  これらはNの値が大きい場合には一致するが、小さい値では異なることに注意されたい。  n.iter>1の場合、ブートストラップされた再標本が見つかります。  これらはブートオブジェクトとして返されます。  これらは、プロットすることも、説明することもできます。  2.5%と97.5%の値はboot.ciオブジェクトで返されます。
驚くべきことに、Spearman (1904) が信頼性の概念を心理学者に紹介してから1世紀以上が経過した今でも、信頼性を測定するための複数のアプローチが存在します。Cronbachのα (1951) は、非常にポピュラーですが、テストの信頼性を過小評価し、第1因子の飽和を過大評価します。α (Cronbach, 1951)はGuttmanのλ3 (Guttman, 1945)と同じで、Lambda 3 = (n)/(n-1)(1-tr(Vx)/(Vx) = (n)/(n-1)(Vx-tr(Vx)/Vx = α計算がとても簡単で、ほとんどの市販プログラムで利用できるためか、αは間違いなく最も頻繁に報告されている内部一貫性の信頼性の尺度です。アルファは、すべての可能なスピット・ハーフ信頼度（テストの長さで補正）の平均です。  単因子検査の場合、これは第1因子飽和度の妥当な推定値ですが、検査に微細構造がある場合（すなわち、"塊状 "の場合）は、係数β (Revelle, 1979; ICLUST参照)やomega_hierchical (omega参照)が一般因子飽和度のより適切な推定値です。  Guttmanのラムダ 6 (G6) は，他のすべての項目の線形回帰（2乗重相関または smc），より正確には誤差の分散 e_j^2 を説明できる各項目の分散量を考慮し， islambda 6 = 1 - sum(e^2)/Vx = 1-sum(1-r^2(smc))/Vx.2乗重相関は、項目の共同性の下界であり、項目数が増えるほど、よりよい推定になります。G6は、テストの塊性にも敏感であり、単一要因構造の尺度として取られるべきではありません。  塊状のテストでは、アルファより大きくなる。  項目負荷量が等しいテストでは、alpha > G6であるが、負荷量が不均等であったり、一般的な因子がある場合は、G6 > alphaである。 alphaは、KR20として知られるKuderとRichardsonによって開発された二項対立項目を持つテストに対する信頼性の以前の推定値、およびショートカット近似であるKR21の一般化である。(Revelle,準備中参照).AlphaとG6は、両方ともテスト中の項目の数とテスト中の項目の平均相互相関の正の関数である。  ここでのように、項目の分散とテスト全体の分散から計算される場合、生のアルファは項目の分散の違いに敏感である。標準化アルファは、共分散ではなく相関に基づいている。  項目数と平均相関に比例するテストの質の有用な指標は、シグナル/ノイズ比であり、ここで s/n = n r/(1-r) (Cronbach and Gleser, 1964; Revelle and Condon (in press))です。単一の尺度のより完全な信頼性分析は、階層的因子分析に基づいてomega_hierchicalとomega_totalを求めるomega関数を使用して行うことができます。  別の関数score.itemsとcluster.corは、複数の尺度を採点し、より有用な統計量を報告します。"標準化 "アルファは項目間相関から計算され、生のアルファとは異なります。raw.rは項目と尺度全体の相関で、項目の重複を補正していません。std.rは項目と尺度全体の相関で、各項目が標準化されている場合です。  これらはそれぞれ従来の統計量ですが、a) 項目の重なりが1つ目を膨らませ、b) 項目が削除されると各項目で尺度が異なるという欠点があります。したがって，4番目の選択肢r.corは，項目分散を差し引くことで項目の重複を補正するが，これを共通分散の最良の推定値であるsmcに置き換える．これはCureton (1966)の提案に似ています。いくつかの項目がリバース・キーされる場合、項目名か項目の位置のどちらかで指定できます。  (3番目と4番目の例を見てください。) 自動反転もできて、これは第1主成分の負荷量の符号に基づきます（例5）。  これには、check.keysオプションをTRUEにする必要がある。  以前のバージョンでは、check.keys=TRUEがデフォルトでしたが、これでは、いくつかの項目が反転していることに気づかずに（警告が発せられているにもかかわらず！）、アルファを見つけるのが簡単すぎるという不満の声もありました。  そこで、デフォルトをcheck.keys=FALSEとし、（このような場合は）いくつかの項目を反転させる必要があるという警告を表示するようにしました。  これらの警告を表示しないようにするには、warnings=FALSEを設定してください。  得点は、得点された項目の単純平均（または合計）に基づいています。したがって、いくつかの項目が欠落している場合、得点は回答された項目だけを反映します。  これは（cumulative=TRUEオプションで）合計得点を使用する場合に特に問題となります。  平均値または中央値を使用して欠損データをインプットするには、scoreItems関数を使用します。   生データを使用する場合、生アルファの標準誤差は、Duhhachek and Iacobucci (2004)の式 2 および 3 を使用して計算されます。  いくつかのシミュレーションでは、これらの値が小さすぎることが示唆されているので、これは問題である。  おそらく、ブートストラップ値.alpha.ciを使用する方が、Feldtら(1987)の手順を使用して信頼区間を見つけることができます。  この手続きは、Duhachek and Iacobucci (2004) の手続きのように検定の内部構造を考慮しません。  つまり、後者は共分散の分散を考慮するが、Feldt 手順は平均共分散だけに基づいている。  2022年3月、alpha.ciは最終的にFeldt手順に従うように修正された。alphaが報告する信頼区間は、FeldとDuhaceckとIabocucciの両方の先行法を使用しています。  これらはNの値が大きい場合には一致するが、小さい値では異なることに注意されたい。  n.iter>1の場合、ブートストラップされた再標本が見つかります。  これらはブートオブジェクトとして返されます。  これらは、プロットすることも、説明することもできます。  2.5%と97.5%の値がboot.ciオブジェクトで返されます。
setCor は SE.残差と自由度を返します。  これらはSSRに変換され、2つ（またはそれ以上）のモデルを比較するために分散分析が使用されます。omegaまたはfaについては、dfの変化の関数としてのMLカイ2乗統計量の変化が報告されます。
世界の状態について2値決定を行う問題は、どこにでもあります。  これは、帰無仮説有意性検定（NHST）、医療診断、職業選択などで見られます。  NHST、シグナル検出理論、臨床アセスメント、大学入試など様々に知られているが、これらの領域はすべて同じ2×2の意思決定タスクを共有している。根底にある現象はおそらく連続的であるが、典型的な意思決定や診断の場面では二項対立的な意思決定が行われる：根底にある現象はおそらく連続的であるが、典型的な決定や診断の場面では二項対立的な決定がなされる。   信号検出理論では、世界には2つの状態がある：ノイズ」対「シグナル＋ノイズ」である。  判断は信号があるかないかである。  診断では、ノイズの多い信号（例えばX線、一連の診断テスト）が与えられたときに、病気を診断するかしないかである。大学入試では、ある学生を受け入れ、ある学生を拒否する。  大学入試では、私たちはある学生を受け入れ、ある学生を拒否する。4～5年後、私たちは誰が「成功」し、卒業するかを観察する。これらの決定はすべて、2×2の分類に基づく4つのセルにつながる。  世界の真の状態が「正」または「負」であり、評価者が「正」または「負」の評価を下すとすると、結果として得られる2×2の表は、対角線上に「真の（有効な）正」と「真の（有効な）負」があり、対角線から外れたところに「偽の正」と「偽の負」がある。全体のパーセンテージとして表現すると、ベース・レート（BR）は世界の状態に依存するが、セレクション・レシオ（SR）は決定を下す人のコントロール下にあり、偽陽性の数と有効陽性の数に影響する。残念なことに、データを分類するこの方法は評価では典型的であるが（例えば、Wiggins 1973など）、すべてが全体のパーセンテージで表現されるが、いくつかの決定論文では、VPは全陽性決定に対するVPの比率で表現される（Wickens, 1984など）。  これらのデータが意味する関係は、評価者と世界との間のファイ相関または四分位相関として、あるいはいくつかの代替的な尺度を用いた意思決定プロセスとして要約することができる。  もし2つの次元が連続的で、人為的に2分されたと仮定するなら、テトラコロリック相関はこれら2つの潜在的次元間の連続的相関の推定値である。  もしデータが本当に2つの状態、例えばワクチン接種済みか未接種か、死んでいるか生きているか、などを表していると考えるなら、ファイ係数がより適切である。  感度、特異度、精度、曲線下面積、d'（d prime）。これらの指標は次のように定義される。 1点しか見つかっていないが、判定基準の関数としてVP対FPを滑らかな曲線でグラフ表示することができる。この滑らかな曲線は正規性を仮定しているが，他の点は単に点 (0,0), (FP,VP), (1,1) 間の 2 本の線分である．表入力を使用する場合、値はカウントであり、したがって1より大きいか、または単に確率であり、これは足して1になるはずである。
被験者内の複数の尺度を調査するとき，すべての試行間の変動に加えて，試行ごとのオブザベーションの変動を考慮することが有用なことがある．  連続した差の2乗平均 (mssd) および連続した差の2乗平均 (rmssd) は、 σ^2 = Σ(x_i - x_{i+1})^2 /(n-lag) ここで n-lag が使用されているのは、n-lag のケースしかないからです。被験者（グループ）ごとに複数のオブザベーションを持つ複数の被験者（グループ）の場合、グルーピング変数を指定すると、各グループの出力が得られます。   同様の関数は、matrixStats パッケージでも利用可能です。ただし、そのパッケージの varDiff 関数は、MeanSquare ではなく差の分散です。これは単にdiff関数からの結果に分散と標準偏差を適用したものです。おそらく気分を研究するときに便利なautoR関数は、指定されたラグについて各項目の自己相関を求めます。  また、rmssd(root means square successive difference)も返します。これはラグデータの相関を求めることによって行われる。
これは基本的にfa関数とpca関数にfaCor関数を組み合わせたものです。  これらは繰り返し呼び出され、得られた解からの重みが因子/成分の相関を見つけるために使われます。デフォルトでは、1からn因子までのすべての因子解を実行しますが、これは因子解の一部だけを指定することで簡略化できます。したがって、spiの135項目については、3,5,27項目の解を求める方が合理的である。bassAckward.diagram関数は、diagram関数を使用して呼び出すこともできるし、直接呼び出すこともできる。bassAckward.diagramからの出力は、fa.lookupを使用するのに適したソートされた因子構造である。特にきれいではないが、各レベルでSchmid-Leiman回転を行うことが可能である。  rotate="schmid "として回転を指定します。
これは基本的にfaとpcaにfaCor関数を組み合わせたラッパーである。  これらは繰り返し呼び出され、得られた解からの重みが因子/成分相関を求めるのに使われます。デフォルトでは、1からn因子までのすべての因子解を実行しますが、これは因子解の一部だけを指定することで簡略化できます。したがって、spiの135項目については、3,5,27項目の解を求める方が合理的である。bassAckward.diagram関数は、diagram関数を使用して呼び出すこともできるし、直接呼び出すこともできる。bassAckward.diagramからの出力は、fa.lookupを使用するのに適したソートされた因子構造である。特にきれいではないが、各レベルでSchmid-Leiman回転を行うことが可能である。  rotate="schmid "として回転を指定します。
Holzinger and Swineford (1937)は、精神能力について2因子モデル（1つの一般因子といくつかのグループ因子）を導入しました。  これは、オメガ関数やsemを用いて分析できる階層的な因子構造の素晴らしい実証データセットです。このようなデータを分析するには、いくつかの方法があります。  1つは、オメガ関数を使用して、Schmid-Leiman変換を使用して階層因数分解を行うことである。これは、探索的モデルとして、そしてomegaSemを用いた確認的モデルとして行うことができます。もう1つの方法は、通常の因子分析を行い、bifactor 回転またはbiquartimin 回転を使用することです。後者の2つの関数は、Jennrich and Bentler (2011) のバイファクター変換とバイクォーティミン変換を実装しています。  バイファクター回転は，局所極小の問題（Mansolf and Reise, 2016）に悩まされるので，探索的分析と確認的分析の混合が好ましいかもしれない．14の変数は、3つの空間テスト、3つのメンタル・スピード・テスト、4つの運動スピード・テスト、4つの言語テストを反映するように順序付けされている。  Holzingerからのもう1つのデータ集合（Holzinger.9）は、9つの認知能力（Holzinger, 1939）を表し、Karl Joreskog (2003)がMINRESアルゴリズムによる因子分析の例として使用し、LISRELのマニュアルにも例NPV.KMとして掲載されています。  このデータ集合は、Grant White中学校の9つのテストの得点です：  「t01_visperc""t02_cubes""t04_lozenges""t06_paracomp""t07_sentcomp""t09_wordmean""t10_addition""t12_countdot "および "t13_sccaps "で、lavaanパッケージの変数x1 ... x9（Grant-Whiteの学校）として使用されます。もう1つの古典的なデータ集合は、R. P. McDonald (1985, 1999)によって詳細に議論され、SASのPROC CALIS マニュアルと同様に sem パッケージで例として使用されている9変数のThurstone問題です。  これらの9つのテストは、ThurstoneとThurstone, 1941によって（他のデータに基づいて）3つの要因にグループ化された：Verbal Comprehension、Word Fluency、Reasoningである。元のデータはThurstone and Thurstone (1941)によるものだが、Bechthold (1961)によって再分析され、彼はデータセットを2つに分けた。サンプルサイズは213である。Thurstone (1933)に起因する9つの認知変数のもう1つのセットは、プリンストンのBrigham教授が大学入試委員会に報告した4,175人の学生のデータセットである。  Tucker (1958) は、Turstone and Thburstone (1941)の9変数を、彼のバッテリー間因子分析の例に使用しています。  二因子モデルの最近の応用は、心理的状態の測定である。Reiseのデータセットは、Consumer Assessment of Health Care Provider and Systems調査票に対する35,000以上の観察に基づく相関行列である。Reise, Morizot, and Hays (2007)は、1,000症例に基づく二因子解を記述している。    Reiseらによる5つの因子は、「迅速に治療を受ける」（1-3）、「医師がよくコミュニケーションをとる」（4-7）、「丁寧で親切なスタッフ」（8,9）、「必要な治療を受ける」（10-13）、「医療プランの顧客サービス」（14-16）である。2つのBechtoldtデータセットは、Thurstone and Thurstone (1941)からの2つのサンプルである。  これらは、17の変数を含み、そのうちの9つは、Thurstoneデータ集合を形成するためにMcDonaldによって使用されました。サンプルサイズはそれぞれ212と213である。提案された6つの因子は、記憶、言語、単語、空間、数、推論を反映し、暗記記憶因子を期待するすべての3つのマーカーがある。このセットから9変数がThurstoneデータセットに現れる。同様の構造を持つデータセットがHarmanデータセットにさらに2つある。  これには、Harman link{Harman.Holzinger}が使用したHolzingerの別の9変数（被験者696人）と、link{burt}の8感情変数が含まれます。二因子構造の検定のために調べる価値があるもう1つのデータ集合は、Keith Widamanによって提供されたHolzinger and Swineford (1939)のオリジナル・データを含むholzinger.swinefordデータ集合です。  これはpsychToolsパッケージに入っている。Bechtoldt.1: 能力検査の17 x 17相関行列、N = 212.Bechtoldt.2：能力検査の17 x 17相関行列，N = 213．Holzinger：能力検査の14 x 14相関行列，N = 355 Holzinger.9：能力検査の9 x 9相関行列，N = 145 Reise：健康満足度項目の16 x 16相関行列．  N = 35,000 Thurstone: 能力検査の9 x 9相関行列、N = 213 Thurstone.33: 能力検査の別の9 x 9相関行列、N = 4175 Thurstone:9：さらに別の9×9の能力テストの相関行列、N=710
HolzingerとSwineford（1937）は、精神能力について二因子モデル（1つの一般因子といくつかのグループ因子）を導入した。  これは、オメガ関数やsemを用いて分析できる階層的な因子構造のすばらしい実証データセットである。このようなデータを分析するには、いくつかの方法があります。  1つは、オメガ関数を使用して、Schmid-Leiman変換を使用して階層因数分解を行うことである。これは、探索的モデルとして、そしてomegaSemを用いた確認的モデルとして行うことができます。もう1つの方法は、通常の因子分析を行い、bifactor 回転またはbiquartimin 回転を使用することです。後者の2つの関数は、Jennrich and Bentler (2011) のバイファクター変換とバイクォーティミン変換を実装しています。  バイファクター回転は，局所最小の問題（Mansolf and Reise, 2016）に悩まされるので，探索的分析と確認的分析の混合が望ましいかもしれない．14の変数は、3つの空間テスト、3つのメンタル・スピード・テスト、4つの運動スピード・テスト、4つの言語テストを反映するように順序付けされている。  Holzingerからのもう1つのデータ集合（Holzinger.9）は、9つの認知能力（Holzinger, 1939）を表し、Karl Joreskog (2003)がMINRESアルゴリズムによる因子分析の例として使用し、LISRELのマニュアルにも例NPV.KMとして掲載されています。  このデータ集合は、Grant White中学校の9つのテストの得点です：  「t01_visperc""t02_cubes""t04_lozenges""t06_paracomp""t07_sentcomp""t09_wordmean""t10_addition""t12_countdot "および "t13_sccaps "で、lavaanパッケージの変数x1 ... x9（Grant-Whiteの学校）として使用されます。もう1つの古典的なデータ集合は、R. P. McDonald (1985, 1999)によって詳細に議論され、SASのPROC CALIS マニュアルと同様に sem パッケージで例として使用されている9変数のThurstone問題です。  これらの9つのテストは、ThurstoneとThurstone, 1941によって（他のデータに基づいて）3つの要因にグループ化された：Verbal Comprehension、Word Fluency、Reasoningである。元のデータはThurstone and Thurstone (1941)によるものだが、Bechthold (1961)によって再分析され、彼はデータセットを2つに分けた。サンプルサイズは213である。Thurstone (1933)に起因する9つの認知変数のもう1つのセットは、プリンストンのBrigham教授が大学入試委員会に報告した4,175人の学生のデータセットである。  Tucker (1958) は、Turstone and Thburstone (1941)の9変数を、彼のバッテリー間因子分析の例に使用しています。  二因子モデルの最近の応用は、心理的状態の測定である。Reiseのデータセットは、Consumer Assessment of Health Care Provider and Systems調査票に対する35,000を超える観察に基づく相関行列である。Reise, Morizot, and Hays (2007)は、1,000症例に基づく二因子解を記述している。    Reiseらによる5つの因子は、「迅速に治療を受ける」（1-3）、「医師がよくコミュニケーションをとる」（4-7）、「丁寧で親切なスタッフ」（8,9）、「必要な治療を受ける」（10-13）、「医療プランの顧客サービス」（14-16）である。2つのBechtoldtデータセットは、Thurstone and Thurstone (1941)からの2つのサンプルである。  これらは、17の変数を含み、そのうちの9つは、Thurstoneデータ集合を形成するためにMcDonaldによって使用されました。サンプルサイズはそれぞれ212と213である。提案された6つの因子は、記憶、言語、単語、空間、数、推論を反映し、暗記記憶因子を期待するすべての3つのマーカーがある。このセットから9変数がThurstoneデータセットに現れる。同様の構造を持つデータセットがHarmanデータセットにさらに2つある。  これには、Harman link{Harman.Holzinger}が使用したHolzingerの別の9変数（被験者696人）と、link{burt}の8感情変数が含まれます。二因子構造の検定のために調べる価値があるもう1つのデータ集合は、Keith Widamanによって提供されたHolzinger and Swineford (1939)のオリジナル・データを含むholzinger.swinefordデータ集合です。  これはpsychToolsパッケージに入っている。Bechtoldt.1: 能力検査の17 x 17相関行列、N = 212.Bechtoldt.2：能力検査の17 x 17相関行列，N = 213．Holzinger：能力検査の14 x 14相関行列，N = 355 Holzinger.9：能力検査の9 x 9相関行列，N = 145 Reise：健康満足度項目の16 x 16相関行列．  N = 35,000 Thurstone: 能力検査の9 x 9相関行列、N = 213 Thurstone.33: 能力検査の別の9 x 9相関行列、N = 4175 Thurstone:9：さらに別の9×9の能力テストの相関行列、N=710
HolzingerとSwineford（1937）は、精神能力について二因子モデル（1つの一般因子といくつかのグループ因子）を導入した。  これは、オメガ関数やsemを用いて分析できる階層的な因子構造のすばらしい実証データセットである。このようなデータを分析するには、いくつかの方法があります。  1つは、オメガ関数を使用して、Schmid-Leiman変換を使用して階層因数分解を行うことである。これは、探索的モデルとして、そしてomegaSemを用いた確認的モデルとして行うことができます。もう1つの方法は、通常の因子分析を行い、bifactor 回転またはbiquartimin 回転を使用することです。後者の2つの関数は、Jennrich and Bentler (2011) のバイファクター変換とバイクォーティミン変換を実装しています。  バイファクター回転は，局所最小の問題（Mansolf and Reise, 2016）に悩まされるので，探索的分析と確認的分析の混合が望ましいかもしれない．14の変数は、3つの空間テスト、3つのメンタル・スピード・テスト、4つの運動スピード・テスト、4つの言語テストを反映するように順序付けされている。  Holzingerからのもう1つのデータ集合（Holzinger.9）は、9つの認知能力（Holzinger, 1939）を表し、Karl Joreskog (2003)がMINRESアルゴリズムによる因子分析の例として使用し、LISRELのマニュアルにも例NPV.KMとして掲載されています。  このデータ集合は、Grant White中学校の9つのテストの得点です：  「t01_visperc""t02_cubes""t04_lozenges""t06_paracomp""t07_sentcomp""t09_wordmean""t10_addition""t12_countdot "および "t13_sccaps "で、lavaanパッケージの変数x1 ... x9（Grant-Whiteの学校）として使用されます。もう1つの古典的なデータ集合は、R. P. McDonald (1985, 1999)によって詳細に議論され、SASのPROC CALIS マニュアルと同様に sem パッケージで例として使用されている9変数のThurstone問題です。  これらの9つのテストは、ThurstoneとThurstone, 1941によって（他のデータに基づいて）3つの要因にグループ化された：Verbal Comprehension、Word Fluency、Reasoningである。元のデータはThurstone and Thurstone (1941)によるものだが、Bechthold (1961)によって再分析され、彼はデータセットを2つに分けた。サンプルサイズは213である。Thurstone (1933)に起因する9つの認知変数のもう1つのセットは、プリンストンのBrigham教授が大学入試委員会に報告した4,175人の学生のデータセットである。  Tucker (1958) は、Turstone and Thburstone (1941)の9変数を、彼のバッテリー間因子分析の例に使用しています。  二因子モデルの最近の応用は、心理的状態の測定である。Reiseのデータセットは、Consumer Assessment of Health Care Provider and Systems調査票に対する35,000を超える観察に基づく相関行列である。Reise, Morizot, and Hays (2007)は、1,000症例に基づく二因子解を記述している。    Reiseらによる5つの因子は、「迅速に治療を受ける」（1-3）、「医師がよくコミュニケーションをとる」（4-7）、「丁寧で親切なスタッフ」（8,9）、「必要な治療を受ける」（10-13）、「医療プランの顧客サービス」（14-16）である。2つのBechtoldtデータセットは、Thurstone and Thurstone (1941)からの2つのサンプルである。  これらは、17の変数を含み、そのうちの9つは、Thurstoneデータ集合を形成するためにMcDonaldによって使用されました。サンプルサイズはそれぞれ212と213である。提案された6つの因子は、記憶、言語、単語、空間、数、推論を反映し、暗記記憶因子を期待するすべての3つのマーカーがある。このセットから9変数がThurstoneデータセットに現れる。同様の構造を持つデータセットがHarmanデータセットにさらに2つある。  これには、Harman link{Harman.Holzinger}が使用したHolzingerの別の9変数（被験者696人）と、link{burt}の8感情変数が含まれます。二因子構造の検定のために調べる価値があるもう1つのデータ集合は、Keith Widamanによって提供されたHolzinger and Swineford (1939)のオリジナル・データを含むholzinger.swinefordデータ集合です。  これはpsychToolsパッケージに入っている。Bechtoldt.1: 能力検査の17 x 17相関行列、N = 212.Bechtoldt.2：能力検査の17 x 17相関行列，N = 213．Holzinger：能力検査の14 x 14相関行列，N = 355 Holzinger.9：能力検査の9 x 9相関行列，N = 145 Reise：健康満足度項目の16 x 16相関行列．  N = 35,000 Thurstone: 能力検査の9 x 9相関行列、N = 213 Thurstone.33: 能力検査の別の9 x 9相関行列、N = 4175 Thurstone:9：さらに別の9×9の能力テストの相関行列、N=710
予測変数の集合から基準を予測するために使用できる多くの手順がある．  その総称が「機械学習」または「統計学習」である。  これらの手順の基本ロジックは，ある適合統計量にしたがってクライテリアを最もよく予測する項目の集合を見つけ，これらの項目を何度も交差検証することである．  「bestScalesは、回帰のように部分相関に重み付けをするのではなく、基準とのゼロ次相関から選択された項目に単位重み付けをすることで、これらの手続きとは異なります。  これは、よく知られている発見（Wilks, 1938; Wainer, 1976; Dawes, 1979; Waller, 2008）を考慮した単純な手順で、回帰加重はどのような特定のデータセットに対しても最適であるが、単位加重はほぼ同等（カンジブル）で、サンプルのばらつきに対してよりロバストである。  いくつかの提案に従って，我々は，項目が基準とのゼロ次相関によって重みづけされる尺度を見つける機能を追加した．   これは事実上、単位重み付けと回帰重み付け（ここで、重みはゼロ次相関に相関行列の逆数を掛けたもの）の妥協点である。この重み付きバージョンは、単位重み付きバージョンBISCUITとは対照的に、BISCWITと考えることができる。他のMLアルゴリズムと比較できるように、我々は今、複数の解（項目数 >= min.itemからmax.itemまで）を考慮する。  最終的な尺度は、妥当性を最大にする、または少なくとも最大値からデルタ * rの標準誤差以内にある項目数で構成される。  したがって、bestScales は、cut よりも大きい基準との絶対相関を持つ項目を、基準ごとに最大 n.項目まで見つけます。  overlap オプションがFALSE（デフォルト）の場合、他の基準は使用されない。  これは "dust bowl empiricism "の例で、測定される潜在構成要素はなく、ただ基準の集合と最も相関するそれらの項目があるだけである。経験的に特定された項目は、（内部一貫性の概念を無視して）尺度に形成され、基準と相関されます。  明らかに、bestScalesは偶然の関連を利用している。  したがって、経験的尺度を検証するには、被験者総数のごく一部で尺度を導き出し、残りの被験者で相互検証を行う必要があります。(これはK-foldクロス検証としてもバギングとしても知られている。  どちらも行うことができる）。  もしfolds > 1なら、k-foldクロスバリデーションが行われる。  これは導出標本の標本から1/k（fold）を取り除き、その残りのfoldで検証する。これをk回繰り返す。  伝統的なクロス・バリデーションは、k =2のk倍である。  より最近のアプリケーションでは、90%の導出サンプルと10%のクロス検証サンプルを持つために、k =10が好まれるようです。「バギング」として知られる代替案は、導出サンプル（バッグ）に対してブートストラップサンプル（これは置換サンプリングなので、通常サンプルの1- 1/e = 63.2%を抽出する）を行い、サンプルの残りの1/e（バッグ外）で検証することです。  これをn.iter回行う。安定した交差検証を得るためには、これを複数回（n.iter > 1、例えばn.iter=1000）繰り返す必要がある。それぞれを試すことで、これら2つのアプローチの有効性を比較することができる。  n.iterサンプルの平均予測可能性とクロス検証の平均有効性を示す。   これはxが相関行列ではなく、データ行列/data.frameである場合にのみ可能である。  bestScalesは、k-fold検証と同様に、'bagging'（ブートストラップ集計）と機械学習の効果的なアプリケーションです。bestItemsとlookupは、相関行列や因子負荷行列を要約するための単純なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列の行列として内容を含め、項目内容については必要な数のフィールドを含める。(辞書の例 bfi.dictionaryを参照).導出されたモデルは、最良の尺度オブジェクトと新しいデータセットが与えられた場合、predict.psych関数を使用して、さらに別の保留サンプルに対して検証することができます。
予測変数の集合からクライテリアを予測するために使用できる多くの手順がある．  この総称は "機械学習 "または "統計学習 "です。  これらの手順の基本的な論理は、ある適合統計量に従ってクライテリアを最もよく予測する項目の集合を見つけ、次にこれらの項目を何回も交差検証することである。  「bestScalesは、回帰のように部分相関に重み付けをするのではなく、基準とのゼロ次相関から選択された項目に単位重み付けをすることで、これらの手続きとは異なります。  これは、よく知られている発見（Wilks, 1938; Wainer, 1976; Dawes, 1979; Waller, 2008）を考慮した単純な手順で、回帰加重はどのような特定のデータセットに対しても最適であるが、単位加重はほぼ同等（カンジブル）で、サンプルのばらつきに対してよりロバストである。  いくつかの提案に従って，我々は，項目が基準とのゼロ次相関によって重みづけされる尺度を見つける機能を追加した．   これは事実上、単位重み付けと回帰重み付け（ここで、重みはゼロ次相関に相関行列の逆数を掛けたもの）の妥協点である。この重み付きバージョンは、単位重み付きバージョンBISCUITとは対照的に、BISCWITと考えることができる。他のMLアルゴリズムと比較できるように、我々は今、複数の解（項目数 >= min.itemからmax.itemまで）を考慮する。  最終的な尺度は、妥当性を最大にする、または少なくとも最大値からデルタ * rの標準誤差以内にある項目数で構成される。  したがって、bestScales は、cut よりも大きい基準との絶対相関を持つ項目を、基準ごとに最大 n.項目まで見つけます。  overlap オプションがFALSE（デフォルト）の場合、他の基準は使用されない。  これは "dust bowl empiricism "の例で、測定される潜在構成要素はなく、ただ基準の集合と最も相関するそれらの項目があるだけである。経験的に特定された項目は、（内部一貫性の概念を無視して）尺度に形成され、基準と相関されます。  明らかに、bestScalesは偶然の関連を利用している。  したがって、経験的尺度を検証するには、被験者総数のごく一部で尺度を導き出し、残りの被験者で相互検証を行う必要があります。(これはK-foldクロス検証としてもバギングとしても知られている。  どちらも行うことができる）。  もしfolds > 1なら、k-foldクロスバリデーションが行われる。  これは導出標本の標本から1/k（fold）を取り除き、その残りのfoldで検証する。これをk回繰り返す。  伝統的なクロス検証は、k =2のk倍である。  より最近のアプリケーションでは、90%の導出サンプルと10%のクロス検証サンプルを持つために、k =10が好まれるようです。「バギング」として知られる代替案は、導出サンプル（バッグ）に対してブートストラップサンプル（これは置換サンプリングなので、通常サンプルの1- 1/e = 63.2%を抽出する）を行い、サンプルの残りの1/e（バッグ外）で検証することです。  これをn.iter回行う。安定した交差検証を得るためには、これを複数回（n.iter > 1、例えばn.iter=1000）繰り返す必要がある。それぞれを試すことで、これら2つのアプローチの有効性を比較することができる。  n.iterサンプルの平均予測可能性とクロス検証の平均有効性を示す。   これはxが相関行列ではなく、データ行列/data.frameである場合にのみ可能である。  bestScalesは、k-fold検証と同様に、'bagging'（ブートストラップ集計）と機械学習の効果的なアプリケーションです。bestItemsとlookupは、相関行列や因子負荷行列を要約するための単純なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列の行列として内容を含め、項目内容については必要な数のフィールドを含める。(辞書の例bfi.dictionaryを参照).最良のスケール・オブジェクトと新しいデータセットが与えられれば、predict.psych関数を使用して、導出されたモデルをさらに別の保留サンプルに対して検証することができます。
このデータセットは非推奨であり、ユーザはbfi.を使用することが推奨される。最初の25項目は5つの推定因子で構成されている：最初の25項目は、5つの推定される因子によって構成されている：同意性、良心性、外向性、神経質、開放性。  これらの5つの因子は、irt.faを使って項目反応理論に基づく多項式相関行列の潜在因子分析を行う有用な例である。  各項目のエンドースメント・プロット、および項目情報関数は、項目がその質において異なることを明らかにしている。項目データは6段階の回答尺度を用いて収集された：項目データは、Synthetic Apeture Personality Assessment (SAPA https://www.sapa-project.org/)プロジェクトの一環として、6段階の回答尺度を用いて収集された：1 Very Inaccurate2 Moderately Inaccurate3 Slightly Inaccurate4 Slightly Accurate5 Moderately Accurate6 Very Accurate。  データ収集手法の例を見るには、https://www.sapa-project.org/ または International Cognitive Ability Resource（https://icar-project.org/）を参照。  与えられた項目は、ルイス・ゴールドバーグの国際パーソナリティ項目プールから、SAPAのサンプリング技法を用いてサンプリングされたものである。  これは、より大規模なSAPAデータバンクから抽出されたサンプルデータセットである。
このデータセットは非推奨であり、ユーザーはbfiを使うことが推奨される。最初の25項目は5つの推定因子によって構成されている：最初の25項目は、5つの推定される因子によって構成されている：同意性、良心性、外向性、神経質、開放性。  これらの5つの因子は、irt.faを使って項目反応理論に基づく多項式相関行列の潜在因子分析を行う有用な例である。  各項目のエンドースメント・プロット、および項目情報関数は、項目がその質において異なることを明らかにしている。項目データは6段階の回答尺度を用いて収集された：項目データは、Synthetic Apeture Personality Assessment (SAPA https://www.sapa-project.org/)プロジェクトの一環として、6段階の回答尺度を用いて収集された：1 Very Inaccurate2 Moderately Inaccurate3 Slightly Inaccurate4 Slightly Accurate5 Moderately Accurate6 Very Accurate。  データ収集手法の例を見るには、https://www.sapa-project.org/ または International Cognitive Ability Resource（https://icar-project.org/）を参照。  与えられた項目は、ルイス・ゴールドバーグの国際パーソナリティ項目プールから、SAPAのサンプリング技法を用いてサンプリングされたものである。  これは、はるかに大規模なSAPAデータバンクから取り出したサンプルデータセットである。
ヒストグラム/棒グラフを背中合わせに描く些細な、しかし便利な機能。各グループに1つずつ。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装したbiquartiminの2つであろう。もう1つはTargetQで、これはターゲットの欠損NA値を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようです。faRotateは、ここで追加されたものと同様に、様々なGPArotation関数を呼び出す便利な方法に過ぎません。biquartiminとbifactorの違いは、後者がJennrich and Bentler (2011)で文書化されている直交ケースであるということだけです。  Holzingerの24認知変数に対するbifactorの出力は、JennrichとBentlerの出力と一致し、fm="mle "が使用され、JennrichとBentlerの解が共分散から相関に再スケーリングされた場合のChenらの問題に対する出力も一致します。Promaxは、stats::promax関数を非常に直接的に適応したものです。  varimin は、Suitbert Ertl (2013) によって提案された varimin 基準を実装しています。  varimax 基準を最大化するのではなく、最小化する。  さらに、これらの関数は、factanal、fa、または以前の（factor.pa、factor.minres、またはprincipal）関数からの出力を受け取り、分析のために負荷行列だけを選択します。equamaxは、GPArotationのcFT関数（回転のCrawford Fergusonファミリー用）を呼び出すだけです。TargetQはMichael Browneのアルゴリズムを実装したもので、NA値の指定が可能です。Targetの入力はリストである（例参照）。  因子を定義する際に、因子が何でないかを指定することがいかに強力に働くかは興味深い。  target.rot関数は、Michael Browneの関数を適応したもので、任意のターゲット行列に対して回転を行うことができます。  Pat Shroutの提案によるものです。target.rotのデフォルトは、独立クラスター構造（すべての項目が、最も負荷の高いグループに割り当てられる）に回転することです。target.rotは、線形従属性を持つターゲット（たとえば、すべての変数にg負荷とグループ因子がある純粋なバイファクターモデル）は扱いません。
データは size=size のサブセットに分割される。  そして、各サブセットとサブセットのペアで相関が発見されます。基本ループは、部分集合をループします。サイズが変数数の整数部分集合であり、コア数の整数である場合、マルチコアがより多く使用されます。  660/80と660/100では、660/80の方が有利であることに注目してほしい。  しかし、660/165を試してみると、これは破綻する。  さらに、より小さなサブセット（55）を使用した場合のメリットに注目。  2.4GHZのIntellコアi9.options(mc.cores=4)を搭載した8コアのMac Book Proで、645Kの被験者を使ったさまざまな問題のタイミング（秒）（8つあるので、これをテストしながら同時に作業できる）まず644,495人の被験者と、可能な変数の数の1/10でテストする。  次に、もう少し少ない変数でテストします。  さらに被験者の数を減らしてテストする。  時間は被験者数に対してほぼ線形です。最後に1万人の被験者で比較し、適切なサイズの値を得ることの効果を示します。時間はケース数に対してほぼ線形で、変数数の2乗で増加します。  コア数の増加は顕著である。4コアの場合、8セットか12セットに分割するサイズを使うべきだと思われる。  そうしないと、実際にはすべてのコアを効率的に使うことはできない。マルチコアの使用には多少のオーバーヘッドがあります。  そのため、小さい問題（例えば、psychTools::spiデータセットの145項目の4,000ケース）では、タイムはbigCor（デフォルトサイズ）でおよそ0.44秒、通常のcorで0.36秒です。  しかし、サイズをいじると、size = 40で0.37になる。   クロスオーバーポイントは、およそ5Kの被験者であるようだ。
因子分析fa、fa.polyまたは主成分分析principalの出力を取り込み、因子/成分負荷量とともに因子/成分得点をプロットするために、一般的なbiplot関数を使用します。これは、2つの空間における点のプロットをよりコントロールできるようにするための一般的なbiplot関数の拡張であり、3つ以上の因子（一度に2つ）をプロットすることもできます。  これは、fa、fa.poly、principalによって生成されたオブジェクトで、元のデータ行列に適用された場合に機能します。  しかし、tetrachoricまたはpolychoricの出力に基づく相関行列があり、その相関に対してfaまたはprincipalを実行した場合、明らかにバイプロットはできない。  しかし、これらの関数はどちらも重み行列を生成し、元のデータと組み合わせて、factor.scoresを使ってスコアを求めることができます。  biplot.psychはxオブジェクトの2つの要素：x$loadingsとx$scoreを探しているので、プロットするために適切なオブジェクトを作成することができます。3番目の例を参照してください。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜め2因子回転を実装したbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようです。faRotateは、ここで追加されたものと同様に、様々なGPArotation関数を呼び出す便利な方法に過ぎません。biquartiminとbifactorの違いは、後者がJennrich and Bentler (2011)で文書化されている直交ケースであるということだけです。  Holzingerの24認知変数に対するbifactorの出力は、JennrichとBentlerの出力と一致し、fm="mle "が使用され、JennrichとBentlerの解が共分散から相関に再スケーリングされた場合のChenらの問題に対する出力も一致します。Promaxは、stats::promax関数を非常に直接的に適応したものです。  varimin は、Suitbert Ertl (2013)によって提案されたvarimin 基準を実装しています。  varimax 基準を最大化するのではなく、最小化する。  さらに、これらの関数は、factanal、fa、または以前の（factor.pa、factor.minres、またはprincipal）関数からの出力を受け取り、分析のために負荷行列だけを選択します。equamaxは、GPArotationのcFT関数（回転のCrawford Fergusonファミリー用）を呼び出すだけです。TargetQはMichael Browneのアルゴリズムを実装したもので、NA値の指定が可能です。Targetの入力はリストである（例参照）。  因子を定義する際に、因子が何でないかを指定することがいかに強力に働くかは興味深い。  target.rot関数は、Michael Browneの関数を適応したもので、任意のターゲット行列に対して回転を行うことができます。  Pat Shroutの提案によるものです。target.rotのデフォルトは、独立クラスター構造（すべての項目は、その負荷が最も高いグループに割り当てられる）に回転することです。target.rotは、線形従属性を持つターゲット（たとえば、すべての変数にg負荷とグループ因子がある純粋なバイファクターモデル）を扱うことはできません。
四分位相関は、二変量正規性を仮定して、2 x 2 の度数表から潜在的なピアソン相関を推論します。  推定手順は，2段階のML．  各組の項目のセル度数が求められる．テトラコリックスの場合、カウントがゼロのセルは、連続性の補正として0.5に置き換えられる（correct=TRUE）。データは通常、真/偽（4値法）または限定された回答数（多値法）のいずれかで採点されたアンケートへの回答の生データ行列になります。  どちらの場合も、限界度数は正規理論のしきい値に変換され、各項目ペアの結果の表は、観察されたセル度数と観察された限界度数を生成する（推測された）潜在ピアソン相関に変換されます。  (例としてdraw.tetraとdraw.corを参照)これは計算集約的な関数であり、マルチコアを使用し、並列パッケージを使用することでかなり高速化できる。  polychoricまたはtetrachoricを行う際に使用するコアの数はoptionsコマンドで指定することができる。最も速度が向上するのは1コアから2コアにすることで、約50％の節約になる。  4コアにすると66％、8コアにすると75％の節約になるようだ。  options("mc.cores"=4)は、コア数を4に設定します。tetrachoricとpolychoricは、x変数（列）とy変数（行）のセットの非対称相関行列を求めることができます。  これは、解を基本集合から別の集合に拡張する場合に便利である。  四分位相関は様々な文脈で使用され，1つはテスト得点の項目反応理論（IRT）分析で，もう1つは共存統計量の相関係数への変換で重要である．  この2番目の文脈で、セル度数に対する係数の感度の例が明らかになります。Kirk (1973)のテストデータセットを考えてみましょう。彼は、テトラコリック相関（例参照）に対するMLアルゴリズムの有効性を報告しています。  以前のバージョンはJohn Foxのpolychor関数を使用していましたが、現在はpolyc関数に置き換えられています。poly.matはpolycor関数の代替ラッパーでした。双列相関と多列相関は、観測された点-双列相関と点-多列相関（それ自体は単なるピアソン相関です）に相当する推定潜在相関です。polyserial 関数は、行列またはデータフレーム入力で動作し、応答頻度の全体的な（すべての観察されたケースの）確率で補正されたペアワイズ Pearson r を見つけることによって欠損データを扱います。  これは、大量の欠損データがあり、完全な症例がないSAPA手順（https://www.sapa-project.org/）（Revelle et al. 2010, 2016, 2020）に特に有用です。同様のデータについては、International Cognitive Ability Resource (https://www.icar-project.org/)も参照してください。能力検査や性格検査の行列は、通常、通常のピアソン相関を使用する場合よりも、テトラコロリック相関やポリコロリック相関を使用する場合の方が、よりきれいな構造を持ちます。双列相関（単なるピアソン相関である点双列相関と混同しないように）は，xとyの間の潜在相関で，yは連続，xは2値であるが，（未観測の）連続正規変数を表すと仮定される．p = xのレベル1の確率，q = 1 - pとする． zp = pに関連するz スコアの正規縦軸とする．MacCallumら, 2002によってうまく議論されているように，平均で人為的に2分すると，ポイント2等分線は2等分線の0.8になる（実際には0.798）．  同様に、ファイ係数（2分値データでのピアソン）は、実数値（rho）の2[arcsin(rho)/pi)になります。「アドホック」多列相関、rps は、単に r = r * sqrt(n-1)/n) σ y /∑(zpi) であり、ここで zpi は、項目回答間のカットポイント境界の正規等価での正規曲線の縦線です。(Olsson, 1982) これらはすべて、相関の正確なML推定に使用されるべきJohn Foxのpolychorパッケージからインスパイアされ（そして、そこから適応され）ました。  特に、polychorパッケージのhetcor関数を参照してください。  polychoricの結果は、correct=FALSE、global=FALSEを使用した場合、polychorの答えと少なくとも小数点以下5桁で一致します。特に欠損データのあるデータセットからのテトラコリック相関の場合、行列が正定値にならないことがあります。  さまざまな平滑化の選択肢がありますが、ここで行われるのは、相関行列の固有値分解を行い、すべての負の固有値を10 * .Machine$double.epsに設定し、正の固有値を変数の数の合計になるように正規化し、相関行列を再構成することです。   非常に小さなデータセットの場合、特にglobal=FALSEオプションを使用している場合、または一度に1つの相関だけを行う場合、多項式相関の連続性の補正が困難になる可能性があります。補正値を小さく設定する（つまり、correct =.1）ことで解決するようです。  John Uebersax (2015)は、ポリコーリック相関とテトラコーリック相関の両方が、過去の発見方法であるテトラコーリックやポリコーリックではなく、発見方法から潜在相関または潜在連続相関と呼ばれるべきであるという興味深い指摘をしています。つまり，人為的に2つ（四分位）またはそれ以上（多分位）の値に分割すると，観察された度数のn x n 表が得られる2つの潜在変数の間の相関は何かということである．  連続変数、カテゴリー変数、2値変数の組み合わせについては、mixed.corを参照してください。応答選択肢の数が可変のデータを使用する場合は、polychoricでglobal=FALSEオプションを使用する必要があります。  (この条件が検出された場合、自動的に設定されます).2値データで比較的小さなサンプルの場合、いくつかのセルが空であったり、再サンプリングされた行列が正半定値でない場合、警告が出されます。これは、multi.cores(Macを使用している場合のデフォルト)を使用している場合、深刻な問題につながります。解決策は、multi.coresを使用しないことであるようです（例えば、options(mc.cores =1) mixedCorは、N = 4,000、145項目のspiデータセットに対してpolychoricを呼び出し、2.4GHz 8コアのIntel i9を搭載したMac book Pro上で、1コアで130秒、2コアで68秒、4コアで37秒、8コアで22秒、16コアで22.8秒かかりました。  ポリコレ相関（spi[11:145]）を見つけるだけで、4コアでは34秒、8コアでは22秒かかった。(2022年更新：M1 maxチップを使用) 145変数すべてに対するmixedCor：1コア=54、2コア=28、4コア=15.8秒、8コア=8.9秒。  ポリコレだけの場合は、4コア＝13.7秒、8コア＝7.4秒。     カテゴリの数が増えるにつれて、計算時間も増加する。  約8カテゴリー以上では、通常のピアソン相関とポリコレの差はあまり大きくない*。  しかし，必要であれば，カテゴリー数（num.cat）を大きな値に設定してもよい．  (バージョン2.0.6で追加).*FoldnesとGronnebergの最近の論文によると、カテゴリ数が大きくても、カテゴリデータにポリコレを使用することが適切であることが示唆されている。  これは特に、カテゴリ度数の分布が非常に非正規分布の場合である。
NA
lsat6データセットは、McDonald (1999)と同様にltmパッケージで分析されている。どちらのデータセットもBock and Lieberman (1970)によって説明されています。どちらのセットも、IRT手順をテストし、irt.fa関数を用いたテトラコリック相関と項目因子分析の使用を示す有用な例です。
Cattell (1963) は、Thurstoneからの8つの認知変数とInstitute for Personality Assessment Test (IPAT)からの4つの認知変数について報告しました。  Rindskopf and Rose (1988) は、このデータ集合を2次因子分析の例として使用しています。したがって、二因子回転、オメガ階層、esem因子分析、バッテリー間因子分析などの代替解を検証するのに適したセットです。
lowerCor は、対角行列の下側を丸めたものを出力し、列名は桁数+3文字に省略されます。  デフォルトでは、変数のペアワイズ削除が使用されます。  この行列は、きれいな印刷を行うlowerMatを呼び出します。  必要なのはlowerMatだけなのにlowerCorを呼び出さないことを覚えておくことが重要です！ csはFrank HarrellによるHmiscパッケージのCs関数をそのままコピーしたものです。  Hmiscパッケージのオーバーヘッドを避けるためにpsychに追加された。
 Schmid and Leiman (1957)による2つの人工相関行列。Chen et al. (2006)からの実共分散行列と人工共分散行列。  Schmid: Schmid-Leiman 変換を示すために作成された 12 x 12 の人工相関行列：対角上に共分散を持つ12 x 12の行列。  これを共分散行列として扱うと，6 x 6 因子解を示す Chen: Chen ら (2006)の健康関連QOL項目の18 x 18 共分散行列．オブザベーションの数 = 403.  最初の項目は、生活の質の尺度である。  残りの17項目は4つのサブファクターを形成する：項目は以下の通りである：「推論や問題解決が困難か？  "言われたことやされたことへの反応が遅い"、"混乱して一度にいくつもの行動を始める"。  "物や約束をどこに置いたか忘れるか？"; "集中するのが難しいか？" (b) 活力下位尺度：「疲れを感じるか？  「(R)「疲れていると感じますか？(右) "疲れを感じるか"、"活力に満ちているか"。(R).(c）メンタルヘルス下位尺度：c）精神的健康下位尺度：「穏やかで平和な気分ですか」（R）、「落ち込んでブルーな気分ですか」（R）、「とても幸せな気分ですか」（R）、「とても神経質な気分ですか」（R）、「何も元気が出ないほど落ち込んでいますか」（R）。 d）疾病の心配下位尺度：(d)病気の心配下位尺度：「健康のことで恐れていましたか」；「健康についてイライラしていましたか」；「健康は生活の心配事でしたか」。西Chenら(2006)による16×16の人工共分散行列。
NA
このシミュレーションは元々、影響の測定における歪みの効果を比較するために開発された（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が（例えば1）であっても、これらの範囲に制限することで項目が歪む可能性があります。  item.dichotを追加することで、異なる難易度（支持）の二項対立項目を持つ構造をテストすることができます。  2つの項目のセットに対して、単純構造または円周構造を持つ2つの因子データが生成され、1つは、low (easy)値より大きいすべての項目に対してスコア1を与え、もう1つは、high (hard)値より大きいすべての項目に対してスコア1を与える。つまり、すべての項目の支持率は50％と仮定される。  項目の難易度の効果を調べるために、lowを-1、highを1とすることもできる。これにより、項目の支持率は、簡単なものが0.84、難しいものが0.16となる。  各難易度セットの中で、最初の1/4は第1因子、2番目は第2因子、3番目は第1因子（ただし負荷量はマイナス）、4番目は第2因子（ただし負荷量はマイナス）に割り当てられる。sim.itemとsim.hierarchicalの結果を比較するのは便利です。sim.itemは、2つの直交因子と同様に、すべての項目を通る一般因子を生成します。  これは、標準的な回転技法では表現しにくいデータセットを生成します。  回転なしで3つの因子を抽出し、2番目と3番目の因子を回転させると、正しい解が得られます。  しかし、3因子の単純な斜め回転やオメガ分析では、根本的な構造を捉えることはできません。  最後の例をご覧ください。さらに、魅力的かもしれないもう1つの構造は、3次元の完全に複雑なデータです。  sim.sphericalはこのようなデータを作成します。
"心理データを表現する一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造である(Revelle & Rocklin, 1979)。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サーカンプレックス（Guttman, 1954）は、単純構造が欠如しているモデルの一種である。第一に、円周構造は変数が相互に関連していることを最低限意味している。第二に、circumplex構造は、問題の領域が2つの次元によって最適に表現されることを意味する。第三に、circumplex 構造は、単純構造のように変数が2つの軸に沿ってグループ化したり、固まったりするのではなく、直交する軸のペアの間に常に間歇的な変数が存在することを意味する(Saucier, 1992)。理想的な場合、この性質は、円の円周に沿った変数の等間隔に反映される（Gurtman, 1994; Wiggins, Steiger, & Gaelick, 1981）。第4に、円周構造は、変数が円の中心から一定の半径を持つことを意味し、これはすべての変数が2つの円周次元で等しい共同性を持つことを意味する（Fisher, 1997; Gurtman, 1994）。第5に、円plex 構造は、すべての回転がドメインの等しく良い表現であることを意味する（Conte & Plutchik, 1981; Larsen & Diener, 1992）。(ActonとRevelle, 2004)ActonとRevelleは、10個の円周構造のテストの有効性を検討し、4個のテストが円周構造と単純構造、または円周構造と楕円構造を識別するのに特に優れていることを発見した。残念なことに、彼らの研究はPascalで行われたため、簡単に入手することができない。等間隔性のギャップ検定軸の等質性のフィッシャーの検定回転に対する無関心性の検定任意の回転にわたって因子負荷量の2乗の分散が等しいことの検定。circ.sim.plotは、変数の数と標本サイズの関数として、circplex、ellipsoid、simple structureのデータに対する4つの検定を比較します。  このプロットからわかることは、1つの検定がこれらの代替構造を識別するのに十分なわけではないが、4つの検定のセットが非常によくできているということである。  特定のデータ集合の構造を検定するとき、4つの検定の結果をすべてシミュレーション・データと比較すると、データの構造特性のよい徴候が得られます。
「心理学的データを表現する一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造である(Revelle & Rocklin, 1979)。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サーカンプレックス（Guttman, 1954）は、単純構造が欠如しているモデルの一種である。第一に、円周構造は変数が相互に関連していることを最低限意味している。第二に、circumplex構造は、問題の領域が2つの次元によって最適に表現されることを意味する。第三に、circumplex 構造は、単純構造のように変数が2つの軸に沿ってグループ化したり、固まったりするのではなく、直交する軸のペアの間に常に間歇的な変数が存在することを意味する(Saucier, 1992)。理想的な場合、この性質は、円の円周に沿った変数の等間隔に反映される（Gurtman, 1994; Wiggins, Steiger, & Gaelick, 1981）。第4に、円周構造は、変数が円の中心から一定の半径を持つことを意味し、これはすべての変数が2つの円周次元で等しい共同性を持つことを意味する（Fisher, 1997; Gurtman, 1994）。第5に、circumplex 構造は、すべての回転がドメインの等しく良い表現であることを暗示する（Conte & Plutchik, 1981; Larsen & Diener, 1992）」。(ActonとRevelle, 2004)ActonとRevelleは、10個のcircumplex構造のテストの有効性を検討し、4個のテストがcircumplex構造と単純構造、またはcircumplexと楕円構造を識別するのに特に優れていることを発見した。残念なことに、彼らの研究はPascalで行われたため、簡単に入手することができない。等間隔性のギャップ検定軸の等質性のフィッシャーの検定回転に対する無関心性の検定任意の回転にわたって因子負荷量の2乗の分散が等しいことの検定。circ.sim.plotは、変数の数と標本サイズの関数として、circplex、ellipsoid、simple structureのデータに対する4つの検定を比較します。  このプロットからわかることは、1つの検定がこれらの代替構造を識別するのに十分なわけではないが、4つの検定のセットが非常によくできているということである。  特定のデータ集合の構造を検定するとき、4つの検定の結果をすべてシミュレーション・データと比較すると、データの構造特性のよい徴候が得られます。
「心理学的データを表現する一般的なモデルは単純構造である（Thurstone, 1947）。ある一般的な解釈によると、項目や尺度が1つだけの因子にゼロでない因子負荷量を持つとき、データは単純構造である(Revelle & Rocklin, 1979)。単純構造の一般的な適用にもかかわらず、いくつかの心理学モデルは単純構造の欠如によって定義される。サーカンプレックス（Guttman, 1954）は、単純構造が欠如しているモデルの一種である。第一に、円周構造は変数が相互に関連していることを最低限意味している。第二に、circumplex構造は、問題の領域が2つの次元によって最適に表現されることを意味する。第三に、circumplex 構造は、単純構造のように変数が2つの軸に沿ってグループ化したり、固まったりするのではなく、直交する軸のペアの間に常に間歇的な変数が存在することを意味する(Saucier, 1992)。理想的な場合、この性質は、円の円周に沿った変数の等間隔に反映される（Gurtman, 1994; Wiggins, Steiger, & Gaelick, 1981）。第4に、円周構造は、変数が円の中心から一定の半径を持つことを意味し、これはすべての変数が2つの円周次元で等しい共同性を持つことを意味する（Fisher, 1997; Gurtman, 1994）。第5に、circumplex 構造は、すべての回転がドメインの等しく良い表現であることを暗示する（Conte & Plutchik, 1981; Larsen & Diener, 1992）。(Acton and Revelle, 2004)ActonとRevelleは、10個の円周構造のテストの有効性を検討し、4個のテストが円周構造と単純構造、または円周構造と楕円構造を識別するのに特に優れていることを発見した。残念なことに、彼らの研究はPascalで行われたため、簡単に入手することができない。これらのさまざまな検定の値を解釈するために、特定の解を、円周構造と単純構造の純粋なケースを表すシミュレーション解と比較することが有用です。  circ.simulationの出力例を参照し、これらのプロットとcirc.testの結果を比較してください。
データが角度を表す場合（1日の中で覚醒度がピークになる時間や緊張度がピークになる時間など）、より普通の線形統計量ではなく、円形統計量を適用する必要があります（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照してください）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  Pearson相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、一日の気分に関する様々な研究からのデータを分析できるように適応された。  これらの2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようです。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようです。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようです。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)(時間で表現)の場合、β.cとβ.sは回帰によって求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションのすべてを足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  Pearson相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、最もフィットする位相角を推定するために線形回帰による円形を使用します。  cos.t <- cos(time)、sin.t = sin(time)(時間で表現)の場合、β.cとβ.sは回帰によって求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、最もフィットする位相角を推定するために線形回帰による円形を使用します。  cos.t <- cos(time)、sin.t = sin(time)(時間で表現)の場合、β.cとβ.sは回帰によって求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、最もフィットする位相角を推定するために線形回帰による円形を使用します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、一日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰によって求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分に最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均の周りでコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
これらは、合成相関行列を形成するSAPA (https://www.sapa-project.org/)手順で使用される関数の3つである。  項目の相関行列があれば、それらの項目からなる尺度の相関行列を見つけるのは簡単です。これは、元のデータ行列から行うこともできますし、 scoreItems を使って相関行列から行うこともできます。  キーが重なっている（項目が複数のスケールで採点されている）場合、scoreOverlap は、重なっている共分散（重なっている場合は分散）を、その項目の平均相関または smc 推定値のいずれかを使用して、項目の「真の」分散の対応する最良推定値に置き換えることによって、この重なりを調整します。  これはアルファ信頼性を求めるときの操作と似ています。  これは、Cureton (1966) や Bashaw and Anderson (1966)によって提案されたアイデアと似ていますが、smcまたは平均項目間相関（デフォルト）を使用します。SAPAプロジェクトでの典型的な使用法は、クラスタリングまたはファクタリング（fa, ICLUST, principalを参照）によって項目の複合を形成し、これらの結果からクラスタを抽出し（factor2cluster）、cluster.corを用いて複合相関行列を形成することです。  この縮小行列の変数は、mat.regress.元の相関にキー行列の(転置)を事前および事後に乗算する多重相関手続きで使用することができます。元の行列からいくつかの相関が欠落している場合、それらの低レベルの相関に基づくスケール間相関の欠落値（NA）につながります。impute=TRUE (デフォルト)の場合、警告が出され、各尺度の欠落していない要素の平均相関に基づいて相関がインプットされます。信頼性のアルファ推定値は、共分散ではなく項目の相関に基づいているので、このアルファ推定値は "標準化アルファ "と呼ばれることもある。  生項目が利用できる場合、標準化アルファと scoreItems を用いて求めた生アルファを比較することが有用である。  scoreOverlapは、尺度や関連する下位尺度を開発するとき、または尺度の代替バージョンを比較するときに、重要な問題に答えます。  項目の重なりの影響を除去することで、観測された合計（平均）スコアによって推定される潜在変数間の関係をよりよく推定することができます。  これは、各被験者に複数のオケージョンがあるESM研究を行う場合に便利です。   また、被験者の部分集合の相関を求めることもできます。例をご覧ください。  欠測の多いESMデータでは、相関行列が正-半正定値にならない可能性が高いことに注意してください。scoreByは、被験者内の相関を調べたい（例えば、ESMデータの場合）、または被験者のグループ内の相関を調べたい（サブグループによる相関構造の安定性を調べる場合）多階層モデルを調べるときに便利です。  どちらの場合も、まずデータをstatsByで処理しなければならない。  尺度の分散を求めるには、statsByのcor="cov "オプションを使う必要がある。
クラスター・モデルは因子モデルに似ています：RはC'Cによって適合されます。ここで C <- クラスタ定義行列 x 負荷行列。  フィット統計量は、元の（2乗）相関と残差相関の比較です。  適合度 = 1 - r*2/r2 ここで r* はデータ-モデルの残差相関で、モデル = C'C.
おそらく重複している）クラスタとして採点される項目の集合と項目の相互相関行列が与えられると，クラスタを求め，各クラスタと各項目の相関を求める．  項目の分散をクラスタ内の平均項目間相関に置き換えることで、項目の重複を補正する。  これはICLUSTの一部ですが、項目と複合尺度の項目-全体相関に興味があるSAPA (https://www.sapa-project.org/) アプリケーションで使用できます。SAPAに関する情報は、Revelle et al, 2010, 2016を参照してください。  SAPAに基づく能力測定については、https://icar-project.org.These 負荷量は、各クラスタについて絶対的な大きさでソートすると特に解釈しやすい（ICLUST.sortを参照）。
因子分析またはクラスター分析の結果がプロットされる。  各項目は、最も負荷の高い因子に割り当てられ、変数名とクラスタ（色）で識別されます。クラスタの割り当ては、負荷による自動クラスタリングを上書きするように指定することができます。これらの関数は両方とも、直接呼び出すか、汎用 plot 関数を呼び出すことによって呼び出すことができます。  (例参照)。
kmeansは項目を逆スコアしないので、kmeansによって定義されたクラスタは、同じ数のクラスタが抽出されたICLUSTのクラスタと必ずしも一致しないことに注意してください。
2つのグループがどのように異なるかを報告する方法はたくさんある．  Cohen の d 統計量は，単に平均の差をプールされたグループ内標準偏差で表現したものである．  これは標本サイズに影響されません。 rは効果量の普遍的な尺度で、dの単純な関数ですが、-1 から 1の境界です。t 統計量は、単に d * sqrt(n)/2 であり、したがって標本サイズを反映します。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プーリングされた分散の推定値を与えますが、pooled が FALSE の場合、Welch の補正が適用されます。マハラノビス距離は、個々の ds を結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットの例を参照。
系列的判断が2つの系列でなされる場合、関係の尺度はファイ係数である。  しかし、いくつかのカテゴリー判断は2つ以上の結果を用いてなされる。  例えば、2人の診断士が患者を3通りに分類するよう求められたり（例えば、人格障害、神経症、精神病）、病気の病期を分類するよう求められたりする。  塩基率が2×2の表で観察されるセルの度数に影響するように、n-way表でも考慮する必要がある(Cohen, 1960)。Kappaは主対角線上のマッチを考慮する。  対角線から外れた一致にはペナルティ関数（重み）を適用できる。  重みが対角からの距離の2乗で増加する場合，重み付きκはクラス内相関（ICC）に似ている．重み付きκの導出は，類似度で表現されることもあれば，非類似度で表現されることもある．後者の場合、対角線上の重みは1で、対角線から外れた重みは1より小さい。この場合、重みが1-対角からの距離の2乗/kであれば、結果はICCに類似している（任意の正のkの場合）。 cohen.kappaは、様々な公表された例と一致させるために、類似度重み付け（対角=0）または非類似度重み付け（対角=1）のいずれかを使用することができる。入力は2列のdata.frameまたは行列で、列は2人の審査員を表し、行は評価される被験者を表す。あるいは、入力は正方形の n x n 行列で、マッチの回数または割合を表すこともできる。  比率が使用される場合、信頼区間を正しく求めるためにオブザベーションの数（n.obs）を指定することが必要である。信頼区間は、Cohen (1968)とBlashfieldの式を修正したFleiss, Cohen, and Everittによって議論された分散推定に基づいている。  κがカテゴリー関係の尺度であるという意味では、これは問題にならないはずである。  しかし、重み付きκを求めると、重み付けされたカテゴリの数は、データ中の潜在的なカテゴリの数より少なくなる。  これはlevelsパラメータを指定することで改善できる。  これは、データ中に潜在的に存在するレベルのベクトルです（欠落しているものもあります）。   2人以上の評価者がいる場合は、すべての評価者の平均がLight's kappaとして知られている(Conger, 1980)．(Conger, 1980).  
合同は、行列によって定義され、原点を基点とするベクトルの対の余弦である。  2つの行列 F1 と F2 に対して、一致度の尺度 phi は phi = sum(F1 F2)/sqrt(sum(F1^2) sum(F2^2)) 一致度をそれぞれの値の相関と比較するのは興味深い練習である。合同は生のクロス積に基づくが、相関は中心化されたクロス積に基づく。つまり，項目の相関は，各列の平均荷重に基づくベクトルの余弦である． phi = sum((F1-a)(F2-b))/sqrt(sum((F1-a)^2) sum((F2-b)^2)) .合同係数については， a = b = 0. 相関については， a = 平均 F1, b = 平均 F2.通常，すべての因子負荷行列は完全でなければならない（欠落した負荷量がない）．  データがゼロ・センターである場合、これは相関であり、データが尺度の中点（M）を中心とする場合、これはコーエンの類似度係数である。  例を参照。Mが指定されていない場合は、xとyの項目の中点として求められる。cohen.profileは、Mを中心としたデータに一致関数を適用する。Mは指定することもできるし、データから求めることもできる。distanceはrの関数として一般化された距離を求めます。city block (r=1), Euclidean (r=2) or weighted towards maximimum (r >2)。
NA
このシミュレーションは、もともと影響の測定における歪みの効果を比較するために開発されました（Rafaeli and Revelle, 2005を参照）。  このシミュレーションは、単純構造または円周構造を持つ感情またはパーソナリティ項目の一般的なシミュレーションを可能にするために拡張されました。  項目は、連続的な正規分布にすることも、n個のカテゴリー（例：-2、-1、0、1、2）に分けることもできる。  項目の平均が（例えば1）であっても、これらの範囲に制限することで項目が歪む可能性があります。  item.dichotを追加することで、異なる難易度（支持）の二項対立項目を持つ構造をテストすることができます。  2つの項目のセットに対して、単純構造または円周構造を持つ2つの因子データが生成され、1つは、low (easy)値より大きいすべての項目に対してスコア1を与え、もう1つは、high (hard)値より大きいすべての項目に対してスコア1を与える。つまり、すべての項目の支持率は50％と仮定される。  項目の難易度の効果を調べるために、lowを-1、highを1とすることもできる。これにより、項目の支持率は、簡単なものが0.84、難しいものが0.16となる。  各難易度セットの中で、最初の1/4は第1因子、2番目は第2因子、3番目は第1因子（ただし負荷量はマイナス）、4番目は第2因子（ただし負荷量はマイナス）に割り当てられる。sim.itemとsim.hierarchicalの結果を比較するのは便利です。sim.itemは、2つの直交因子と同様に、すべての項目を通る一般因子を生成します。  これは、標準的な回転技法では表現しにくいデータセットを生成します。  回転なしで3つの因子を抽出し、2番目と3番目の因子を回転させると、正しい解が得られます。  しかし、3因子の単純な斜め回転やオメガ分析では、根本的な構造を捉えることはできません。  最後の例をご覧ください。さらに、魅力的かもしれないもう1つの構造は、3次元の完全に複雑なデータです。  sim.sphericalはこのようなデータを作成します。
信頼性分析用の例を作成する場合、共属データ構造をシミュレートするのが便利です。  これは最も単純な項目構造で、因子が1つしかありません。主に信頼性理論の議論や因子得点の推定に用いられます。暗黙の共分散行列は、パターン %*% t(pattern)だけです。
共分散行列は、行列によって定義され、原点を基点とするベクトルの対の余弦である。  2つの行列 F1 と F2 に対して、一致度の尺度 phi は phi = sum(F1 F2)/sqrt(sum(F1^2) sum(F2^2)) 一致度をそれぞれの値の相関と比較するのは面白い練習です。合同は生のクロス積に基づくが、相関は中心化されたクロス積に基づく。つまり，項目の相関は，各列の平均荷重に基づくベクトルの余弦である． phi = sum((F1-a)(F2-b))/sqrt(sum((F1-a)^2) sum((F2-b)^2)) .合同係数については， a = b = 0. 相関については， a = 平均 F1, b = 平均 F2.通常，すべての因子負荷行列は完全でなければならない（欠落した負荷量がない）．  データがゼロ・センターである場合、これは相関であり、データが尺度の中点（M）を中心とする場合、これはコーエンの類似度係数である。  例を参照。Mが指定されていない場合は、xとyの項目の中点として求められます。cohen.profileは、Mを中心としたデータに一致関数を適用します。Mは指定することもできますし、データから求めることもできます。distanceはrの関数として一般化された距離を求めます。city block (r=1), Euclidean (r=2) or weighted towards maximimum (r >2)。
相関行列が与えられた場合、信頼区間が従来のr2z fisherz変換（fisherzと正規分布）を用いて標本サイズに基づいて求められる。  キーが指定された場合（正規の場合）、相関に基づく複合尺度が求められ、報告される。  これはcluster.corやscoreItemsを用いたのと同じ手順である。次に（生データを用いた場合）、被験者（行）を置換ありでサンプリングすることによりデータをn.iter回再作成し、相関（および複合尺度）を再度（そして何度も）求める。  これらの値の平均と標準偏差は、相関のフィッシャーZ変換に基づいて計算される。  要約統計量は、元の相関とその信頼区間を含む。  欠損データが多いSAPA (https://www.sapa-project.org/)タイプのデータで特に有用ですが、これはどのような通常のデータセットでも同様に機能します。相関は自動的にcor.plotとして表示されますが、cor.plot.upperLowerCiを使うことで、上下の信頼区間を表示することができます。これはまた、対角線の下と上に相関の下限と上限を表示した印刷用の行列を目に見えないように返します（最初の例を参照）。
大規模なデータ・ベースの相関を要約するとき、または因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示すると便利です。  これはimage関数を使った簡単なグラフ表示です。mat.plot と通常の image プロットとの違いは、主対角線が左上から右下に向かっていることです。-1 から 1 と色の選択がより合理的です。  c(0,1)と設定すると、負の相関がゼロとして扱われることになる。  これは一般的な因子構造を表示するときに有利で、0を白にするからである。  減衰を補正した相関をプロットする場合、興味深いケースがある。  この場合、zlim = NULL（観測された最大値と最小値を使用する）に設定するか、1より上のすべての値は1より少し暗い影が付けられますが、違いはありません。デフォルトでは、図の右側に色分けの凡例が表示されます。David CondonとJosh Wiltの提案に従って、濃い赤（-1）から白（0）を経て濃い青（1）までの、より意味のある色の選択を使用するように修正。grオプション（Lorien Ellemanの提案）を使って色を選択できるようにさらに修正。相関の数値を含めるようにさらに修正。  (corrplotパッケージからヒントを得ました)。  これらの値は、cor.ciまたはcorr.testで見られる確率値に従ってスケーリングされるかもしれません。指定されない限り、フォントサイズは、cex = 10/max(nrow(r),ncol(r))を持つように動的にスケーリングされます。  これは、大きな問題に対してかなり小さなフォントを生成する可能性があります。  ラベルのフォントサイズは、cex.axis（デフォルトは1）を使って調整することができる。  デフォルトでは、cor.ciはcorPlotUpperLowerCiを呼び出し、"有意 "値に基づいて相関をスケーリングします。  プロットされる相関は、信頼度の上限と下限である。  相関そのものを表示するには、corPlotを直接呼び出します。corr.testの出力を使う場合、対角の上側は補正された確率でスケーリングされ、対角の下側は補正されていない確率でスケーリングされます。corr.testまたはcor.ciの出力をcorPlotUpperLowerCiの入力として使う場合、対角の上側は信頼区間の上界、対角の下側は信頼区間の下界になります。  adjust=TRUEの場合、（corr.testによって）HolmまたはBonferroni調整値が使用されます。2つの相関行列の要素を比較するには、lowerUpperの結果をcorPlotします。  同じプロットで複数のcorPlotを行うには、show.legend=FALSEとkeep.par=FALSEを指定します。  最後の例を参照してください。  非対称行列（例えば，scoreItems や scoreOverlap からの補正相関）から行や列を選択する際には注意が必要です．  因子負荷行列（または任意の非対称行列）を表示するには， symmetric=FALSE を設定する．  そうでない場合は，相関が検出されます．
大規模なデータ・ベースの相関を要約するとき、または因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示すると便利です。  これはimage関数を使った簡単なグラフ表示です。mat.plot と通常の image プロットとの違いは、主対角線が左上から右下に向かっていることです。-1 から 1 と色の選択がより合理的です。  c(0,1)と設定すると、負の相関がゼロとして扱われることになる。  これは一般的な因子構造を表示するときに有利で、0を白にするからである。  減衰を補正した相関をプロットする場合、興味深いケースがある。  この場合、zlim = NULL（観測された最大値と最小値を使用する）に設定するか、1より上のすべての値は1より少し暗い影が付けられますが、違いはありません。デフォルトでは、図の右側に色分けの凡例が表示されます。David CondonとJosh Wiltの提案に従って、濃い赤（-1）から白（0）を経て濃い青（1）までの、より意味のある色の選択を使用するように修正。grオプション（Lorien Ellemanの提案）を使って色を選択できるようにさらに修正。相関の数値を含めるようにさらに修正。  (corrplotパッケージからヒントを得ました)。  これらの値は、cor.ciまたはcorr.testで見られる確率値に従ってスケーリングされるかもしれません。指定されない限り、フォントサイズは、cex = 10/max(nrow(r),ncol(r))を持つように動的にスケーリングされます。  これは、大きな問題に対してかなり小さなフォントを生成する可能性があります。  ラベルのフォントサイズは、cex.axis（デフォルトは1）を使って調整することができる。  デフォルトでは、cor.ciはcorPlotUpperLowerCiを呼び出し、"有意 "値に基づいて相関をスケーリングします。  プロットされる相関は、信頼度の上限と下限である。  相関そのものを表示するには、corPlotを直接呼び出します。corr.testの出力を使う場合、対角の上側は補正された確率でスケーリングされ、対角の下側は補正されていない確率でスケーリングされます。corr.testまたはcor.ciの出力をcorPlotUpperLowerCiの入力として使う場合、対角の上側は信頼区間の上界、対角の下側は信頼区間の下界になります。  adjust=TRUEの場合、（corr.testによって）HolmまたはBonferroni調整値が使用されます。2つの相関行列の要素を比較するには、lowerUpperの結果をcorPlotします。  同じプロットで複数のcorPlotを行うには、show.legend=FALSEとkeep.par=FALSEを指定します。  最後の例を参照してください。  非対称行列（例えば，scoreItems や scoreOverlap からの補正相関）から行や列を選択する際には注意が必要です．  因子負荷行列（または任意の非対称行列）を表示するには， symmetric=FALSE を設定する．  そうでない場合は，相関行列が表示されます．
平滑化は固有値分解によって行われます。固有値 < eig.tol は 100 * eig.tol に変更されます。  正の固有値は，項目数の合計になるようにスケールし直される．  行列は再計算され(eigen.vectors %*% diag(eigen.values) %*% t(eigen.vectors))、cov2corを用いて強制的に相関行列に変換されます。(Bock, Gibbons and Muraki, 1988 and Wothke, 1993参照)。これはKnolとten Berge (1989)の解決策を実装していませんし、sfmsmiscのnearcorとposdefifyも、MatrixのnearPDも実装していません。Martin Maechlerがposdedify関数で言っているように、"この問題や関連する問題を解くには、もっと洗練されたアルゴリズムがあります。" cor.smootherは、一度に1つの変数を系統的に削除し、固有値分解を見つけることによって、nvar-1のランクのnvar個のすべての最小値を調べます。  その結果、正定値行列を作る変数が取り除かれる。  また、各変数を取り除いたときの負の固有値の数も報告する。  最後に、元の相関行列と平滑化された相関行列を比較し、絶対偏差がカットより大きい項目を報告します。  これらはすべて、相関行列の何が問題なのかを示すヒントである。  
平滑化は固有値分解によって行われ、固有値 < eig.tolは100 * eig.tolに変更されます。  正の固有値は、項目数の合計になるようにスケールし直される。  行列は再計算され(eigen.vectors %*% diag(eigen.values) %*% t(eigen.vectors))、cov2corを用いて強制的に相関行列に変換されます。(Bock, Gibbons and Muraki, 1988 and Wothke, 1993参照)。これはKnolとten Berge (1989)の解決策を実装していませんし、sfmsmiscのnearcorとposdefifyも、MatrixのnearPDも実装していません。Martin Maechlerがposdedify関数で言っているように、"この問題や関連する問題を解くには、もっと洗練されたアルゴリズムがあります。" cor.smootherは、一度に1つの変数を系統的に削除し、固有値分解を見つけることによって、nvar-1のランクのnvar個のすべての最小値を調べます。  その結果、正定値行列を作る変数が取り除かれる。  また、各変数を取り除いたときの負の固有値の数も報告する。  最後に、元の相関行列と平滑化された相関行列を比較し、絶対偏差がカットより大きい項目を報告します。  これらはすべて、相関行列の何が問題なのかを示すヒントである。  
加重相関は単に∑ (wt_k * (x_ik - x_jk)) です。/sqrt[wt_k ∑(x^2_ik) wt_k ∑(x^2_jk)] ここで、x_ikは加重平均からの偏差である。  重み付き相関は、個々のデータ点がいくつかのオブザベーションの平均を反映しているかもしれないような、集約されたデータを相関させるのに適している。  この場合、各ポイントは、その標本サイズによって（または標準誤差によって）重みづけされる。  重みがすべて等しい場合、相関は通常のPearson相関になる。statsBy を使って求めた群平均の相関を求めるときに使う。
lowerCor は対角行列の下側を丸めたものを出力し、列名は桁数+3文字に省略されます。  デフォルトでは、変数のペアワイズ削除が使用される。  この行列は、きれいな印刷を行うlowerMatを呼び出します。  必要なのはlowerMatだけなのにlowerCorを呼び出さないことを覚えておくことが重要です！ csはFrank HarrellによるHmiscパッケージのCs関数をそのままコピーしたものです。  Hmiscパッケージのオーバーヘッドを避けるためにpsychに追加された。
NA
NA
相関行列が与えられた場合、信頼区間は従来のr2z fisherz変換（fisherzと正規分布）を使用してサンプルサイズに基づいて求められます。  キーが指定された場合（正規の場合）、相関に基づく複合尺度が求められ、報告される。  これは、cluster.corやscoreItemsを用いたのと同じ手順である。次に（生データで）被験者（行）を置換付きでサンプリングしてデータをn.iter回再作成し、相関（および複合尺度）を再度（そして何度も）求める。  これらの値の平均と標準偏差は、相関のフィッシャーZ変換に基づいて計算される。  要約統計量は、元の相関とその信頼区間を含む。  欠損データが多いSAPA (https://www.sapa-project.org/)タイプのデータで特に有用ですが、これはどのような通常のデータセットでも同様に機能します。相関は自動的にcor.plotとして表示されますが、cor.plot.upperLowerCiを使うことで、上下の信頼区間を表示することができます。これはまた、相関の下界と上界が対角線の下と上に表示された印刷用の行列を目に見えないように返します（最初の例を参照）。
欠損データがある場合、完全情報最尤法(FIML)は単純に対相関を使用する代わりに使用できます。構造方程式モデリング用のlavaanパッケージの実装は、相関または共分散を求めるだけの単純なケースに適応されています。  任意の変数のペアに対するペアワイズ解は、行列に含まれる他の変数に影響されません。  一方，ML解は，項目の集合全体が相関していることに依存する．  これは、異なる変数の部分集合に対して、わずかに異なる解を導くことになる。  基本的なFIMLアルゴリズムは、欠測のすべてのパターンについて共分散と平均のペアワイズML解を求め、そして欠測のすべてのユニークなパターンのサイズによって解を重みづけすることである。  
大規模なデータ・ベースの相関を要約するとき、あるいは因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示すると便利です。  これはimage関数を使った簡単なグラフ表示です。mat.plot と通常の image プロットとの違いは、主対角線が左上から右下に向かっていることです。-1 から 1 と色の選択がより合理的です。  c(0,1)と設定すると、負の相関がゼロとして扱われます。  これは一般的な因子構造を表示するときに有利で、0を白にするからである。  減衰を補正した相関をプロットする場合、興味深いケースがある。  この場合、zlim = NULL（観測された最大値と最小値を使用する）に設定するか、1より上のすべての値は1より少し暗い影が付けられますが、違いはありません。デフォルトでは、図の右側に色分けの凡例が表示されます。David CondonとJosh Wiltの提案に従って、濃い赤（-1）から白（0）を経て濃い青（1）までの、より意味のある色の選択を使用するように修正。grオプション（Lorien Ellemanの提案）を使って色を選択できるようにさらに修正。相関の数値を含めるようにさらに修正。  (corrplotパッケージからヒントを得ました)。  これらの値は、cor.ciまたはcorr.testで見られる確率値に従ってスケーリングされるかもしれません。指定されない限り、フォントサイズは、cex = 10/max(nrow(r),ncol(r))を持つように動的にスケーリングされます。  これは、大きな問題に対してかなり小さなフォントを生成する可能性があります。  ラベルのフォントサイズは、cex.axisを使用して調整することができます。  デフォルトでは、cor.ciはcorPlotUpperLowerCiを呼び出し、"有意 "値に基づいて相関をスケーリングします。  プロットされる相関は、信頼度の上限と下限である。  相関そのものを表示するには、corPlotを直接呼び出します。corr.testの出力を使う場合、対角の上側は補正された確率でスケーリングされ、対角の下側は補正されていない確率でスケーリングされます。corr.testまたはcor.ciの出力をcorPlotUpperLowerCiの入力として使う場合、対角の上側は信頼区間の上界、対角の下側は信頼区間の下界になります。  adjust=TRUEの場合、（corr.testによって）HolmまたはBonferroni調整値が使用されます。2つの相関行列の要素を比較するには、lowerUpperの結果をcorPlotします。  同じプロットで複数のcorPlotを行うには、show.legend=FALSEとkeep.par=FALSEを指定します。  最後の例を参照してください。  非対称行列（例えば，scoreItems や scoreOverlap からの補正相関）から行や列を選択する際には注意が必要です．  因子負荷行列（または任意の非対称行列）を表示するには， symmetric=FALSE を設定する．  そうでない場合は，相関が検出されます．
大規模なデータ・ベースの相関を要約するとき、または因子分析やクラスター分析について教えるとき、相関行列の構造をグラフィカルに表示すると便利です。  これはimage関数を使った簡単なグラフ表示です。mat.plot と通常の image プロットとの違いは、主対角線が左上から右下に向かっていることです。-1 から 1 と色の選択がより合理的です。  c(0,1)と設定すると、負の相関がゼロとして扱われます。  これは一般的な因子構造を表示するときに有利で、0を白にするからである。  減衰を補正した相関をプロットする場合、興味深いケースがある。  この場合、zlim = NULL（観測された最大値と最小値を使用する）に設定するか、1より上のすべての値は1より少し暗い影が付けられますが、違いはありません。デフォルトでは、図の右側に色分けの凡例が表示されます。David CondonとJosh Wiltの提案に従って、濃い赤（-1）から白（0）を経て濃い青（1）までの、より意味のある色の選択を使用するように修正。grオプション（Lorien Ellemanの提案）を使って色を選択できるようにさらに修正。相関の数値を含めるようにさらに修正。  (corrplotパッケージからヒントを得ました)。  これらの値は、cor.ciまたはcorr.testで見られる確率値に従ってスケーリングされるかもしれません。指定されない限り、フォントサイズは、cex = 10/max(nrow(r),ncol(r))を持つように動的にスケーリングされます。  これは、大きな問題に対してかなり小さなフォントを生成する可能性があります。  ラベルのフォントサイズは、cex.axis（デフォルトは1）を使って調整することができる。  デフォルトでは、cor.ciはcorPlotUpperLowerCiを呼び出し、"有意 "値に基づいて相関をスケーリングします。  プロットされる相関は、信頼度の上限と下限である。  相関そのものを表示するには、corPlotを直接呼び出します。corr.testの出力を使用する場合、対角の上側は補正された確率でスケーリングされ、対角の下側は補正されていない確率でスケーリングされます。corr.testまたはcor.ciの出力をcorPlotUpperLowerCiの入力として使用する場合、対角の上側は信頼区間の上界、対角の下側は信頼区間の下界になります。  adjust=TRUEの場合、（corr.testによって）HolmまたはBonferroni調整値が使用されます。2つの相関行列の要素を比較するには、lowerUpperの結果をcorPlotします。  同じプロットで複数のcorPlotを行うには、show.legend=FALSEとkeep.par=FALSEを指定してください。  最後の例を参照してください。  非対称行列（例えば，scoreItems や scoreOverlap からの補正相関）から行や列を選択する際には注意が必要です．  因子負荷行列（または任意の非対称行列）を表示するには， symmetric=FALSE を設定する．  そうでない場合は、相関が検出されます。
corr.testは、相関を求めるためにcor関数を使用し、次に、formulat = r* sqrt(n-2)/sqrt(1-r^2) se = sqrt((1-r^2)/(n-2))tと標準誤差は、結果のオブジェクトとして返されますが、通常は表示されません。print(short=FALSE)オプションを使用すると、信頼区間が求められ、表示されます。  これらは、相関のフィッシャーz変換を使用し、r +/- qnorm(alpha/2) * seの範囲を取ることによって求められ、z変換の標準誤差はse = sqrt(1/(n-3))です。   これらの値は相関単位に逆変換される。これらの値は ci オブジェクトで返されます。method=="kendall "の場合、これらは正規理論の信頼区間なので、少し大きすぎることに注意してください。  行列が対称の場合（yデータがない）、元のp値は対角線の下に、調整されたp値は対角線の上に報告される。  それ以外の場合は、すべての確率が調整されます（adjust="none "でない限り）。  これは出力で明示される．corr.pは、partial.rの結果に対して、nをn - s（sはパーシャルアウトされた変数の数）に設定すると適用できる Fisher, 1924.
corr.testは、相関を見つけるためにcor関数を使用し、次に、formulat = r* sqrt(n-2)/sqrt(1-r^2) se = sqrt((1-r^2)/(n-2))を使用して、個々の相関にt検定を適用します。tと標準誤差は、結果のオブジェクトとして返されますが、通常は表示されません。print(short=FALSE)オプションを使用すると、信頼区間が求められ、表示されます。  これらは、相関のフィッシャーz変換を使用し、r +/- qnorm(alpha/2) * seの範囲を取ることによって求められ、z変換の標準誤差はse = sqrt(1/(n-3))です。   これらの値は相関単位に逆変換される。これらの値は ci オブジェクトで返されます。method=="kendall "の場合、これらは正規理論の信頼区間なので、少し大きすぎることに注意してください。  行列が対称の場合（yデータがない）、元のp値は対角線の下に、調整されたp値は対角線の上に報告される。  それ以外の場合は、すべての確率が調整されます（adjust="none "でない限り）。  これは出力で明示される．corr.pは、nがn - s（sは部分化された変数の数）に設定されている場合、partial.rの結果に適用されることがある Fisher, 1924.
非減衰相関は，観察変数の集合によって測定される潜在変数の間の相関と考えることができる．つまり、両方の変数が完全に信頼性をもって測定された場合、2つの（信頼できない）変数の間の相関はどうなるかということです。この関数は、主に相関と信頼度をどこかからインポートする場合に使用されます。  この関数の出力例は、cluster.loadingsとcluster.corにあります。
行列が恒等行列であるかどうかを検定する方法はいくつかある。最もよく知られているのは，Bartlett (1951) と Box (1949)のカイ2乗検定である．Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の和またはフィッシャー変換相関の2乗の和を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normalに実装されている。さらにもう1つの検定は、2つの行列の等質性のJennrich(1970)検定である。これは，カイ2乗検定を用いて2つの行列の平均と2つの行列の差を比較する．これは cortest.jennrich で実装されている。さらにもう1つのオプション cortest.mat は、因子モデルの妥当性を評価する際に使用されるアプローチに類似したアプローチを使用して2つの行列を比較する。  因子分析では，最尤適合統計量は， f = log(trace ((FF'+U2)^{-1} R) - log(|(FF'+U2)^-1 R|) - n.items.である．これはカイ二乗カイ^2 = (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3)) に変換されます。* つまり、モデル(M = FF' + U2)は、M^{-1} Rの関数によって元の相関行列(R)と比較されます。類似して、2つの行列、AとBの場合、cortest.matは、A^{-1}BとA B^{-1}に関連するカイ二乗を見つけます。  これらの2つのχ^2の和もχ^2になりますが、自由度は2倍になります。  
実際の応用よりも教育的な目的のために有用である。因子分析(fa)または主成分分析(principal)からの残差に適用する場合、対角が1に置き換えられなければならないことに注意してください。これは diag=TRUE の場合に自動的に行われます（例を参照）。 相関行列が因子分解可能であるかどうか（すなわち、相関が0と異なるかどうか）を検定するもう1つの方法は、Kaiser-Meyer-Olkin KMO 因子妥当性検定です。
行列が恒等行列であるかどうかを検定する方法はいくつかある．もっともよく知られているのは，Bartlett (1951) と Box (1949) のカイ2乗検定である．Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の合計またはフィッシャー変換相関の2乗の合計を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normalに実装されている。さらにもう1つの検定は、2つの行列の等質性のJennrich(1970)検定である。これは，カイ2乗検定を用いて2つの行列の平均と2つの行列の差を比較する．これは cortest.jennrich で実装されている。さらにもう1つのオプション cortest.mat は、因子モデルの妥当性を評価する際に使用されるアプローチに類似したアプローチを使用して2つの行列を比較する。  因子分析では，最尤適合統計量は， f = log(trace ((FF'+U2)^{-1} R) - log(|(FF'+U2)^-1 R|) - n.items.である．これはカイ二乗カイ^2 = (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3)) に変換されます。* つまり、モデル(M = FF' + U2)は、M^{-1} Rの関数によって元の相関行列(R)と比較されます。類似して、2つの行列、AとBの場合、cortest.matは、A^{-1}BとA B^{-1}に関連するカイ二乗を見つけます。  これらの2つのχ^2の和もχ^2になりますが、自由度は2倍になります。  
行列が恒等行列であるかどうかを検定する方法はいくつかある。最もよく知られているのは、Bartlett (1951) と Box (1949)のカイ2乗検定である。Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の和またはフィッシャー変換相関の2乗の和を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normalに実装されている。さらにもう1つの検定は、2つの行列の等質性のJennrich(1970)検定である。これは，カイ2乗検定を用いて2つの行列の平均と2つの行列の差を比較する．これは cortest.jennrich で実装されている。さらにもう1つのオプション cortest.mat は、因子モデルの妥当性を評価する際に使用されるアプローチに類似したアプローチを使用して2つの行列を比較する。  因子分析では，最尤適合統計量は， f = log(trace ((FF'+U2)^{-1} R) - log(|(FF'+U2)^-1 R|) - n.items.である．これはカイ二乗カイ^2 = (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3)) に変換されます。* つまり、モデル(M = FF' + U2)は、M^{-1} Rの関数によって元の相関行列(R)と比較されます。類似して、2つの行列、AとBの場合、cortest.matは、A^{-1}BとA B^{-1}に関連するカイ二乗を見つけます。  これらの2つのχ^2の和もχ^2になりますが、自由度は2倍になります。  
行列が恒等行列であるかどうかを検定する方法はいくつかある。最もよく知られているのは、Bartlett (1951) と Box (1949)のカイ2乗検定である。Steiger (1980)によって議論された非常に簡単な検定は，2乗相関の和またはフィッシャー変換相関の2乗の和を求めることである．  すべての相関が等しいという帰無仮説の下では、この合計はカイ2乗として分布する。  これは cortest と cortest.normalに実装されている。さらにもう1つの検定は、2つの行列の等質性のJennrich(1970)検定である。これは，カイ2乗検定を用いて2つの行列の平均と2つの行列の差を比較する．これは cortest.jennrich で実装されている。さらにもう1つのオプション cortest.mat は、因子モデルの妥当性を評価する際に使用されるアプローチに類似したアプローチを使用して2つの行列を比較する。  因子分析では，最尤適合統計量は， f = log(trace ((FF'+U2)^{-1} R) - log(|(FF'+U2)^-1 R|) - n.items.である．これはカイ二乗カイ^2 = (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3)) に変換されます。* つまり、モデル(M = FF' + U2)は、M^{-1} Rの関数によって元の相関行列(R)と比較されます。類似して、AとBの2つの行列の場合、cortest.matはA^{-1}BとA B^{-1}に関連するカイ二乗を見つけます。  これらの2つのχ^2の和もχ^2になりますが、自由度は2倍になります。  
データが角度（日中の覚醒のピークや緊張のピークの時間など）を表すとき、我々はより普通の線形統計ではなく、円形統計を適用する必要がある（円形統計の非常に明確な例についてはJammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰によって求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰によって求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均のまわりにコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定である。
データが角度を表すとき（日中の覚醒度のピークの時間や緊張度のピークの時間など）、より通常の線形統計量ではなく、円形統計量を適用する必要がある（円形統計量の非常に明確な例については、Jammalamadaka (2006)を参照）。円形データへの平均の一般化は、各角度をベクトルに変換し、x座標とy座標を平均し、その結果を角度に戻すことである。オブザベーションのコンパクトさを表す統計量は R で、これはオブザベーションをすべて足して得られる（正規化された）ベクトルの長さである。  これは、すべての位相角が同じときに最大値（1）になり、位相角がクロックのまわりに一様に分布しているときに最小値（0）になる。  ピアソン相関の循環統計量への一般化は簡単で、circularパッケージのcor.circularとここのcircadian.corに実装されています。  ピアソンrが2つの分散の積の平方根に対する共分散の比であるように、円相関も同様である。  2つの円ベクトルの円共分散は、円平均からの偏差の正弦の平均積として定義されます。  したがって分散は、円平均からの角度偏差の平均平方正弦である。  円形統計量は、ある期間（たとえば1日）や方向（たとえば風向きや鳥の飛び方）にわたって変化するデータに使われる。  Jammalamadaka and Lund (2006)は、風速と風向の計算における循環統計量の使用について非常に良い例を示している。  CircStatsとcircularのコードは、1日の気分に関する様々な研究からのデータを分析できるように適応された。  これら2つのパッケージは欠損データを扱わず、行列入力を取らず、むしろ単一ベクトルを重視するようだ。  cosinor関数は、観測されたデータに角度の余弦を繰り返しフィットさせるか（opti=TRUE）、線形回帰によって円形を使い、最もフィットする位相角を推定します。  cos.t <- cos(time)、sin.t = sin(time)の場合(時間で表現)、β.cとβ.sは回帰で求められ、位相は sign(beta.c) * acos(beta.c/√(beta.c^2 + beta.s^2)) となる。* 12/piシミュレーション(例を参照)によると、不完全な時間では、最適化手順は線形モデルよりも正しい位相でわずかに良いフィットをもたらすが、その差は非常に小さい。ノイズの多いデータがある場合、これらの利点は逆転するようです。  したがって、線形モデルアプローチ（デフォルト）を使用することを推奨します。  cosinorについて報告される適合統計量は、データとモデル[ cos(time - acrophase) ]との相関である。circadian.reliability関数は、各被験者のデータを前半と後半に分割し（デフォルトでは、または奇数と偶数の項目に分割）、各半分について最も適合する位相を見つける。  次にこれらの相関をとり（circadian.corを使用）、この相関を従来のSpearman-Brown式を使用してテストの長さで調整する。circular.meanとcircular.corは、単なるcircadian.meanとcircadian.corですが、入力は時間ではなくラジアン単位で与えられます。circadian.linear.cor関数は、円形変数の集合と線形変数の集合を相関させます。  最初の（角度）変数は円形で、2番目の（x）変数の集合は線形である。  circadian.Fは、2つ以上のグループを平均位置で比較する。  これは、circular pacakgeの等価関数から適応されている。  これは明らかに、各グループがその平均の周辺でコンパクトであればあるほど（Rの値が大きければ大きいほど）、より強力な検定です。
SAPAプロジェクトで使用されるMMCAR（Massively Missing Completely at Random）計画を使用する場合、対のオブザベーションの数（pairwiseCount）をカウントすることが重要です。  もしオブザベーションが1個以下のペアがあると、相関の値がNAになり、その後の因子分析faや信頼性分析omegaやscoreOverlapが不可能になります。  これは、bigCorに類似しており、相関の各ペアのセルサイズを返します。ある値より少ないカウントを持つ項目ペアを識別するために、pairwiseReportは、'cut'オブザベーションより少ないそれらのペアの名前を報告します。  デフォルトでは、問題のある項目の数だけを報告します。short=FALSEでは、n.obs < cutの項目が表示されます。paiwise countsの特定の表で値 <= n minを持つ特定のペアは、pairwiseZeroで与えられるかもしれません。  相関の欠落の問題を解決するために、pairwiseImputeを用いて欠落した相関をインプットします。この手法は、SAPA項目のスケールベースの構造を利用しています。  ある尺度内の項目（例えば、能力項目と同様の文字数系列）は、別の尺度（例えば、行列推理）の項目と、これら2つの尺度間の項目間平均相関の平均で相関するようにインプットされます。  スケール内およびスケール間の平均相関は pairwiseImpute によって報告され、fix paremeter が指定されている場合は、インプットされた相関行列が返されます。セル・サイズをカウントする時間は、被験者数と項目数の2乗によって線形に変化する。  pairwiseSampleは、このような大きなデータセットのsize=sizeのサンプルを取り、平均、中央値、0.05、0.25、0.5、0.75、0.95分位数などの基本的な記述統計量を返します。   
生データから重回帰や正準相関を計算する方が一般的ですが、相関や共分散の行列から計算することももちろん可能です。  この場合，関数への入力は，x（予測変数），y（基準変数），必要であれば z（共変量）の列番号（または名前）と同様に，正方共分散または相関行列である．入力は， y 変数の集合と x 変数の集合のどちらかで，これは lm の標準的な数式スタイルで記述できる（最後の例を参照）．  この場合、一対またはそれ以上の相互作用（積項）を指定することもできる。  デフォルトでは，積項を見つけるとき，予測変数はゼロ・センタリングされるが（Cohen, Cohen, West and Aiken, 2003），lm の結果または Hayes (2013)で議論されている結果と一致させるために，このオプションをオフ（zero=FALSE）にできる．  除去される共変量は、数式入力で負の符号を付けるか、z 変数を使用して指定します。  共変量を指定するとき，回帰は，偏微分された変数で行われたように行われることに注意すること．  これは、自由度とR2が、パーティション化された変数の回帰を反映することを意味する。(最後の例を参照) 共変量を使用する場合、従属変数だけでなく、独立変数（part=FALSE、デフォルト、これは偏相関を意味する）または独立変数（part=TRUE または part 別名semi-partial correlations）からも取り除く必要があります。  部分相関と偏相関の違いは、共変量の分散がDVとIVの両方から取り除かれるか（偏相関）、IVだけから取り除かれるか（部分相関）です。  回帰の傾きは変わりませんが、部分相関を使うとDVの分散量（したがって標準誤差）が大きくなります。  共変量に偏相関を使用することは，他の変数の効果を解釈するときに，回帰で共変量を使用することと同じである．追加出力は，Cohenの集合相関 (Cohen, 1982)を用いて発見されたR2である．  Cohen (1982) は、2つの変数集合の間の全体的な関係を測定する重相関の多変量一般化である集合相関を導入しました。これは正準相関 (Hotelling, 1936) と 1 - ∏(1-ρ_i^2) の応用で、ρ_i^2 は2乗正準相関です。  集合相関は、2つの変数の集合の間の共有分散（R2）の量である。  3番目の共変量集合を追加すると、集合相関は、多変量R2、部分R2、準部分R2を求めます（準部分と2部分オプションはまだ実装されていません）。 集合相関の詳細は、Cohen (1982)、Cohen (1988)、Cohen, Cohen, Aiken and West (2003)にあります。2つの集合間の R2 は， R2 = 1- |R| /(|Ry| * |Rx|) で，ここで R は x と y 変数の完全な相関行列で，Rx と Ry は関係する2つの集合である．  代替のT2 は，相加分散の割合で，正準の2乗の平均である．  (Cohen et al., 2003), Cramer and Nicewander (1979) も参照。  この平均は、非常に小さな正準相関を含むので、小さすぎる傾向がある。  Cohenらの警告は適切である：「しかし、最終的な分析においては、分析者は、関連性の尺度の選択において、手元の問題に対する実質的かつ方法論的な概念に導かれなければならない。( p613).さらに、2つの集合間の関連性のもう1つの尺度は、2つの集合間の単純な重みなしの相関である。つまり、Ruw=1Rxy1' / (sqrt(1Ryy1'* 1Rxx1'))であり、Rxyは2つの集合間の相関の行列である。  これは各行列の相関の単純な(重み付けされていない)和である。この手法は、線形モデルのロバストな美しさを例証し、xとyの両方が1次元の場合に特に適切で、ベータが符号で異なる項目の場合は、大幅に過小評価されます。αで行われるように、重みなし相関を求めるとき、項目はすべて正符号になるように反転されます。  SAPAプロジェクトでの典型的な使用法は、クラスタリングまたはファクタリング（fa,ICLUST,principalを参照）によって項目の複合を形成し、これらの結果からクラスタを抽出し（factor2cluster）、そしてcluster.corを用いて複合相関行列を形成することです。  この縮小行列の変数は、setCorを使用して複数のR手続きで使用することができます。行列全体は相関が欠損していてもかまいませんが、予測に使用される行列のサブセットの相関は存在しなければなりません。オブザベーションの数が入力されると、従来の信頼区間、統計的有意性、および縮小推定値が報告されます。入力が長方形（正方形ではない）の場合、相関または共分散がデータから求められます。print関数はベータ重みについてt値とp値を報告し、summary関数はベータ重みだけを報告します。  つまり、VIF > 10は、共線性を定義する魔法のカットオフではない。  crossValidationは、setCorまたはbestScalesの結果を取り出し、その重みを別のデータセットに適用するために使用できます。matPlotは、crossValidationの値をプロットするために使用できます（x軸にラベルを指定してmatplotを呼び出すだけです）。matPlotは、凡例を描画し、線種を指定できるように改良されました。setCorLookupは、ベータ重みをソートし、辞書が与えられた場合、項目の内容とともに報告します。matRegは、主にmediateのヘルパー関数ですが、共分散行列と指定されたx、y、z変数を与える一般的な重回帰関数です。その出力は、ベータ、se、t、p、R2です。  matRegは、データ行列では動作せず、数式入力も受け付けません。  matRegはデータ行列では動作せず、数式入力も受け付けません。これは本当にmediateのヘルパー関数にすぎません。
lowerCor は、対角行列の下側を丸めたものを出力し、列名は桁数+3文字に省略されます。  デフォルトでは、変数のペアワイズ削除が使用される。  この行列は、きれいな印刷を行うlowerMatを呼び出します。  必要なのはlowerMatだけなのにlowerCorを呼び出さないことを覚えておくことが重要です！ csはFrank HarrellによるHmiscパッケージのCs関数をそのままコピーしたものです。  Hmiscパッケージのオーバーヘッドを避けるためにpsychに追加された。
CTAモデルの非常に徹底的な議論はRevelle (2008)から入手可能である。cta.15は、Revelle and Condon (2015)の図と分析を作成するために使用されたバージョンです。ctaは最新バージョンで、メルボルン大学のLuke Smillieと共同で開発された学習機能を含んでいます。  基本的な概念は、行動傾向には慣性があるというものであった。  つまり、願望（行動傾向）は満たされるまで持続し、誘因する力がなければ変化しない。  行動をすることの消費的な強さが、今度は行動傾向を弱めると考えられた。  おそらく最も単純な例は、ピザを食べたいという行動傾向（T）であろう。  ピザを食べようとする誘因的な力（F）には、ピザの匂いや見た目、食べてしまえば味や食感などがある。  しかし、ピザを食べる場合、消費力（C）も存在し、これはピザを食べる強さ（gusto）だけでなく、その活動のある一定の消費的価値（c）を反映していると考えられた。  ピザを食べていなくても、ピザ屋にいれば、匂いと視覚的手がかりが組み合わさって、ピザを食べる傾向が高まる。  しかし、ピザを食べてしまえば、消費的効果はもはやゼロではなく、行動傾向の変化は誘因力と消費力の両方の関数となる。  これらは、扇動する力と消費する力が等しいときにバランスをとる。  ピザを食べることの漸近的な強さはこのバランスを反映しており、「設定点」や「比較対象」を必要としない。誘因と消費のラグの問題や決定メカニズムの必要性を避けるために、行動傾向と行動の観点から元のDOAモデルを再パラメータ化することが可能である(Revelle, 1986)。   行動傾向に対して慣性を指定し、常に支配的な行動傾向を表現するという選択ルールを指定するよりも、行動傾向(t)と行動(a)そのものを区別し、慣性特性を持つ傾向だけでなく行動も持つことが有用である。傾向と行動を分離し、両方に慣性特性を与えることで、ラグ・パラメータの必要性を回避し、決定規則を相互抑制のものにすることで、おそらくプロセスが理解しやすくなる。  行動の手がかり（c）を与える環境では、手がかりが行動傾向（t）を強化し、それが行動（a）を強化する。  dt＝Sc-Ca、da＝Et-Ia。  (このモデルの広範な議論についてはRevelle and Condon (2015)を参照)ctaはこのモデルをシミュレートし、アクティビティがキューと傾向の間の接続を強化するような学習パラメータを追加します。  cta.15は、Revelle and Condon (2015)の論文で説明されているctaモデルの状態を表している。
CTAモデルについては、Revelle (2008)で非常に徹底的な議論がなされている。cta.15はRevelle and Condon (2015)の図と分析を作成するために使用されたバージョンである。ctaは最新バージョンであり、メルボルン大学のLuke Smillieと共同で開発された学習機能を含んでいる。  基本的な概念は、行動傾向には慣性があるというものであった。  つまり、願望（行動傾向）は満たされるまで持続し、誘因する力がなければ変化しない。  行動をすることの消費的な強さが、今度は行動傾向を弱めると考えられた。  おそらく最も単純な例は、ピザを食べたいという行動傾向（T）であろう。  ピザを食べようとする誘因的な力（F）には、ピザの匂いや見た目、食べてしまえば味や食感などがある。  しかし、ピザを食べる場合、消費力（C）も存在し、これはピザを食べる強さ（gusto）だけでなく、その活動のある一定の消費的価値（c）を反映していると考えられた。  ピザを食べていなくても、ピザ屋にいれば、匂いと視覚的手がかりが組み合わさって、ピザを食べる傾向が高まる。  しかし、ピザを食べてしまえば、消費的効果はもはやゼロではなく、行動傾向の変化は誘因力と消費力の両方の関数となる。  これらは、扇動する力と消費する力が等しいときにバランスをとる。  ピザを食べることの漸近的な強さはこのバランスを反映しており、「設定点」や「比較対象」を必要としない。誘因と消費のラグの問題や決定メカニズムの必要性を避けるために、行動傾向と行動の観点から元のDOAモデルを再パラメータ化することが可能である(Revelle, 1986)。   行動傾向に対して慣性を指定し、常に支配的な行動傾向を表現するという選択ルールを指定するよりも、行動傾向(t)と行動(a)そのものを区別し、慣性特性を持つ傾向だけでなく行動も持つことが有用である。傾向と行動を分離し、両方に慣性特性を与えることで、ラグ・パラメータの必要性を回避し、決定規則を相互抑制のものにすることで、おそらくプロセスが理解しやすくなる。  行動の手がかり（c）を与える環境では、手がかりが行動傾向（t）を強化し、それが行動（a）を強化する。  dt＝Sc-Ca、da＝Et-Ia。  (このモデルの広範な議論についてはRevelle and Condon (2015)を参照)ctaはこのモデルをシミュレートし、アクティビティがキューと傾向の間の接続を強化するような学習パラメータを追加します。  cta.15は、Revelle and Condon (2015)の論文で説明されているctaモデルの状態を表している。
2つのグループがどのように異なるかを報告する方法はたくさんある。  Cohenのd統計量は、プールされた群内標準偏差で表現された平均値の差だけである。  rは、dの単純な関数である効果量の普遍的な尺度ですが、-1から1に境界があります。t統計量は、単にd * sqrt(n)/2であり、したがってサンプルサイズを反映します。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プーリングされた分散の推定値を与えますが、pooled が FALSE の場合、Welch の補正が適用されます。マハラノビス距離は、個々の ds を結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プーリングされた分散の推定値を与えますが、pooled が FALSE の場合、Welch の補正が適用されます。マハラノビス距離は、個々の ds を結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プールされた推定分散を与えますが、pooledがFALSEの場合、Welchの補正が適用されます。マハラノビス距離は、個々のdsを結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり割合）、d2OVL2（共同分布の重なり割合）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）を使用することで見つけることができます。OVL = 2 φ(-d/2) は重なり割合です（dが大きくなるほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットからの例を参照してください。
2つのグループがどのように異なるかを報告する方法はたくさんあります。  Cohenのd統計量は、プールされたグループ内標準偏差で表現された平均値の差です。  rは効果量の普遍的な尺度で、dの単純な関数であるが、-1～1の境界である。t統計量は単にd * sqrt(n)/2 であり、したがって標本サイズを反映する。   (M2- M1)/Sp ここで Sp はプールされた標準偏差。  √{((n1-1)*s1^2 + (n2-1)* s2^2)/{N}.  }  Cohens dはプールされた平方和の除数としてNを使う。  Hedges gはN-2を用いる。  Cohensのdの信頼区間は、dをtに変換し、tの信頼区間を求め、それをdsに変換することで求めることができる。  cohen.dの結果はerror.dots関数を使って表示することができます。  これには、辞書で提供されたラベルが含まれる。  0（1標本の場合）との比較のためにcohen.d.ciを使用して）信頼区間を求める場合、n1を指定します。  これはd = t/sqrt(n1)をもたらしますが、2つの標本間の差の場合はd = 2*t/sqrt(n) (標本サイズが等しい場合 n = n1+ n2)、または標本サイズが等しくない場合はd = t/sqrt(1/n1 + 1/n2) となります。7/14/21まで、私はtとしたがってp値を推定するために合計nを使っていました。  問い合わせ（ニュース参照）に応えて、実際の標本サイズns（n1とn2）を使用し、ヘッジg値に基づいてtを求めることに切り替えました。  これは、t.testでvar.equal = TRUEオプションで報告されたt値を生成します。報告された様々な信頼区間は正規理論に基づいており、慎重に解釈されるべきであるというコメントは、おそらく有益でしょう。cohen.d.byは、group2で定義されたデータの各サブセットについて、グループのCohenのdを求めます。  出力の要約は、各グループの各変数のd値の簡略化されたリストを生成する。  d.robustはAlgina et al. 2005)に従い、トリム平均(trim =.2)とWinsorize分散(trim =.2)を求めます。  m2tは、2つのグループの平均、標準偏差、標本サイズが与えられたときのStudentのt.t.検定を報告します。  これは、推定値は提供されているが生データが入手できない統計量をチェックするときに便利である。  デフォルトでは、プーリングされた分散の推定値を与えますが、pooled が FALSE の場合、Welch の補正が適用されます。マハラノビス距離は、個々の ds を結合し、それらのユニークな寄与度で重み付けします：  D=√{d'R^{-1}d}。デフォルトでは、cohen.dは2つのグループ間のマハラノビス距離を求めます（複数のDVがある場合）。これはすべてのDVの相関を求める必要があり、いくつかのペアが存在しないため、その行列が可逆でない場合は失敗することがあります。  したがって，MD=FALSEに設定すると，マハラノビスの計算ができなくなります．Marco del Giudice (2019)は，さまざまな重複係数の観点からdとMdを解釈する方法について議論した非常に有用な論文を持っています．これらは、d2OVL（1つの分布の重なり率）、d2OVL2（共同分布の重なり率）、d2CL（共通言語の効果量）、d2U3（上位群の割合が下位群の中央値を超える）の使用によって見つけることができます。OVL = 2 φ(-d/2) は重なり率です（dが大きいほど小さくなります）。ここで Phi は正規分布の累積密度関数である.OVL_2 = OVL/(2-OVL)U3U_3 = φ(d).The Common Language Effect size CL = φ(d * √(2) )最後の2つは、(abs (d))で大きくなる。  CohenのdとMahalanobis Dのグラフ表示については、scatterHistの例、またはpsychTools::GERASデータセットの例を参照してください。
バイオリン・プロットを用いてデータを記述する。alphaを変更して陰影を変更する。  比較的小さなデータセット（< 500-1000）の場合、実際のデータ点を表示することは有益です。これはdots=TRUEオプションで行います。ジッター値は任意に0.05に設定されますが、これを大きくすると（例えば0.1や0.2）、より多くのポイントが表示されます。
基本的なデータ分析では、基本的な記述統計量を得ることが重要です。summaryやHmisc::describeのような手続きはそれを行います。  psychパッケージのdescribe関数は、心理測定や心理学の研究で最も頻繁に要求される統計量を生成し、読みやすいdata.frameで生成することを目的としています。数式モードでグループ化変数が呼び出された場合、その処理に対して describeBy も呼び出されます。範囲統計量(min, max, range)はコーディングエラーを検出するためのデータチェックに最も有用であり、データの初期分析で発見されるべきである。  describeは行列と同様にデータフレームでも機能しますが、データフレームの場合、記述統計量は意味のある変数についてのみ報告される（つまり、英数字データでは報告されない）ことを理解することが重要です。チェック・オプションがTRUEの場合、カテゴリー変数または論理変数は数値に変換され、記述される。  これらの変数は、行名に * が付きます。  これは多少遅くなります。カテゴリや因子の場合、数値の順序は必ずしも期待されたものではないことに注意。  典型的な研究では、クリップボードからデータを読み込み(read.clipboard)、相関のsplomプロットを表示し(pairs.panel)、そしてデータを記述します。  歪度（skew）と尖度（kurtosis）を求めるとき、3つの異なるオプションが利用できます。  これらは、e1071パッケージの歪度（skewness）と尖度（kurtosis）で利用可能な選択肢と一致しています（それぞれの利点についてはJoanes and Gill (1998)を参照してください）。m_r = [sum(X- mx)^r]/n と定義すると、タイプ1は g_1 = m_3/(m_2)^{3/2} と g_2 = m_4/(m_2)^2 -3 で歪度と尖度を求めます。 タイプ2は G1 = g1 * √{n *(n-1)}/(n-2) と G2 = (n-1)*[(n+1)g2 +6]/((n-2)(n-3)) です。  タイプ 3 は b1 = [(n-1)/n]^{3/2} m_3/m_2^{3/2} and b2 = [(n-1)/n]^{3/2} m_4/m_2^2)である。追加のヘルパー関数 describeData は、データ配列をスキャンして、データがすべて数値か、論理/階乗か、カテゴリーかを報告するだけである。  これは、非常に大きなデータ集合の記述統計量を得ようとする場合に実行すると便利なチェックで、速度を向上させるためにチェックオプションはFALSEになります。  さらに高速なデータの概要は、describeFastで、総ケース数、完全ケース数、数値変数数、因子数を報告します。fast=TRUE オプションは、すべての統計量を求めないことにより、より大きな問題で約50%のスピードアップにつながります（注意参照）異なるグループのデータを記述するには、 describeBy を参照するか、数式モードでグループ化変数を指定します（例を参照）。
複数の異なるグループ化変数の記述統計量を得るには、そのグループがリストであることを確認してください。  2020年7月より、グループ化変数は数式モードで指定することができるようになりました（例を参照してください）。  詳細は describe を参照。別の関数（statsBy）は、各グループの平均、n、標準偏差のリストを返す。  これは、cor.wtを使用してグループ平均の重み付き相関を求める場合に特に有用である。さらに重要なことは、相関の適切な群内および群間分解を行うことである。データを平均差に変換し、グループ内の標準偏差をプールする。  cohen.d 統計量と多変量汎化（Mahalanobis D）を返します。
複数の異なるグループ化変数の記述統計量を得るには、group がリストであることを確認してください。  2020年7月現在、グループ化変数は数式モードで指定することができます（例を参照してください）。  詳細は describe を参照。別の関数（statsBy）は、各グループの平均、n、標準偏差のリストを返す。  これは、cor.wtを使用してグループ平均の重み付き相関を求める場合に特に有用である。さらに重要なことは、相関の適切な群内および群間分解を行うことである。データを平均差に変換し、グループ内の標準偏差をプールする。  cohen.d 統計量と多変量一般化（Mahalanobis D）を返します。
基本的なデータ分析では、基本的な記述統計量を得ることが重要です。summaryやHmisc::describeのような手続きはそれを行います。  psychパッケージのdescribe関数は、心理測定や心理学の研究で最も頻繁に要求される統計量を生成し、読みやすいdata.frameで生成することを目的としています。グループ化変数が数式モードで呼び出された場合、その処理に対して describeBy も呼び出されます。範囲統計量(min, max, range)はコーディングエラーを検出するためのデータチェックに最も有用であり、データの初期分析で発見されるべきである。  describeは行列と同様にデータフレームでも機能しますが、データフレームの場合、記述統計量は意味のある変数についてのみ報告される（つまり、英数字データでは報告されない）ことを理解することが重要です。チェック・オプションがTRUEの場合、カテゴリー変数または論理変数は数値に変換され、記述される。  これらの変数は、行名に * が付きます。  これは多少遅くなります。カテゴリや因子の場合、数値の順序は必ずしも期待されるものではないことに注意。  典型的な研究では、クリップボードからデータを読み込み(read.clipboard)、相関のsplomプロットを表示し(pairs.panel)、そしてデータを記述します。  歪度（skew）と尖度（kurtosis）を求めるとき、3つの異なるオプションが利用できます。  これらはe1071パッケージの歪度（skewness）と尖度（kurtosis）で利用可能な選択肢と一致しています（それぞれの利点についてはJoanes and Gill (1998)を参照してください）。m_r = [sum(X- mx)^r]/n と定義すると、タイプ1は g_1 = m_3/(m_2)^{3/2} と g_2 = m_4/(m_2)^2 -3 で歪度と尖度を求めます。 タイプ2は G1 = g1 * √{n *(n-1)}/(n-2) と G2 = (n-1)*[(n+1)g2 +6]/((n-2)(n-3)) です。  タイプ 3 は b1 = [(n-1)/n]^{3/2} m_3/m_2^{3/2} and b2 = [(n-1)/n]^{3/2} m_4/m_2^2)である。追加のヘルパー関数 describeData はデータ配列をスキャンし、データが全て数値か、論理/階乗か、カテゴリーかをレポートするだけである。  これは、非常に大きなデータ集合の記述統計量を得ようとする場合に実行すると便利なチェックで、速度を向上させるためにチェックオプションはFALSEになります。  さらに高速なデータの概要は、describeFastで、総ケース数、完全ケース数、数値変数数、因子数を報告します。fast=TRUEオプションは、すべての統計量を求めないことにより、より大きな問題で約50%のスピードアップにつながります（注意参照）異なるグループのデータを記述するには、describeByを参照するか、数式モードでグループ化変数を指定します（例を参照）。
基本的なデータ分析では、基本的な記述統計量を得ることが重要です。summaryやHmisc::describeのようなプロシージャがそれを行います。  psychパッケージのdescribe関数は、心理測定や心理学の研究で最も頻繁に要求される統計量を生成し、読みやすいdata.frameで生成することを目的としています。グループ化変数が数式モードで呼び出された場合、その処理に対して describeBy も呼び出されます。範囲統計量(min, max, range)はコーディングエラーを検出するためのデータチェックに最も有用であり、データの初期分析で発見されるべきである。  describeは行列と同様にデータフレームでも機能しますが、データフレームの場合、記述統計量は意味のある変数についてのみ報告される（つまり、英数字データでは報告されない）ことを理解することが重要です。チェック・オプションがTRUEの場合、カテゴリー変数または論理変数は数値に変換され、記述される。  これらの変数は、行名に * が付きます。  これは多少遅くなります。カテゴリや因子の場合、数値の順序は必ずしも期待されるものではないことに注意。  典型的な研究では、クリップボードからデータを読み込み(read.clipboard)、相関のsplomプロットを表示し(pairs.panel)、そしてデータを記述します。  歪度（skew）と尖度（kurtosis）を求めるとき、3つの異なるオプションが利用できます。  これらは、e1071パッケージの歪度（skewness）と尖度（kurtosis）で利用可能な選択肢と一致しています（それぞれの利点についてはJoanes and Gill (1998)を参照してください）。m_r = [sum(X- mx)^r]/n と定義すると、タイプ1は g_1 = m_3/(m_2)^{3/2} と g_2 = m_4/(m_2)^2 -3 で歪度と尖度を求めます。 タイプ2は G1 = g1 * √{n *(n-1)}/(n-2) と G2 = (n-1)*[(n+1)g2 +6]/((n-2)(n-3)) です。  タイプ 3 は b1 = [(n-1)/n]^{3/2} m_3/m_2^{3/2} and b2 = [(n-1)/n]^{3/2} m_4/m_2^2)である。追加のヘルパー関数 describeData はデータ配列をスキャンし、データが全て数値か、論理/階乗か、カテゴリーかをレポートするだけである。  これは、非常に大きなデータ集合の記述統計量を得ようとする場合に実行すると便利なチェックで、速度を向上させるためにチェックオプションはFALSEになります。  さらに高速なデータの概要は、describeFastで、総ケース数、完全ケース数、数値変数数、因子数を報告します。fast=TRUEオプションは、すべての統計量を求めないことにより、より大きな問題で約50%のスピードアップにつながります（注意参照）異なるグループのデータを記述するには、describeByを参照するか、数式モードでグループ化変数を指定します（例参照）。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールしようとする際に生じる不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールしようとする際に生じる不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールしようとする際に生じる不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールしようとする際に生じる不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、因子不定性の問題を示すために、（オプションで）矢印を辺と中心とする円錐を描画します。
diagram関数は、フィット入力のクラスに応じて、fa.diagram、omega.diagram、ICLUST.diagram、lavaan.diagram、またはbassAckward.diagramを呼び出します。  残りの関数は、fa.diagram、structure.diagram、omega.diagram、ICLUST.diagram、het.diagramで使用されるグラフィック・プリミティブです。これらの関数は、テキストを囲む矩形、楕円、三角形を作成し、それらを直線または曲線の矢印に接続します。描画を高速化するために、dia.rectとdia.arrowは実際の描画を抑制し、描画する位置と値を返すことができます。  これらの値は、textやrectから行列入力で直接呼び出すことができる。これは、多くの変数を処理する際のスピードアップにつながります。multi.rect、multi.self、multi.arrow、multi.curved.arrow関数は、適切なプリミティブから保存された出力を受け取り、それらを一度に描画します。各図形（楕円、矩形、三角形）には、矢印をつなぐのに使える左右、上下、中心の座標があります。曲線は両頭の矢印です。   デフォルトでは、ある位置から別の位置へと進み、左右（上下に進む場合）または上下（左から右に進む場合）にカーブします。  ヘルパー関数は、Rgraphvizとgraphvizをインストールする際に発生する不具合を回避するために開発されました。 これらの関数は、fa.diagram,het.diagramの中核を成しています。これらの関数が改良されるにつれて、より良いドキュメントが追加される予定です。  dia.coneは、（オプションで）矢印を辺と中心とする円錐を描き、因子の不確定性の問題を示します。
"多くの尺度は、開発者やユーザーによって、主に1つの潜在変数の尺度であると仮定されています。尺度が測定の効果指標モデルに適合することも仮定されている場合（心理アセスメントではほとんど常にそうです）、その尺度の内部構造に関する証拠でそのような解釈をサポートすることが重要です。特に、そのような尺度の内部構造に関連する2つの特性を調べることが重要です。最初の特性は、尺度を形成するすべての指標が共通に潜在変数を測定しているかどうかに関係します。2番目の内部構造特性は、（指標の合計または平均から得られる）尺度スコアにおける分散のうち、すべての指標に共通するこの潜在変数が占める割合に関係します（Cronbach, 1951; McDonald, 1999; Revelle, 1979）。すなわち，効果指標尺度が，尺度を形成するすべての指標に共通する1つの潜在変数の測定が主であるなら，その潜在変数が尺度得点の分散の大部分を占めるはずである．別の言い方をすると，この分散比率は，指標のサンプリングから生じるすべての指標に共通する潜在変数での個人の立ち位置を推定するとき（すなわち，Lord, 1956の用語を使用すると，タイプ2またはタイプ12サンプリングのいずれかを扱うとき），サンプリングの変動に関する重要な情報を提供する．つまり、この分散比率は、尺度スコアと、尺度指標がサブセットである指標の無限の宇宙のすべての指標に共通する潜在変数との間の相関の2乗として解釈できます。さらに別の言い方をすると、この分散比率は信頼性係数としても有効性係数としても重要です。これは信頼性の問題で、この分散比が大きければ大きいほど、個人の観察された尺度スコアに基づいて、すべての尺度の指標に共通する潜在変数における個人の相対的な地位をより正確に予測できるからです。同時に、構成概念の妥当性は尺度の内部構造を包含しているため、この分散比は尺度の構成概念の妥当性にも影響します。(Zinbarg, Yovel, Revelle, and McDonald, 2006).McDonaldは、テストの一般的な因子飽和の推定値として係数ω_h (ω_h)を提唱しています。  Zinbarg, Revelle, Yovel and Li (2005) https://personality-project.org/revelle/publications/zinbarg.revelle.pmet.05.pdf は，McDonaldの ω_hをCronbachの αとRevelleの βと比較して， ω_hが最良の推定であると結論している．(Zinbarg et al., 2006とRevelle and Zinbarg (2009)も参照）。   ω_hを求める1つの方法は、元のデータ集合の因子分析を行い、因子を斜めに回転させ、その相関行列を因子化し、Schmid-Leiman (schmid)変換を行って一般的な因子負荷量を求め、それからω_hを求めることです。  omega_hは、因子の推定方法によって異なります。  4つのオプションが利用可能で、3つはfa関数を使用しますが、ファクタリングの方法が異なります：デフォルトはminres因子解を行い、fm="pa "は主軸因子分析を行い、fm="mle "は最尤解を行い、fm="pc "は(principal)を使用して主成分分析を行います。  能力項目については、すべての項目が一般因子に正の負荷量を持つことが一般的です。  しかし、非認知的項目の場合、ある項目は正に得点され、ある項目は負に得点されることがよくあります。  おそらく、キー・ベクトルを指定することで、項目がどの方向に得点されるかを指定する方がよいですが、 flip =TRUE (デフォルト)の場合、項目は一般因子に正の負荷量を持つように反転されます。  キーは scoreItems 関数を使用してスコアを見つけられるように報告されます。  このように項目を恣意的に反転させると、一般因子を過大評価する可能性があります。(シミュレートされたcircumplexの例を参照) ω_hの代替であるベータは，最悪のスプリット・ハーフ信頼性として定義される(Revelle, 1979)．  これはICLUST（元々はメインフレーム用に開発され、Fortranで書かれた階層クラスタリング・アルゴリズムで、現在ではpsychパッケージの一部となっている。  (ICLUSTアルゴリズムが尺度構築に有用である理由については、Cooksey and Soutar, 2005を参照）。ω関数は、ω_h係数を推定するために探索的因子分析を使用します。  ω_hを推定するために選ばれた手法に関係なく、耳を傾けるべき推奨は、ω_hを推定する前に、推定された一般因子負荷量のパターンを常に調査することである」ということを覚えておくことが重要です。このような検査は、EFAの文脈でも実施できる、尺度のすべての指標に共通する潜在変数があるという仮定の非公式なテストを構成します。もし負荷量が指標の比較的小さなサブセットでのみ顕著であったなら、これは共分散行列の根底に真の一般因子がないことを示唆します。このような非公式な仮定テストがあるだけで、ここで報告されたシミュレーションで時折生成される誤解を招くω_h推定値を誤って解釈する可能性から大いに保護することができたであろう。(Zinbargら, 2006, p 137).2つのグループ因子のうちの1つだけを反映したω推定値の問題の簡単な実証は、最後の例で見つけることができます。  ω解の質を反映する診断統計量は、他の固有値に対するg因子固有値の相対的な大きさの比較、一般因子分散（p2）である各項目の共通分散のパーセンテージ、p2の平均、およびp2の標準偏差を含みます。  omega_hは、3つ以上のサブファクターが抽出された場合のみ一意に定義されますが、2因子解を持つことが望まれることもあります。  デフォルトでは、2つのサブファクターが等しい負荷量を持つものとしてschmid抽出を強制することで、これを実現します。  この条件には3つのオプションがあります：2つの低次因子間の一般因子の負荷量を "等しい "と設定し、これはsqrt(因子間の斜め相関)になるか、または "第1 "か "第2 "に設定します。モデルが本当によく定義されていないことを示唆するメッセージが発行されます。この解決法は、Zinbarg et al., 2007で議論されている。  omegaでこれを行うには、callにoption="first" または option="second "を追加します。明らかに1因子解では意味がありませんが、もちろん、第1（そして唯一の）因子への負荷量の合計を求め、それらを2乗し、行列全体の分散と比較することは可能です。  ω_hに加えて、McDonaldの係数のもう1つはω_tである。  これはテストの全信頼性の推定値です。マクドナルドのω_tは、Guttmanの λ_6, guttmanに似ていますが、e_j^2を求めるために因子分析からの一意性の推定値（u^2）を用います。これは、テスト得点の分散V_xを4つの部分に分解することに基づきます：一般因子による分散、(vec{g})、グループ因子の集合による分散、(vec{f})（いくつかの項目には共通するが、すべての項目には共通しない因子）、各項目に固有な固有因子、(vec{s})、そしてランダム誤差の(vec{e})です。  (特異的分散は、テストが少なくとも2回行われない限り、無作為誤差と区別できないので、これらの両方を誤差にまとめるものもある)。x = cg + Af + Ds + et とすると、一般因子とグループ因子に基づく item_j の共同性 h_j^2 = c_j^2 + sum(f_ij^2)と、項目の固有分散 u_j^2 = σ_j^2 (1-h_j^2)は、テストの信頼性を推定するために使用できます。すなわち、h_j^2が項目_jの共同性で、一般因子とグループ因子に基づくとすると、標準化項目については、e_j^2 = 1 - h_j^2 とω_t = (1 cc' 1 + 1 AA' 1')/(V_x)h_j^2 ≥q r_{smc}^2, ω_t ≥q λ_6.ここでMcDonald, 1978の2つのω係数とMcDonald, 1999の式6.20aのω_tとω_hを区別することが重要である。  ω_h = (1 cc' 1')/VxAnother estimate is the omega for an infinite length test with a similar structure with the observed test (ωH漸近)．  これは ω_{limit} = (1 cc' 1')/(1 cc' 1' + 1 AA' 1') によって求められる。Steve Reiseの提案に従い，説明される共通分散（ECV）も報告される．  これは，すべての固有値の合計に対する一般因子の固有値の比率である．  omegaへの入力は，相関行列または生データ行列，または因子間相関（Phi）行列を持つ因子パターン行列である．  omegaは、Schmid-Leiman変換を使用する探索的因子分析関数です。omegaSemは、最初にomegaを呼び出し、Schmid-Leiman解を受け取り、これを確認的semモデルに変換し、確認的モデルを実施するためにsemパッケージを呼び出します。行儀のよい問題では、EFA解とCFA解は実質的に同じになりますが、CFA解は必ずしもEFA解と一致しません。特に、推定R^2が1を超えることがあります（この例は、Harman 24の認知能力問題です）。さらに、すべてのEFA解が実行可能なCFA解を生成するわけではありません。  モデル仕様の誤りは、非常に奇妙なCFA推定値につながります。オメガに因子パターン行列と関連する因子間相関を与えることも可能です。  この場合、分析はこれらの行列に対して行われます。  これは、探索的EFAの解や回転オプションに満足できず、どうにか代替案を考え出した場合に特に便利です。(たとえば、指定されたm値でカイザー正規化されたPromax解を用いて、fm='pa'を用いたEFAを行いたい場合があります。) omegaFromSem は、 sem モデルからの出力を取り、それを用いて ω_h を求めます。  変数と因子の多重R^2によって求められる因子不確定性の推定値は、EFAモデルによって求められるものとは一致しません。  特に，推定 R^2 は，1 を超えることがある（この例は，Harman 24 の認知能力の問題である）．Ωの概念は，全体的なテストだけでなく，個々の因子にも適用できる．オメガの典型的な使用法は、インベントリ全体の下位尺度を識別することである。  その変動の一部は、インベントリの一般的な因子によるものであり、一部は各下位尺度の特定の分散によるものである。  したがって，いくつかの異なるオメガの推定を見つけることができる：各サブファクターで識別された項目の分散の何パーセントが，実際に一般因子によるものなのか．  どの分散が共通であるが、サブファクターに固有であるか、そして、各サブファクターの合計信頼できる分散は何か。   これらの結果は，omega.groupオブジェクトと通常出力の最後の数行で報告される．最後に，まだテスト中であるが，Waller (2017)から適応されたomegaDirectである．  これは階層因数分解(directSl)を行わず、Schmid-Leimanのような解への直接回転です。  この回転はオメガの観点から解釈される。  これは、代替手順omegaやomegaSemとの比較を可能にするために、ここに含まれています。  予備的な分析によると、一般因子がない場合には不適切な解を生成することが示唆されている。omegaから返される様々なオブジェクトは以下の通りです：
合同は、行列によって定義され、原点を基準とするベクトルのペアの余弦です。  2つの行列 F1 と F2 に対して、一致度の尺度 phi は phi = sum(F1 F2)/sqrt(sum(F1^2) sum(F2^2)) 一致度をそれぞれの値の相関と比較するのは面白い練習です。合同は生のクロス積に基づくが、相関は中心化されたクロス積に基づく。つまり，項目の相関は，各列の平均荷重に基づくベクトルの余弦である． phi = sum((F1-a)(F2-b))/sqrt(sum((F1-a)^2) sum((F2-b)^2)) .合同係数については， a = b = 0. 相関については， a = 平均 F1, b = 平均 F2.通常，すべての因子負荷行列は完全でなければならない（欠落した負荷量がない）．  データがゼロ・センターである場合、これは相関であり、データが尺度の中点（M）を中心とする場合、これはコーエンの類似度係数である。  例を参照。Mが指定されていない場合は、xとyの項目の中点として求められます。cohen.profileは、Mを中心としたデータに一致関数を適用します。Mは指定することもできますし、データから求めることもできます。最後の例はCohen (1969)からの引用です。distanceはrの関数として一般化された距離を求めます。city block (r=1)、Euclidean (r=2)、weighted towards maximimum (r >2)があります。
テトラコリック相関の図解。教育目的に使用される。  デフォルト値は、相関が0.5で、1と1でカットされている。  このコードは、ベース・グラフィックスを使った複雑なグラフィックスのレイアウト機能の使い方のデモンストレーションでもある。
テトラコリック相関のグラフィック・デモンストレーション。教育目的に使用。  デフォルト値は相関0.5で、1と1でカットしています。  このコードは、ベース・グラフィックスを使った複雑なグラフィックスのレイアウト機能の使い方のデモンストレーションでもある。
dummy.codeは、これらのカテゴリーをn個の異なるダミーコード変数に変換する、もしダミー・コード化された変数を予測変数として使用する場合、n-1変数を使用することを忘れないでください。もしgroupが指定されると、groupに含まれるxのすべての値に1が与えられ、そうでない場合は0が与えられます。この例では、喫煙のダミーコードを形成している)
NA
NA
楕円の寸法は、x変数とy変数の間の相関から計算され、sqrt(1+r) および sqrt(1-r) としてスケーリングされる。そして，それらは size[1] および size[2] 標準偏差単位としてスケーリングされる．   95%および99%の信頼度でスケーリングするには、c(1.64,2.32) を使用します。
これらの関数の中で最も有用なものは、Jennrich and Bentler (2011)によって導入された斜めバイファクター回転を実装したbiquartiminでしょう。2番目はTargetQで、ターゲットのNA値の欠損を許容します。次に優れているのは、直交の場合のbifactorである。  これらはいずれもGPArotationには（まだ）実装されていないようです。faRotateは、ここで追加されたものと同様に、様々なGPArotation関数を呼び出す便利な方法に過ぎません。biquartiminとbifactorの違いは、後者がJennrich and Bentler (2011)で文書化されている直交ケースであるということだけです。  Holzingerの24認知変数に対するbifactorの出力は、JennrichとBentlerの出力と一致し、fm="mle "が使用され、JennrichとBentlerの解が共分散から相関に再スケーリングされた場合のChenらの問題に対する出力も一致します。Promaxは、stats::promax関数を非常に直接的に適応したものです。  varimin は、Suitbert Ertl (2013)によって提案されたvarimin 基準を実装しています。  varimax 基準を最大化するのではなく、最小化する。  さらに、これらの関数は、factanal、fa、または以前の（factor.pa、factor.minres、またはprincipal）関数からの出力を受け取り、分析のために負荷行列だけを選択します。equamaxは、GPArotationのcFT関数（回転のCrawford Fergusonファミリー用）を呼び出すだけです。TargetQはMichael Browneのアルゴリズムを実装したもので、NA値の指定が可能です。Targetの入力はリストである（例参照）。  因子を定義する際に、因子が何でないかを指定することがいかに強力に働くかは興味深い。  target.rot関数は、Michael Browneの関数を適応したもので、任意のターゲット行列に対して回転を行うことができます。  Pat Shroutの提案によるものです。target.rotのデフォルトは、独立クラスター構造（すべての項目が、最も負荷の高いグループに割り当てられる）に回転することです。target.rotは、線形従属性を持つターゲット（たとえば、すべての変数にg負荷とグループ因子がある純粋な2因子モデル）は扱いません。
平均 +/- 信頼区間の描画は、実験結果を報告するときによく使われる関数である。デフォルトでは，信頼区間はt分布の1.96標準誤差である．  within=TRUE の場合、エラー・バーは、分散を(1-smc)の係数で減らすことによって、他の変数との相関を補正される。  これは，変数間の比較を可能にする．エラーバーは，通常， describe 関数を用いてデータから計算される．  代わりに、値、平均、se の列見出しを持つ統計量の行列が提供された場合、それらの値がプロットに使用されます（stats オプションを使用）。  統計量の行列に n が含まれている場合，分布は n-1 df の t 分布で描画される．  nが省略（NULL）またはNAの場合、分布は正規分布になります。  sdがTRUEである場合、エラーバーはアルファと標準誤差の関数ではなく、平均からの1標準偏差を表します。別の関数からの統計量でデータをプロットする場合については、最後の2つの例を参照してください。また、error.bars.tabは、表データを受け取り、行、列、または全体のパーセンテージに変換し、（sqrt(pq/N)に基づく）等価な標準誤差とともにパーセンテージとしてプロットします。2018年8月、error.barsとerror.bars.byの機能が統合され、グループが指定された場合、エラーバーがグループごとに行われるようになりました。  さらに、x変数がDV ~ IVの形の式の場合、error.bars.byがプロットを行うために呼び出されます。
平均±信頼区間の描画は、実験結果を報告するときによく使われる機能である。デフォルトでは、信頼区間は1.96標準誤差（t分布で調整）である。2018年8月に改善/修正され、数式入力が可能になり（例を参照）、複数のグループをより適切に扱えるようになりました。グループ化変数のラベル付けを改善する要望を受けて、v.labオプションが棒グラフだけでなく折れ線グラフにも実装されました。  複数のグループ化変数を使用する場合、ラベルは最もレベルの高い変数（最初のものであるべき）のものであることに注意してください。この関数は、もともとは単なるerror.barsのラッパーでしたが、グループをx軸として、または別々の線として整理できるように書かれました。このタイプのプロットは情報量が少ないと多くの人が感じており（例えば、https://biostat.mc.vanderbilt.edu/DynamitePlots ）、より標準的なドットプロットを推奨している。特に、棒グラフを描くことを選択した場合、開始値は0.0であり、ymパラメータを設定すると、0がymの範囲に含まれていない場合、厄介な結果になる可能性があることに注意してください。  この場合、本当に棒グラフを描画するつもりだったのですか？3つまでのグループの場合、色はデフォルトで "black"、"blue"、"red "です。色を半透明にするには、濃度を負の数に設定してください。  最後の例を参照。
平均 +/- 信頼区間を描くことは、実験結果を報告するときによく使われる機能である。デフォルトでは、信頼区間はt分布の1.96標準誤差である。  within=TRUE の場合、エラー・バーは、分散を(1-smc)の係数で減らすことによって、他の変数との相関を補正される。  これは，変数間の比較を可能にする．エラーバーは，通常， describe 関数を用いてデータから計算される．  代わりに、値、平均、se の列見出しを持つ統計量の行列が提供された場合、それらの値がプロットに使用されます（stats オプションを使用）。  統計量の行列に n が含まれている場合，分布は n-1 df の t 分布で描画される．  nが省略（NULL）またはNAの場合、分布は正規分布になります。  sdがTRUEである場合、エラーバーはアルファと標準誤差の関数ではなく、平均からの1標準偏差を表します。別の関数からの統計量でデータをプロットする場合については、最後の2つの例を参照してください。また、error.bars.tabは、表データを受け取り、行、列、または全体のパーセンテージに変換し、（sqrt(pq/N)に基づく）等価な標準誤差とともにパーセンテージとしてプロットします。2018年8月、error.barsとerror.bars.byの機能が統合され、グループが指定された場合、エラーバーがグループごとに行われるようになりました。  さらに、x変数がDV ~ IVの形の数式である場合、error.bars.byがプロットを行うために呼び出されます。
肯定的および否定的な感情に対する気分操作の効果を記述する2方向のエラー・バーの例については、https://personality-project.org/revelle/publications/happy-sad-appendix/FIG.A-6.pdfThe を参照。2番目の例は、グループ化変数が動的に見つけられる複数の変数について、エラー・クロスがどのように行われるかを示す。errorCircles の例は、これを1ステップで行う方法を示しています。
複数のプロットを高速化するために、この関数は前の実行の出力から作業することができます。  dotplotにerror.dotsプロットを追加するためにadd=TRUEオプションを使用する場合、dotplotの変数の順序は最後から最初になることに注意してください（実際には、最高のy値は、ベクトルの最後の値です）また、プロットが正しく並ぶようにxlimパラメータを設定する必要があることに注意してください。
実験操作の効果や複数のグループの関係を可視化する場合、それらの平均と信頼領域を2次元空間にプロットするのが便利である。  囲む円（楕円）の直径は，1/sqrt(N) * すべての変数の最大標準誤差としてスケールする．  つまり，楕円の面積は標本サイズを反映する．  
faで実装されている因子分析は，変数の集合の共分散（相関）構造を，潜在変数または「因子」の小さな集合で要約しようとする．  この解は，元の解を変更することなく，より多くの変数を持つより大きな空間に「拡張」することができる（fa.extension.F因子を参照）．  同様に，2番目の変数集合（Y 集合）の因子は，元の（X ）集合に拡張することができる．  そして，潜在変数のこれらの2つの集合は，探索的構造方程式モデルのために相関させることができる．  (これは、sem、lavaan、Mxのような伝統的な構造方程式モデリング・パッケージを用いた確証的因子モデル（CFA）ではなく、探索的因子分析（EFA）に基づくので、探索的です）出力は、faを用いた通常のEFAと非常に似ているように見えますが、実際には、2つの独立した因子分析（XとYのセット）が相互に拡張されます。  つまり、XとYのセットからの負荷量と構造行列が単に組み合わされ、2つの因子セット間の相関が発見される。バッテリ間因子分析は、2つのテストのバッテリに共通する因子を比較する方法として、Tucker (1958) によって開発された。   (現在開発中で、まだ完成していない）。いくつかの簡単な線形代数を用いて，変数の2つのセットの間の相互相関の因子を見つけるのは簡単である．  これは共分散性の推定を必要とせず、正準相関の手順と高度に関連している。  esemと系列間アプローチの違いは，まずX集合を因子分析し，次にそれらの因子をY集合の因子に関係づけることである．  一方，系列間因子分析は，両方の集合を結びつける因子の1つの集合を見つけようとするが，両方の集合を一緒に因数分解することとは異なる．  
faに実装されている因子分析は，変数の集合の共分散（相関）構造を，潜在変数または「因子」の小さな集合で要約しようとするものである．  この解は、元の解を変更することなく、より多くの変数を持つより大きな空間に「拡張」することができる（fa.extension.F因子を参照）。  同様に，2番目の変数集合（Y 集合）の因子は，元の（X ）集合に拡張することができる．  そして，潜在変数のこれらの2つの集合は，探索的構造方程式モデルのために相関させることができる．  (これは、sem、lavaan、Mxのような伝統的な構造方程式モデリング・パッケージを用いた確証的因子モデル（CFA）ではなく、探索的因子分析（EFA）に基づくので、探索的です）出力は、faを用いた通常のEFAと非常に似ているように見えますが、実際には、2つの独立した因子分析（XとYのセット）が相互に拡張されます。  つまり、XとYのセットからの負荷量と構造行列が単に組み合わされ、2つの因子セット間の相関が発見される。電池間因子分析は、2つのテストの電池に共通する因子を比較する方法として、Tucker (1958) によって開発された。   (現在開発中で、まだ完成していない）。いくつかの簡単な線形代数を用いて，変数の2つのセットの間の相互相関の因子を見つけるのは簡単である．  これは共分散性の推定を必要とせず、正準相関の手順と高度に関連している。  esemと系列間アプローチの違いは，まずX集合を因子分析し，次にそれらの因子をY集合の因子に関係づけることである．  一方，系列間因子分析は，両方の集合を結びつける因子の1つの集合を見つけようとするが，両方の集合を一緒に因数分解することとは異なる．  
パス図の表現は，確認的因子分析では標準的になっているが，探索的因子分析ではまだ一般的ではない．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．デフォルトでは，潜在変数から観察変数に矢印が来る．  これはもちろん因子モデルです。  しかし、描画されるオブジェクトのクラスが'principal'であれば、矢印の方向を逆にすると、'潜在'変数はもはや潜在ではなく、ボックスとして表示されます。クラスター・モデルの場合、デフォルトでは因子として扱われますが、ic =TRUEの場合、成分モデルとして扱われます。fa.diagramはRgraphvizを使用せず、好ましい関数です。fa.graphは、Rgraphvizを使用せず、この機能を優先します。fa.graphは、外部グラフィックス・プログラムで使用するドット・コードを生成します。gパラメータにTRUEを指定することで、階層（2因子）モデルを描画することができます。  これにより、二因子構造を持つさまざまな因子変換をグラフィカルに表示することができます（例えば、bifactorやbiquartimin。  これらの構造を見つける別の方法についてはomegaを参照してください。  het.diagram関数は、複数レベルのヘテラル構造のケースを表示します。  また、尺度セット（EPI、NEO、BFIなど）間の相関のパターンを示すのにも使用できます。  この事例は、Thurstoneデータ集合からの3セットの4変数の間の関係を示すものです。extension.diagramは、fa.diagramやより汎用的なdiagram関数を使用するよりも若干コントロールしやすいfa.extendの結果を描画します。fa.rgraphでは、直交因子の場合はきれいなグラフが描画されますが、斜交因子の描画は許容範囲ですが、Rの外部でクリーンアップするか、fa.diagramを使用した方がよいでしょう。通常の入力はfaまたはICLUSTの出力から取られる。この後者のケースは、ICLUSTの結果をクラスタ構造ではなく、クラスタ負荷量の観点から表示する。  因子負荷行列を入力として与えることも可能である。  この場合、因子相関の Phi 行列を与えることも可能である。fa.graph は schmid$sl オブジェクトに適用し、ラベルは schmid$sl の rownames で指定する。  結果はドット言語によるプロットと完全に互換性を持たせるために編集が必要です。  構造方程式の確認分析でモデルを指定する場合は、structure.diagram を使用してください。
因子分析は、相関行列または共分散行列をより小さいランクのもので近似する試みである。  基本的なモデルは、 nRn = nFk kFn' + U2 (kはnよりずっと小さい)です。因子分析を行う方法はたくさんありますが、最尤法がおそらく最も一般的に好まれる方法でしょう（factanalを参照）。  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分は，データの最も簡潔な記述を提供する．  因子負荷量は，後者が各変数の固有誤差を反映するため，成分負荷量よりも小さくなる．因子解の対角外残差は，成分モデルのそれより優れている（小さい）．  因子負荷量は，各因子に負荷される変数の数が増加するにつれて，漸近的な成分負荷量として考えることができる．  主軸因子分析は、探索的分析で長い歴史があり、簡単な手順です。  連続した固有値分解は，∑(diag(FF'))が（あまり）変化しなくなるまで，対角をdiag (FF')で置き換えた相関行列で行われる．  現在のmax.iter =50の制限は、ほとんどの問題に対して有効のようですが、Holzinger-Harmonの24変数問題では、5因子解の収束に約203回の繰り返しが必要です。  主軸を行うすべての因子プログラムが反復解を行うわけではありません。  SASのマニュアル（第33章）の例はそのようなケースである。その解を得るためには、max.iter = 1と指定する必要がある。  その解と反復解（デフォルト）を比較すると、反復によって解が改善されることがわかる。さらに、fm="mle "は、この例でさらに良い解を生成します。  RMSEAと残差の二乗平均平方根の両方が、fm="pa "の解よりも小さくなっています。しかし、複数の問題セットのシミュレーションによると、fm="pa "は、fm="minres "やfm="mle "よりもRMSEAがわずかに大きく、残差がわずかに小さくなる傾向があります。    つまり、fm="pa "の残差の2乗和は、fm="minres "を使用した場合よりもわずかに小さいようですが、RMSEAは、fm="pa "を使用した場合の方がわずかに悪いのです。  つまり、"真の "最小残差は、おそらくfm="pa "によって発見される。Hao WuとMikko Ronkkoとの広範なやりとりを経て、2017年4月、minresとuls)フィッティングの導関数が修正された。  これは、以前の手順よりもわずかに小さな残差（残差を最小化すると主張する方法としては十分に適切）をもたらす。  以前の分析との一貫性を保つために、"old.min "がこれらのわずかに大きい残差を与えるために追加された。  old.minと新しい "minres "および "ols "解との差は、小数点以下第3位から第4位であるが、それでも注目に値する。比較のために、fm="ols "は経験的一次導関数を使用し、ulsとminresは方程式ベースの一次導関数を使用する。  結果は同じように見えますが、minresとulsの解は、より大きな問題に対してより少ない反復を必要とし、より高速です。Hao Wuに感謝する。  通常、これらの様々なアルゴリズムは同等の結果を出すが、手法間の大きな違いを示すデータセットがいくつか含まれている。SchutzはHeywoodとsuper Heywoodのケースを生成し、blantは非常に異なる解を導く。  特に、minres解は、mle解よりも小さな残差を生成し、factor.congruence係数は、非常に異なる解を示す。MLEを使用することに反対する非常に強力な議論は、OLSアプローチがほとんどの時間で同等の解を生成し、いくつかの時間ではより良い解を生成することを示すMacCallum, Brown and Cai (2007)の章にある。  これは特に、モデル化されていない小因子を持つモデルの場合です。  (fm="minres "も同様で、より良い（RMSEAがより小さい）解を出す傾向があります。fm="minchi "オプションは、"minres" (ols)解のバリエーションで、残差だけでなくサンプルサイズ重み付き残差を最小化します。これは、SAPAプロジェクトで発生するMassively Missing Completely at Random (MMCAR)というデータの問題を取り扱うために開発されました。因子分析の伝統的な問題は、収束を早めるために、元の共分散性の最適な推定値を見つけることでした。  各変数について自乗重相関（SMC）を用いると、元の共分散性が過小評価され、1を用いると過大評価されます。  デフォルトでは，SMC推定が使用される．  非可逆行列の場合，擬似逆行列が見つけられるので，SmCはまだ推定されることに注意．いずれの場合も、反復技法は安定解に収束する傾向があります。しかし、解が得られない場合は、ones (SMC =FALSE)を使って再試行するのが有効である。  反復主軸アルゴリズムは，（最尤基準によって定義される）最良の解を見つけようとはせず，むしろ，連続する固有値分解を用いて，急速に収束する解を見つけようとする．  適合の最尤基準および関連するカイ2乗値が報告され、最尤手順を使用して発見されたものより（少し）悪くなります。最小残差（minres）解は、少し異なるアプローチをとる重み付けなしの最小2乗解です。  これはoptim関数を使用し、因子モデルが縮小行列の固有値分解である場合、2乗残差を最小化するように相関行列の対角要素を調整します。  MINRESとPAは、行列が特異である場合に使用できるため、MLが機能しない場合に機能します。導関数の変更前は、MINRES解はPA解よりもML解に若干似ていました。MINRESの導関数の変更により、MINRES、PA、ULSの解は実質的に同じになりました。minres解とwls解は、導関数の変更に伴うファクトナル関数のアイデアにほぼ従っている。重み付き最小2乗（wls）解は、相関行列の逆行列の1/対角で残差行列を重み付けします。  これは，共分散性の低い項目を共分散性の高い項目よりも重みづけする効果がある．一般化最小2乗（gls）解は，相関行列の逆行列で残差行列を重みづけする．  最尤法は、さらに別のアプローチをとり、カイ2乗適合度検定を最小化するような共同性の値を見つけます。  fm="ml "オプションは、factanalで使用されている手順に従って最尤解を提供しますが、その関数のすべての追加機能を提供しません。  最小順位因子モデル（MRFA）は、Shapiro and Ten Berge (2002)とTen Berge and Kiers (1991)の考えにほぼ従います。  これは、Andreas Moltnerによって貢献されたglb.algebraic手順を利用します。  MRFAは、残差行列が依然として正半定値であるような因子の抽出を試みます。  アルファ因子分析は、共同体性を補正した相関行列に基づいて解を求め、それらを元の相関行列に再スケーリングします。  この手順はKaiser and Coffey, 1965によって記述されています。  出力をSPSSと比較したテストケースは、PAアルゴリズムがSPSSがulsと呼ぶものと一致し、wls解がその適合において同等であることを示唆しています。wls解とgls解は、固有値がわずかに大きいが、minres解や最尤解よりも対角残差の適合がわずかに悪い。  Harman(1976)の例と結果を比較すると、反復なしのPA解は、HarmanがPrincipal Axesと呼ぶもの（SASと同じ）に一致し、反復PA解は、彼のminres解に一致します。  psychで発見されたminres解は、反復PA解よりも対角外残差がわずかに小さい傾向があります（そうあるべきです）。   項目については、顕著な項目をスコアリングして（例えば、scoreItemsを使用して）因子スコアを見つけるのが典型的ですが、因子スコアは、他のいくつかの手段と同様に、回帰によって推定することができます。可能なアプローチは複数あり(Grice, 2001を参照)，ここで取り上げた1つはtenBergeらによって開発されたものである(factor.scoreを参照)．Factanalにマッチする代替は，回帰を使用してスコアを見つけることである - Thurstoneの最小2乗回帰（ここで，重みは，W = inverse(R)S によって見つけられる．  斜交ケースでは，因子負荷量はパターン係数と呼ばれ， S = P Phi によって構造係数に関係し，したがって， P = S Phi^-1 である．  因子スコアを推定するとき，faとfactanalは，faが構造行列から因子を見つけるのに対して，factanalはパターン行列から見つけるという点で異なる．  したがって，直交の場合，faとfactanalは因子スコアの推定において完全に一致するが，斜め因子の場合には一致しない．  oblique.scores = TRUEに設定すると、factanalの推定値と一致する因子スコアが得られます。因数分解されなかった変数に因子解を拡張することが有用な場合があります。  これは、fa.extensionを使用して行うことができます。因子拡張は通常、いくつかの変数が因数分解するのに適切でなかったが、元の因子への因子負荷量がまだ必要な場合に行われます。  因子拡張は，因子スコアを使用せずに因子-基準相関を求めることができるという点で，とても強力な手続きである．2値項目または多値項目については，ピアソン相関よりもむしろ4値相関または多値相関を分析することが推奨される．これは，データに2値変数，多値変数，および連続変数が混在している場合， cor="poly" または cor="tet" または cor="mixed" を指定することによって行うことができる．  2値または多値データの分析は、irt.faを使用するか、単にcor="poly "オプションを設定することによっても行うことができる。  最初のケースでは、因子分析の結果は項目応答理論（IRT）の用語で報告されますが、元の因子解が結果に返されます。後者の場合、典型的な因子負荷量行列が返されますが、irt.faによる再分析のために、テトラコリック/ポリコリック相関行列と項目統計量が保存されます（連続項目、二項項目、多項項目の混合から相関を求めるmixed.cor関数も参照してください）。様々な回転/変換オプションのうち、varimax、Varimax、quartimax、bentlerT、geominT、bifactorは直交回転を行います。oblimin、quartimin、simplimax、bentlerQ、geominQ、biquartiminは斜め変換です。これらのほとんどは、GPArotationパッケージを呼び出すだけである。cluster "オプションは、varimax解のクラスター表現によって定義された構造に対して、的を絞った回転を行います。  オプションの "keys "パラメータを指定すると、"target "オプションは、キー行列として与えられたターゲットに回転する。(target.rotを参照)obliminは、GPArotationではδ=0のquartiminの呼び出しによって実装されています。これは、人々がquartimin解を参照する際に混乱を招きます。因子回転に関する汚い小さな秘密に注意することは重要である。  それはローカルミニマムの問題である。  回転アルゴリズムの複数回の再起動が強く推奨されている（Nguyen and Waller, N. G. 2021を参照）。GPArotationの呼び出しにより、さらに2つのターゲット回転オプションが利用できる。  これらはMichael BrowneのtargetQ（斜め）とtargetT（直交）ターゲット回転である。  詳細は target.rot を参照。bifactor "回転は、GPArotationパッケージのGPForth関数を呼び出し、JennrichとBentlerのMatLabコードから適応した2つの関数を使用することで、JennrichとBentler（2011）のbifactor回転を実装しています。  これにはローカル・ミニマムの問題があるようで、複数の開始値を使用する必要があります。  1つは、GPArotationパッケージのVarimaxで、デフォルトではカイザー正規化を適用しません。  もう1つは、statsパッケージのvarimaxで、これは適用されます。  正規化が設定されていても、2つの回転関数はわずかに異なる結果を生成するようです。他の回転関数との一貫性を保つためには、おそらく Varimax の方が好ましいでしょう。これらのオプションのすべてから回転行列（rot.mat）が返されます。これは GPArotation パッケージが返す Th (theta?) オブジェクトの逆行列です。  因子の相関は、Phi = Th' Thで求めることができます。2値または多値の回答を扱う2つの方法があります：通常の因子分析出力と同様に4値または多値の相関行列を返すcor="poly "オプション付きのfaと、通常のfa出力と同様に2パラメータのirt分析を返すirt.faです。2値または多値の回答を持つ項目を因子分析する場合、irt.fa関数は因子出力の項目応答理論表現を提供します。fa.polyは非推奨で、その機能はcor="poly "を設定することで実現できます。  fa.polyは通常の因子分析出力を生成しますが、その後のirt分析のために多項式行列(rho)と項目困難度(tau)を保存します。fa.polyはデフォルトで、データがあれば因子スコアを求めます。  相関はテトラコロリックまたはポリコロリックのいずれかを用いて求められ、その後この行列が因数分解されます。  fa関数は、データのブートストラップ標本（存在する場合）または観測された相関行列に基づくシミュレートされたデータセットに対して、分析をn.iter回繰り返します。  推定値の平均と標準偏差が返され、元の因子分析と推定係数のアルファ値信頼区間が表示されます。  ブートストラップされた解は、target.rotを使用して元の解に向かって回転されます。因子負荷量はz変換され、平均化され、そして逆変換されます。これは、Heywood のケースの誤差につながります。  より良い代替案は、ブートストラップされた平均値を見つけ、観測された値の範囲に基づいて信頼区間を見つけることです。デフォルトは、n.iter =1であり、ブートストラップは行いません。多値項目または2値項目を使用する場合、irt.fa関数を使用して、fa.polyで報告された因子負荷量と等価な項目反応理論パラメータを見つけることが、おそらくより有用です。  ペアワイズ削除を使用したり、テトラコーリックまたはポリコーリック行列から生じるいくつかの相関行列は、適切ではありません。  つまり、正の半正定値（すべての固有値 >= 0）にはなりません。  cor.smooth関数は、すべての負の固有値を0より少し大きくして相関行列を調整し（平滑化し）、その他の固有値を変数数の合計になるようにスケーリングし直し、相関行列を再作成します。  burtデータセットを使ったこの問題の例については、cor.smoothを参照してください。tetrachoricsやpolychoricsを使った場合のこの問題の原因の1つは、連続性の調整にあるようです。  SPSSタイプの出力が好きな人のために、Kaiser-Meyer-Olkin KMO検定として知られるファクタリングの妥当性の尺度は、KMO関数を使用して相関行列またはデータ行列から見つけることができます。  同様に、Bartlettの球形度検定もcortest.bartlett関数を使用して求めることができます。分散を説明するオブジェクトを持ちたい人のために、これはprint関数によって見えないように返されます。  (e.g., p <- print(fa(ability))$Vaccounted ).  これはfa関数でも同様に返されるようになりました(例: p <- fa(ability)$Vaccounted )。  共産性がパターン %*% t(Structure)の対角によって見つけられるように、説明される分散も対角( t(Structure) %*% Pattern.)によって見つけることができます。  SS負荷量と呼ばれることに注意してください。print.psych.fa関数の出力は、因子負荷量（パターン行列から）、h2（共同性）、u2（一意性）、com（その変数の因子負荷量の複雑さ（下記参照））を表示します。  直交解の場合，h2 は単に因子負荷量の2乗の行和である．しかし，斜め解の場合，それは直交因子負荷量の行和である（回転や変換は共同性を変えないことを覚えておいてほしい）．  マウスから得られた複数のインピュテーションデータセットを結合したいというAsghar Minaeiからのリクエストに応えて、fa.pooledが追加されました。  別々のデータセットがリスト（データセット）にまとめられ、それが別々に因数分解される。各解はリストの最初のセットに向かって回転される。  fa.sapaはSAPA(Synthetic Aperture Personality Assessment)を行うプロセスをシミュレートする。  これは、データセットの分数（frac）の連続したランダム標本について反復解を行います。これにより、様々なサンプルサイズと様々なサンプルレートに対する解の安定性を見つけることができます。反復回数(n.iter)とサンプリングされたデータの割合(frac)を指定する必要があります。  
因子負荷量の2つのセットの間の因子一致係数を求めます。因子一致は、負荷量行列によって定義され、原点を基点とするベクトルの対の余弦である。  したがって，スケーラー（たとえば，固有値の大きさ）によってのみ異なる負荷量について，因子合同は1になる．F1とF2の因子負荷量ベクトルについて，因子合同の尺度 phi は， phi = sum(F1 F2)/sqrt(sum(F1^2) sum(F2^2)) 因子合同を因子負荷量の相関と比較するのは，興味深いエクササイズである．  因子合同は生のクロス積に基づくが，相関は中心化されたクロス積に基づく．つまり、因子負荷量の相関は、各因子の平均負荷量に基づくベクトルの余弦である。 phi = sum((F1-a)(F2-b))/sqrt(sum((F1-a)^2) sum((F2-b)^2)) .合同係数については、 a = b= 0. 相関については、 a = 平均 F1, b = 平均 F2.2つ以上の解を比較するために，x は行列のリストであってもよく，それらすべてが比較される．  データがゼロ中心の場合、これは相関であり、データが尺度の中間点(M)を中心とする場合、これはコーエンの類似度係数である。  例を参照。Mが指定されていない場合は、xとyの項目の中点として求められる。cohen.profileは、Mを中心としたデータに一致関数を適用する。Mは指定することもできるし、データから求めることもできる。distanceはrの関数として一般化された距離を求める。city block (r=1), Euclidean (r=2) or weighted towards maximimum (r >2)。
パス図の表現は，確認的因子分析では標準になっているが，探索的因子分析ではまだ一般的でない．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．デフォルトでは，潜在変数から観察変数に矢印が来る．  これはもちろん因子モデルです。  しかし、描画されるオブジェクトのクラスが'principal'であれば、矢印の方向を逆にすると、'潜在'変数はもはや潜在ではなく、ボックスとして表示されます。クラスター・モデルの場合、デフォルトでは因子として扱われますが、ic =TRUEの場合、成分モデルとして扱われます。fa.diagramはRgraphvizを使用せず、好ましい機能です。fa.graphは、Rgraphvizを使用せず、この機能を優先します。fa.graphは、外部グラフィックス・プログラムで使用するドット・コードを生成します。gパラメータにTRUEを指定することで、階層（2因子）モデルを描画することができます。  これにより、二因子構造を持つさまざまな因子変換をグラフィカルに表示することができます（例えば、bifactorやbiquartimin。  これらの構造を見つける別の方法についてはomegaを参照してください。  het.diagram関数は、複数レベルのヘテラル構造のケースを表示します。  また、尺度セット（EPI、NEO、BFIなど）間の相関のパターンを示すのにも使用できます。  この事例は、Thurstoneデータ集合からの3セットの4変数の間の関係を示すものです。extension.diagramは、fa.diagramやより汎用的なdiagram関数を使用するよりも若干コントロールしやすいfa.extendの結果を描画します。fa.rgraphでは、直交因子の場合はきれいなグラフが描画されますが、斜交因子の描画は許容範囲ですが、Rの外部でクリーンアップするか、fa.diagramを使用した方がよいでしょう。通常の入力はfaまたはICLUSTの出力から取られる。この後者のケースは、ICLUSTの結果をクラスタ構造ではなく、クラスタ負荷量の観点から表示する。  因子負荷行列を入力として与えることも可能である。  この場合、因子相関の Phi 行列を与えることも可能である。fa.graph は schmid$sl オブジェクトに適用し、ラベルは schmid$sl の rownames で指定する。  結果はドット言語でのプロットと完全に互換性を持たせるために編集が必要です。  構造方程式の確認分析でモデルを指定する場合は、structure.diagram を使用してください。
因子が変数の集合（Fo 因子負荷量）から導出され、拡張された変数の集合（Fe）の負荷量がどうなるかを見たい場合があります。オリジナルの相関行列Ro とRoeの拡張変数とのこれらのオリジナル変数の相関があれば、オリジナル因子での拡張変数の負荷量Fe を見つけるのは簡単な計算です。  この手法は，すべての作業をやり直すことなく，因子分析に新しい変数を追加するケースのために，Dwyer (1937)によって開発された．しかし，Horn (1973)によって議論されたように，因子拡張は，拡張変数を元の因子分析に含めたくないが，とにかく負荷量がどうなるかを見たい場合にも適切である．これは，因子スコアを推定して，拡張変数の因子スコアとの共分散を求めることによって行うことができる．しかし、元のデータが入手できず、共分散行列または相関行列だけが入手できる場合は、fa.extensionの使用が最も適切です。fa.extensionは，元の因子解がfa関数によって発見されたことを仮定する．因子スコア，相関行列，因子拡張での因子負荷量の間の関係については，Horn (1973)を参照．  つまり，元の集合の変数が因数分解され，この解が拡張集合に拡張され，結果の出力は，元の変数と拡張変数の両方が一緒に因数分解されたかのように表示される．  これは、オメガ分析でも行われる。codefa.extendの例では、factor.congruenceを使用して、拡張解とすべての変数の直接解を比較しています。
因子が変数の集合（Fo 因子負荷量）から導出され、拡張された変数の集合（Fe）の負荷量がどうなるかを見たい場合があります。オリジナルの相関行列Ro とRoeの拡張変数とのこれらのオリジナル変数の相関があれば、オリジナル因子での拡張変数の負荷量Fe を見つけるのは簡単な計算です。  この手法は，すべての作業をやり直すことなく，因子分析に新しい変数を追加するケースのために，Dwyer (1937)によって開発された．しかし，Horn (1973)によって議論されたように，因子拡張は，拡張変数を元の因子分析に含めたくないが，とにかく負荷量がどうなるかを見たい場合にも適切である．これは，因子スコアを推定して，拡張変数の因子スコアとの共分散を求めることによって行うことができる．しかし、元のデータが入手できず、共分散行列または相関行列だけが入手できる場合は、fa.extensionの使用が最も適切です。fa.extensionは，元の因子解がfa関数によって発見されたことを仮定する．因子スコア，相関行列，因子拡張での因子負荷量の間の関係については，Horn (1973)を参照．  つまり，元の集合の変数が因数分解され，この解が拡張集合に拡張され，結果の出力は，元の変数と拡張変数の両方が一緒に因数分解されたかのように表示される．  これは、オメガ分析でも行われる。codefa.extendの例では、factor.congruenceを使用して、拡張解とすべての変数の直接解を比較しています。
パス図の表現は，確証的因子分析では標準的になっていますが，探索的因子分析ではまだ一般的ではありません．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．デフォルトでは，矢印は潜在変数から観察変数に来る．  これはもちろん因子モデルです。  しかし、描画されるオブジェクトのクラスが'principal'であれば、矢印の方向を逆にすると、'潜在'変数はもはや潜在ではなく、ボックスとして表示されます。fa.diagramはRgraphvizを使用せず、好ましい機能です。fa.graphは外部グラフィックスプログラムで使用するドットコードを生成します。fa.graphは、Rgraphvizを使用せず、この機能を優先します。fa.graphは、外部グラフィックス・プログラムで使用するドット・コードを生成します。gパラメータにTRUEを指定することで、階層（2因子）モデルを描画することができます。  これにより、二因子構造を持つさまざまな因子変換をグラフィカルに表示することができます（例えば、bifactorやbiquartimin。  これらの構造を見つける別の方法についてはomegaを参照してください。  het.diagram関数は、複数レベルのヘテラル構造のケースを表示します。  また、尺度セット（EPI、NEO、BFIなど）間の相関のパターンを示すのにも使用できます。  この事例は、Thurstoneデータ集合からの3セットの4変数の間の関係を示すものです。extension.diagramは、fa.diagramやより汎用的なdiagram関数を使用するよりも若干コントロールしやすいfa.extendの結果を描画します。fa.rgraphでは、直交因子の場合はきれいなグラフが描画されますが、斜交因子の描画は許容範囲ですが、Rの外部でクリーンアップするか、fa.diagramを使用した方がよいでしょう。通常の入力はfaまたはICLUSTの出力から取られる。この後者のケースは、ICLUSTの結果をクラスタ構造ではなく、クラスタ負荷量の観点から表示する。  因子負荷行列を入力として与えることも可能である。  この場合、因子相関の Phi 行列を与えることも可能である。fa.graph は schmid$sl オブジェクトに適用し、ラベルは schmid$sl の rownames で指定する。  結果はドット言語でのプロットと完全に互換性を持たせるために編集が必要です。  結果の構造方程式確証分析のモデルを指定するには、代わりにstructure.diagramを使う。
fa.lookupとlookupは、相関行列や因子負荷行列を要約するための簡単なヘルパー関数です。bestItemsは、xの指定された列（基準）を列の（絶対）値に基づいてソートします。  デフォルトとして返されるのは、それらの絶対値 > cut を持つ変数の名前だけである。   項目内容と項目名の辞書がある場合、項目名に対応する rowname を持つ 2 列 (またはそれ以上) の行列として内容を含める。(辞書の例bfi.dictionaryを参照).lookupは、bestItemsによって使用され、xの値と一致するyのc1の値を見つける。  そして、lookup(rownames(x),y)によってxに対応する辞書の項目を見つけることができます。列が指定されていない場合は、rownames(y)によってマッチします。fa.lookupは、因子分析の出力を調べ、対応する変数名と内容が欲しいときに使用されます。返されたオブジェクトは、charオプションをTRUEに設定してdf2latex関数を使用することによりLaTexで印刷することができます。fa.lookupは、fa、pcaまたはomegaからの出力で動作します。  同様に、x変数の相関行列rが与えられたとき、別の項目または尺度と最も相関する項目を見つけ、辞書からその項目の内容を表示したい場合、bestItems(r,c1=xの列番号または名前, contents = y)item.lookupは、因子分析faからの出力と単純な記述統計（平均値のデータフレーム）を辞書と組み合わせます。  項目は、因子負荷量 > カットでグループ化され、項目平均でソートされる。  これにより、項目の支持の意味という観点から、尺度がどのように機能するかをよりよく理解することができます。 lookupItems は、ある内容を持つすべての項目を辞書から検索します。  返されたオブジェクトのrownameは項目番号であり、この番号を他の関数で使用して、それらの項目を持つ尺度の統計量（ωなど）を求めることができます。   項目ごとの尺度の相関行列が与えられた場合、その尺度と項目の相関も表示されます。
因子分析および1つの高次因子の場合については、 fa および omega を参照。
因子分析の議論と1つの高次因子の場合については、faとωを参照。
fa.results$loadingsは、ソートされたloadingsに置き換えられます。fa.organizeは、因子分析または成分出力を受け取り、oの順序で因子を再編成します。項目はi順に整理される。  flipオプションは行列入力の場合にのみ機能し、完全なfaオブジェクトには機能しません。reflect関数を使用してください。
Cattellの "scree" 検定は，因子数の問題に対する最も簡単な検定の1つである．  Horn (1965) の "並列 "分析も同様に説得力のある手順である．  最も最適な因子数を決定するための他の手順には，VSS（Very Simple Structure）基準（VSS ）とVelicerのMAP手順（VSSに含まれる）を見つけることが含まれる．fa.parallelは，主成分と因子解（デフォルトではminres）の固有値をプロットし，元のデータ行列と同じサイズのランダム行列に対しても同じことを行います．  fa.parallelにcor=polyオプションを指定すると、fa.parallel.polyが明示的に行うこと、つまり多項式因子と四項式因子の並列分析が行われます。もしデータが2値であれば、fa.parallel.polyは実データとシミュレートデータの4値相関を求め、そうでなければカテゴリ数が10以下であれば多値相関を求めます。  fa.parallel.polyはテトラコロリック/ポリコロリック相関の計算が複雑なため、fa.parallelより遅いことに注意してください。  fa.parallel.polyの機能はfa.parallelにcor=polyオプション(etc)オプションで含まれていますが、古いfa.parallel.polyは直接呼び出す人のために残されています。つまり、fa.parallelは現在、corオプションが "tet "または "poly "に設定されている場合、テトラコリックまたはポリコリックを直接行います。  fa.parallel.polyと同様、これは時間がかかる。  (ntrials)ランダム解の平均を示す。  エラーバーは通常非常に小さく、デフォルトでは抑制されているが、要求があれば表示することができる。  simオプションをTRUE（デフォルト）に設定すると、ランダムな正規データだけでなく、再標本化されたデータに対しても並列解析が行われます。sim=FALSEの場合は、並列解析は再標本化データに対してのみ行われます。    どちらの手続きも同意する傾向があります。  バージョン1.5.4では、シミュレーション/再標本化データの分位数を指定し、標準偏差または標準誤差をプロットする機能を追加しました。  デフォルトでは、これは95パーセンタイルに設定されています。  因子の数の問題を推定する別の方法は、Very Simple Structure (Revelle and Rocklin, 1979)のドキュメント(VSS)で議論されており、Wayne VelicerのMAPアルゴリズム(Veicer, 1976)が含まれています。  因子の並列分析は，実際，見かけよりも難しい．  共分散度が自乗重相関（SMC） smcによって推定される場合、元データの固有値は、主要因子だけでなくマイナー因子も反映します（このようなデータをシミュレートするにはsim.minorを参照してください）。  ランダムデータはもちろん構造を持たないので、マイナー因子の存在によって因子の数が上方に偏る傾向があります。  デフォルトでは、fa.parallelは1因子のminres解に基づいて共分散度を推定します。  これは交互性を過小評価することになりますが、シミュレートされたデータセットや実際のデータセット（例えば、bfiやHarman74）において、より良い解を導くようです。  他のアルゴリズム（例えば、paranパッケージのparan関数）との比較のために、smc=TRUEに設定すると、共通性の推定値としてsmcsが使用されます。さらにもう1つのオプション（Florian Scharfによって提案された）は、特定の因子モデル（例えば、nfactors > 1を指定）に基づいて固有値を推定することです。   結果を印刷すると、シミュレーション値よりも大きいオリジナルデータの固有値が表示されます。パラレル分析についての悲しい観察は、サンプルサイズに敏感であるということです。  つまり、大きなデータセットでは、ランダムデータの固有値は1に非常に近くなります。これは、サンプルサイズの関数として因子数の異なる推定につながります。  bfiデータセット（最初の25項目は5因子モデルを表すことを意味する）の因子構造を考えてみよう。  200以下のサンプルでは、並列分析は5因子を示唆するが、1000以上では6因子と成分が示される。  これは、実データの固有値が不安定なためではなく、nが大きくなるにつれてランダムデータが1に近づくためです。nfactors=1では6因子が示唆されますが、nfactors=5を指定すると、bfiの並列分析では12因子が抽出されるべきことが示唆されます！fa.parallel.polyで2値データをシミュレートする場合、シミュレートされたデータは元データと同じ難しさを持ちます。  これは機能的には、シミュレートされた結果と再サンプリングされた結果が非常によく似ていることを意味します。  なお、fa.parallel.polyは機能的にはfa.parallelにcor="poly "オプションを付けたものに置き換えられています。多くの心理関数と同様に、fa.parallelはマルチコア処理ができるように変更されています。  多くの心理関数と同様に、fa.parallelはマルチコア処理を可能にするように変更されました。多数の反復を実行するには、コア数を可能な限り増やす方が明らかに高速です（options("mc.cores=n "コマンドを使用します。
Cattellの "scree "テストは、因子数問題に対する最も単純なテストの1つである。  Horn (1965)の "並列 "分析も同様に説得力のある手順である。  最も最適な因子数を決定するための他の手順には，VSS（Very Simple Structure）基準（VSS ）とVelicerのMAP手順（VSSに含まれる）を見つけることが含まれる．fa.parallelは，主成分と因子解（デフォルトではminres）の固有値をプロットし，元のデータ行列と同じサイズのランダム行列に対しても同じことを行います．  fa.parallelにcor=polyオプションを指定すると、fa.parallel.polyが明示的に行うこと、つまり多項式因子と四項式因子の並列分析が行われます。もしデータが2値であれば、fa.parallel.polyは実データとシミュレートデータの4値相関を求め、そうでなければカテゴリ数が10以下であれば多値相関を求めます。  fa.parallel.polyはテトラコロリック/ポリコロリック相関の計算が複雑なため、fa.parallelより遅いことに注意してください。  fa.parallel.polyの機能はfa.parallelにcor=polyオプション(etc)オプションで含まれていますが、古いfa.parallel.polyは直接呼び出す人のために残されています。つまり、fa.parallelは現在、corオプションが "tet "または "poly "に設定されている場合、テトラコリックまたはポリコリックを直接行います。  fa.parallel.polyと同様、これは時間がかかる。  (ntrials)ランダム解の平均を示す。  エラーバーは通常非常に小さく、デフォルトでは抑制されているが、要求があれば表示することができる。  simオプションをTRUE（デフォルト）に設定すると、ランダムな正規データだけでなく、再標本化されたデータに対しても並列解析が行われます。sim=FALSEの場合は、並列解析は再標本化データに対してのみ行われます。    どちらの手続きも同意する傾向があります。  バージョン1.5.4では、シミュレーション/再標本化データの分位数を指定し、標準偏差または標準誤差をプロットする機能を追加しました。  デフォルトでは、これは95パーセンタイルに設定されています。  因子の数の問題を推定する別の方法は、Very Simple Structure (Revelle and Rocklin, 1979)のドキュメント(VSS)で議論されており、Wayne VelicerのMAPアルゴリズム(Veicer, 1976)が含まれています。  因子の並列分析は，実際，見かけよりも難しい．  共分散度が自乗重相関（SMC） smcによって推定される場合、元データの固有値は、主要因子だけでなくマイナー因子も反映します（このようなデータをシミュレートするにはsim.minorを参照してください）。  ランダムデータはもちろん構造を持たないので、マイナー因子の存在によって因子の数が上方に偏る傾向があります。  デフォルトでは、fa.parallelは1因子のminres解に基づいて共分散度を推定します。  これは交互性を過小評価することになりますが、シミュレートされたデータセットや実際のデータセット（例えば、bfiやHarman74）において、より良い解を導くようです。  他のアルゴリズム（例えば、paranパッケージのparan関数）との比較のために、smc=TRUEに設定すると、共通性の推定値としてsmcsが使用されます。さらにもう1つのオプション（Florian Scharfによって提案された）は、特定の因子モデル（例えば、nfactors > 1を指定）に基づいて固有値を推定することです。   結果を印刷すると、シミュレーション値よりも大きいオリジナルデータの固有値が表示されます。パラレル分析についての悲しい観察は、サンプルサイズに敏感であるということです。  つまり、大きなデータセットでは、ランダムデータの固有値は1に非常に近くなります。これは、サンプルサイズの関数として因子数の異なる推定につながります。  bfiデータセット（最初の25項目は5因子モデルを表すことを意味する）の因子構造を考えてみよう。  200以下のサンプルでは、並列分析は5因子を示唆するが、1000以上では6因子と成分が示される。  これは、実データの固有値が不安定なためではなく、nが大きくなるにつれてランダムデータが1に近づくためです。nfactors=1では6因子が示唆されますが、nfactors=5を指定すると、bfiの並列分析では12因子が抽出されるべきことが示唆されます！fa.parallel.polyで2値データをシミュレートする場合、シミュレートされたデータは元データと同じ難しさを持ちます。  これは機能的には、シミュレートされた結果と再サンプリングされた結果が非常によく似ていることを意味します。  なお、fa.parallel.polyは機能的にはfa.parallelにcor="poly "オプションを付けたものに置き換えられています。多くの心理関数と同様に、fa.parallelはマルチコア処理ができるように変更されています。  多くの心理関数と同様に、fa.parallelはマルチコア処理ができるように変更されました。多数の反復を実行する場合は、コア数を可能な限り増やす方が明らかに高速です（options("mc.cores=n "コマンドを使用。nはdetectCores()から決定されます）。
因子分析またはクラスター分析の結果がプロットされます。  各項目は、最も負荷の高い因子に割り当てられ、変数名とクラスタ（色）で識別されます。クラスタ割り当ては、負荷による自動クラスタリングを上書きするように指定することができます。これらの関数は両方とも、直接呼び出すか、汎用 plot 関数を呼び出すことによって呼び出すことができます。  (例参照)。
これらの古い関数のすべての機能については、faの記述を参照してください。
因子分析とは、相関行列や共分散行列をより小さいランクの行列で近似する試みです。  基本的なモデルは、nRn = nFk kFn' + U2 (kはnよりはるかに小さい)です。因子分析を行うには多くの方法がありますが、最尤法がおそらく最も一般的でしょう（factanalを参照）。  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分は，データの最も簡潔な記述を提供する．  因子負荷量は，後者が各変数の固有誤差を反映するため，成分負荷量よりも小さくなる．因子解の対角外残差は，成分モデルのそれより優れている（小さい）．  因子負荷量は，各因子に負荷される変数の数が増加するにつれて，漸近的な成分負荷量として考えることができる．  主軸因子分析は、探索的分析で長い歴史があり、簡単な手順です。  連続した固有値分解は，∑(diag(FF'))が（あまり）変化しなくなるまで，対角をdiag (FF')で置き換えた相関行列で行われる．  現在のmax.iter =50の制限は、ほとんどの問題に対して有効のようですが、Holzinger-Harmonの24変数問題では、5因子解の収束に約203回の繰り返しが必要です。  主軸を行うすべての因子プログラムが反復解を行うわけではありません。  SASのマニュアル（第33章）の例はそのようなケースである。その解を得るためには、max.iter = 1と指定する必要がある。  その解と反復解（デフォルト）を比較すると、反復によって解が改善されることがわかる。さらに、fm="mle "は、この例でさらに良い解を生成します。  RMSEAと残差の二乗平均平方根の両方が、fm="pa "の解よりも小さくなっています。しかし、複数の問題セットのシミュレーションによると、fm="pa "は、fm="minres "やfm="mle "よりもRMSEAがわずかに大きく、残差がわずかに小さくなる傾向があります。    つまり、fm="pa "の残差の2乗和は、fm="minres "を使った場合よりもわずかに小さいようですが、RMSEAは、fm="pa "を使った場合の方がわずかに悪いのです。  つまり、"真の "最小残差は、おそらくfm="pa "によって発見される。Hao WuとMikko Ronkkoとの広範なやりとりを経て、2017年4月、minresとuls)フィッティングの導関数が修正された。  これは、以前の手順よりもわずかに小さな残差（残差を最小化すると主張する方法としては十分に適切）をもたらす。  以前の分析との一貫性を保つために、"old.min "がこれらのわずかに大きい残差を与えるために追加された。  old.minと新しい "minres "および "ols "解との違いは、小数点以下3桁目から4桁目であるが、それでも注目に値する。比較のために、fm="ols "は経験的一次導関数を使用し、ulsとminresは方程式ベースの一次導関数を使用する。  結果は同じように見えますが、minresとulsの解は、より大きな問題に対してより少ない反復を必要とし、より高速です。Hao Wuに感謝する。  通常、これらの様々なアルゴリズムは同等の結果を出すが、手法間の大きな違いを示すデータセットがいくつか含まれている。SchutzはHeywoodとsuper Heywoodのケースを生成し、blantは非常に異なる解を導く。  特に、minres解は、mle解よりも小さな残差を生成し、factor.congruence係数は、非常に異なる解を示す。MLEを使用することに反対する非常に強い議論は、OLSアプローチがほとんどの時間で同等の解を生成し、いくつかの時間ではより良い解を生成することを示すMacCallum, Brown and Cai (2007)の章にある。  これは特に、モデル化されていない小因子を持つモデルの場合です。  (fm="minres "も同様で、より良い（RMSEAがより小さい）解を出す傾向があります。fm="minchi "オプションは、"minres" (ols)解のバリエーションで、残差だけでなくサンプルサイズ重み付き残差を最小化します。これは、SAPAプロジェクトで起こる条件であるMassively Missing Completely at Random (MMCAR)のデータの問題を取り扱うために開発されました。因子分析の伝統的な問題は、収束をスピードアップするために、元の共分散性の最適な推定値を見つけることでした。  各変数について自乗重相関（SMC）を用いると、元の共分散性が過小評価され、1を用いると過大評価されます。  デフォルトでは，SMC推定が使用される．  非可逆行列の場合，擬似逆行列が見つけられるので，SmCはまだ推定されることに注意．いずれの場合も、反復技法は安定解に収束する傾向があります。しかし、解が得られない場合は、ones (SMC =FALSE)を使って再試行するのが有効である。  反復主軸アルゴリズムは，（最尤基準で定義された）最良の解を見つけようとはせず，むしろ，連続する固有値分解を用いて，急速に収束する解を見つけようとする．  適合の最尤基準と関連するカイ2乗値が報告され、最尤法を用いて発見されたものより（少し）悪くなります。最小残差（minres）解は、少し異なるアプローチをとる重み付けなしの最小2乗解です。  これはoptim関数を使用し、因子モデルが縮小行列の固有値分解である場合、2乗残差を最小化するように相関行列の対角要素を調整します。  MINRESとPAは、行列が特異である場合に使用できるため、MLが機能しない場合に機能します。導関数の変更前は、MINRES解はPA解よりもML解に若干似ていました。MINRESの導関数の変更により、MINRES、PA、ULSの解は実質的に同じになりました。minres解とwls解は、導関数の変更に伴うファクトナル関数のアイデアにほぼ従っている。重み付き最小2乗（wls）解は、相関行列の逆行列の1/対角で残差行列を重み付けします。  これは，共分散性の低い項目を共分散性の高い項目よりも重みづけする効果がある．一般化最小2乗（gls）解は，相関行列の逆行列で残差行列を重みづけする．  最尤法は、さらに別のアプローチをとり、カイ2乗適合度検定を最小化するような共同性の値を見つけます。  fm="ml "オプションは、factanalで使用されている手順に従って最尤解を提供しますが、その関数のすべての追加機能を提供しません。  最小順位因子モデル（MRFA）は、Shapiro and Ten Berge (2002)とTen Berge and Kiers (1991)の考えにほぼ従います。  これは、Andreas Moltnerによって貢献されたglb.algebraic手順を利用します。  MRFAは、残差行列が依然として正半定値であるような因子の抽出を試みます。  アルファ因子分析は、共同体性を補正した相関行列に基づいて解を求め、それらを元の相関行列に再スケーリングします。  この手順はKaiser and Coffey, 1965によって記述されています。  出力をSPSSと比較したテストケースでは、PAアルゴリズムはSPSSがulsと呼ぶものと一致し、wls解はその適合において同等であることが示唆されています。wls解とgls解は、固有値がわずかに大きいが、minres解や最尤解よりも対角残差の適合がわずかに悪い。  この結果をHarman (1976)の例と比較すると、反復なしのPA解は、HarmanがPrincipal Axesと呼ぶもの（SASと同じ）に一致し、反復PA解は、彼のminres解に一致します。  psychで発見されたminres解は、反復PA解よりも対角外残差がわずかに小さい傾向があります（そうあるべきです）。   項目については、顕著な項目をスコアリングして（例えば、scoreItemsを使用して）因子スコアを見つけるのが典型的ですが、因子スコアは、他のいくつかの手段と同様に、回帰によって推定することができます。可能なアプローチは複数あり(Grice, 2001を参照)，ここで取り上げた1つはtenBergeらによって開発されたものである(factor.scoreを参照)．Factanalにマッチする代替は，回帰を使用してスコアを見つけることである - Thurstoneの最小2乗回帰（ここで，重みは，W = inverse(R)S によって見つけられる．  斜交ケースでは，因子負荷量はパターン係数と呼ばれ， S = P Phi によって構造係数に関係し，したがって， P = S Phi^-1 である．  因子スコアを推定するとき，faとfactanalは，faが構造行列から因子を見つけるのに対して，factanalはパターン行列から見つけるという点で異なる．  したがって，直交の場合，faとfactanalは因子スコアの推定において完全に一致するが，斜め因子の場合には一致しない．  oblique.scores = TRUEに設定すると、factanalの推定値と一致する因子スコアが得られます。因数分解されなかった変数に因子解を拡張することが有用な場合があります。  これは、fa.extensionを使用して行うことができます。因子拡張は通常、いくつかの変数が因数分解するのに適切でなかったが、元の因子への因子負荷量がまだ必要な場合に行われます。  因子拡張は，因子スコアを使用せずに因子-基準相関を求めることができるという点で，とても強力な手続きである．2値項目または多値項目については，ピアソン相関よりもむしろ4値相関または多値相関を分析することが推奨される．これは，データに2値変数，多値変数，および連続変数が混在している場合， cor="poly" または cor="tet" または cor="mixed" を指定することによって行うことができる．  2値または多値データの分析は、irt.faを使用するか、単にcor="poly "オプションを設定することによっても行うことができる。  最初のケースでは、因子分析の結果は項目応答理論（IRT）の用語で報告されますが、元の因子解が結果に返されます。後者の場合、典型的な因子負荷量行列が返されますが、irt.faによる再分析のために、テトラコリック/ポリコリック相関行列と項目統計量が保存されます（連続項目、二項項目、多項項目の混合から相関を求めるmixed.cor関数も参照してください）。様々な回転/変換オプションのうち、varimax、Varimax、quartimax、bentlerT、geominT、bifactorは直交回転を行います。oblimin、quartimin、simplimax、bentlerQ、geominQ、biquartiminは斜め変換です。これらのほとんどは、GPArotationパッケージを呼び出すだけである。cluster "オプションは、varimax解のクラスター表現によって定義された構造に対して、的を絞った回転を行います。  オプションの "keys "パラメータを指定すると、"target "オプションは、キー行列として与えられたターゲットに回転する。(target.rotを参照)obliminは、GPArotationではδ=0のquartiminの呼び出しによって実装されています。これは、人々がquartimin解を参照する際に混乱を招きます。因子回転に関する汚い小さな秘密に注意することは重要である。  それはローカルミニマムの問題である。  回転アルゴリズムの複数回の再起動が強く推奨されている（Nguyen and Waller, N. G. 2021を参照）。GPArotationの呼び出しにより、さらに2つのターゲット回転オプションが利用できる。  これらはMichael BrowneのtargetQ（斜め）とtargetT（直交）ターゲット回転である。  詳細は target.rot を参照。bifactor "回転は、GPArotationパッケージのGPForth関数を呼び出し、JennrichとBentlerのMatLabコードから適応した2つの関数を使用することで、JennrichとBentler（2011）のbifactor回転を実装しています。  これにはローカル・ミニマムの問題があるようで、複数の開始値を使用する必要があります。  1つは、GPArotationパッケージのVarimaxで、デフォルトではカイザー正規化を適用しません。  もう1つは、statsパッケージのvarimaxで、これは適用されます。  正規化が設定されていても、2つの回転関数はわずかに異なる結果を生成するようです。他の回転関数との一貫性を保つためには、おそらく Varimax の方が好ましいでしょう。これらのオプションのすべてから回転行列（rot.mat）が返されます。これは GPArotation パッケージが返す Th (theta?) オブジェクトの逆行列です。  因子の相関は、Phi = Th' Thで求めることができます。2値または多値の回答を扱う2つの方法があります：通常の因子分析出力と同様に4値または多値の相関行列を返すcor="poly "オプション付きのfaと、通常のfa出力と同様に2パラメータのirt分析を返すirt.faです。2値または多値の回答を持つ項目を因子分析する場合、irt.fa関数は因子出力の項目応答理論表現を提供します。fa.polyは非推奨で、その機能はcor="poly "を設定することで実現できます。  fa.polyは通常の因子分析出力を生成しますが、その後のirt分析のために多項式行列(rho)と項目困難度(tau)を保存します。fa.polyはデフォルトで、データが利用可能であれば因子スコアを求めます。  相関はテトラコロリックまたはポリコロリックのいずれかを用いて求められ、その後この行列が因数分解されます。  fa関数は、データのブートストラップ標本（存在する場合）または観測された相関行列に基づくシミュレートされたデータセットに対して、分析をn.iter回繰り返します。  推定値の平均と標準偏差が返され、元の因子分析と推定係数のアルファ値信頼区間が表示されます。  ブートストラップされた解は、target.rotを使用して元の解に向かって回転されます。因子負荷量はz変換され、平均化され、そして逆変換されます。これは、Heywood のケースの誤差につながります。  より良い代替案は、ブートストラップされた平均値を見つけ、観測された値の範囲に基づいて信頼区間を見つけることです。デフォルトは、n.iter =1であり、ブートストラップは行いません。多値項目または2値項目を使用する場合、irt.fa関数を使用して、fa.polyで報告された因子負荷量と等価な項目反応理論パラメータを見つけることが、おそらくより有用です。  ペアワイズ削除を使用したり、テトラコーリックまたはポリコーリック行列から生じるいくつかの相関行列は、適切ではありません。  つまり、正の半正定値（すべての固有値 >= 0）にはなりません。  cor.smooth関数は、すべての負の固有値を0より少し大きくして相関行列を調整し（平滑化し）、その他の固有値を変数数の合計になるようにスケーリングし直し、相関行列を再作成します。  burtデータセットを使ったこの問題の例については、cor.smoothを参照してください。tetrachoricsやpolychoricsを使った場合のこの問題の原因の1つは、連続性の調整にあるようです。  SPSSタイプの出力が好きな人のために、Kaiser-Meyer-Olkin KMO検定として知られるファクタリングの妥当性の尺度は、KMO関数を使用して相関行列またはデータ行列から見つけることができます。  同様に、Bartlettの球形度検定もcortest.bartlett関数を使用して求めることができます。分散を説明するオブジェクトを持ちたい人のために、これはprint関数によって見えないように返されます。  (e.g., p <- print(fa(ability))$Vaccounted ).  これはfa関数でも同様に返されるようになりました(例: p <- fa(ability)$Vaccounted )。  共産性がパターン %*% t(Structure)の対角によって見つけられるように、説明される分散も対角( t(Structure) %*% Pattern.)によって見つけることができます。  SS負荷量と呼ばれることに注意してください。print.psych.fa関数の出力は、因子負荷量（パターン行列から）、h2（共同性）、u2（一意性）、com（その変数の因子負荷量の複雑さ（下記参照））を表示します。  直交解の場合，h2 は単に因子負荷量の2乗の行和である．しかし，斜め解の場合，それは直交因子負荷量の行和である（回転や変換は共同性を変えないことを覚えておいてほしい）．  マウスから得られた複数のインピュテーションデータセットを結合したいというAsghar Minaeiからのリクエストに応えて、fa.pooledが追加されました。  別々のデータセットがリスト（データセット）にまとめられ、それが別々に因数分解される。各解はリストの最初のセットに向かって回転される。  fa.sapaはSAPA(Synthetic Aperture Personality Assessment)を行うプロセスをシミュレートする。  これは、データセットの分数（frac）の連続したランダム標本について反復解を行います。これにより、様々なサンプルサイズと様々なサンプルレートに対する解の安定性を見つけることができます。反復回数(n.iter)とサンプリングされたデータの割合(frac)を指定する必要があります。  
この関数はprofileRパッケージのwprifm関数にインスパイアされたもので、Davison, Kim and Close (2009)の論文が引用されています。  基本的なロジックは、各被験者から平均ベクトルを抽出し、得られたipsatizedデータ行列を分析することです。  これは、パーソナリティ項目の場合はアクビエンス（acquiecence）を、能力項目の場合は一般因子を除去することと見なすことができる。  すべて同じようにキー設定された項目からなる因子（たとえば、bfiデータ集合のNeuroticism）は、この手法によって最も影響を受けます。出力は通常のfa出力と同じで、subjectとwithin.rという2つのオブジェクトが追加されている。subjectオブジェクトは、すべての項目の各被験者の平均スコアのベクトルであり、within.rは、それらのスコアと各項目の相関である。  
パス図の表現は，確証的因子分析では標準的になっているが，探索的因子分析ではまだ一般的ではない．  因子構造をグラフィカルに表現することは，構造を理解するのに役立つ人もいる．デフォルトでは，潜在変数から観察変数に矢印が来る．  これはもちろん因子モデルです。  しかし、描画されるオブジェクトのクラスが'principal'であれば、矢印の方向を逆にすると、'潜在'変数はもはや潜在ではなく、ボックスとして表示されます。fa.diagramはRgraphvizを使用せず、好ましい機能です。fa.graphは外部グラフィックスプログラムで使用するドットコードを生成します。fa.graphは、Rgraphvizを使用せず、この機能を優先します。fa.graphは、外部グラフィックス・プログラムで使用するドット・コードを生成します。gパラメータにTRUEを指定することで、階層（2因子）モデルを描画することができます。  これにより、二因子構造を持つさまざまな因子変換をグラフィカルに表示することができます（例えば、bifactorやbiquartimin。  これらの構造を見つける別の方法についてはomegaを参照してください。  het.diagram関数は、複数レベルのヘテラル構造のケースを表示します。  また、尺度セット（EPI、NEO、BFIなど）間の相関のパターンを示すのにも使用できます。  この事例は、Thurstoneデータ集合からの3セットの4変数の間の関係を示すものです。extension.diagramは、fa.diagramやより汎用的なdiagram関数を使用するよりも若干コントロールしやすいfa.extendの結果を描画します。fa.rgraphでは、直交因子の場合はきれいなグラフが描画されますが、斜交因子の描画は許容範囲ですが、Rの外部でクリーンアップするか、fa.diagramを使用した方がよいでしょう。通常の入力はfaまたはICLUSTの出力から取られる。この後者のケースは、ICLUSTの結果をクラスタ構造ではなく、クラスタ負荷量の観点から表示する。  因子負荷行列を入力として与えることも可能である。  この場合、因子相関の Phi 行列を与えることも可能である。fa.graph は schmid$sl オブジェクトに適用し、ラベルは schmid$sl の rownames で指定する。  結果はドット言語でのプロットと完全に互換性を持たせるために編集が必要です。  構造方程式の確認分析でモデルを指定する場合は、structure.diagram を使用してください。
因子分析は、相関行列または共分散行列をより小さいランクのもので近似する試みである。  基本的なモデルは、 nRn = nFk kFn' + U2 (kはnよりずっと小さい)です。因子分析を行うには多くの方法がありますが、最尤法がおそらく最も一般的に好まれる方法でしょう（factanalを参照）。  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分は，データの最も簡潔な記述を提供する．  因子負荷量は，後者が各変数の固有誤差を反映するため，成分負荷量よりも小さくなる．因子解の対角外残差は，成分モデルのそれより優れている（小さい）．  因子負荷量は，各因子に負荷される変数の数が増加するにつれて，漸近的な成分負荷量として考えることができる．  主軸因子分析は、探索的分析で長い歴史があり、簡単な手順です。  連続した固有値分解は，∑(diag(FF'))が（あまり）変化しなくなるまで，対角をdiag (FF')で置き換えた相関行列で行われる．  現在のmax.iter =50の制限は、ほとんどの問題に対して有効のようですが、Holzinger-Harmonの24変数問題では、5因子解の収束に約203回の繰り返しが必要です。  主軸を行うすべての因子プログラムが反復解を行うわけではありません。  SASのマニュアル（第33章）の例はそのようなケースである。その解を得るためには、max.iter = 1と指定する必要がある。  その解と反復解（デフォルト）を比較すると、反復によって解が改善されることがわかる。さらに、fm="mle "は、この例でさらに良い解を生成します。  RMSEAと残差の二乗平均平方根の両方が、fm="pa "の解よりも小さくなっています。しかし、複数の問題セットのシミュレーションによると、fm="pa "は、fm="minres "やfm="mle "よりもRMSEAがわずかに大きく、残差がわずかに小さくなる傾向があります。    つまり、fm="pa "の残差の2乗和は、fm="minres "を使用した場合よりもわずかに小さいようですが、RMSEAは、fm="pa "を使用した場合の方がわずかに悪いのです。  つまり、"真の "最小残差は、おそらくfm="pa "によって発見される。Hao WuとMikko Ronkkoとの広範なやりとりを経て、2017年4月、minresとuls)フィッティングの導関数が修正された。  これは、以前の手順よりもわずかに小さな残差（残差を最小化すると主張する方法としては十分に適切）をもたらす。  以前の分析との一貫性を保つために、"old.min "がこれらのわずかに大きい残差を与えるために追加された。  old.minと新しい "minres "および "ols "解との違いは、小数点以下3桁目から4桁目であるが、それでも注目に値する。比較のために、fm="ols "は経験的一次導関数を使用し、ulsとminresは方程式ベースの一次導関数を使用する。  結果は同じように見えますが、minresとulsの解は、より大きな問題に対してより少ない反復を必要とし、より高速です。Hao Wuに感謝する。  通常、これらの様々なアルゴリズムは同等の結果を出すが、手法間の大きな違いを示すデータセットがいくつか含まれている。SchutzはHeywoodとsuper Heywoodのケースを生成し、blantは非常に異なる解を導く。  特に、minres解は、mle解よりも小さな残差を生成し、factor.congruence係数は、非常に異なる解を示す。MLEを使用することに反対する非常に強い議論は、OLSアプローチがほとんどの時間で同等の解を生成し、いくつかの時間ではより良い解を生成することを示すMacCallum, Brown and Cai (2007)の章にある。  これは特に、モデル化されていない小因子を持つモデルの場合です。  (fm="minres "も同様で、より良い（RMSEAがより小さい）解を出す傾向があります。fm="minchi "オプションは、"minres" (ols)解のバリエーションで、残差だけでなくサンプルサイズ重み付き残差を最小化します。これは、SAPAプロジェクトで発生するMassively Missing Completely at Random (MMCAR)というデータの問題を取り扱うために開発されました。因子分析の伝統的な問題は、収束を早めるために、元の共分散性の最適な推定値を見つけることでした。  各変数について自乗重相関（SMC）を用いると、元の共分散性が過小評価され、1を用いると過大評価されます。  デフォルトでは，SMC推定が使用される．  非可逆行列の場合，擬似逆行列が見つけられるので，SmCはまだ推定されることに注意．いずれの場合も、反復技法は安定解に収束する傾向があります。しかし、解が得られない場合は、ones (SMC =FALSE)を使って再試行するのが有効である。  反復主軸アルゴリズムは，（最尤基準によって定義される）最良の解を見つけようとはせず，むしろ，連続する固有値分解を用いて，急速に収束する解を見つけようとする．  適合の最尤基準および関連するカイ2乗値が報告され、最尤手順を使用して発見されたものより（少し）悪くなります。最小残差（minres）解は、少し異なるアプローチをとる重み付けなしの最小2乗解です。  これはoptim関数を使用し、因子モデルが縮小行列の固有値分解である場合、2乗残差を最小化するように相関行列の対角要素を調整します。  MINRESとPAは、行列が特異である場合に使用できるため、MLが機能しない場合に機能します。導関数の変更前は、MINRES解はPA解よりもML解に若干似ていました。MINRESの導関数の変更により、MINRES、PA、ULSの解は実質的に同じになりました。minres解とwls解は、導関数の変更に伴うファクトナル関数のアイデアにほぼ従っている。重み付き最小2乗（wls）解は、相関行列の逆行列の1/対角で残差行列を重み付けします。  これは，共分散性の低い項目を共分散性の高い項目よりも重みづけする効果がある．一般化最小2乗（gls）解は，相関行列の逆行列で残差行列を重みづけする．  最尤法は、さらに別のアプローチをとり、カイ2乗適合度検定を最小化するような共同性の値を見つけます。  fm="ml "オプションは、factanalで使用されている手順に従って最尤解を提供しますが、その関数のすべての追加機能を提供しません。  最小順位因子モデル（MRFA）は、Shapiro and Ten Berge (2002)とTen Berge and Kiers (1991)の考えにほぼ従います。  これは、Andreas Moltnerによって貢献されたglb.algebraic手順を利用します。  MRFAは、残差行列が依然として正半定値であるような因子の抽出を試みます。  アルファ因子分析は、共同体性を補正した相関行列に基づいて解を求め、それらを元の相関行列に再スケーリングします。  この手順はKaiser and Coffey, 1965によって記述されています。  出力をSPSSと比較したテストケースは、PAアルゴリズムがSPSSがulsと呼ぶものと一致し、wls解がその適合において同等であることを示唆しています。wls解とgls解は、固有値がわずかに大きいが、minres解や最尤解よりも対角残差の適合がわずかに悪い。  この結果をHarman (1976)の例と比較すると、反復なしのPA解は、HarmanがPrincipal Axesと呼ぶもの（SASと同じ）に一致し、反復PA解は、彼のminres解に一致します。  psychで発見されたminres解は、反復PA解よりも対角外残差がわずかに小さい傾向があります（そうあるべきです）。   項目については、顕著な項目をスコアリングして（例えば、scoreItemsを使用して）因子スコアを見つけるのが典型的ですが、因子スコアは、他のいくつかの手段と同様に、回帰によって推定することができます。可能なアプローチは複数あり(Grice, 2001を参照)，ここで取り上げた1つはtenBergeらによって開発されたものである(factor.scoreを参照)．Factanalにマッチする代替は，回帰を使用してスコアを見つけることである - Thurstoneの最小2乗回帰（ここで，重みは，W = inverse(R)S によって見つけられる．  斜交ケースでは，因子負荷量はパターン係数と呼ばれ， S = P Phi によって構造係数に関係し，したがって， P = S Phi^-1 である．  因子スコアを推定するとき，faとfactanalは，faが構造行列から因子を見つけるのに対して，factanalはパターン行列から見つけるという点で異なる．  したがって，直交の場合，faとfactanalは因子スコアの推定において完全に一致するが，斜め因子の場合には一致しない．  oblique.scores = TRUEに設定すると、factanalの推定値と一致する因子スコアが得られます。因数分解されなかった変数に因子解を拡張することが有用な場合があります。  これは、fa.extensionを使用して行うことができます。因子拡張は通常、いくつかの変数が因数分解するのに適切でなかったが、元の因子への因子負荷量がまだ必要な場合に行われます。  因子拡張は，因子スコアを使用せずに因子-基準相関を求めることができるという点で，とても強力な手続きである．2値項目または多値項目については，ピアソン相関よりもむしろ4値相関または多値相関を分析することが推奨される．これは，データに2値変数，多値変数，および連続変数が混在している場合， cor="poly" または cor="tet" または cor="mixed" を指定することによって行うことができる．  2値または多値データの分析は、irt.faを使用するか、単にcor="poly "オプションを設定することによっても行うことができる。  最初のケースでは、因子分析の結果は項目応答理論（IRT）の用語で報告されますが、元の因子解が結果に返されます。後者の場合、典型的な因子負荷量行列が返されますが、irt.faによる再分析のために、テトラコリック/ポリコリック相関行列と項目統計量が保存されます（連続項目、二項項目、多項項目の混合から相関を求めるmixed.cor関数も参照してください）。様々な回転/変換オプションのうち、varimax、Varimax、quartimax、bentlerT、geominT、bifactorは直交回転を行います。oblimin、quartimin、simplimax、bentlerQ、geominQ、biquartiminは斜め変換です。これらのほとんどは、GPArotationパッケージを呼び出すだけである。cluster "オプションは、varimax解のクラスター表現によって定義された構造に対して、的を絞った回転を行います。  オプションの "keys "パラメータを指定すると、"target "オプションは、キー行列として与えられたターゲットに回転する。(target.rotを参照)obliminは、GPArotationではδ=0のquartiminの呼び出しによって実装されています。これは、人々がquartimin解を参照する際に混乱を招きます。因子回転に関する汚い小さな秘密に注意することは重要である。  それはローカルミニマムの問題である。  回転アルゴリズムの複数回の再起動が強く推奨されている（Nguyen and Waller, N. G. 2021を参照）。GPArotationの呼び出しにより、さらに2つのターゲット回転オプションが利用できる。  これらはMichael BrowneのtargetQ（斜め）とtargetT（直交）ターゲット回転である。  詳細は target.rot を参照。bifactor "回転は、GPArotationパッケージのGPForth関数を呼び出し、JennrichとBentlerのMatLabコードから適応した2つの関数を使用することで、JennrichとBentler（2011）のbifactor回転を実装しています。  これにはローカル・ミニマムの問題があるようで、複数の開始値を使用する必要があります。  1つは、GPArotationパッケージのVarimaxで、デフォルトではカイザー正規化を適用しません。  もう1つは、statsパッケージのvarimaxで、これは適用されます。  正規化が設定されていても、2つの回転関数はわずかに異なる結果を生成するようです。他の回転関数との一貫性を保つためには、おそらく Varimax の方が好ましいでしょう。これらのオプションのすべてから回転行列（rot.mat）が返されます。これは GPArotation パッケージが返す Th (theta?) オブジェクトの逆行列です。  因子の相関は、Phi = Th' Thで求めることができます。2値または多値の回答を扱う2つの方法があります：通常の因子分析出力と同様に4値または多値の相関行列を返すcor="poly "オプション付きのfaと、通常のfa出力と同様に2つのパラメータirt分析を返すirt.faです。2値または多値の回答を持つ項目を因子分析する場合、irt.fa関数は因子出力の項目応答理論表現を提供します。fa.polyは非推奨で、その機能はcor="poly "を設定することで実現できます。  fa.polyは通常の因子分析出力を生成しますが、その後のirt分析のために多項式行列(rho)と項目困難度(tau)を保存します。fa.polyはデフォルトで、データが利用可能であれば因子スコアを求めます。  相関はテトラコロリックまたはポリコロリックのいずれかを用いて求められ、その後この行列が因数分解されます。  fa関数は、データのブートストラップ標本（存在する場合）または観測された相関行列に基づくシミュレートされたデータセットに対して、分析をn.iter回繰り返します。  推定値の平均と標準偏差が返され、元の因子分析と推定係数のアルファ値信頼区間が表示されます。  ブートストラップされた解は、target.rotを使用して元の解に向かって回転されます。因子負荷量はz変換され、平均化され、そして逆変換されます。これは、Heywood のケースの誤差につながります。  より良い代替案は、ブートストラップされた平均値を見つけ、観測された値の範囲に基づいて信頼区間を見つけることです。デフォルトは、n.iter =1であり、ブートストラップは行いません。多値項目または2値項目を使用する場合、irt.fa関数を使用して、fa.polyで報告された因子負荷量と等価な項目反応理論パラメータを見つけることが、おそらくより有用です。  ペアワイズ削除を使用したり、テトラコーリックまたはポリコーリック行列から生じるいくつかの相関行列は、適切ではありません。  つまり、正の半正定値（すべての固有値 >= 0）にはなりません。  cor.smooth関数は、すべての負の固有値を0より少し大きくして相関行列を調整し（平滑化し）、その他の固有値を変数数の合計になるようにスケーリングし直し、相関行列を再作成します。  burtデータセットを使ったこの問題の例については、cor.smoothを参照してください。tetrachoricsやpolychoricsを使った場合のこの問題の原因の1つは、連続性の調整にあるようです。  SPSSタイプの出力が好きな人のために、Kaiser-Meyer-Olkin KMO検定として知られるファクタリングの妥当性の尺度は、KMO関数を使用して相関行列またはデータ行列から見つけることができます。  同様に、Bartlettの球形度検定もcortest.bartlett関数を使用して求めることができます。分散を説明するオブジェクトを持ちたい人のために、これはprint関数によって見えないように返されます。  (e.g., p <- print(fa(ability))$Vaccounted ).  これはfa関数でも同様に返されるようになりました(例: p <- fa(ability)$Vaccounted )。  共産性がパターン %*% t(Structure)の対角によって見つけられるように、説明される分散も対角( t(Structure) %*% Pattern.)によって見つけることができます。  SS負荷量と呼ばれることに注意してください。print.psych.fa関数の出力は、因子負荷量（パターン行列から）、h2（共同性）、u2（一意性）、com（その変数の因子負荷量の複雑さ（下記参照））を表示します。  直交解の場合，h2 は単に因子負荷量の2乗の行和である．しかし，斜め解の場合，それは直交因子負荷量の行和である（回転や変換は共同性を変えないことを覚えておいてほしい）．  マウスから得られた複数のインピュテーションデータセットを結合したいというAsghar Minaeiからのリクエストに応えて、fa.pooledが追加されました。  別々のデータセットがリスト（データセット）にまとめられ、それが別々に因数分解される。各解はリストの最初のセットに向かって回転される。  fa.sapaはSAPA(Synthetic Aperture Personality Assessment)を行うプロセスをシミュレートする。  これは、データセットの分数（frac）の連続したランダム標本について反復解を行います。これにより、様々なサンプルサイズと様々なサンプルレートに対する解の安定性を見つけることができます。反復回数(n.iter)とサンプリングされたデータの割合(frac)を指定する必要があります。  
fa.results$loadingsは、ソートされたloadingsに置き換えられます。fa.organizeは、因子分析またはコンポーネント出力を受け取り、oの順序で因子を再編成します。項目はi順に整理される。  flipオプションは行列入力の場合にのみ機能し、完全なfaオブジェクトには機能しません。reflect関数を使用する。
faとprincipalで使用される適合度検定を1つの関数に統合。  行列が特異な場合、適合関数を求める前に相関行列を平滑化します。SEM関数と同様に、RMSEA（近似の二乗平均平方根誤差）とアルファ信頼区間を求めます。  カイ2乗は2つの方法で求められます。  1つ目（STATISTIC）は、最尤目的関数（下記参照）から適合度検定を適用します。  これは多変量正規性を仮定する。  もう1つは、観察された残差相関行列と各相関の観察された標本サイズに基づく経験的カイ2乗です。  これは、残差相関の2乗と標本サイズを合計することによって求められます。  
irt.faは、項目応答分析のプロセスを簡単にするために、いくつかの関数を1つにまとめたものです。  相関は、テトラコリックまたはポリコリックのいずれかを使用して求められます。  そして、すべての正規オプションを用いた探索的因子分析がfaを使って行われます。  そして、その結果は、IRTパラメータ（困難度と識別度）の観点で報告されるように整理され、より従来の因子分析のアウトプットと同様になります。さらに、相関ステップはやや時間がかかるので、最初のステップで発見された相関行列を用いて再分析を行うことができる。  この場合，fm="minchi" 因子分解法を使用したい場合，オブザベーションの数は， pairwiseCount から得られる行列として指定される必要がある．二項項目の四項相関行列は，（たとえば）最小残差因子分析関数fa を使用して因子分解され，結果の負荷量λ_i は，a = λ / (sqrt(1-λ^2))によって判別に変換される．難易度パラメータδは、テトラコロリックまたはポリコロリック関数のτパラメータから求められます。δ = τ / (sqrt(1-λ^2)同様の分析は、ポリコロリック相関と各項目応答に対する項目難易度（位置）の個別の推定値を用いて、離散項目応答で行うことができます。結果は、2値項目の場合はlink{plot.irt}を、多値項目の場合はlink{plot.poly}を用いてグラフィカルに表示することができます。  これらは、irt.fa出力をプロットすることによって呼び出されます。）   type="IIC "は項目情報関数をプロットし、type="test "はテスト情報関数をプロットします。  type="IIC "は項目特性応答関数をプロットし、type="test "はテスト情報関数をプロットします。プロット関数からの不可視出力は、特性のいくつかのレベルの関数としての項目情報の表、およびそれらの各レベルでの測定の標準誤差と信頼性を返します。  しかし、相関行列がすでにテトラコリック、ポリコリック、またはirt.faを使用した以前の分析で求められている場合は、その結果を直接処理することができます。  irt.faは分析からrho行列とtau行列を保存するので、入力が最初の実行で返されたオブジェクトであれば、同じデータセットのその後の分析ははるかに速くなります。  同様の機能はomegaにもあります。出力はグラフィック表示で見るのが最適です。  irt.faの出力をプロットして、アイテムとテスト情報の関数を見る。  print関数は、項目の位置と識別を表示します。  irt.select関数は、さらなる分析のために先行分析のサブセットを選択できるようにするヘルパー関数です。まずirt.faを実行し、その後のirt.fa分析で分析する変数のサブセットを選択します。  より良い方法は、プロットして選択した項目の情報を見つけることでしょう。  irt.faオブジェクトのプロット関数は、ICC（項目特性曲線）、IIC（項目情報曲線）、またはテスト情報曲線をプロットします。また、"keys "オプションを使用することで、選択した項目に対してこれら3種類のプロットを行うことができます。これは、長い形式の因子分析に基づいて、短い形式のテストの情報特性を見ようとするときに、特に便利です。プロット機能は、各項目の情報のピークの位置だけでなく、特性の複数のレベルでの情報量、平均情報量（曲線の下の面積）も（見えないように）返します。  これらを印刷したり、印刷のソート・オプションを使ってソート順に印刷することができる。
マルチレベル・データは、心理学研究では一般的です。マルチレベル・データでは、オブザベーションは、ある上位レベルのグループ化変数に入れ子になっている被験者について取られます。  データは実験的（参加者は実験条件に入れ子になっている）かもしれないし、観察的（学生は教室に、学生は大学の専攻に入れ子になっている）かもしれない。この種のデータを分析するには、ランダム効果モデルや混合効果モデル、より一般的にはマルチレベル・モデルを使用します。  少なくとも2つの非常に強力なパッケージ（nlmeとmultilevel）があり、階層（マルチレベル）データ構造の複雑な分析を可能にします。  data.frameまたは行列(data)のグループ変数(group)について、基本的な記述統計量(mean, sd, n)とグループ内相関(cors=TRUE)が各グループについて求められます。  全分散と比較したグループ化変数に関連する分散量は、第1種クラス内相関 (ICC1):ICC1 = (MSb-MSw)/(MSb + MSw*(npr-1))ここで npr は、各グループ内のケースの平均数です。群間差の信頼性は、平均が群内変動に関してどれだけ異なるかを反映するICC2によって求めることができる。  ICC2=(MSb-MSw)/MSb.平均2乗間は標本サイズに敏感なので，この推定も標本サイズを反映する．おそらく，statsByの最も有用な部分は，変数間の観察された相関を2つの部分に分解することである：グループ内相関とグループ間相関．これは、Pedazur (1997)やマルチレベル・パッケージのBlieseによって議論された、観測された相関をグループ内のプール相関(rwg)とグループ間の平均の重み付き相関に分解することに従います。* eta_{y_{wg}}x_{wg}} * r_{xy_{wg}}  + eta_{x_{bg}} * eta_{x_{bgx_{bg}} * eta_{y_{bg}}* r_{xy_{bg}}ここで、r_{xy}は正規相関で、グループ内相関r_{xy_{wg}}とグループ間相関r_{xy_{bg}}に分解でき、etaはグループ内値、つまりグループ平均とのデータの相関である。  つまり、「生態学的相関」（グループ間相関）から低レベル（グループ内）相関を推論することは不適切である。  しかし、より高いレベルで推論を行うのであれば、これらのグループ間相関は依然として非常に意味のあるものである。  グループ間にプールされたグループ内相関を求めるには、実際には2つの方法がある。  すべてのグループ内の相関を求め、それらを標本サイズで重みづけして、このプール値（pooled）を報告することができます。  これはcorsオプションをTRUEに設定すると得られます。  これは論理的には、標本サイズで重み付けしたメタ分析相関を行うことと同じです。  もう1つの方法rwgは、各被験者のスコアがグループ平均からの偏差スコアとして与えられるとき、共分散、分散、したがって相関を考慮します。  四分位相関、多分位相関、または混合相関を発見した場合、これらの2つの推定値は異なります。weightsパラメータが指定された場合、プールされた相関は、標本サイズではなく、指定された重みでグループを重み付けすることによって求められます。r_{xy_{wg}}, pwgの信頼値と有意性は、グループ内のプールされたケース数を反映しますが、r_{xy_{bg}} , pbgは、グループ内のプールされたケース数を反映します。pbg} , グループの数。sim.multilevelは、マルチレベル構造のシミュレーションデータを生成します。statsBy.boot関数は、グループ化変数ntrialsを何回も無作為化して、statsBy出力を求めます。  これには長い時間がかかり、大量の出力が得られます。  この出力は、statsBy.boot.summary 関数で目的の変数を指定して、関連する変数について要約することができます。  この2つの関数は、単なるグループ分けが大きなグループ間相関をもたらすかどうかを調べるのに便利です。データを教育水準でグループ分けした場合のさまざまな能力テスト間の関係（statsBy(sat.act, "education"）、または影響度データを影響度操作内と操作間で分析した場合（statsBy(flat,group="Film")）を考えてみましょう。）faByはstatsByの出力を使って、各グループ内の相関行列の因子分析を行います。freeパラメータがFALSEの場合、各解は（可能な限り）グループ解に向かって回転されます。  出力は、各因子解のリストと、すべてのグループの負荷量と因子間相関の要約行列です。
因子分析は，相関行列または共分散行列をより小さいランクのもので近似する試みである．  基本的なモデルは，nRn = nFk kFn' + U2 (kはnよりずっと小さい)である．因子分析を行うには多くの方法があり，最尤法はおそらく最も一般的に好まれる方法であろう(factanalを参照)．  一意性の存在は，因子分析を主成分分析（例えば，プリンシパル）と区別するものである．変数が「真の」または潜在的な部分を表すと考えられる場合，因子分析は，データを表す潜在因子（複数可）との相関の推定を提供する．  変数が誤差なく測定されると考えられる場合，主成分は，データの最も簡潔な記述を提供する．  因子負荷量は，後者が各変数の固有誤差を反映するため，成分負荷量よりも小さくなる．因子解の対角外残差は，成分モデルのそれより優れている（小さい）．  因子負荷量は，各因子に負荷される変数の数が増加するにつれて，漸近的な成分負荷量として考えることができる．  主軸因子分析は、探索的分析で長い歴史があり、簡単な手順です。  連続した固有値分解は，∑(diag(FF'))が（あまり）変化しなくなるまで，対角をdiag (FF')で置き換えた相関行列で行われる．  現在のmax.iter =50の制限は、ほとんどの問題に対して有効のようですが、Holzinger-Harmonの24変数問題では、5因子解の収束に約203回の繰り返しが必要です。  主軸を行うすべての因子プログラムが反復解を行うわけではありません。  SASのマニュアル（第33章）の例はそのようなケースである。その解を得るためには、max.iter = 1と指定する必要がある。  その解と反復解（デフォルト）を比較すると、反復によって解が改善されることがわかる。さらに、fm="mle "は、この例でさらに良い解を生成します。  RMSEAと残差の二乗平均平方根の両方が、fm="pa "の解よりも小さくなっています。しかし、複数の問題セットのシミュレーションによると、fm="pa "は、fm="minres "やfm="mle "よりもRMSEAがわずかに大きく、残差がわずかに小さくなる傾向があります。    つまり、fm="pa "の残差の2乗和は、fm="minres "を使った場合よりもわずかに小さいようですが、RMSEAは、fm="pa "を使った場合の方がわずかに悪いのです。  つまり、"真の "最小残差は、おそらくfm="pa "によって発見される。Hao WuとMikko Ronkkoとの広範なやりとりを経て、2017年4月、minresとuls)フィッティングの導関数が修正された。  これは、以前の手順よりもわずかに小さな残差（残差を最小化すると主張する方法としては十分に適切）をもたらす。  以前の分析との一貫性を保つために、これらのわずかに大きな残差を与える "old.min "が追加された。  old.minと新しい "minres "および "ols "解との差は、小数点以下第3位から第4位であるが、それでも注目に値する。比較のために、fm="ols "は経験的一次導関数を使用し、ulsとminresは方程式ベースの一次導関数を使用する。  結果は同じように見えますが、minresとulsの解は、より大きな問題に対してより少ない反復を必要とし、より高速です。Hao Wuに感謝する。  通常、これらの様々なアルゴリズムは同等の結果を出すが、手法間の大きな違いを示すデータセットがいくつか含まれている。SchutzはHeywoodとsuper Heywoodのケースを生成し、blantは非常に異なる解を導く。  特に、minres解は、mle解よりも小さな残差を生成し、factor.congruence係数は、非常に異なる解を示す。MLEを使用することに反対する非常に強い議論は、OLSアプローチがほとんどの時間で同等の解を生成し、いくつかの時間ではより良い解を生成することを示すMacCallum, Brown and Cai (2007)の章にある。  これは特に、モデル化されていない小因子を持つモデルの場合です。  (fm="minres "も同様で、より良い（RMSEAがより小さい）解を出す傾向があります。fm="minchi "オプションは、"minres" (ols)解のバリエーションで、残差だけでなくサンプルサイズ重み付き残差を最小化します。これは、SAPAプロジェクトで発生するMassively Missing Completely at Random (MMCAR)というデータの問題を取り扱うために開発されました。因子分析の伝統的な問題は、収束を早めるために、元の共分散性の最適な推定値を見つけることでした。  各変数について自乗重相関（SMC）を用いると、元の共分散性が過小評価され、1を用いると過大評価されます。  デフォルトでは，SMC推定が使用される．  非可逆行列の場合，擬似逆行列が見つけられるので，SmCはまだ推定されることに注意．いずれの場合も、反復技法は安定解に収束する傾向があります。しかし、解が得られない場合は、ones (SMC =FALSE)を使って再試行するのが有効である。  反復主軸アルゴリズムは，（最尤基準によって定義される）最良の解を見つけようとはせず，むしろ，連続する固有値分解を用いて，急速に収束する解を見つけようとする．  適合の最尤基準および関連するカイ2乗値が報告され、最尤手順を使用して発見されたものより（少し）悪くなります。最小残差（minres）解は、少し異なるアプローチをとる重み付けなしの最小2乗解です。  これはoptim関数を使用し、因子モデルが縮小行列の固有値分解である場合、2乗残差を最小化するように相関行列の対角要素を調整します。  MINRESとPAは、行列が特異である場合に使用できるため、MLが機能しない場合に機能します。導関数の変更前は、MINRES解はPA解よりもML解に若干似ていました。MINRESの導関数の変更により、MINRES、PA、ULSの解は実質的に同じになりました。minres解とwls解は、導関数の変更に伴うファクトナル関数のアイデアにほぼ従っている。重み付き最小2乗（wls）解は、相関行列の逆行列の1/対角で残差行列を重み付けします。  これは，共分散性の低い項目を共分散性の高い項目よりも重みづけする効果がある．一般化最小2乗（gls）解は，相関行列の逆行列で残差行列を重みづけする．  最尤法は、さらに別のアプローチをとり、カイ2乗適合度検定を最小化するような共同性の値を見つけます。  fm="ml "オプションは、factanalで使用されている手順に従って最尤解を提供しますが、その関数のすべての追加機能を提供しません。  最小順位因子モデル（MRFA）は、Shapiro and Ten Berge (2002)とTen Berge and Kiers (1991)の考えにほぼ従います。  これは、Andreas Moltnerによって貢献されたglb.algebraic手順を利用します。  MRFAは、残差行列が依然として正半定値であるような因子の抽出を試みます。  アルファ因子分析は、共同体性を補正した相関行列に基づいて解を求め、それらを元の相関行列に再スケーリングします。  この手順はKaiser and Coffey, 1965によって記述されています。  出力をSPSSと比較したテストケースでは、PAアルゴリズムはSPSSがulsと呼ぶものと一致し、wls解はその適合において同等であることが示唆されています。wls解とgls解は、固有値がわずかに大きいが、minres解や最尤解よりも対角残差の適合がわずかに悪い。  Harman(1976)の例と結果を比較すると、反復なしのPA解は、HarmanがPrincipal Axesと呼ぶもの（SASと同じ）に一致し、反復PA解は、彼のminres解に一致します。  psychで発見されたminres解は、反復PA解よりも対角外残差がわずかに小さい傾向があります（そうあるべきです）。   項目については、顕著な項目をスコアリングして（例えば、scoreItemsを使用して）因子スコアを見つけることが典型的ですが、因子スコアは、他のいくつかの手段と同様に、回帰によって推定することができます。可能なアプローチは複数あり(Grice, 2001を参照)，ここで取り上げた1つはtenBergeらによって開発されたものである(factor.scoreを参照)．Factanalにマッチする代替は，回帰を使用してスコアを見つけることである - Thurstoneの最小2乗回帰（ここで，重みは，W = inverse(R)S によって見つけられる．  斜交ケースでは，因子負荷量はパターン係数と呼ばれ， S = P Phi によって構造係数に関係し，したがって， P = S Phi^-1 である．  因子スコアを推定するとき，faとfactanalは，faが構造行列から因子を見つけるのに対して，factanalはパターン行列から見つけるという点で異なる．  したがって，直交の場合，faとfactanalは因子スコアの推定において完全に一致するが，斜め因子の場合には一致しない．  oblique.scores = TRUEに設定すると、factanalの推定値と一致する因子スコアが得られます。因数分解されなかった変数に因子解を拡張することが有用な場合があります。  これは、fa.extensionを使用して行うことができます。因子拡張は通常、いくつかの変数が因数分解するのに適切でなかったが、元の因子への因子負荷量がまだ必要な場合に行われます。  因子拡張は，因子スコアを使用せずに因子-基準相関を求めることができるという点で，とても強力な手続きである．2値項目または多値項目については，ピアソン相関よりもむしろ4値相関または多値相関を分析することが推奨される．これは，データに2値変数，多値変数，および連続変数が混在している場合， cor="poly" または cor="tet" または cor="mixed" を指定することによって行うことができる．  2値または多値データの分析は、irt.faを使用するか、単にcor="poly "オプションを設定することによっても行うことができる。  最初のケースでは、因子分析の結果は項目応答理論（IRT）の用語で報告されますが、元の因子解が結果に返されます。後者の場合、典型的な因子負荷量行列が返されますが、irt.faによる再分析のために、四分位/多分位相関行列と項目統計量が保存されます（連続項目、二分位項目、多分位項目の混合から相関を求めるmixed.cor関数も参照してください）。様々な回転/変換オプションのうち、varimax、Varimax、quartimax、bentlerT、geominT、bifactorは直交回転を行います。oblimin、quartimin、simplimax、bentlerQ、geominQ、biquartiminは斜め変換です。これらのほとんどは、GPArotationパッケージを呼び出すだけである。cluster "オプションは、varimax解のクラスター表現によって定義された構造に対して、的を絞った回転を行います。  オプションの "keys "パラメータを指定すると、"target "オプションは、キー行列として与えられたターゲットに回転する。(target.rotを参照)obliminは、GPArotationではδ=0のquartiminの呼び出しによって実装されています。これは、人々がquartimin解を参照する際に混乱を招きます。因子回転に関する汚い小さな秘密に注意することは重要である。  それはローカルミニマムの問題である。  回転アルゴリズムの複数回の再起動が強く推奨されている（Nguyen and Waller, N. G. 2021を参照）。GPArotationの呼び出しにより、さらに2つのターゲット回転オプションが利用できる。  これらはMichael BrowneのtargetQ（斜め）とtargetT（直交）ターゲット回転である。  詳細は target.rot を参照。bifactor "回転は、GPArotationパッケージのGPForth関数を呼び出し、JennrichとBentlerのMatLabコードから適応した2つの関数を使用することで、JennrichとBentler（2011）のbifactor回転を実装しています。  これにはローカル・ミニマムの問題があるようで、複数の開始値を使用する必要があります。  1つは、GPArotationパッケージのVarimaxで、デフォルトではカイザー正規化を適用しません。  もう1つは、statsパッケージのvarimaxで、これは適用されます。  正規化が設定されていても、2つの回転関数はわずかに異なる結果を生成するようです。他の回転関数との一貫性を保つためには、おそらく Varimax の方が好ましいでしょう。これらのオプションのすべてから回転行列（rot.mat）が返されます。これは GPArotation パッケージが返す Th (theta?) オブジェクトの逆行列です。  因子の相関は、Phi = Th' Thで求めることができます。2値または多値の回答を扱う2つの方法があります：通常の因子分析出力と同様に4値または多値の相関行列を返すcor="poly "オプション付きのfaと、通常のfa出力と同様に2つのパラメータirt分析を返すirt.faです。2値または多値の回答を持つ項目を因子分析する場合、irt.fa関数は因子出力の項目応答理論表現を提供します。fa.polyは非推奨で、その機能はcor="poly "を設定することで実現できます。  fa.polyは通常の因子分析出力を生成しますが、その後のirt分析のために多項式行列(rho)と項目困難度(tau)を保存します。fa.polyはデフォルトで、データが利用可能であれば因子スコアを求めます。  相関はテトラコロリックまたはポリコロリックのいずれかを用いて求められ、その後この行列が因数分解されます。  fa関数は、データのブートストラップ標本（存在する場合）または観測された相関行列に基づくシミュレートされたデータセットに対して、分析をn.iter回繰り返します。  推定値の平均と標準偏差が返され、元の因子分析と推定係数のアルファ値信頼区間が表示されます。  ブートストラップされた解は、target.rotを使用して元の解に向かって回転されます。因子負荷量はz変換され、平均化され、そして逆変換されます。これは、Heywood のケースの誤差につながります。  より良い代替案は、ブートストラップされた平均値を見つけ、観測された値の範囲に基づいて信頼区間を見つけることです。デフォルトは、n.iter =1であり、ブートストラップは行いません。多値項目または2値項目を使用する場合、irt.fa関数を使用して、fa.polyで報告された因子負荷量と等価な項目反応理論パラメータを見つけることが、おそらくより有用です。  ペアワイズ削除を使用したり、テトラコーリックまたはポリコーリック行列から生じるいくつかの相関行列は、適切ではありません。  つまり、正の半正定値（すべての固有値 >= 0）にはなりません。  cor.smooth関数は、すべての負の固有値を0より少し大きくして相関行列を調整し（平滑化し）、その他の固有値を変数数の合計になるようにスケーリングし直し、相関行列を再作成します。  burtデータセットを使ったこの問題の例については、cor.smoothを参照してください。tetrachoricsやpolychoricsを使った場合のこの問題の原因の1つは、連続性の調整にあるようです。  SPSSタイプの出力が好きな人のために、Kaiser-Meyer-Olkin KMO検定として知られるファクタリングの妥当性の尺度は、KMO関数を使用して相関行列またはデータ行列から見つけることができます。  同様に、Bartlettの球形度検定もcortest.bartlett関数を使用して求めることができます。分散を説明するオブジェクトを持ちたい人のために、これはprint関数によって見えないように返されます。  (e.g., p <- print(fa(ability))$Vaccounted ).  これはfa関数でも同様に返されるようになりました(例: p <- fa(ability)$Vaccounted )。  共産性がパターン %*% t(Structure)の対角によって見つけられるように、説明される分散も対角( t(Structure) %*% Pattern.)によって見つけることができます。  SS負荷量と呼ばれることに注意してください。print.psych.fa関数の出力は、因子負荷量（パターン行列から）、h2（共同性）、u2（一意性）、com（その変数の因子負荷量の複雑さ（下記参照））を表示します。  直交解の場合，h2 は単に因子負荷量の2乗の行和である．しかし，斜め解の場合，それは直交因子負荷量の行和である（回転や変換は共同性を変えないことを覚えておいてほしい）．  マウスから得られた複数のインピュテーションデータセットを結合したいというAsghar Minaeiからのリクエストに応えて、fa.pooledが追加されました。  別々のデータセットがリスト（データセット）にまとめられ、それが別々に因数分解される。各解はリストの最初のセットに向かって回転される。  fa.sapaはSAPA(Synthetic Aperture Personality Assessment)を行うプロセスをシミュレートする。  これは、データセットの分数（frac）の連続したランダム標本について反復解を行います。これにより、様々なサンプルサイズと様々なサンプルレートに対する解の安定性を見つけることができます。反復回数(n.iter)とサンプリングされたデータの割合(frac)を指定する必要があります。  
因子相関は、Gorsuch (1983)によって議論されたアプローチを使用して求められ、w=S R^{-1}とr = w' R wによって求められる重み行列を使用します。F1 と F2 の因子負荷ベクトルについて、因子一致性の尺度 phi は {phi = sum(F1 F2)/sqrt(sum(F1^2) sum(F2^2))}であり、factor.congruence.For 1 から n までの因子解の比較でも見つけられる。この関数は、同じ相関/データ行列からの2つの解を比較するだけです。 factor.congruenceは、因子負荷量の任意の2つのセットを比較するために使用できます。tenBergeは、因子得点の因子相関を維持する重みを生成します。
因子負荷量の2つのセットの間の因子一致係数を求めます．因子一致は，負荷量行列によって定義され，原点を基点とするベクトルの対の余弦である．  したがって，スケーラー（たとえば，固有値のサイズ）によってのみ異なる負荷量について，因子合同は1になる．F1とF2の因子負荷量ベクトルについて，因子合同，phiの尺度は， phi = sum(F1 F2)/sqrt(sum(F1^2) sum(F2^2)) 因子合同を因子負荷量の相関と比較することは，興味深いエクササイズである．  因子合同は生のクロス積に基づくが，相関は中心化されたクロス積に基づく．つまり、因子負荷量の相関は、各因子の平均負荷量に基づくベクトルの余弦である。 phi = sum((F1-a)(F2-b))/sqrt(sum((F1-a)^2) sum((F2-b)^2)) .合同係数については、 a = b= 0. 相関については、 a = 平均 F1, b = 平均 F2.2つ以上の解を比較するために，x は行列のリストで，それらすべてが比較される．通常，すべての因子負荷行列は完全であるべきである（欠落した負荷量を持たない）．  データがゼロ中心の場合、これは相関であり、データが尺度の中間点(M)を中心とする場合、これはコーエンの類似度係数である。  例を参照。Mが指定されていない場合は、xとyの項目の中点として求められる。cohen.profileは、Mを中心としたデータに一致関数を適用する。Mは指定することもできるし、データから求めることもできる。distanceはrの関数として一般化された距離を求めます。city block (r=1)、Euclidean (r=2)、weighted towards maximimum (r >2)。
適合指標は、おそらく心理測定者の数だけある。  この適合度は、因子モデルが与えられたときの相関行列の削減量のもっともらしい推定値である。  元の相関の大きさに敏感であることに注意してください。  つまり、残差が小さくても元の相関が小さければ、それは悪い適合です。R*= R - FF'fit = 1 - sum(R*^2)/sum(R^2) とする。和は対角要素から外れた部分についてとります。
これらの古い関数のすべての機能については、faの書き込みを参照してください。
NA
これらの古い関数に含まれるすべての機能については、fa の記述を参照してください。
因子分析またはクラスター分析の結果がプロットされている。  各項目は、最も負荷の高い因子に割り当てられ、変数名とクラスタ（色）で識別されます。クラスターの割り当ては、負荷による自動クラスタリングを上書きするように指定することができます。これらの関数は両方とも、直接呼び出すか、汎用 plot 関数を呼び出すことによって呼び出すことができます。  (例を参照)。
基本因子方程式は nRn = nFk kFn' + U2 です。残差はR* = R - F'Fです。残差は，因子分析の妥当性を理解するために調査されるべきである（しかし，実際にはおそらくめったに調査されない）．  因子分析または主成分分析を行う場合，通常，残差がランダム行列から期待される残差と異ならないまで，因子/成分を抽出し続ける．
factor.rotateは，回転がどのように機能するかのデモンストレーションとしての意味もあり，GPArotationのようなより高度なパッケージでは利用できない特定の回転を必要とする場合に有用である．  plot オプションを TRUE に設定すると，元の軸が破線で表示される．
因子分析モデルは構造レベルでは定義されているが、データレベルでは未定義である。  これは因子分析のよく知られた問題であるが，あまり議論されていない．  因子スコアは，変数の共通部分の推定を表し，因子そのものと同一であると考えるべきではない．因子がアイスクリームのコーンの中心に突き刺さったチョップ・スティックと考えられ、因子スコアの推定値がコーンの縁に沿ったストローで表されるとすると、因子の不確定性の問題が明らかになります。(イメージはNiels Wallerから引用し、Stanley Mulaikから脚色した）。因子スコアの不確定性の問題についての非常に明確な議論の中で，Grice (2001) は，因子スコアを推定するいくつかの代替方法をレビューし，相関のない因子スコア推定値を生成する重み付けスキームと，粗いコード化された（単位重み付けされた）因子重みを使用する効果を検討している．  すべての場合において，因子スコアの推定は，データ行列Xに観測された変数に重み付けをする重み付け行列Wを掛けたものに基づいている．多値データまたは2値データの場合，因子スコアは項目反応理論のテクニックを使って推定することができる（例えば，link{irt.fa}を使い，次にlink{scoreIrt}を使う）．  method="Thurstone "は回帰ベースの重みを求めます：method="tenBerge" は、斜め解の因子間の相関が保存されるような重みを見つけます。L=FΦ^(1/2)C=R^(-1/2)L(L'R^(-1)L)^(-1/2)W=R^(-1/2)CΦ^(1/2) method="Anderson "は、因子スコアが無相関になるような重みを求める：W = U^{-2}F (F' U^{-2} R U^{-2} F)^{-1/2} ここで U は一意性の対角行列。方法="Bartlett" は、 W = U^{-2}F (F' U^{-2}F)^{-1} 方法="Harman" は、いわゆる "理想化された "変数に基づいて重みを求める：method="components" は，成分負荷量だけの重みを使用する．  
