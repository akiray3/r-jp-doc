x
単項演算子および二項演算子はジェネリック関数です:メソッドは個別に、またはOpsグループジェネリック関数を通して書くことができます(ディスパッチの計算方法についてはOpsを参照してください)。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、結果は配列になります(例えば、リサイクルルールが起動された場合はなりません)。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型に対する算術演算は、'round to nearest, ties to even'モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
数値ベクトルとして指定する場合、xは整数である必要はありませんが、Datesのヘルプの小数日に関するコメントを参照してください。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）の開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
二項演算子 : には2つの意味があります: 因子a:bに対してはinteraction(a, b)と等価です（ただし、レベルの順序とラベルは異なります）。  数値以外の引数は、内部的に数値に強制されます(そのため、ディスパッチメソッドがありません)。
pkgパッケージの場合、pkg::nameは名前空間pkgにexportedされた変数名の値を返し、aspkg::nameは内部の変数名の値を返します。  pkg::nameは、(パッケージの名前空間がアタッチされるまで存在しない)環境パッケージpkg内のオブジェクトにはアクセスしないことに注意してください。  また、レイジーローディングによって利用可能になったデータセットにアクセスすることもできます。
pkg パッケージの場合、pkg::name は名前空間 pkg でエクスポートされた変数名の値を返し、aspkg:::name は内部の変数名の値を返します。  pkg::nameは、(パッケージの名前空間がアタッチされるまで存在しない)環境パッケージpkg内のオブジェクトにはアクセスしないことに注意してください。  レイジーローディングによって利用可能になったデータセットにアクセスすることができます。
と && は論理 AND を、 | と || は論理 OR を表します。  短縮形は、算術演算子とほぼ同じ方法で要素間の比較を行う。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、ゼロは偽、ゼロ以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (ディスパッチの計算方法についてはOpsを参照してください。)NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
クラス "hexmode "は、単に16進数で出力されることを保証するためだけに使用される、そのクラス属性を持つ整数ベクトルから構成されます。width = NULL（デフォルト）の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-f（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  サブセット([)も動作します。width = NULL (デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数(integer型またはdouble型)と、要素が0〜7桁のみ(またはNA)を含む文字ベクトルをクラス "octmode "に変換することができます。
バイナリ比較演算子はジェネリック関数です。メソッドは個別に書くこともできますし、Opsグループのジェネリック関数を介して書くこともできます。  (ディスパッチの計算方法についてはOpsを参照してください。)文字ベクトル内の文字列の比較は、使用するロケールの照合順序seelocalesを使用して文字列内で辞書式に行われます。  en_USのようなロケールの照合順序は、通常C（ASCIIを使用する）と異なるため、驚くことがある。  例えば、エストニア語ではZはSとTの間にあり、照合順序は必ずしも文字単位とは限りません。ウェールズ語ではngはシングルソート単位であるかどうかはわかりません。  プラットフォームによってはロケールを無視し、8ビットロケールでは常にバイトの数値順、UTF-8ロケールではUnicodeのコードポイント順でソートすることがあります（同じ言語でも文字セットが異なると同じ順でソートされないことがあります）。  文字以外のもの（空白、句読点、ハイフン、分数など）の照合は、さらに問題があります。文字列は、異なるマーク付けされたエンコーディング（エンコーディングを参照）で比較することができます：比較する前にUTF-8に変換されます。生のベクトルは、実際には順序を持っていると考えるべきではありませんが、バイト表現の数値順序が使用されます。xとyの少なくとも一方はアトミックベクトルでなければならないが、もう一方がリストの場合、Rはそれをアトミックベクトルの型に強制しようとする：リストが正しい型に強制できる長さの要素で構成されていれば、これは成功する。2つの引数が異なる型の原子ベクトルである場合、一方は他方の型に強制され、優先順位は（小さい順に）文字、複素数、数値、整数、論理、rawとなります。欠損値（NA）とNaN値は、それ自身に対しても比較不可能とみなされるため、これらの値を含む比較は常にNAとなります。  また、文字列を比較したときに、その文字列が現在の照合ロケールで有効でない場合にも欠損値が発生する可能性があります。シンボルやコールなどの言語オブジェクトは、比較の前に文字列にデパースされます。
NA
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを処理するメソッドを書くことができます。[.data.frame]や[.factor.InternalMethods]を参照してください。  ここでの説明は、既定のメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち高い方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が結果として返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
関数 I には 2 つの主な用途があります。関数data.frameにおいて。  I は、データ・フレームに追加されるオブジェクトや、as.data.frame を介してデータ・フレームに変換されるオブジェクトを保護するためにも使用できます。  クラス "AsIs "は、for [, as.data.frame,printとformatを含むいくつかの独自のメソッドを持っています。関数式では。  そこでは、"+", "-", "*", "^"といった演算子を数式演算子として解釈することを禁止するために使用されます。  これはterms.formulaによって記号として解釈される。
データ・フレームはいくつかのモードでインデックスを付けることができる。  と[[ が1つのベクトル添字（x[i]またはx[[i]]）と一緒に使用されると、あたかもリストのようにデータフレームに添字を付けます。  この使い方では、drop引数は警告とともに無視されます。$用のdata.frameメソッドは存在しないので、x$nameはxをリストとして扱うデフォルトのメソッドを使用します（一致する列名が一意であれば、列名の部分一致を行います。）  ($の)replacementメソッドは、値が正しい行数であるかどうかをチェックし、必要であればそれを複製します。[]と[[]を2つの添字(x[i, j]とx[[i, j]])で使用すると、行列の添字のように動作します：  [は、1つの要素を選択するために使われる。  もし[]がデータフレームを返すのであれば、それは一意な(そして欠落のない)行名を持ち、必要であればmake.uniqueを使って行名を変換します。  同様に、カラムが選択された場合、カラム名は必要に応じて一意に変換されます (例えば、カラムが複数回選択された場合、カラム名は一意に変換されます)、この場合、列はデータフレームの右端に追加され、数値インデックスは既存のインデックスと連続しなければなりません。  その場合、列はデータフレームの右端に追加され、数値添字は既存の添字と連続しなければならない。一方、行は現在の最終行の後の任意の行に追加することができ、列は欠損値で埋められる。  置換値はリストとすることができます: リストの各要素は、必要に応じてリストを再利用しながら、1つの列の置換(の一部)に使用されます。  番号で指定された列が作成される場合、対応するリスト要素の名前（もしあれば）が列の名前として使用されます。  置換が行を選択しない場合、リストの値にNULL要素が含まれることがあり、その場合は対応する列が削除されます。  (例題を参照のこと。) [ を使用した行列インデックス(x[i]に論理または2列の整数i)は推奨されない。  抽出の場合、xはまず行列に強制されます。置換は一度に1列ずつ行われ、複数回の型強制が行われる可能性がある。  デフォルトではどちらも列名に部分的にマッチしませんが、[[は exact = FALSE の場合にマッチします (exact = NA の場合は警告が表示されます)。  行名に完全一致させたい場合は、例のようにematchを使用します。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。多くのメソッドの中から、いくつかのメソッドについては個別にドキュメント化されています。
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  format メソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを処理するメソッドを記述することができます。[.data.frame および [.factor.Index] と同様に InternalMethods を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち大きい方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnames は適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が返されます。サブセット・テーブルではないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
これは、DLL を管理する内部テーブルに問い合わせます。
未使用のレベルが削除されると、残りのレベルの順序は保持されます。value が levels(x) にない場合は、警告とともに欠落値が割り当てられます。
クラス "hexmode "は、単に16進数で出力されることを保証するために使用される、そのクラス属性を持つ整数ベクトルから構成されます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-f（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができます。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち大きい方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が結果として返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
noquote は、引数を "noquote" クラスのオブジェクトとして返します。  c() と subscriptmethod ("[.noquote") のメソッドがあり、サブセットによってクラスが失われないようにします。  printメソッド(print.noquote)は、文字列を引用符なしで表示します（"...... "は......と表示されます）。rightがprint(x, right=*)の呼び出しで指定された場合、xの可能なright設定（例えば、x <- noquote(*, right=TRUE)）よりも優先されます。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルから構成され、特に755のようなUnixライクなファイルパーミッションのために、8進数で表示されることを保証するためだけに使用されます。  width=NULL（デフォルト）の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数（"integer "または "double "型）と、要素が0〜7桁のみを含む（またはNAの）文字ベクトルをクラス "octmode "に変換することができます。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年始以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
これらの演算子は汎用的である。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち高い方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは逐次的に行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が結果として返されます。
引数dnnが指定されない場合、内部関数list.namesが呼び出されて'dimname名'が計算されます。  ...の引数に名前が付けられている場合は、その名前が使用されます。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、除外された値をカウントしないように注意されています（以前はNAcountに含まれていました）。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(warningが生成される時点)の最大値であり、デフォルトでは50であることに注意。  たとえば、options(warn)が変更された場合や、致命的なエラーが発生した場合などです。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]や[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち高い方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
データ・フレームには、いくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトル添字（x[i]またはx[[i]]）と一緒に使用されると、あたかもリストのようにデータフレームに添字を付けます。  この使い方では、drop引数は警告とともに無視されます。$用のdata.frameメソッドは存在しないので、x$nameはxをリストとして扱うデフォルトのメソッドを使用します（一致する列名が一意であれば、列名の部分一致を行います。）  ($の)replacementメソッドは、値が正しい行数であるかどうかをチェックし、必要であればそれを複製します。[]と[[]を2つの添字(x[i, j]とx[[i, j]])で使用すると、行列の添字のように動作します：  [は、1つの要素を選択するために使われる。  もし[]がデータフレームを返すのであれば、それは一意な(そして欠落のない)行名を持ち、必要であればmake.uniqueを使って行名を変換します。  同様に、カラムが選択された場合、カラム名は必要に応じて一意に変換されます (例えば、カラムが複数回選択された場合、カラム名は一意に変換されます)、この場合、列はデータフレームの右端に追加され、数値インデックスは既存のインデックスと連続しなければなりません。  その場合、列はデータフレームの右端に追加され、数値添字は既存の添字と連続しなければならない。一方、行は現在の最終行の後の任意の行に追加することができ、列は欠損値で埋められる。  置換値はリストとすることができます: リストの各要素は、必要に応じてリストを再利用しながら、1つの列の置換(の一部)に使用されます。  番号で指定された列が作成される場合、対応するリスト要素の名前（もしあれば）が列の名前として使用されます。  置換が行を選択しない場合、リストの値にNULL要素が含まれることがあり、その場合は対応する列が削除されます。  (例題を参照のこと。) [ を使用した行列インデックス(x[i]に論理または2列の整数i)は推奨されない。  抽出の場合、xはまず行列に強制されます。置換は一度に1列ずつ行われ、複数回の型強制が行われる可能性がある。  デフォルトではどちらも列名に部分的にマッチしませんが、[[は exact = FALSE の場合にマッチします (exact = NA の場合は警告が表示されます)。  行名に完全一致させたい場合は、例のようにematchを使用します。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  端数日は印刷時に無視されます。  methods(クラス = "Date")を参照してください。また、いくつかのメソッドは個別にドキュメント化されています。
未使用の水準が削除されると、残りの水準の順序は保持されます。valueがlevels(x)にない場合、警告とともに欠損値が代入されます。drop = TRUEでない限り、因子に代入されたコントラストは保持されます。
数値バージョンは1つ以上の非負整数のシーケンスで、通常（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年始以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、これまで27日は86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、これまで27日は86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
これらの演算子は汎用的である。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち大きい方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
データ・フレームはいくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトル添字（x[i]またはx[[i]]）と一緒に使用されると、あたかもリストのようにデータフレームに添字を付けます。  この使い方では、drop引数は警告とともに無視されます。$用のdata.frameメソッドは存在しないので、x$nameはxをリストとして扱うデフォルトのメソッドを使用します（一致する列名が一意であれば、列名の部分一致を行います。）  ($の)replacementメソッドは、値が正しい行数であるかどうかをチェックし、必要であればそれを複製します。[]と[[]が2つの添字(x[i, j]とx[[i, j]])で使用される場合、それらは行列の添字のように動作します：  [は、1つの要素を選択するために使われる。  もし[]がデータフレームを返すのであれば、それは一意な(そして欠落のない)行名を持ち、必要であればmake.uniqueを使って行名を変換します。  同様に、カラムが選択された場合、カラム名は必要に応じて一意に変換されます (例えば、カラムが複数回選択された場合、カラム名は一意に変換されます)、この場合、列はデータフレームの右端に追加され、数値インデックスは既存のインデックスと連続しなければなりません。  その場合、列はデータフレームの右端に追加され、数値添字は既存の添字と連続しなければならない。一方、行は現在の最終行の後の任意の行に追加することができ、列は欠損値で埋められる。  置換値はリストとすることができます: リストの各要素は、必要に応じてリストを再利用しながら、1つの列の置換(の一部)に使用されます。  番号で指定された列が作成される場合、対応するリスト要素の名前（もしあれば）が列の名前として使用されます。  置換が行を選択しない場合、リスト値にはNULL要素が含まれることがあり、対応する列は削除されます。  (例を参照のこと。) [ を使用した行列インデックス (x[i] を論理行列または2列整数行列 i で指定) は推奨されない。  抽出の場合、xはまず行列に強制されます。置換は一度に1列ずつ行われ、複数回の型強制が行われる可能性がある。  デフォルトではどちらも列名に部分的にマッチしませんが、[[は exact = FALSE の場合にマッチします (exact = NA の場合は警告が表示されます)。  行名に完全一致させたい場合は、例のようにematchを使用します。
未使用の水準が削除されると、残りの水準の順序は維持されます。value が levels(x) にない場合は、警告とともに欠損値が割り当てられます。
数値バージョンは1つ以上の非負整数のシーケンスで、通常（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
これらの演算子は汎用的である。  特定のクラスのオブジェクトのインデックスを扱うメソッドを書くことができます。[.data.frame]と[.factor.InternalMethods]を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち高い方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
データ・フレームには、いくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトル添字（x[i]またはx[[i]]）と一緒に使用されると、あたかもリストのようにデータフレームに添字を付けます。  この使い方では、drop引数は警告とともに無視されます。$用のdata.frameメソッドは存在しないので、x$nameはxをリストとして扱うデフォルトのメソッドを使用します（一致する列名が一意であれば、列名の部分一致を行います。）  ($の)replacementメソッドは、値が正しい行数であるかどうかをチェックし、必要であればそれを複製します。[]と[[]が2つの添字(x[i, j]とx[[i, j]])で使用される場合、それらは行列の添字のように動作します：  [は、1つの要素を選択するために使われる。  もし[]がデータフレームを返すのであれば、それは一意な(そして欠落のない)行名を持ち、必要であればmake.uniqueを使って行名を変換します。  同様に、カラムが選択された場合、カラム名は必要に応じて一意に変換されます (例えば、カラムが複数回選択された場合、カラム名は一意に変換されます)、この場合、列はデータフレームの右端に追加され、数値インデックスは既存のインデックスと連続しなければなりません。  その場合、列はデータフレームの右端に追加され、数値添字は既存の添字と連続しなければならない。一方、行は現在の最終行の後の任意の行に追加することができ、列は欠損値で埋められる。  置換値はリストとすることができます: リストの各要素は、必要に応じてリストを再利用しながら、1つの列の置換(の一部)に使用されます。  番号で指定された列が作成される場合、対応するリスト要素の名前（もしあれば）が列の名前として使用されます。  置換が行を選択しない場合、リストの値にNULL要素が含まれることがあり、その場合は対応する列が削除されます。  (例題を参照のこと。) [ を使用した行列インデックス(x[i]に論理または2列の整数i)は推奨されない。  抽出の場合、xはまず行列に強制されます。置換は一度に1列ずつ行われ、複数の型強制が行われる可能性がある。[[ と [[ の抽出メソッドはどちらも列名に部分的にマッチする。  デフォルトではどちらも列名に部分的にマッチしませんが、[[は exact = FALSE の場合にマッチします (exact = NA の場合は警告が表示されます)。  行名に完全一致させたい場合は、例のようにematchを使用します。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。多くのメソッドの中から、いくつかのメソッドについては個別にドキュメント化されています。
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、テキスト文字列として単位を追加します。
未使用の水準が削除されると、残りの水準の順序は維持されます。value が levels(x) にない場合は、警告とともに欠損値が割り当てられます。
数値バージョンは1つ以上の非負整数のシーケンスで、通常（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：不明な場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます（例を参照してください）。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が間違っている場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
NA
これらの演算子は、パッケージ・メソッドの正式なクラスをサポートしており、パッケージ・メソッドがロードされたときにのみ有効になります（デフォルト）。  オブジェクトがS4オブジェクトであることがチェックされ(isS4参照)、それ以外のオブジェクトに@を使おうとするとエラーになります。  (オブジェクトがS4オブジェクトであることがチェックされ（isS4参照）、それ以外のオブジェクトに@を使おうとするのはエラーになります（内部でのみ使用される名前.Dataには例外があります）。replacement演算子は、オブジェクトにslotがすでに存在しているかチェックします（オブジェクトが本当にそのクラスのものであれば、存在するはずです）。
これらの演算子はパッケージメソッドの正式なクラスをサポートしており、パッケージメソッドがロードされたときにのみ有効になります（デフォルト）。  オブジェクトがS4オブジェクトであることがチェックされ(isS4参照)、それ以外のオブジェクトに@を使おうとするとエラーになります。  (オブジェクトがS4オブジェクトであることがチェックされ（isS4参照）、それ以外のオブジェクトに@を使おうとするとエラーになります（内部でのみ使用される名前.Dataには例外があります）。replacement演算子は、オブジェクトにslotがすでに存在しているかチェックします（オブジェクトが本当にそのクラスのものであれば存在するはずです）。
単項演算子と二項演算子はジェネリック関数です。これらのメソッドは個別に記述することもできますし、Opsグループのジェネリック関数を使って記述することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、結果は配列になります(例えば、リサイクルルールが起動された場合はなりません)。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型に対する算術演算は、'round to nearest, ties to even'モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対して、round、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のためのメソッドも用意されている。units = "auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる可能な最大の単位（"weeks "を除く）が選択される。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
単項演算子および二項演算子はジェネリック関数です。これらのメソッドは、個別に記述することも、Ops グループのジェネリック関数を使用して記述することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、結果が配列になるのは、それが賢明な場合です(例えば、リサイクルルールが起動された場合はなりません)。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型に対する算術演算は、'round to nearest, ties to even'モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対して、round、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のためのメソッドも用意されている。units = "auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる可能な最大の単位（"weeks "を除く）が選択される。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定する必要があり、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
!"は論理否定（NOT）を表し、"&"と"&&"は論理積（AND）を表し、"|"と"||"は論理和（OR）を表します。  短縮形は、算術演算子とほぼ同じ方法で要素間の比較を行う。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、ゼロは偽、ゼロ以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
クラス "hexmode "は、単に16進数で出力されることを保証するためだけに使用される、そのクラス属性を持つ整数ベクトルから構成されます。width = NULL（デフォルト）の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-f（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  width=NULL(デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数(integer型またはdouble型)と、要素が0〜7桁のみを含む(またはNAの)文字ベクトルをクラス "octmode "に変換することができます。
は論理否定（NOT）を示し、&と&&は論理ANDを、そして｜と｜｜は論理ORを示す。  より短い形式は、算術演算子とほぼ同じ方法で要素間の比較を行います。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、ゼロは偽、ゼロ以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については、構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
ベクトルが行列に昇格する場合、as.matrixとは異なり、その名前は行名または列名に昇格しません。ベクトルが1行または1列の行列に昇格するのは、2つの選択肢のうち1つでxとyが適合する次元を得ることができる場合です。  S4メソッドは、xとyという2つの引数の関数に対して書く必要がある。
単項演算子と二項演算子はジェネリック関数です。メソッドは個別に記述することも、Opsグループジェネリック関数を介して記述することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、結果が配列になるのは、それが賢明な場合です(例えば、リサイクルルールが発動された場合はなりません)。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型に対する算術演算は、'round to nearest, ties to even'モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
単項演算子および二項演算子はジェネリック関数であり、メソッドを個別に記述することも、Opsグループジェネリック関数を使用して記述することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、それが賢明であれば結果は配列になります(例えば、リサイクルルールが起動された場合はなりません)。論理ベクトルは整数または数値ベクトルに強制され、FALSEは値0、TRUEは値1になります。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型の算術演算は、「最も近い値に丸め、偶数に結ぶ」モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
in%は現在"%in%"として定義されています。 <- function(x, table) match(x, table, nomatch = 0) > 0因子、生のベクトル、リストは文字ベクトルに変換され、xとtableはマッチングの前に共通の型(Rの順序では、論理 < 整数 < 数値 < 複素 < 文字の2つの型のうち遅い方)に強制されます。  すべての型に対して、NAはNAにマッチし、それ以外の値にはマッチしません。実数と複素数の値に対して、NaN値は他のNaN値にはマッチしますが、NAにはマッチしないとみなされます。文字列は、入力が "bytes "とマークされていればバイト列として比較され、そうで なければ、エンコーディングが異なっていてもUTF-8に変換されれば等しいとみなされ る（エンコーディングを参照）。
XとYはFUNに適した引数でなければなりません。  FUNはこれら2つの拡張されたベクトルを引数として呼び出される（さらに...の引数も）。  FUNはこれら2つの拡張されたベクトルを引数として呼び出されます(さらに...の引数も)。FUNはベクトル化された関数(またはその名前)でなければならず、少なくとも2つの引数を期待し、最初の引数(および2番目の引数)と同じ長さの値を返します。それらが存在する場合、XとYの[dim]名が答えにコピーされ、XとYの次元(次元が存在しない場合は長さ)の積である次元が割り当てられます。FUN="*"は、as.vector(X) %*% t(as.vector(Y))によって特別な場合として扱われ、数値ベクトルや配列のみを対象としています。
XとYが同じ次元数でない場合、小さい方の配列にサイズ1の次元が詰められます。  x%はkroneckerのエイリアスである（FUNは "*"にハードワイヤされている）。
単項演算子および二項演算子はジェネリック関数です。メソッドは個別に、またはOpsグループのジェネリック関数を使用して記述できます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、結果が配列になるのは、それが賢明な場合です(例えば、リサイクルルールが発動された場合はなりません)。論理ベクトルは整数または数値ベクトルに強制されます。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型に対する算術演算は、'round to nearest, ties to even'モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
単項演算子および二項演算子はジェネリック関数であり、メソッドを個別に記述することも、Opsグループジェネリック関数を使用して記述することもできます。  (ディスパッチがどのように計算されるかについてはOpsを参照してください。)配列に適用された場合、それが賢明であれば結果は配列になります(例えば、リサイクルルールが呼び出された場合はなりません)。論理ベクトルは整数または数値ベクトルに強制され、FALSEは値0、TRUEは値1になります。x ^ y は、（数値）引数のいずれかが無限大（Inf または-Inf のいずれか）である場合にも、適切な極限結果を与えるべきである。また、%% や x %/% y は、例えば 1 %/% 0.2 のような非整数の y に対しても使用できますが、結果は表現エラーの影響を受けるため、プラットフォームに依存する可能性があります。  例えば(-8)^(1/3)がなぜNaNなのか。ユーザは返された値に驚くことがある。  二重入力の場合、RはすべてのプラットフォームでIEC 60559の算術演算を使用し、^演算子にはCsystemの関数powを使用する。  関連規格は、多くのコーナーケースにおける結果を定義している。  特に、上の例の結果は、C99標準によって規定されている。  Rのdouble型に対する算術演算は、'round to nearest, ties to even'モードで行われることになっているが、これはコンパイラとFPUが正しくセットアップされているかどうかに依存する。
数値ベクトルとして指定する場合、xは整数である必要はありませんが、Datesのヘルプの小数日に関するコメントを参照してください。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）の開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年始以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
バイナリ比較演算子はジェネリック関数です。メソッドは個別に記述することも、Opsグループジェネリック関数を介して記述することもできます。  (ディスパッチの計算方法についてはOpsを参照してください。)文字ベクトル内の文字列の比較は、使用するロケールの照合順序seelocalesを使用して、文字列内で辞書式に行われます。  en_USのようなロケールの照合順序は、通常C（ASCIIを使用する）とは異なるため、驚くことがある。  例えば、エストニア語ではZはSとTの間にあり、照合順序は必ずしも文字単位とは限りません。ウェールズ語ではngはシングルソート単位であるかどうかはわかりません。  プラットフォームによってはロケールを無視し、8ビットロケールでは常にバイトの数値順、UTF-8ロケールではUnicodeのコードポイント順でソートすることがあります（同じ言語でも文字セットが異なると同じ順でソートされないことがあります）。  文字以外のもの（空白、句読点、ハイフン、分数など）の照合は、さらに問題があります。文字列は、異なるマーク付けされたエンコーディング（エンコーディングを参照）で比較することができます：比較する前にUTF-8に変換されます。生のベクトルは、実際には順序を持っていると考えるべきではありませんが、バイト表現の数値順序が使用されます。xとyの少なくとも一方はアトミックベクトルでなければならないが、もう一方がリストの場合、Rはそれをアトミックベクトルの型に強制しようとする：リストが正しい型に強制できる長さの要素で構成されていれば、これは成功する。2つの引数が異なる型の原子ベクトルである場合、一方は他方の型に強制され、優先順位は（小さい順に）文字、複素数、数値、整数、論理、rawとなります。欠損値（NA）とNaN値は、それ自身に対しても比較不可能とみなされるため、これらの値を含む比較は常にNAとなります。  シンボルやコールなどの言語オブジェクトは、比較の前に文字列に分解されます。
演算子 <- と = は、それが評価される環境に代入されます。  演算子<-はどこでも使用できるが、演算子=はトップレベル（例えば、コマンド・プロンプトで入力された完全な式）か、中括弧で囲まれた式のリストの中の部分式の1つとしてのみ使用できる。演算子<<-と->>は通常関数でのみ使用され、代入される変数の既存の定義を親環境から検索する。  もしそのような変数が見つかれば（そしてそのバインディングがロックされていなければ）、その値は再定義されます。  これらのセマンティクスはSlanguageのそれとは異なりますが、Rのスコープルールと組み合わせて使用すると便利です。  すべての代入演算子式において、xは名前または置換されるオブジェクトの一部を定義する式（例えば、z[[1]]）である。  左向きの代入 <- = <<- グループ右から左へ、もう一方は左から右へ。
演算子 <- と = は、それが評価される環境に代入されます。  演算子<-はどこでも使用できるが、演算子=はトップレベル（例えば、コマンド・プロンプトで入力された完全な式）か、中括弧で囲まれた式のリストの中の部分式の1つとしてのみ使用できる。演算子<<-と->>は通常関数でのみ使用され、代入される変数の既存の定義を親環境から検索する。  もしそのような変数が見つかれば（そしてそのバインディングがロックされていなければ）、その値は再定義されます。  これらのセマンティクスはSlanguageのそれとは異なりますが、Rのスコープルールと組み合わせて使用すると便利です。  すべての代入演算子式において、xは名前または置換されるオブジェクトの一部を定義する式（例えば、z[[1]]）である。  左向きの代入 <- = <<- は右から左へ、もう一方は左から右へグループ化します。
二項比較演算子はジェネリック関数であり、メソッドは個別に記述することもできるし、Opsグループジェネリック関数を使って記述することもできる。  (ディスパッチの計算方法についてはOpsを参照してください。)文字ベクトル内の文字列の比較は、使用するロケールの照合順序seelocalesを使用して文字列内で辞書式に行われます。  en_USのようなロケールの照合順序は、通常C（ASCIIを使用する）と異なるため、驚くことがある。  例えば、エストニア語ではZはSとTの間にあり、照合順序は必ずしも文字単位とは限りません。ウェールズ語ではngはシングルソート単位であるかどうかはわかりません。  プラットフォームによってはロケールを無視し、8ビットロケールでは常にバイトの数値順、UTF-8ロケールではUnicodeのコードポイント順でソートすることがあります（同じ言語でも文字セットが異なると同じ順でソートされないことがあります）。  文字以外のもの（空白、句読点、ハイフン、分数など）の照合は、さらに問題があります。文字列は、異なるマーク付けされたエンコーディング（エンコーディングを参照）で比較することができます：比較する前にUTF-8に変換されます。生のベクトルは、実際には順序を持っていると考えるべきではありませんが、バイト表現の数値順序が使用されます。xとyの少なくとも一方はアトミックベクトルでなければならないが、もう一方がリストの場合、Rはそれをアトミックベクトルの型に強制しようとする：リストが正しい型に強制できる長さの要素で構成されていれば、これは成功する。2つの引数が異なる型の原子ベクトルである場合、一方は他方の型に強制され、優先順位は（小さい順に）文字、複素数、数値、整数、論理、rawとなります。欠損値（NA）とNaN値は、それ自身に対しても比較不可能とみなされるため、これらの値を含む比較は常にNAとなります。  シンボルやコールなどの言語オブジェクトは、比較の前に文字列に分解されます。
演算子 <- と = は、それが評価される環境に代入されます。  演算子<-はどこでも使用できるが、演算子=はトップレベル（例えば、コマンド・プロンプトで入力された完全な式）か、中括弧で囲まれた式のリストの中の部分式の1つとしてのみ使用できる。演算子<<-と->>は通常関数でのみ使用され、代入される変数の既存の定義を親環境から検索する。  もしそのような変数が見つかれば（そしてそのバインディングがロックされていなければ）、その値は再定義されます。  これらのセマンティクスはSlanguageのそれとは異なりますが、Rのスコープルールと組み合わせて使用すると便利です。  すべての代入演算子式において、xは名前または置換されるオブジェクトの一部を定義する式（例えば、z[[1]]）である。  左向きの代入 <- = <<- は右から左へ、もう一方は左から右へグループ化します。
二項比較演算子はジェネリック関数であり、メソッドは個別に記述することもできるし、Opsグループジェネリック関数を使って記述することもできる。  (ディスパッチの計算方法についてはOpsを参照してください。)文字ベクトル内の文字列の比較は、使用するロケールの照合順序seelocalesを使用して文字列内で辞書式に行われます。  en_USのようなロケールの照合順序は、通常C（ASCIIを使用する）と異なるため、驚くことがある。  例えば、エストニア語ではZはSとTの間にあり、照合順序は必ずしも文字単位とは限りません。ウェールズ語ではngはシングルソート単位であるかどうかはわかりません。  プラットフォームによってはロケールを無視し、8ビットロケールでは常にバイトの数値順、UTF-8ロケールではUnicodeのコードポイント順でソートすることがあります（同じ言語でも文字セットが異なると同じ順でソートされないことがあります）。  文字以外のもの（空白、句読点、ハイフン、分数など）の照合は、さらに問題があります。文字列は、異なるマーク付けされたエンコーディング（エンコーディングを参照）で比較することができます：比較する前にUTF-8に変換されます。生のベクトルは、実際には順序を持っていると考えるべきではありませんが、バイト表現の数値順序が使用されます。xとyの少なくとも一方はアトミックベクトルでなければならないが、もう一方がリストの場合、Rはそれをアトミックベクトルの型に強制しようとする：リストが正しい型に強制できる長さの要素で構成されていれば、これは成功する。2つの引数が異なる型の原子ベクトルである場合、一方は他方の型に強制され、優先順位は（小さい順に）文字、複素数、数値、整数、論理、rawとなります。欠損値（NA）とNaN値は、それ自身に対しても比較不可能とみなされるため、これらの値を含む比較は常にNAとなります。  シンボルやコールなどの言語オブジェクトは、比較の前に文字列に分解されます。
バイナリ比較演算子はジェネリック関数です。メソッドは個別に、またはOpsグループのジェネリック関数を介して記述することができます。  (ディスパッチの計算方法についてはOpsを参照してください。)文字ベクトル内の文字列の比較は、使用するロケールの照合順序seelocalesを使用して文字列内で辞書式に行われます。  en_USのようなロケールの照合順序は、通常C（ASCIIを使用する）と異なるため、驚くことがある。  例えば、エストニア語ではZはSとTの間にあり、照合順序は必ずしも文字単位とは限りません。ウェールズ語ではngはシングルソート単位であるかどうかはわかりません。  プラットフォームによってはロケールを無視し、8ビットロケールでは常にバイトの数値順、UTF-8ロケールではUnicodeのコードポイント順でソートすることがあります（同じ言語でも文字セットが異なると同じ順でソートされないことがあります）。  文字以外のもの（空白、句読点、ハイフン、分数など）の照合は、さらに問題があります。文字列は、異なるマーク付けされたエンコーディング（エンコーディングを参照）で比較することができます：比較する前にUTF-8に変換されます。生のベクトルは、実際には順序を持っていると考えるべきではありませんが、バイト表現の数値順序が使用されます。xとyの少なくとも一方はアトミックベクトルでなければならないが、もう一方がリストの場合、Rはそれをアトミックベクトルの型に強制しようとする：リストが正しい型に強制できる長さの要素で構成されていれば、これは成功する。2つの引数が異なる型の原子ベクトルである場合、一方は他方の型に強制され、優先順位は（小さい順に）文字、複素数、数値、整数、論理、rawとなります。欠損値（NA）とNaN値は、それ自身に対しても比較不可能とみなされるため、これらの値を含む比較は常にNAとなります。  シンボルやコールなどの言語オブジェクトは、比較の前に文字列に分割されます。
バイナリ比較演算子はジェネリック関数です。メソッドは個別に、またはOpsグループのジェネリック関数を介して記述することができます。  (ディスパッチの計算方法についてはOpsを参照してください。)文字ベクトル内の文字列の比較は、使用するロケールの照合順序seelocalesを使用して文字列内で辞書式に行われます。  en_USのようなロケールの照合順序は、通常C（ASCIIを使用する）とは異なるため、驚くことがある。  例えば、エストニア語ではZはSとTの間にあり、照合順序は必ずしも文字単位とは限りません。ウェールズ語ではngはシングルソート単位であるかどうかはわかりません。  プラットフォームによってはロケールを無視し、8ビットロケールでは常にバイトの数値順、UTF-8ロケールではUnicodeのコードポイント順でソートすることがあります（同じ言語でも文字セットが異なると同じ順でソートされないことがあります）。  文字以外のもの（空白、句読点、ハイフン、分数など）の照合は、さらに問題があります。文字列は、異なるマーク付けされたエンコーディング（エンコーディングを参照）で比較することができます：比較する前にUTF-8に変換されます。生のベクトルは、実際には順序を持っていると考えるべきではありませんが、バイト表現の数値順序が使用されます。xとyの少なくとも一方はアトミックベクトルでなければならないが、もう一方がリストの場合、Rはそれをアトミックベクトルの型に強制しようとする：リストが正しい型に強制できる長さの要素で構成されていれば、これは成功する。2つの引数が異なる型の原子ベクトルである場合、一方は他方の型に強制され、優先順位は（小さい順に）文字、複素数、数値、整数、論理、rawとなります。欠損値（NA）とNaN値は、それ自身に対しても比較不可能とみなされるため、これらの値を含む比較は常にNAとなります。  シンボルやコールなどの言語オブジェクトは、比較の前に文字列に分解されます。
と&&は論理ANDを示し、｜と｜｜は論理ORを示す。  短縮形は、算術演算子とほぼ同じ方法で要素ごとの比較を行う。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、0は偽、0以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (ディスパッチの計算方法についてはOpsを参照してください。)NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
クラス "hexmode "は、そのクラス属性を持つ整数ベクトルで構成され、単に16進数で出力されることを保証するために使用されます。width = NULL (デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-f（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができます。
クラス "octmode "は、このクラス属性を持つ整数ベクトルで構成され、単に8進数で表示されることを保証するために使用されます。  width=NULL(デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数(integer型またはdouble型)と、要素が0〜7桁のみを含む(またはNAの)文字ベクトルをクラス "octmode "に変換することができます。
は論理否定（NOT）を示し、&と&&は論理ANDを、そして｜と｜｜は論理ORを示す。  より短い形式は、算術演算子とほぼ同じ方法で要素間の比較を行います。  長い方の形式は、各ベクトルの最初の要素だけを調べて左から右に評価します。  評価が進むのは、結果が決まるまでです。  isTRUE(x)は{ is.logical(x) && length(x) == 1 && !is.na(x) && x }と同じで、isFALSE()も同様に定義されます。  その結果、if(isTRUE(cond))は、NAのため、if(cond)よりも好ましいかもしれません。以前のRバージョンでは、isTRUE <- function(x) identical(x, TRUE)は、例えば、x <- c(val = TRUE)の場合、偽になるという欠点がありました。数値ベクトルや複素数ベクトルは、論理値に強制され、0は偽、0以外の値はすべて真となります。  生のベクトルは、!、&、|、xorのために強制されることなく処理されます。これらの演算子はビット単位で適用されます（つまり、!は1の補数です）。演算子!、&、|はジェネリック関数です：メソッドは個別に、またはOps（またはS4 Logic。  (ディスパッチの計算方法についてはOpsを参照してください。)NAは有効な論理オブジェクトです。  xまたはyの成分がNAである場合、結果が曖昧であれば結果はNAになる。  言い換えると、NA & TRUEはNAと評価されるが、NA & FALSEはFALSEと評価される。  これらの演算子の優先順位については構文を参照してください。（Sを含む）他の多くの言語とは異なり、AND演算子とOR演算子の優先順位は同じではありません（AND演算子の方がOR演算子よりも優先順位が高い）。
左辺は省略可能で、文脈によっては片辺の式が使用されることもある。  構成要素は、~、左辺（存在する場合）、右辺の順である。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを処理するメソッドを書くことができます。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち大きい方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnames は適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が返されます。サブセット・テーブルではないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
これは、DLL を管理する内部テーブルに問い合わせます。
数値バージョンは 1 つ以上の非負整数のシーケンスで、通常は (パッケージの 'DESCRIPTION' ファイルなど) シーケンスの要素を連結し、.または - 文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
これらの演算子は汎用的です。  特定のクラスのオブジェクトのインデックスを処理するメソッドを書くことができます。[.data.frame や [.factor と同様に InternalMethods を参照してください。  ここでの説明は、デフォルトのメソッドにのみ適用されます。  置換関数[<-、[[<-、および$<-は、式の代入側でインデックス付けが行われる場合に使用するため、別々のメソッドが必要であることに注意してください。  インデックス付けは、式の右辺で抽出することも、左辺で置換することもできます。  インデックス式が代入（代入と呼ばれる）の左辺にある場合、xのその部分は代入の右辺の値に設定されます。  この場合、文字インデックスの部分マッチングは行われず、左辺は必要に応じて値を受け入れるように強制される。  ベクトルでは、raw < logical < integer < double < complex < character < list < expressionの階層で、xとvalueの型のうち大きい方の型が答えとなる。  属性は保持されます（ただし、name、dim、dimnamesは適切に調整されます）。サブアサインメントは順次行われるため、インデックスが複数回指定された場合は、インデックスに割り当てられた最新の値が返されます。サブセットテーブルでないオブジェクト（関数など）にこれらの演算子を適用するのはエラーです。
データ・フレームはいくつかのモードでインデックスを付けることができます。  と[[ が1つのベクトル添字（x[i]またはx[[i]]）と一緒に使用されると、あたかもリストのようにデータフレームに添字を付けます。  この使い方では、drop引数は警告とともに無視されます。$用のdata.frameメソッドは存在しないので、x$nameはxをリストとして扱うデフォルトのメソッドを使用します（一致する列名が一意であれば、列名の部分一致を行います。）  ($の)replacementメソッドは、値が正しい行数であるかどうかをチェックし、必要であればそれを複製します。[]と[[]が2つの添字(x[i, j]とx[[i, j]])で使用される場合、それらは行列の添字のように動作します：  [は、1つの要素を選択するために使われる。  もし[]がデータフレームを返すのであれば、それは一意な(そして欠落のない)行名を持ち、必要であればmake.uniqueを使って行名を変換します。  同様に、カラムが選択された場合、カラム名は必要に応じて一意に変換されます (例えば、カラムが複数回選択された場合、カラム名は一意に変換されます)、この場合、列はデータフレームの右端に追加され、数値インデックスは既存のインデックスと連続しなければなりません。  その場合、列はデータフレームの右端に追加され、数値添字は既存の添字と連続しなければならない。一方、行は現在の最終行の後の任意の行に追加することができ、列は欠損値で埋められる。  置換値はリストとすることができます: リストの各要素は、必要に応じてリストを再利用しながら、1つの列の置換（の一部）に使用されます。  番号で指定された列が作成される場合、対応するリスト要素の名前（もしあれば）が列の名前として使用されます。  置換が行を選択しない場合、リストの値にNULL要素が含まれることがあり、その場合は対応する列が削除されます。  (例題を参照のこと。) [ を使用した行列インデックス(x[i]に論理または2列の整数i)は推奨されない。  抽出の場合、xはまず行列に強制されます。置換は一度に1列ずつ行われ、複数の型強制が行われる可能性がある。[[ と [[ の抽出メソッドはどちらも列名に部分的にマッチする。  デフォルトではどちらも列名に部分的にマッチしませんが、[[は exact = FALSE の場合にマッチします (exact = NA の場合は警告が表示されます)。  行名に完全一致させたい場合は、例のようにematchを使用します。
デフォルトのアルゴリズム(method = "left.keeped")はSと似ています。単一の文字列に対して以下のように動作します。まず文字列の末尾の空白が取り除かれ、次に(必要であれば)その他の空白が取り除かれます。  names.argの要素が複数の単語を含む場合（単語はスペースで区切られる）、各単語から少なくとも1つの文字が保持されます。use.classesがFALSEの場合、文字とスペースの区別のみが行われます。
これらは内部ジェネリック・プリミティブ関数です。メソッドは個別に定義することも、Mathグループジェネリックを介して定義することもできます。  複素引数(およびデフォルトのメソッド)、z、abs(z) == Mod(z)、sqrt(z) == z^0.5.abs(x)は、xが整数または論理の場合、整数ベクトルを返します。
2つの引数のアークタンジェント atan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)となります、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
ブランチカットは逆三角関数asinらと一致しており、AbramowitzとStegunの図4.7、86ページで定義されているものと一致しています。   実際のカットの動作は、C99標準に従っており、終点を反時計回りに回ってくる連続性が要求される。
lockEnvironment関数はenvironment引数をロックします。environmentをロックすることで、environmentからの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時に保存されませんが、.onLoadで作成することができます。
ベクトルxの型は制限されない。as.characterメソッドを持ち、ソート可能（byorder）でなければならないだけである。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される)になります。デフォルトでは、これが最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左辺にis.naを使用することです(is.na(f)[i] <- TRUEのように。is.na内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、要素のレベル集合にレベルが出現する順序で、要素のレベル集合の和をレベルとする因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
トップレベル・タスクは、入力行全体ではなく、個々の式である。  トップレベル・タスクのコールバックは、トップレベル・タスクの式、トップレベル・タスクの結果、正常に完了したかどうかを示す論理値（常にTRUE）、結果がプリントされたかどうかを示す論理値で呼び出される。  コールバック関数は論理値を返すべきである。値がFALSEの場合、コールバックはタスクリストから削除され、このメカニズムによって再度呼び出されることはない。関数がTRUEを返した場合、その関数はリストに保持され、次のトップレベルタスクの完了時に呼び出される。
ある文字列を別の文字列に変換するのに必要な挿入、削除、置換の総数である。これはVille Laurikariによるtreコード（https://github.useBytesの主な効果は、マルチバイトのロケールにおける無効な入力や偽のマッチに関するエラーや警告を回避することである。これは、符号化方式がマークされた入力の変換を抑制し、"bytes "とマークされた入力が見つかると強制される(Encodingを参照)。
ある文字列を別の文字列に変換するのに必要な挿入、削除、置換の総数である。これは、Ville Laurikariによるtreコード（https://github.useBytesの主な効果は、無効な入力やマルチバイト・ロケールでの偽のマッチに関するエラーや警告を回避することである。これは、マークされたエンコーディングを持つ入力の変換を抑制し、"bytes "とマークされた入力が見つかると強制される（エンコーディングを参照）。
LISPのような）伝統的なドット付きペアリストは使用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として使用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
これはジェネリック関数です。メソッドは直接定義することも、Summaryグループのgenericを介して定義することもできます。これが正しく動作するためには、引数...には名前を付ける必要があり、ディスパッチは最初の引数に対して行われます。整数以外の型（raw、double、complex、character、list）の強制は、しばしば意図的でないため警告を発します。
all.equalはジェネリック関数で、ターゲット引数のメソッドをディスパッチします。  使用可能なメソッドを見るにはemethods("all.equal")を使用しますが、デフォルトのメソッドもいくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される：all.equal.numericが呼び出されるので、引数stoleranceとscaleが使用できる、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドでも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される：all.equal.numericが呼び出されるので、引数stoleranceとscaleが使用できる、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドでも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される：all.equal.numericが呼び出されるので、引数stoleranceとscaleが使用できる、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される：all.equal.numericが呼び出されるので、引数stoleranceとscaleが使用できる、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻を（"POSIXct "表現で）0.001秒のデフォルト許容誤差で比較します。
all.equalはジェネリック関数で、target引数のメソッドをディスパッチします。  使用可能なメソッドを見るには、emethods("all.equal")を使用します。しかし、デフォルトのメソッドも、論理ターゲットに対してrawメソッドを使用するなど、いくつかのディスパッチを行っていることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、（特定のall.equalメソッドが定義されていない限り）参照クラスにも使用されます。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻（"POSIXct "表現）を0.001秒のデフォルト許容誤差で比較します。
これらの関数の違いは、引数のデフォルト値のみである。
これらの関数は、引数のデフォルト値が異なるだけです。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最近確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによって不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
.signalSimpleWarning、.handleSimpleError、.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。これはジェネリック関数です。メソッドは直接、またはSummaryグループのgenericを介して定義できます。これが正しく動作するためには、引数...には名前を付ける必要があり、ディスパッチは最初の引数で行われます。整数以外の型（raw、double、complex、character、list）を強制すると、意図しないことが多いため警告が表示されます。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに同等のメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットであり、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに同等のメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに同等のメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに同等のメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに同等のメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠落値（"NA"）は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合はエラーになる可能性がある： nmax = 1 は黙って無視される。長いベクトルは、デフォルトの重複メソッドでサポートされているが、 nmax が指定された場合にのみ使用可能である。
文字型のNAは、文字列 "NA "とは異なる。  is.na<-.is.naとanyNAは汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。na<-は、より安全な欠測の設定方法を提供するかもしれません。例えば、因子の場合は異なる動作をします。NAを使用した数値計算は通常NAになります。  しかし、これは保証されたものではなく、将来のCPUやコンパイラは異なる動作をするかもしれません。動的バイナリ変換もこの動作に影響を与える可能性があります(valgrindでは、NaNが関与していなくてもNAを使用した計算がNaNになる可能性があります)。論理計算では、NAは欠損したTRUE/FALSE値として扱われるため、式がNAオペランドに依存しない場合、TRUEまたはFALSEを返す可能性があります。anyNAのデフォルトメソッドは、aclassとNULLを持たないアトミックベクトルを扱います。  any(is.na(x))は、クラスを持つオブジェクトや、recursive = FALSEのリストやペアリストに対して呼び出されます。
文字型のNAは文字列 "NA "とは異なる。  is.naとanyNAは汎用的なもので、特定のクラスのオブジェクトを扱うメソッドを書くことができます。na<-は、より安全な欠測の設定方法を提供するかもしれません。例えば、因子の場合は異なる動作をします。NAを使用した数値計算は通常NAになります。  しかし、これは保証されたものではなく、将来のCPUやコンパイラは異なる動作をするかもしれません。動的バイナリ変換もこの動作に影響を与える可能性があります(valgrindを使用すると、NaNが関与していなくてもNAを使用した計算がNaNになる可能性があります)。論理計算では、NAは欠損したTRUE/FALSE値として扱われるため、式がNAオペランドに依存しない場合、TRUEまたはFALSEを返す可能性があります。anyNAのデフォルトメソッドは、aclassとNULLを持たないアトミックベクトルを扱います。  any(is.na(x))は、クラスを持つオブジェクト、および recursive = FALSE のリストとペアリストに対して呼び出されます。
数値バージョンは、1つ以上の非負整数のシーケンスであり、通常(例えば、パッケージの'DESCRIPTION'ファイルでは)、シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
NA
NA
NA
NA
Xが配列ではなく、nulldimでない値を持つクラスのオブジェクト（データフレームなど）である場合、applyは、それが2次元（データフレームなど）であればas.matrixを介して、またはas.arrayを介して、それを配列に強制しようとします、FUNは、match.funの呼び出しによって検出され、通常、関数、シンボル（例えば、バッククォート名）、またはapplyの呼び出しの環境から検索される関数を指定する文字列のいずれかである。  これは、MARGINやFUNとの部分一致を避けると同時に、X、MARGIN、FUNという名前の引数が...を通過した場合に適切なエラーメッセージが表示されるようにするためです。
複素数ベクトルはcomplexで作成できます。  ベクトルは長さ、実数部、虚数部、またはモジュラスと引数で指定できます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、つまり実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られず、実数部または虚数部がNaNの複素数が得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列の乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義されており、 solve, eigen, svdも同様である。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。上記のNA_complex_を参照)、またはプラスマイナス無限大になる。
この関数は、主に関数の引数リストを表示するために対話的に使用される。  プログラミングでは、代わりにformalsを使うことを検討する。
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができます。  2次元配列は行列と同じものです。1次元配列はしばしばベクトルのように見えますが、関数によっては異なって扱われることがあります。dim "属性は、非負の値を含む長さ1以上の整数ベクトルで、値の積は配列の長さと一致しなければなりません。is.arrayはプリミティブ関数である。リスト配列の場合、printメソッドはinteger,7という型と長さを示す形式で、長さが1でないエントリを表示する。
NA
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができる。  2次元の配列は行列と同じものです。1次元の配列はしばしばベクトルと同じように見えますが、関数によっては扱いが異なる場合があります。dim "属性は、非負の値を含む長さ1以上の整数ベクトルで、値の積は配列の長さと一致しなければなりません。is.arrayはプリミティブ関数です。リスト配列の場合、printメソッドはinteger,7という型と長さを示す形式で、長さが1でないエントリを表示します。
Rの配列は、1次元、2次元、またはそれ以上の次元を持つことができます。  2次元配列は行列と同じものです。1次元配列はしばしばベクトルと同じように見えますが、関数によっては扱いが異なる場合があります。dim "属性は、非負の値を含む長さ1以上の整数ベクトルで、値の積は配列の長さと一致しなければなりません。is.arrayはプリミティブ関数です。リスト配列の場合、printメソッドはinteger,7という型と長さを示す形式で、長さが1でないエントリを表示します。
つまり、与えられた引数（nameは呼び出される関数名を示す文字列でなければならない）に名前付き関数を適用した評価されない式を返します。  呼び出しは評価されないが、引数...は評価されることに注意。callはプリミティブであるため、最初の引数はnameとみなされ、残りの引数は構築された呼び出しの引数とみなされる。  is.call(x)は、typeof(x) == "language "と厳密に等価であることに注意してください。is.language()は、呼び出しに対しても真です（ただし、is.call()が偽の場合は、シンボルと式に対しても真）。as.call(<string>)を使おうと思ったら、parse(text=*)の効率的なバージョンであるstr2lang(*)を使うことを検討してください。call()とas.call()は、適用可能であれば、これらのparse()ベースのアプローチよりもはるかに好ましいことに注意してください。
as.characterとis.characterは汎用的です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。as.characterは実数と複素数を有効数字15桁で表します（技術的には、コンパイラがISO C定数DBL_DIGを設定したもので、C99標準に従ってIEC60559算術演算をサポートするマシンでは15になります）。  これは、結果のすべての桁が信頼できる（表現エラーの結果ではない）ことを保証しますが、文字に変換して数値に戻すと数値が変わる可能性があることを意味します。  可能な限りの精度で数値を文字に変換したい場合は、formatを使用してください。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
通常のベクトルの再循環ルールがxとformatに適用されるため、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切で利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、および "POSIXlt "クラスと "POSIXct "クラスのオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け付けますが、これはoriginが指定されている場合に限ります。formatメソッドとas.characterメソッドは、日付の端数を無視します。
as.characterとis.characterは汎用的です。特定のクラスのオブジェクトを処理するメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。as.characterは実数と複素数を有効数字15桁で表します（技術的には、コンパイラがISO C定数DBL_DIGを設定したもので、C99標準に従ってIEC60559算術演算をサポートするマシンでは15になります）。  これは、結果のすべての桁が信頼できる（表現エラーの結果ではない）ことを保証しますが、文字に変換して数値に戻すと数値が変わる可能性があることを意味します。  可能な限りの精度で数値を文字に変換したい場合は、formatを使用してください。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートで不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル(エラー、警告など)で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を指定する必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、および.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。
as.characterとis.characterは一般的なもので、特定のクラスのオブジェクトを処理するメソッドを書くことができます。  さらに、as.characterでは、デフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。as.characterは、実数と複素数を有効数字15桁で表します（技術的には、コンパイラがISO C定数DBL_DIGを設定したもので、C99標準に従ってIEC60559算術演算をサポートするマシンでは15になります）。  これは、結果のすべての桁が信頼できる（表現エラーの結果ではない）ことを保証しますが、文字に変換して数値に戻すと数値が変わる可能性があることを意味します。  可能な限りの精度で数値を文字に変換したい場合は、formatを使用する。
クラス "hexmode "は、そのクラス属性を持つ整数ベクトルで構成され、単に16進数で出力されることを保証するために使用されます。width = NULL（デフォルト）の場合、出力は、すべての外れない要素に必要な最小の幅まで、先頭のゼロでパディングされます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-f（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができる。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルから構成され、特に755のようなUnixライクなファイルパーミッションのために、8進数で表示されることを保証するためだけに使用されます。  as.octmodeは、整数（"integer "または "double "型）と、0〜7桁（またはNA）のみを要素とする文字ベクトルをクラス "octmode "に変換することができます。
formatメソッドとas.characterメソッド、そしてstrftimメソッドは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換する。strftimeはformat.POSIXltのラッパーであり、format.POSIXctはまずas.POSIXltを呼び出してクラス "POSIXlt "に変換します（したがって、これらはクラス "Date "でも動作します）。  xとformatには、通常のベクトルの再循環規則が適用されるため、答えはこれらのベクトルのうち長い方の長さになる。  これは、LC_TIMEロケールカテゴリの設定によって、日や月の名前、AM/PMインジケータ（使用されている場合）、%xや%Xなどの出力書式のセパレータに影響します。  説明の'currentlocale'は、Rセッションの開始時またはこれらの関数が最初に使用された時に使用されているロケールを意味する。  (入力の場合、ロケール固有の変換は、LC_TIME (またはLC_ALL)カテゴリでSys.setlocaleを呼び出すことで変更できる。  変換指定は%で導入され、通常はその後に1文字、またはOかE、そして1文字が続く。  変換指定の一部でない書式文字列の文字は、文字通りに解釈されます（そして、%%は%%を与えます）。  広く実装されている変換指定には、このプラットフォームの現在のロケールでの曜日名の省略形があります。  (入力時のフルネームにもマッチする。ロケールによっては、名前の省略形がないものもある。)現在のロケールでの完全な曜日名。  (入力時の省略形名とも一致します。)このプラットフォーム上の現在のロケールにおける月名の省略形。  (入力時のフルネームとも一致する。ロケールによっては省略形がないものもある。)現在のロケールにおける完全な月名。  (入力時には省略形にもマッチする。)日付と時刻。   センチュリー（00-99）：西暦を100で割った整数部分。10進数としての月日（01-31）。%m/%d/%yのような日付書式：C99標準では、この書式に忠実であるべきとされている（ただし、すべてのOSが準拠しているわけではない）。Y-%m-%d（ISO8601の日付書式）に相当する。  (入力時は無視される。)10進数としての週ベースの年(%Vを参照)。  (入力時に無視されますが受け入れられます。)%b.Hours as decimal number (00-23)に相当します。  特別な例外として、ISO 8601では24:00:00のような文字列が許可されているため、入力として受け入れられる：  出力時には改行、入力時には任意の空白文字。  Iとは併用され、%Hとは併用されない。  一部のロケールでは空文字列となる（例えば、一部のOS、ロシアを含む非英語欧州ロケール）。このようなロケールで入力に使われた場合の動作は未定義である。いくつかのプラットフォームでは、小文字変換を使う%Pを出力に受け付ける（%pも小文字を使うことがある）。秒を整数 (00-61) で表し、うるう秒を2秒まで許容する (ただし、POSIX準拠の実装ではうるう秒は無視される)。  1月1日を含む週（月曜始まり）が新年に4日以上ある場合、その週は第1週とみなされる。  そうでない場合は前年の最終週となり、次の週が第1週となる。  (曜日は10進数（0～6、日曜日は0）、週は10進数（00～53）で、月曜日を週の初日とする（通常、その年の最初の月曜日を第1週の第1日目とする）。  英国の慣習。  出力時はロケール固有、入力時は"%y/%m/%d"。  出力時はロケール固有、入力時は"%H:%M:%S"。  入力では、00から68の値の先頭に20が、69から99の値の先頭に19が付きます。これは2018年のPOSIX標準によって指定された動作ですが、「将来のバージョンでは、2桁の年から推測されるデフォルトの世紀が変更されることが予想される」とも書かれています。  元のグレゴリオ暦にはゼロがなかったが、ISO 8601:2004ではゼロが有効であると定義されていることに注意すること（1BCと解釈される）：https://en.wikipedia.org/wiki/0_(year)を参照のこと。  入力については、年0:9999のみが受け入れられる。符号のオフセットはUTCから時分単位で、-0800はUTCから8時間遅れとなる。最大値は+1400。  (標準は出力のみ。  (出力のみ。) タイムゾーンの略称を1文字文字列で指定(利用できない場合は空)。  先頭のゼロが表示されている場合、出力時には使用されるが、入力時にはオプションである。  名前は、入力時には大文字小文字を区別せずにマッチングされる。出力時に大文字になるかどうかは、プラットフォームとロケールに依存する。  略称はプラットフォーム固有であることに注意してください（標準では、Cロケールでは大文字で表記された英語名の最初の3文字でなければならないと規定されていますが：この規約は英語のロケールでは広く使われていますが、例えばフランス語の月の略称はLinux、macOS、Solaris、Windowsのどれでも同じではありません）。入力フォーマットの一部として%a、%b、%hを使いたい場合は、省略形が何であるかを知っておくことが重要です。タイムゾーンが割り当てられているオブジェクトの出力に%zまたは%Zが使われた場合、そのタイムゾーンの値を使おうと試みますが、必ず成功するとは限りません。標準にはなく、あまり広く実装されていないのは、24時間時計の時刻で、1桁の前に空白が入ります。ロケールに依存する可能性がある。出力には、ロケールに依存する別の書式（ローマ数字など）で数字を出力する%O[dHImMUVwWy]や、別の「時代」（別の宗教暦など）を使うことができる%E[cCyYxX]もある。  どれがサポートされるかはOSに依存する。  Rに特有なのは%OSnで、これは出力時に小数点以下0 <= n <= 6桁に切り詰めた秒を与える（また、%OSの後に数字が続かない場合は、getOption("digits.secs")の設定を使うか、それが未設定の場合はn = 0となる）。  さらに、strptimeの場合、%OSは端数秒を含む秒を入力する。  Sは、出力で端数部分を読まないことに注意してください。他の変換指定の動作は（また、%で始まる他の文字シーケンスが変換指定であっても）システム固有である。  システムによっては、フォーマットでのマルチバイト文字の使用がサポートされていないことを文書化しているものもあります：UTF-8ローカライズが問題になる可能性は低い。
srcfile関数は、ソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むsrcfileクラスのオブジェクトを生成し、ソース・レベルのデバッグ（未実装）やソース・エコーに使用します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)と解析された行(要素7, 8)は、 #lineディレクティブがコード内で使用されている場合、異なるかもしれません: 前者はディレクティブを尊重し、後者は単に行数をカウントします。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...> レコードが出力されます。isOpen は内部的な使用を目的としており、srcfile オブジェクトに関連付けられた接続が開いているかどうかをチェックします。
複素数ベクトルは complex で作成できます。  ベクトルは、長さ、実数部と虚数部、またはモジュラスと引数で指定できます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、すなわち実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られず、実数部または虚数部がNaNの複素数が得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列の乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義されており、solve, eigen, svdも同様である。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。上記のNA_complex_を参照)、またはプラスマイナス無限大になる。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  リストが与えられると、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが提供された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  リストが提供された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数シーケンスになります。  行名の重複をチェックするメソッドはほとんどない。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となる。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、その暦が使用されていたのはそれほど昔ではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。また、いくつかのメソッドは個別にドキュメント化されています。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  もしリストが与えられると、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数シーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  リストが提供された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数シーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが提供された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数シーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが提供された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数シーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらなるメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどない。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  もしリストが与えられると、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどない。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年(UTCタイムゾーン)開始からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザーやパッケージはさらなるメソッドを提供することができます。  リストが与えられると、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどない。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname names'が計算される。  もし...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、（以前はNAcountに含まれていた）除外された値をカウントしないように注意されています。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
as.data.frameは多くのメソッドを持つ汎用関数で、ユーザやパッケージはさらにメソッドを提供することができます。  もしリストが与えられると、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数のシーケンスになります。  行名の重複をチェックするメソッドはほとんどありません。
as.data.frameは多くのメソッドを持つ汎用関数であり、ユーザやパッケージはさらにメソッドを提供することができます。  リストが指定された場合、各要素はデータフレームの列に変換されます。  同様に、行列の各列は別々に変換されます。オブジェクトがas.data.frameのメソッドを持つクラスを持っている場合、これをオーバーライドすることができます。2つの例として、クラス "model.matrix "の行列（1つの列として含まれます）とクラス "POSIXlt "のリストオブジェクトがクラス "POSIXct "に強制されます。  1次元配列はベクトルのように扱われ、2次元配列は行列のように扱われます。  データ・フレームが与えられると、"data.frame "の前にあるすべてのクラスが取り除かれ、その引数が与えられると行名が変更されます。row.names = NULLの場合、行名はxのnamesまたはdimnamesから作成され、そうでない場合は1から始まる整数シーケンスになります。  行名の重複をチェックするメソッドはほとんどない。
通常のベクトル再利用ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになる。文字列への変換や文字列からの変換は、適切で利用可能な場合、ロケール固有の変換が使用される。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け取りますが、これはoriginが指定された場合のみです。formatメソッドとas.characterメソッドは、日付の端数を無視します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切かつ利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け取りますが、これはoriginが指定された場合のみです。formatメソッドとas.characterメソッドは、日付の端数を無視します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切かつ利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け取りますが、これはoriginが指定された場合のみです。formatメソッドとas.characterメソッドは、日付の端数を無視します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切かつ利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け取りますが、これはoriginが指定された場合のみです。formatメソッドとas.characterメソッドは、日付の端数を無視します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切かつ利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け取りますが、これはoriginが指定された場合のみです。formatメソッドとas.characterメソッドは、日付の端数を無視します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切かつ利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け取りますが、これはoriginが指定された場合のみです。formatメソッドとas.characterメソッドは、日付の端数を無視します。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切かつ利用可能な場合にロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、およびクラス "POSIXlt "と "POSIXct "のオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け付けますが、これはoriginが指定されている場合に限ります。formatメソッドとas.characterメソッドは、日付の端数を無視します。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドも用意されている。units = "auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる可能な最大の単位（"weeks "を除く）が選択される。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
double は、指定された長さの倍精度ベクトルを作成します。  これはnumeric.asと同じです。doubleは汎用関数です。  as.numericと同じです。  is.doubleはdouble型のテストです。Rには単精度データ型がありません。  すべての実数は倍精度形式で格納されます。  関数as.singleとsingleはas.doubleとdoubleと同じですが、Cと.Fortranインターフェースで使用される属性Csingleを設定します。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  units="auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる可能な最大の単位（"weeks "を除く）が選択されます。difftimeをunits="auto "で呼び出すと、このクラスのオブジェクトが得られます。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
as.POSIX*関数は、オブジェクトを日付/時刻を表すために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることに注意。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであると予想すべきだが、2つ目はBSTまたはGMTのどちらとも解釈できる（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意してください（seestrftime）。
これはプリミティブなジェネリック関数です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。
ここでの「式」は、口語的な意味、つまり数学的な式の意味で使われているのではありません。  expression "モードのオブジェクトはリストであるため、[, [[ や $ で置き換えることができます。  expressionとis.expressionはプリミティブ関数です。expressionは「特殊」で、引数を評価しません。
ここでの「式」は口語的な意味、つまり数学的な式の意味で使われているのではありません。  expression "モードのオブジェクトはリストであるため、[, [[ や $ で置き換えることができます。  expressionとis.expressionはプリミティブ関数です。expressionは「特殊」で、引数を評価しません。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。ベクトルのエンコーディングは次のように行われます。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して(並べ替え可能な)因子を他のオブジェクトと結合する場合、すべてのオブジェクトが(並べ替え可能な)因子であれば、結果は、要素のレベル集合にレベルが出現する順序で、要素のレベル集合の和をレベルとする因子になります(これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します)。
NA
NA
クラス "hexmode "は、単に16進数で出力されることを保証するためだけに使用される、そのクラス属性を持つ整数ベクトルで構成されます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-f（またはNA）のみを要素に含む文字ベクトルを "hexmode "クラスに変換することができます。
整数ベクトルは、それを期待するCやFortranコードにデータを渡すことができるように、また（小さな）整数データを正確かつコンパクトに表現できるように存在します。現在のRの実装では、整数ベクトルには32ビット整数を使用しているため、表現可能な整数の範囲は約±2*10^9に制限されていることに注意してください。
LISPのような）伝統的なドット付きペア・リストも使用可能ですが、ユーザーが目にすることはほとんどありません（関数の形式として使用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません（順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します）。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにpairlistにコピーされ、リストの名前はpairlistのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
listまたはpairlistの引数はvalueまたはtag = valueの形式です。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません（順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します）。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、グレゴリオ暦が使われていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。また、いくつかのメソッドは個別にドキュメント化されています。
LISPのような）伝統的なドット付きペア・リストは使用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として使用する場合を除きます）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません（順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します）。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signの各メソッドを提供し、グループ・ジェネリック（Ops参照）の論理演算と算術演算のメソッドもあります。  また、as.difftime()は文字コード化された時間間隔でも数値時間間隔でも動作します。後者の場合、単位を指定する必要があり、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは単に数値をフォーマットし、単位をテキスト文字列として追加します。
LISPのような）伝統的なドット付きペア・リストは使用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として使用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません（順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します）。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにpairlistにコピーされ、リストの名前はpairlistのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
listまたはpairlistの引数はvalueまたはtag = valueの形式です。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにpairlistにコピーされ、リストの名前はpairlistのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
listまたはpairlistの引数はvalueまたはtag = valueの形式です。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
数値バージョンは1つ以上の非負整数からなるシーケンスで、通常（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。ただし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
TRUEとFALSEはR言語の論理定数を示す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  TRUEは1Lに、FALSEは0Lに、NAはNA_integer_にマッピングされる。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  TRUEは1Lに、FALSEは0Lに、そしてNAはNA_integer_にマッピングされる。
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとする。  もしどちらも与えられない場合，1列の行列が返される．もし data の要素が少なすぎて行列を埋められない場合， data の要素は再利用される．  データの長さが0の場合，アトミックベクトルの場合は適切な型のNA（生のベクトルの場合は0）が使用され，リストの場合はNULLが使用されます．is.matrixは，xがベクトルで長さ2の "dim "属性を持つ場合にTRUEを返し，そうでない場合はFALSEを返します．  この関数は汎用的であり、特定のクラスのオブジェクトを扱うメソッドを書くことができます。  データフレーム用のメソッドは、atomic列と(numeric/logical/complex)以外の列しかない場合は文字行列を返し、それ以外の文字列にはas.vectortを適用して因子と書式を指定します、as.matrixのデフォルトメソッドはas.vector(x)を呼び出すので、例えば因子を文字ベクトルに強制します。is.matrixはプリミティブな関数です。行列のprintメソッドは、各要素の名前またはインデックスを矩形にレイアウトします。  リスト行列の場合，長さが1でないエントリは，型と長さを示す integer,7 の形式で表示される．
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとする。  もしどちらも与えられない場合、1列の行列が返される。もし data の要素が少なすぎて行列を埋められない場合、 data の要素は再利用される。  データの長さが0の場合，アトミックベクトルの場合は適切な型のNA（生のベクトルの場合は0）が使用され，リストの場合はNULLが使用されます．is.matrixは，xがベクトルで長さ2の "dim "属性を持つ場合にTRUEを返し，そうでない場合はFALSEを返します．  この関数は汎用の関数です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。  データフレーム用のメソッドは、atomic列と(numeric/logical/complex)以外の列しかない場合は文字行列を返し、それ以外の文字列にはas.vectortを適用して因子と書式を指定します、as.matrixのデフォルトメソッドはas.vector(x)を呼び出すので、例えば因子を文字ベクトルに強制します。is.matrixはプリミティブな関数です。行列のprintメソッドは、各要素の名前またはインデックスを矩形にレイアウトします。  リスト行列の場合，長さが1でないエントリは，型と長さを示す integer,7 の形式で表示される．
nrowまたはncolのいずれかが与えられない場合、データの長さと他のパラメータからそれを推測しようとする。  もしどちらも与えられない場合、1列の行列が返される。もし data の要素が少なすぎて行列を埋められない場合、 data の要素は再利用される。  データの長さが0の場合，アトミックベクトルの場合は適切な型のNA（生のベクトルの場合は0）が使用され，リストの場合はNULLが使用されます．is.matrixは，xがベクトルで長さ2の "dim "属性を持つ場合にTRUEを返し，そうでない場合はFALSEを返します．  この関数は汎用の関数です。特定のクラスのオブジェクトを扱うメソッドを書くことができます。  データフレーム用のメソッドは、atomic列と(numeric/logical/complex)以外の列しかない場合は文字行列を返し、それ以外の文字列にはas.vectortを適用して因子と書式を指定します、as.matrixのデフォルトメソッドはas.vector(x)を呼び出すので、例えば因子を文字ベクトルに強制します。is.matrixはプリミティブな関数です。行列のprintメソッドは、各要素の名前またはインデックスを矩形にレイアウトします。  リスト行列の場合，長さが1でないエントリは，型と長さを示す integer,7 の形式で出力される．
noquote は、引数を "noquote" クラスのオブジェクトとして返す。  c()メソッドと添え字メソッド("[.noquote")があり、サブセットによってクラスが失われないようになっています。  printメソッド(print.noquote)は、文字列を引用符なしで表示します（"...... "は......と表示されます）。rightがprint(x, right=*)の呼び出しで指定された場合、xの可能なright設定よりも優先されます。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルとして表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、オブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
as.nameは、まず引数を内部的に文字ベクトルに強制します（そのため、as.character用のメソッドは使用されません）。  as.nameはas.vector(x, "symbol")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。
NULLは、構文的に正当な方法であれば、インデックスを付けることができます（Extract参照）。  NULLを持つオブジェクトは置換演算子で変更することができ、右辺の型に強制されます。NULLは空のペアリストとしても使用されます。NULLオブジェクトは1つしかないため、NULL値を持つオブジェクトは属性を持つことができません。
NULLをインデックス化する（Extractを参照）ことは、構文的に合法な方法であれば何でも可能です。  NULLを持つオブジェクトは置換演算子で変更することができ、右辺の型に強制されます。NULLは空のペアリストとしても使用されます。値NULLを持つオブジェクトは、NULLオブジェクトが1つしかないため、属性を持つことができません。属性を割り当てようとすると、エラー(attr)になるか、オブジェクトが属性を持つ空のリストに昇格します(属性と構造体)。
as.numericは汎用関数ですが、S3のメソッドはas.double用に書かなければなりません。  これはas.doubleと同じです。is.numericは内部汎用プリミティブ関数です：オブジェクトの特定のクラスを処理するメソッドを書くことができます。  is.doubleとは異なります。  因子はデフォルト・メソッドで処理され、"Date"、"POSIXt"、"difftime "クラス用のメソッドがあります（これらは全てfalseを返します）。  is.numericのメソッドは、そのクラスの基本型がdoubleまたはintegerであり、値が数値として合理的に見なされる場合（例えば、その値に対する算術演算が理にかなっており、比較は基本型で行われるべき）にのみtrueを返すべきです。
数値型は1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルから構成され、特に755のようなUnixライクなファイルパーミッションのために、8進数で表示されることを保証するためだけに使用されます。  width=NULL(デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数(integer型またはdouble型)と、要素が0〜7桁のみを含む(またはNAである)文字ベクトルをクラス "octmode "に変換することができます。
ベクトルxの型は制限されない。as.characterメソッドを持ち、ソート可能（byorder）であることだけが条件である。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は要素のレベル集合の和をレベルとする因子になり、レベルが要素のレベル集合に出現する順番になる（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合になることを意味する）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
LISPのような）伝統的なドット付きペア・リストは使用可能ですが、ユーザが目にすることはほとんどありません（関数の形式として使用する場合を除く）。  関数は、引数の指定方法に応じて、各値がタグ付きまたはタグなしの引数で構成されたリストまたはペアリストを返します。  alistはformals.as.と組み合わせて使われることが多い。as.listは引数をリストに強制しようとする。  関数の場合、これは形式引数のリストと関数本体を連結したものを返す。  as.listは因子を1要素の因子のリストに変換します。  引数がすでにリストか式でない限り、属性は取り除かれる。  (as.listの "environment "メソッドは、名前と値のペア（ドットで始まらない名前）を環境から名前付きリストにコピーします。  ユーザは、すべての名前付きオブジェクトをコピーするように要求できます。  sorted = TRUEでない限り、リストは特定の順序ではありません (順序はオブジェクトの作成順序と環境がハッシュ化されているかどうかに依存します)。  (コピーされたオブジェクトは重複するので、これは高価な操作になる可能性があります。)逆操作として、リスト・オブジェクトに対するas.environment()メソッドがあることに注意してください。空のペアリスト、pairlist()はNULLと同じです。  as.pairlistはas.vector(x, "pairlist")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。  リストは要素ごとにペアリストにコピーされ、リストの名前はペアリストのタグとして使用されます：他のタイプの引数の戻り値は文書化されていません。
as.POSIX*関数は、オブジェクトを、日付/時刻を表すのに使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のうちの1つに変換します。  as.POSIX*関数は、他のクラスと "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることに注意。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであると予想すべきだが、2つ目はBSTまたはGMTのどちらとも解釈できる（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることに注意。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることに注意。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意すること（seestrftime）。
as.POSIX*関数は、オブジェクトを日付/時刻を表現するために使用される2つのクラス（カレンダーの日付と最も近い秒までの時刻）のいずれかに変換します。  as.POSIX*関数は、他のクラスや "Date "クラスのオブジェクトをこれらのクラスに変換することができます。  また、"2001-02-03 "や "2001/02/03 "といった書式の文字列を変換することもできます。"14:52 "や "14:52:03 "といった書式では、その後に空白文字と時刻が続きます。  (「01/02/03」のような書式は曖昧だが、strptimeによる書式指定で変換できる)。  formatが指定された場合、format指定の中にはロケール固有のものがあることを覚えておいてください。  これは、%b、%B（月名）、%p（AM/PM）の使用に影響することが多い。論理NAはどちらのクラスにも変換できるが、その他の論理ベクトルは変換できない。  POSIXlt "から "POSIXct "への変換は、選択されたタイムゾーンの時間を検証します。  1つの問題は、例えば英国では、サマータイムへの移行時やサマータイムからの移行時に、それぞれ無効（時計が1:00GMTから2:00BSTに進んだ）と曖昧（時計が2:00BSTから1:00GMTに戻った）が発生することである。  このようなケースで何が起こるかはOSに依存する。1つ目はNAであることを期待すべきだが、2つ目はBSTまたはGMTのどちらかと解釈される可能性がある（一般的なOSは両方の可能な値を与える）。  OSの機能が無効な時刻を正しくフォーマットしない可能性があることにも注意されたい（seestrftime）。
QR分解は多くの統計手法で重要な役割を果たしている。  QR分解は多くの統計的手法で重要な役割を果たします。特に、与えられた行列 ㊟とベクトル㊟に対して方程式㊟=㊟を解くのに使えます。  qr.coef、qr.resid、qr.fitted関数は、QR分解qrでyを行列に当てはめたときの係数、残差、当てはめ値を返します（ピボットが使用されている場合、係数の一部はNAになります）。qtyはQ %*% yとt(Q) %*% yを返します。ここでQは(完全な)∕ボールド{Q}行列です。上記の関数はすべて、もしあればxとyのdim名(と名前)を保持します。  is.qrはxがリストであればTRUEを返し、"qr "を継承します。"qr "モードにオブジェクトを強制することはできません。  LINPACK インタフェースは、2^31 以下の要素を持つ行列 x に制限されている。qr.fitted と qr.resid は LINPACK インタフェースのみをサポートしている。
raw 型は生のバイトを保持することを意図している。  バイトのシーケンスを抽出し、要素を置換することが可能である（ただし、生のベクトルの要素によってのみ）。  関係演算子（バイト表現の数値順序を使用する比較を参照）は、ビットごとの解釈を持つ論理演算子（論理を参照）と同様に機能する。  rawへの強制は、入力値を小さな(10進)整数を表すものとして扱うので、入力はまず整数に強制され、[0 ... 255]の範囲外かNAの値は0(ヌルバイト)に設定されます。
doubleは、指定された長さの倍精度ベクトルを作成します。  as.doubleはジェネリック関数です。  as.numericと同じです。  is.doubleはdouble型のテストです。Rには単精度データ型がありません。  すべての実数は倍精度形式で格納されます。  関数as.singleとsingleは、as.doubleとdoubleと同じですが、Cと.Fortranインターフェースで使用される属性Csingleを設定します。
doubleは指定された長さの倍精度ベクトルを作成します。  これはnumeric.as.doubleと同じ汎用関数です。  as.numericと同じです。  is.doubleはdouble型のテストです。Rには単精度データ型がありません。  すべての実数は倍精度形式で格納されます。  関数as.singleとsingleは、as.doubleとdoubleと同じですが、Cと.Fortranインターフェイスで使用される属性Csingleを設定します。
as.nameは、まず引数を内部的に文字ベクトルに強制します（そのため、as.character用のメソッドは使用されません）。  as.nameはas.vector(x, "symbol")として実装されているので、汎用関数as.vectorのメソッドをディスパッチします。
引数dnnが与えられない場合、内部関数list.namesが呼び出されて'dimname名'が計算されます。  ...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、（以前はNAcountに含まれていた）除外された値をカウントしないように注意が払われています。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
引数dnnが与えられない場合、内部関数list.namesが呼び出され、'dimname name'が計算される。  ...の引数に名前が付けられていれば、その名前が使用される。  その他の引数については、deparse.level = 0は空の名前を与え、deparse.level = 1は与えられた引数がシンボルであればそれを使用し、deparse.level = 2は引数を破棄します、useNAは、NA値のカウントを表に含めるかどうかを制御する。許容される値は、never（"no"）、カウントが正の場合のみ（"ifany"）、カウントがゼロの場合でも（"always"）に対応する。useNAとexcludeの両方によって異なる扱いを受ける2つの異なる種類のNAという、やや「病的」なケースに注意。  非要素引数aは、factor(a, exclude=exclude)によって強制される。  R 3.4.0以降では、（以前はNAcountに含まれていた）除外された値をカウントしないように注意されています。クラス "table "のsummaryメソッド（tableまたはxtabsで作成されたオブジェクトに使用）は、基本的な情報を与え、因子の独立性のカイ2乗検定を実行します（chisq.test関数は現在2次元の表しか扱えないことに注意してください）。
mode="any "の場合、is.vectorはアトミックモード、リストおよび式に対してTRUEを返す。  (一方、as.vectorは、アトミックモードの結果に対して、nameを含む全ての属性を除去します（ただし、モード "list "や "expression "の結果は除去しません）。
is.vectorはFALSEを返し、as.vectorはmode = "any "の場合、因子を文字ベクトルに変換します（これは、S.vectorと互換性がありません）。  (一方、as.vectorは、アトミックモードの結果に対して、nameを含む全ての属性を除去します（ただし、モード "list "や "expression "の結果は除去しません）。
2つの引数のアークタンジェント atan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)です、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。これらはすべて、利用可能な場合、同じ名前のシステム・コール（複素引数には接頭辞cをつける）へのラッパーです。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
ブランチカットは逆三角関数asinらと一致しており、AbramowitzとStegunの図4.7、86ページで定義されているものと一致しています。   カットの実際の振る舞いは、C99標準に従っており、終点を反時計回りに回ってくる連続性が要求される。
packageHasNamespaceは、パッケージがamespaceを持っているかどうかを示すのではなく(現在はすべて持っています)、むしろ'NAMESPACE'ファイルを持っているかどうかを示します。  しかし、それを使うことを意図しているわけではありません。
applyは常に共通の長さの結果を単純化するので、 apply(x, MARGIN, identity)を使って分割しようとしてもうまくいかない(単にxを与えるだけだから)。  asplitをlapplyまたはvapplyと連鎖させることで、自動単純化しないapplyの変形を得ることができる。
asS3はcompleteの値を使って、オブジェクトをS3クラスの有効なオブジェクトに変換しようとするかどうかを制御します。  completeがTRUEである場合、S3クラスを拡張するS4クラスからのオブジェクトは、対応するS3クラスを持つS3オブジェクトに変換されます（S3Partを参照）。  これには、擬似クラスarrayとmatrixを拡張したクラスも含まれます。このようなオブジェクトは、class属性がNULLに設定されます。
isS4はmethodspackageに依存しないので、特にそのパッケージを要求する必要性を検出するために使用できることに注意してください。asS3はcompleteの値を使用して、オブジェクトを暗黙のS3クラスの有効なオブジェクトに変換しようとするかどうかを制御します。  completeがTRUEである場合、S3クラスを拡張するS4クラスからのオブジェクトは、対応するS3クラスを持つS3オブジェクトに変換されます（S3Partを参照）。  これには、擬似クラスarrayとmatrixを拡張したクラスも含まれます。そのようなオブジェクトは、class属性がNULLに設定されます。
pos引数には、オブジェクトを割り当てる環境を、-1（デフォルト）、正の整数（検索リスト内の位置）、検索リスト内の要素の文字列名、環境（sys.frameを使用して現在アクティブな関数にアクセスすることも含む）のいずれかで指定することができます。assignは代入メソッドをディスパッチしないので、ベクタの要素、名前、属性などを設定するために使用することはできません。添付リストやデータフレームに代入すると、元のオブジェクトではなく、添付されたコピーが変更されることに注意してください。
2つの引数のアークタンジェントatan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)となります、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。これらはすべて、利用可能な場合、同じ名前のシステム・コール（複素引数には接頭辞cをつける）へのラッパーです。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合はcosなどの呼び出しが使用され、2分の1の倍数の場合は特別なケースがあります)。
2つの引数のアーク・タンジェント atan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返す、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。これらはすべて、利用可能な場合、同じ名前のシステム・コール（複素引数には接頭辞cをつける）へのラッパーです。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
ブランチカットは逆三角関数asinらと一致しており、AbramowitzとStegunの図4.7、86ページで定義されているものと一致しています。   実際のカットの動作は、C99標準に従っており、終点を反時計回りに回ってくる連続性が要求される。
変数名や関数名を評価するとき、Rはsearchでリストされたデータベースからその名前を検索する。  データ・フレーム（またはリスト）を検索パスにアタッチすることで、データ・フレーム内の変数をデータ・フレームの構成要素としてではなく、名前だけで参照することができます（例えば、以下の例では、women$heightではなくheight）。  これは pos オプションで検索パスの後の方にアタッチするように変更できますが、pos = 1 でアタッチすることはできません。  データベースが実際にアタッチされるのではなく、検索パス上に新しい環境が作成され、リストの要素（データフレームの列を含む）や保存ファイルや環境内のオブジェクトが新しい環境にコピーされます。  <<-またはassignを使用してアタッチされたデータベースに割り当てた場合、変更されるのはアタッチされたコピーだけで、元のオブジェクトは変更されません(通常の割り当てでは、変更されたバージョンがユーザのワークスペースに置かれます: 例を参照してください)。  package: "で始まる名前はライブラリ用に予約されており、エンドユーザが使用すべきではありません。  添付ファイルはデフォルトでfile:whatという名前になります。  OmegahatパッケージRObjectTablesでサポートされている "UserDefinedDatabase "クラスのユーザ定義テーブルオブジェクトをアタッチするフックがあります。
関数loadNamespaceとattachNamespaceは、通常ライブラリが名前空間と必要なインポートをロードするために使用されるときに暗黙的に呼び出されます。  loadNamespace は、指定された名前空間をロードし、内部データベースに登録します。  指定された名前空間がすでにロードされているときに、その名前空間をロードするように要求しても、何の効果もありません。  引数は、libraryへの対応する引数と同じ意味を持っています。libraryのヘルプ・ページでは、特定のインストール済みパッケージがどのように選択されるかの詳細が説明されています。  ロード後、loadNamespaceは.onLoadという名前のフック関数を名前空間の内部変数として探します（これはエクスポートされるべきではありません）。  loadNamespaceは読み込んだ名前空間を検索パスにアタッチしません。attachNamespaceを使用すると、名前空間のエクスポートされた値を含むフレームを検索パスにアタッチできます（ただし、これはほとんどの場合ライブラリ経由で実行されます）。  isNamespaceLoaded(pkg)はpkg %in%loadedNamespaces()と同等ですが、pkg %in%loadedNamespaces()よりも効率的です。unloadNamespaceを使用すると、名前空間を強制的にアンロードすることができます。  名前空間がアタッチされている場合、最初にその名前空間がデタッチされ、それによって、名前空間に.onDetach関数または.Last.lib関数がエクスポートされている場合はその関数が実行されます。  名前空間が他のロードされた名前空間によってインポートされた場合、エラーがシグナルされ、名前空間はアンロードされない。  定義されている場合、内部レジストリから名前空間を削除する前にフック関数.onUnloadが実行されます。名前空間のアンロードと再ロードに関するいくつかの問題については、detachのヘルプのコメントを参照してください。
これらの関数は、オブジェクトの単一の属性へのアクセスを提供します。置換形式は、指定された属性に指定された値を取らせます（または、指定された値で新しい属性を作成します）。抽出関数は、まずxの属性の中でどの属性に完全に一致するかを探し、次に（exact = TRUEでない限り）一意な部分一致を探します。(オプション(warnPartialMatchAttr = TRUE)を設定すると、部分一致は警告を発します。)置換関数は、完全一致のみを使用します。いくつかの属性(class、comment、dim、dimnames、names、row.names、tsp)は特別に扱われ、設定できる値に制限があることに注意してください。  (NULLオブジェクトは属性を持つことができず、attrで割り当てようとするとエラーになります。
all.equalはジェネリック関数で、ターゲット引数にメソッドをディスパッチします。  使用可能なメソッドを見るにはemethods("all.equal")を使用しますが、デフォルトのメソッドでもいくつかのディスパッチが行われることに注意してください。  scale = NULL(デフォルト)での数値比較は、ターゲット値がゼロに近い場合を除き、通常相対差分スケールで行われます：  まず、2つの数値ベクトルの平均絶対差が計算されます。  まず、2つの数値ベクトルの差の平均絶対値が計算されます。これが許容範囲より小さいか、有限でない場合、差の絶対値が使用され、そうでない場合、差の絶対値の平均値でスケーリングされた相対差が使用されます。countEQ が真の場合、"サンプル "サイズを決定する際に、等しい場合とNAの場合がカウントされます。scaleが数値（かつ正）の場合、scaleでスケーリング（除算）した後に絶対比較が行われる。複素数のtargetの場合、差のモジュラス（Mod）が使用される、environmentメソッドはlistメソッドを介して動作し、参照クラスにも使用されます（特定のall.equalメソッドが定義されている場合を除く）。日付時刻オブジェクトのメソッドでは、all.equal.numericを使用して時刻（"POSIXct "表現）を0.001秒のデフォルト許容誤差で比較します。
これらの関数は、オブジェクトの単一の属性へのアクセスを提供します。置換形式は、指定された属性に指定された値を取らせます（または、指定された値で新しい属性を作成します）。抽出関数は、まずxの属性のうちwhichに完全に一致するものを探し、次に（exact = TRUEでない限り）一意の部分一致を探します。(オプション(warnPartialMatchAttr = TRUE)を設定すると、部分一致は警告を発します。)置換関数は、完全一致のみを使用します。いくつかの属性(class、comment、dim、dimnames、names、row.names、tsp)は特別に扱われ、設定できる値に制限があることに注意してください。  (NULLオブジェクトは属性を持つことができず、attrで割り当てようとするとエラーとなります。
いくつかの属性（class、comment、dim、dimnames、names、row.names、tsp）は特別に扱われ、設定できる値に制限があることに注意してください。  (これは、levels置換関数を使用して要因に設定されるべきlevelsには当てはまらないことに注意してください。)属性は、内部的にはリストとして格納されておらず、ベクトルではなく集合として考えるべきです。  これは、デフォルト引数attrib.as.set = TRUEを指定した場合のidentical()の動作にも反映されている。  mostattributes代入では、dim属性、names属性、dimnames属性に特別な注意が払われ、有効であることが分かっている場合のみ代入されます。  これは主に配列を対象としたもので、クラス化されたオブジェクトでは注意して使用する必要があります。  NULLオブジェクトはアトリビュートを持つことができず、アトリビュートを割り当てようとするとオブジェクトは空リストになります。
いくつかの属性（class、comment、dim、dimnames、names、row.names、tsp）は特別に扱われ、設定できる値に制限があることに注意してください。  (これは、levels置換関数を使用して要因に設定されるべきlevelsには当てはまらないことに注意してください。)属性は、内部的にはリストとして格納されておらず、ベクトルではなく集合として考えるべきです。  これは、デフォルト引数attrib.as.set = TRUEを指定した場合のidentical()の動作にも反映されている。  mostattributes代入では、dim属性、names属性、dimnames属性に特別な注意が払われ、有効であることが分かっている場合のみ代入されます。  これは主に配列を対象としたもので、クラス化されたオブジェクトでは注意して使用する必要があります。  NULLオブジェクトは属性を持つことができず、属性を割り当てようとするとオブジェクトは空リストになります。
NA
NA
x <- backsolve (R, b) は R x = b を、x <- forwardsolve(L, b) は L x = b をそれぞれ解きます。r/l は少なくとも k 行と列を、x は少なくとも k 行を持たなければなりません。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成される。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピーのセマンティクスがあるため、注意が必要です。
末尾のパス区切り文字はパスを分解する前に除去され、dirnameの場合は末尾のファイル区切り文字は結果から除去される。
nu < 0の場合、Abramowitz &Stegunの式9.1.2および9.6.2が適用されます(これはおそらく最適ではありません)。  場合によっては、この警告は誇張されており、精度は完璧です。  大きなν、例えば数百万オーダーの場合、現在のアルゴリズムはほとんど役に立ちません。
もしexpon.scaled = TRUEであれば、exp(-x) I(x;ν)またはexp(x) K(x;ν)が返されます。ν < 0であれば、Abramowitz &Stegunの式9.1.2と9.6.2が適用されます(これはおそらく最適ではありません)。  場合によっては、この警告は誇張されており、精度は完璧です。  大きなν、例えば数百万オーダーの場合、現在のアルゴリズムはほとんど役に立ちません。
もしexpon.scaled = TRUEであれば、exp(-x) I(x;ν)またはexp(x) K(x;ν)が返されます。ν < 0であれば、Abramowitz &Stegunの式9.1.2と9.6.2が適用されます(これはおそらく最適ではありません)。  場合によっては、この警告は誇張されており、精度は完璧です。  大きなν、例えば数百万オーダーの場合、現在のアルゴリズムはほとんど役に立ちません。
もしexpon.scaled = TRUEであれば、exp(-x) I(x;ν)またはexp(x) K(x;ν)が返されます。ν < 0であれば、Abramowitz &Stegunの式9.1.2と9.6.2が適用されます(これはおそらく最適ではありません)。  場合によっては、この警告は誇張されており、精度は完璧です。  大きなν、例えば数百万のオーダーでは、現在のアルゴリズムはほとんど役に立ちません。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lgamma関数、digamma関数、trigamm関数は内部ジェネリック・プリミティブ関数です：メソッドは個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。
環境をロックすることで、環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時には保持されませんが、.onLoadで作成することができます。
環境をロックすることで、環境からの変数バインディングの追加や削除を防ぐことができます。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時に保存されませんが、.onLoadで作成することができます。
domainがNULLまたは""で、gettextまたはngettextがパッケージpkgの名前空間の関数から呼び出された場合、domainは "R-pkg "に設定されます。  適切なドメインが見つかった場合、各文字列は翻訳され、現在の言語への翻訳が見つかればそれに置き換えられる。  メッセージの翻訳に使用される言語は、OSのデフォルトやRの起動時のロケール設定（Sys.getlocale()参照）、特にLANGUAGE環境変数によって決定される。通常、パッケージpkgのRの警告/エラーメッセージのドメインは "R-pkg "であり、Cレベルのメッセージのドメインは "pkg "です。  このようなメッセージの翻訳は、言語によって非常に特殊なルールがあります: GNU Gettextマニュアルを参照してください。  文字列には、insprintfで使用される%dのインスタンスが1つ含まれます。  bindtextdomainは、同じ名前のC関数のラッパーである。  dirnameがNULL以外の場合、メッセージカタログを探す場所を指定します。domain = NULLの場合、現在の場所を返します。
整数ベクトルの各要素は32ビットです。ペア演算の結果は整数のNAになることがあります。
整数ベクトルの各要素は32ビットで、ペア演算は整数のNAになる可能性があります。シフトは、値が符号なし整数を表すと仮定して行われます。
整数ベクトルの各要素は32ビットを持つ。ペア演算は整数のNAになる可能性があり、シフトは値が符号なし整数を表すと仮定して行われる。
整数ベクトルの各要素は32ビットを持つ。ペア演算は整数のNAになる可能性があり、シフトは値が符号なし整数を表すと仮定して行われる。
整数ベクトルの各要素は32ビットを持つ。ペア演算は整数のNAになる可能性があり、シフトは値が符号なし整数を表すと仮定して行われる。
整数ベクトルの各要素は32ビットで、ペア演算は整数のNAになる。
最初の形式では、fun には操作する関数を示す文字列を指定することができ、親フレームから検索される。  最も単純なものを除くすべてのボディは、中括弧で囲まれた式、つまり{への呼び出しです：このような呼び出しの作成方法については、「例」のセクションを参照してください。
最初の形式では、funは操作する関数を表す文字列で、親フレームから検索されます。  最も単純なものを除くすべてのボディは、中括弧で囲まれた式、つまり {: への呼び出しです。このような呼び出しの作成方法については、「例」のセクションを参照してください。
NA
breakはforループ、whileループ、repeatループから抜け出し、制御はループの一番外側の最初の文に移る。  breakもnextも、入れ子になったループの一番内側だけに適用される。よくある間違いだが、ステートメントを中括弧（{ .. }）で囲むのを忘れることがある、特に、if...else構文をキーボードやソースから入力する際の構文エラーを避けるために、}とelseの間に改行を入れるべきではありません。そのため、防御的なプログラミングの（やや極端な）姿勢の1つとして、if節などでは常に中括弧を使用するようにしています。  seqの長さがゼロの場合、ループの本体はスキップされる。そうでなければ、変数varにseqの各要素の値が順番に代入される。ループ本体内でvarに代入することもできるが、次の繰り返しには影響しない。  ループが終了しても、varは最新の値を含む変数として残る。
text引数とcondition引数の目的は、ヘルパー・プログラム（外部デバッガなど）がここに特定の値を挿入できるようにすることで、ブラウザへの特定の呼び出し（おそらくソース・ファイル内の位置）を特定し、特別な処理を行えるようにすることです。  この値は、browserTextとbrowserConditionを呼び出すことで取得できる。expr引数の目的は、条件付きデバッグを錯覚させることである。ほとんどの場合、呼び出し側プログラムでif文を使用した方が効率的ですが、この引数を使用した方が簡単な場合もあります。skipCalls引数は、browser()呼び出しが他のデバッグ関数内にネストされている場合に使用する。  コマンドは、ブラウザを終了し、次のステートメントで実行を継続します。c.の同義語は、現在のループまたは関数の実行を終了しますprintこのコマンドのリストは、関数呼び出しをステップオーバーしながら、次のステートメントを評価します。  ブラウザ呼び出しによって中断されるバイトコンパイル関数の場合、nはc.evaluate the next statementと等価であり、関数呼び出しに入ります。  この場合も、バイトコンパイルされた関数は、c.print a stack trace of all active function callsと等価になります。空行の処理は、"browserNLdisabled "オプションに依存し、TRUEであれば空行は無視される。  そうでない場合、空行はn（または直近に使用された場合はs）と同じになる。ブラウザのプロンプトに入力された他のものは、呼び出し環境で評価されるR式として解釈される。特にオブジェクト名を入力すると、そのオブジェクトが表示され、ls()は呼び出しフレーム内のオブジェクトを一覧表示する。  (ブラウザのプロンプトはBrowse[n]>という形式です: ここでvar{n}は「ブラウザ・レベル」を示します。  ブラウザはブラウズ中に呼び出すことができ(デバッグが使用されているときはよく呼び出される)、再帰的に呼び出されるたびに数値が増加する。  (実際の数は、コンテキスト・スタック上の「コンテキスト」の数である。これは通常、ブラウジングの外側レベルでは2であり、デバッガでダンプを調べるときには1である。)これはプリミティブ関数であるが、標準的な方法で引数のマッチングを行う。
browserText関数とbrowserCondition関数は、これらの値を取得する方法を提供します。  常に複数のブラウザ・コンテキストがアクティブである可能性があるため、異なるコンテキストからの値の取得もサポートしています。  browserSetDebugは、呼び出し関数のいずれかでブラウザを開始するメカニズムを提供します。  呼び出しスタックについてのより完全な議論はsys.frameを参照してください。browserSetDebugを使用するには、呼び出し関数を選択し、それが呼び出しスタックのどのくらい後ろにあるかを決定し、nをその値に設定してbrowserSetDebugを呼び出します。その後、ブラウザのプロンプトでcと入力すると、評価が続行され、ブラウザや他の割り込みへの呼び出しが介在しない限り、評価が指定されたクロージャに戻ると制御が再び停止します。  これは、他のデバッガにおけるgdborの「ステップ・アウト」機能に似ている。
browserを呼び出すたびに、テキスト文字列または条件を指定することができる。browserText関数とbrowserCondition関数は、これらの値を取得する方法を提供する。  常に複数のブラウザ・コンテキストがアクティブである可能性があるため、異なるコンテキストからの値の取得もサポートしています。  browserSetDebugは、呼び出し関数のいずれかでブラウザを開始するメカニズムを提供します。  呼び出しスタックについてのより完全な議論はsys.frameを参照してください。browserSetDebugを使用するには、呼び出し関数を選択し、それが呼び出しスタックのどのくらい後ろにあるかを決定し、nをその値に設定してbrowserSetDebugを呼び出します。その後、ブラウザのプロンプトでcと入力すると、評価が続行され、ブラウザや他の割り込みへの呼び出しが介在しない限り、評価が指定されたクロージャに戻ると制御が再び停止します。  これは、他のデバッガにおけるgdborの「ステップ・アウト」機能に似ている。
browserを呼び出すたびに、テキスト文字列または条件を指定することができる。browserText関数とbrowserCondition関数は、これらの値を取得する方法を提供する。  常に複数のブラウザ・コンテキストがアクティブである可能性があるため、異なるコンテキストからの値の取得もサポートしています。  browserSetDebugは、呼び出し関数のいずれかでブラウザを開始するメカニズムを提供します。  呼び出しスタックについてのより完全な議論はsys.frameを参照してください。browserSetDebugを使用するには、呼び出し関数を選択し、それが呼び出しスタックのどのくらい後ろにあるかを決定し、nをその値に設定してbrowserSetDebugを呼び出します。その後、ブラウザのプロンプトでcと入力すると、評価が続行され、ブラウザや他の割り込みへの呼び出しが介在しない限り、評価が指定されたクロージャに戻ると制御が再び停止します。  これは、gdや他のデバッガにおける「ステップ・アウト」機能のup機能に似ている。
builtins()は、シンボル・テーブルのオブジェクトのソートされていないリスト、つまりベース環境のすべてのオブジェクトを返します。  ls(baseenv(),all.names=TRUE)を使った方が混乱しないでしょう。builtins(TRUE)は、内部関数の名前のソートされていないリストを返します。
データフレームは行ごとに1つ以上の因子の値でサブセットされたデータフレームに分割され、関数FUNは各サブセットに順番に適用されます。デフォルトのメソッドでは、次元を持つオブジェクト（例えば行列）がデータフレームに連結され、データフレームメソッドが適用されます。  他のオブジェクトもデータ・フレームに強制されますが、FUN はデータ・フレームの各列 (のサブセット) に個別に適用されます。
デフォルトの方法では、次元を持つオブジェクト（例えば行列）がデータフレームに強制され、データフレーム法が適用されます。  他のオブジェクトもデータ・フレームに強制されますが、FUN はデータ・フレームの各列 (のサブセット) に個別に適用されます。
デフォルトの方法では、次元を持つオブジェクト（例えば行列）がデータフレームに強制され、データフレーム法が適用されます。  他のオブジェクトもデータ・フレームに強制されますが、FUN はデータ・フレームの各列（のサブセット）に個別に適用されます。
最初の11の関数は接続を作成します。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptによって作成されたソケットコネクション、およびserverSocketによって作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することによってオープンされるかもしれない。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
出力型は、NULL < raw < logical < integer < double < complex < character < list < expression の階層にあるコンポーネントの中で最も高い型から決定されます。  ペアリストはリストとして扱われ、ベクトル以外の構成要素(名前 / シンボルや呼び出しなど)は1要素のリストとして扱われます。as.vectorはより直感的な方法ですが、nameも落とします。  これはプリミティブ関数です。
日付は1970-01-01からの日数で表され、それ以前の日付は負の値となります。  日付は常に現在のグレゴリオ暦の規則に従って表示されますが、その暦が使用されていたのはそれほど昔のことではありません（イギリスとその植民地では1752年に採用されました）。  小数点以下の日数は、印刷時には無視されます。  methods(クラス = "Date")を参照してください。多くのメソッドの中から、いくつかのメソッドについては個別にドキュメント化されています。
関数difftimeは2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドがあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
ベクトルxの型は制限されません。as.characterメソッドを持ち、ソート可能（byorder）でなければなりません。順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、要素のレベル集合にレベルが出現する順序で、要素のレベル集合の和をレベルとする因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
noquote は引数を "noquote" クラスのオブジェクトとして返します。  c()メソッドと添え字メソッド("[.noquote")があり、サブセットによってクラスが失われないようにします。  printメソッド(print.noquote)は、文字列を引用符なしで表示します（"...... "は......と表示されます）。rightがprint(x, right=*)の呼び出しで指定された場合、xの可能なright設定よりも優先されます（例えば、x <- noquote(*, right=TRUE)で作成）。
数値バージョンは1つ以上の非負整数のシーケンスであり、通常(例えばパッケージの'DESCRIPTION'ファイルでは)シーケンスの要素を連結し、1つの.または-文字で区切られた文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、（UTCタイムゾーンにおける）1970年初頭からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置換したりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(警告が生成される時点)で最大となり、デフォルトでは50であることに注意。  例えば、options(warn)が変更された場合や、壊滅的なエラーが発生した場合などです。
つまり、与えられた引数（nameは呼び出される関数名を示す文字列でなければならない）に名前付き関数を適用した評価されない式を返します。  呼び出しは評価されないが、引数...は評価されることに注意。callはプリミティブであるため、最初の引数はnameとみなされ、残りの引数は構築された呼び出しの引数とみなされる。  is.call(x)は、typeof(x) == "language "と厳密に等価であることに注意してください。is.language()は、呼び出しに対しても真です（ただし、is.call()が偽の場合は、シンボルと式に対しても真）。as.call(<string>)を使おうと思ったら、parse(text=*)の効率的なバージョンであるstr2lang(*)を使うことを検討してください。call()とas.call()は、適用可能であれば、これらのparse()ベースのアプローチよりもはるかに好ましいことに注意してください。
callCCは、計算の早期終了に便利な非ローカル終了メカニズムを提供します。callCCは1つの引数、終了関数でfunを呼び出します。  exit関数は1つの引数、つまり意図された戻り値を取ります。  funのボディがexit関数を呼び出すと、callCCの呼び出しは直ちに戻り、exit関数に供給された値がcallCCによって返された値となる。
NA
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換する。範囲指定はサポートされているが、文字クラスと繰り返し文字はサポートされていない。  tolowerとtoupperは、文字ベクトル内の大文字を小文字に、またはその逆に変換する。  アルファベット以外の文字は変更されない。  casefoldは、S-PLUSとの互換性のために用意されたtolowerとtoupperのラッパーである。
catは、ユーザー定義関数の出力に便利です。引数を文字ベクトルに変換し、それらを1つの文字ベク トルに連結し、各要素に指定されたsep =文字列を付加して出力します。" \n "で明示的に要求されない限り、またはfillで生成されない限り（引数fillがTRUEまたは数字 の場合）、改行は出力されません。  現在のところ、アトミックなベクトルと名前だけが扱われ、NULLと他のゼロ長オブジェク トも扱われます（これは出力を生成しません）。  文字列は'そのまま'出力されます（print.defaultが非印字文字とバックスラッシュをエスケープするのとは異なります。）  その他のタイプのRオブジェクトは、catに渡す前に（as.characterやformatなどで）変換する必要があります。  catは数値/複素数の要素をprintと同じ方法で変換するので（Sに相当するas.characterと同じ方法では変換しません）、オプション "digits "と "scipen "が関連します。  ただし、すべての要素に同じフィールド幅ではなく、各要素に必要な最小のフィールド幅を使用する。
関数cbindとrbindは、データフレーム用のメソッドを持つS3汎用関数である。  少なくとも1つの引数がデータフレームで、残りがベクトルまたは行列の場合、データフレームメソッドが使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスである場合、つまりisS4(.)が真である場合、S4メソッドが求められ、パッケージ・メソッドの隠れたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、defaultメソッドと同様にdeparse.levelに従います。defaultメソッドでは、すべてのベクトル/行列はアトミック（vector参照）かリストでなければなりません。  言語オブジェクト（式や呼び出しなど）とペアリストはリストに強制され、その他のオブジェクト（名前や外部ポインタなど）はリスト結果の要素として含まれます。  複数の行列引数がある場合、それらはすべて同じ列数（または行数）でなければならず、これが結果の列数（または行数）となります。  すべての引数がベクトルの場合、結果の列（行）数は最長のベクトルの長さに等しくなります。  引数に行列とベクトルが混在している場合、結果の列(行)数は行列引数の列(行)数によって決定されます。  cbind(rbind)では、Sとの互換性のため、結果が0行(0列)にならない限り、長さ0のベクトル(NULLを含む)は無視される(S3では0行(0列)の行列は存在せず、Rでも無視されない)。行列は、64ビットシステムでも2^31行(行)および2列(列)以下に制限される。  R 3.2.0からは、より多くの要素を持つ（しかし行と列の制限を満たす）入力行列が許可されます。
関数cbindとrbindは、データフレーム用のメソッドを持つS3汎用関数です。  データ・フレーム・メソッドは、少なくとも1つの引数がデータ・フレームで、残りがベクトルまたは行列の場合に使用されます。  特に、時系列オブジェクト用のメソッドがあります。  使用するメソッドがどのように選択されるかについては、'ディスパッチ'のセクションを参照のこと。  引数のいくつかがS4クラスである場合、つまりisS4(.)が真である場合、S4メソッドが求められ、パッケージ・メソッドの隠れたcbind/rbind関数が呼び出され、それぞれoncbind2またはrbind2が構築される。  その場合、defaultメソッドと同様にdeparse.levelに従います。defaultメソッドでは、すべてのベクトル/行列はアトミック（vector参照）かリストでなければなりません。  言語オブジェクト（式や呼び出しなど）とペアリストはリストに強制され、その他のオブジェクト（名前や外部ポインタなど）はリスト結果の要素として含まれます。  複数の行列引数がある場合、それらはすべて同じ列数（または行数）でなければならず、これが結果の列数（または行数）となります。  すべての引数がベクトルの場合、結果の列（行）数は最長のベクトルの長さに等しい。  引数に行列とベクトルが混在している場合、結果の列(行)数は行列引数の列(行)数によって決定されます。  cbind(rbind)では、Sとの互換性のため、結果が0行(0列)にならない限り、長さ0のベクトル(NULLを含む)は無視される(S3では0行(0列)の行列は存在せず、Rでも無視されない)。行列は、64ビットシステムでも2^31行(行)および2列(列)以下に制限される。  R 3.2.0からは、より多くの要素を持つ（しかし行と列の制限を満たす）入力行列が許可されます。
5を四捨五入する場合、IEC 60559標準（'IEEE 754'も参照）が使用され、'偶数桁に行く'ことが期待されていることに注意してください。  ただし、これはOSのサービスや表示誤差に依存する（例えば0.15は正確に表現されていないため、丸めルールは表現された数字に適用され、印刷された数字には適用されないため、round(0.15, 1)は0.1にも0.2にもなりうる）。例えば、 round(x, digits = -2) は、最も近い100に丸められます。signifの場合、digitsの認識値は1...22であり、欠落していない値は、その範囲の最も近い整数に丸められます。  複素数は、指定された桁数を保持するように、成分の大きいほうに丸められます。  これらはすべてプリミティブ関数です。
この関数は、関数の引数に省略形が許され、可能な値のターゲットテーブルに対して一意に展開する必要がある場合に特に便利です。
as.characterとis.characterは汎用的です。特定のクラスのオブジェクトを処理するメソッドを書くことができます。  さらに、as.characterではデフォルトのメソッドがas.vectorを呼び出すので、ディスパッチはまずas.character用のメソッドで行われ、次にas.vector用のメソッドで行われます。as.characterは実数と複素数を15桁の有効数字で表します（技術的には、コンパイラがISO C定数DBL_DIGを設定したもので、C99標準に従ってIEC60559算術演算をサポートするマシンでは15になります）。  これは、結果のすべての桁が信頼できる（表現エラーの結果ではない）ことを保証しますが、文字に変換して数値に戻すと数値が変わる可能性があることを意味します。  可能な限りの精度で数値を文字に変換したい場合は、formatを使用してください。
完全一致は、部分一致(マッチする値が対象の最初の部分と完全一致するが、 対象の方が長い場合)よりも優先されます。完全一致が1つだけ、あるいは完全一致がなく一意に部分一致する場合は、 マッチする値のインデックスが返されます。
numToBits(.)とpackBits(., type="double")は互いに逆関数である。
chartrは、oldで指定されたxの各文字を、newで指定された対応する文字に変換します。範囲指定はサポートされていますが、文字クラスや繰り返し文字はサポートされていません。  tolowerとtoupperは、文字ベクトル内の大文字を小文字に、またはその逆に変換する。  アルファベット以外の文字は変更されない。  casefoldは、S-PLUSとの互換性のために用意されたtolowerとtoupperのラッパーです。
日付/時刻には2つの基本クラスがある。  クラス "POSIXct "は、1970年（UTCタイムゾーン）開始からの（符号付き）秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年明け以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトは、多くの場合 "tzone "という属性を持つ。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性を削除します。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
NA
pivot=FALSEでxが非負定数でない場合、エラーが発生する。  pivot = TRUEの場合、正の半定値xのコレスキー分解を計算することができます。  ピボットはattr(Q, "pivot")として返されます。  しかし、pivot <- attr(Q, "pivot") and oo <- order(pivot)と設定すると、t(Q[, oo]) %*% Q[, oo] equals x、または、t(Q) %*% Q equals x[pivot, pivot]となります。  tolの値はLAPACKに渡され、負の値では（通常）nrow(x) * .Machine$double.neg.eps * max(diag(x))のデフォルトの公差が選択されます。  基礎となるLAPACKコードからの失敗結果は、正のエラーコードを与えるエラーになります： これらは、FORTRANコードを詳細に研究することによってのみ解釈できます。
もし pivot = FALSE で x が非負定数でなければエラーが発生する。  pivot = TRUEの場合、正の半定値xのコレスキー分解を計算することができます。  ピボットはattr(Q, "pivot")として返されます。  しかし、pivot <- attr(Q, "pivot") and oo <- order(pivot)と設定すると、t(Q[, oo]) %*% Q[, oo] equals x、または、t(Q) %*% Q equals x[pivot, pivot]となります。  tolの値はLAPACKに渡され、負の値では（通常）nrow(x) * .Machine$double.neg.eps * max(diag(x))のデフォルトの公差が選択されます。  基礎となる LAPACK コードからの失敗結果は、正のエラーコードを与えるエラーとなります： これらは、FORTRAN コードの詳細な研究によってのみ解釈することができます。
NA
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1、258ページ)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lγ関数、digamma関数、trigamma関数は内部ジェネリック・プリミティブ関数です：メソッドは個別に定義することも、Mathグループジェネリックを介して定義することもできます。
ここでは、いわゆる "S3 "クラス（およびメソッド）について説明します。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトは、オブジェクトが継承するクラスの名前を与える文字ベクトルであるクラス属性を持っています（関数oldClassおよびoldClass<-は、この属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性設定と同様にclass属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトであれば is を使用し、そうでなければ class(x) の全ての要素が what に含まれる場合に TRUE を返します。
ここでは、いわゆる "S3 "クラス（とメソッド）について説明する。S4 "クラス（およびメソッド）については、後述の "正式なクラス "を参照してください。多くのRオブジェクトは、オブジェクトが継承するクラスの名前を与える文字ベクトルであるclass属性を持っています（関数oldClassおよびoldClass<-は、この属性を取得および設定します。)オブジェクトがclass属性を持たない場合、それは暗黙的なclassを持ちます。例えば、"matrix"、"array"、"function"、"numeric"、またはtypeof(x)(これはmode(x)に似ています)の結果です。暗黙的な(あるいはS4)クラスのオブジェクトxの場合、(S3の)ジェネリック関数foo(x)が呼び出されると、メソッドディスパッチはclass(x)によって返されるよりも多くのクラスを使用する可能性があることに注意してください、例えば、数値行列の場合、foo.numeric() メソッドが適用されます。  UseMethod()が使用するクラスの正確な全文字ベクトルは、Rバージョン4.0.0以降、.class2(x)として利用可能です。(これは、S3ディスパッチが考慮される場合、S4オブジェクトにも適用されます。下記を参照してください。) .class2()を、実用的、診断的、デバッグのため以外の理由で使用することは、スマートというよりむしろ誤用かもしれないことに注意してください。クラス属性c("first", "second")を持つオブジェクトにジェネリック関数funが適用されると、システムはfun.firstという関数を検索し、見つかればオブジェクトに適用します。  そのような関数が見つからなければ、fun.secondと呼ばれる関数が試されます。  適切な関数を生成するクラス名がない場合、（存在すれば）fun.defaultという関数が使用されます。  class関数は、オブジェクトが継承するクラス名のベクトルを表示します。  これに対応して、class<-はオブジェクトが継承するクラスを設定します。  空の文字ベクトルまたはNULLを代入すると、oldClass<-または直接属性設定と同様にclass属性が削除されます。  例えば、class(x) <- setdiff(class(x), "ts").unclassはclass属性が削除された引数（のコピー）を返します。  (inheritsは、最初の引数がwhat引数で指定されたクラスのいずれかを継承しているかどうかを示します。  これがTRUEであれば、whatと同じ長さの整数ベクトルが返されます。  各要素は、whatの要素がマッチしたクラス(x)の位置を示します。isa は、x が S4 オブジェクトの場合は is を使用して、what で指定された class(es) のオブジェクトであるかどうかを調べます。
複数の文字列を1つまたは複数の機会にプッシュバックすることができる。この機会はスタックを形成するので、最初に取り出される行は、最後にpushBackを呼び出したときの最初の文字列になる。  プッシュバックされた行は、readLinesやscanのような通常のテキスト読み取り関数によって、接続からの通常の入力の前に読み取られます。  このため、変換できない文字が <U+xxxx> として表示されることがあります。  encoding = "UTF-8 "の場合はUTF-8に変換され、encoding = "bytes "の場合はそのままになります。
最初の11個の関数は接続を作成します。  デフォルトでは、コネクションはオープンされませんが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンすることができます。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ利用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルだけをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ利用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルだけをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができます。
srcfile関数は、ソース・コード・ファイルの名前とディレクトリ、およびタイムスタンプを含むsrcfileクラスのオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
srcfile 関数は、ソース・レベル・デバッグ（まだ実装されていません）やソース・エコーに使用するソース・コード・ファイルの名前とディレクトリ、タイムスタンプを含むクラス srcfile のオブジェクトを生成します。  ファイルのエンコーディングが保存されます。エンコーディングについては file を、プラットフォームで許可されるエンコーディングの一覧についてはiconvlist を参照してください。srcfilecopy 関数は、子孫クラスの srcfilecopy オブジェクトを生成し、ソース行を文字ベクトルに保存します。  srcfilealias 関数は、子孫クラス srcfilealias のオブジェクトを生成し、別の srcfile に別の名前を付けます。  srcref関数は、asrcfileの文字の範囲を表すクラスsrcrefのオブジェクトを生成します。  4つの値しか与えられない場合、カラムとバイトは一致すると仮定される。  行(要素1, 3)とパースされた行(要素7, 8)は、 #lineディレクティブが使われている場合には異なるかもしれません。  srcfile および srcfilecopy クラスには、print、summary、open、close メソッドが定義されています。open メソッドは、特定の行で内部ファイル接続を開きます。  as.charactメソッドは、関連するソース・ファイルを読み込んで、参照に対応するテキストを取得します。  to引数が与えられた場合、それは同じファイル内の最初のsrcrefに続く2番目のsrcrefでなければなりません。  正確な動作は、ソースファイルのclassに依存します。  ソース・ファイルが srcfilecopy クラスを継承している場合、行数は "解析された" 行数を使用して保存されたコピーから取得されます。  そうでない場合は、ファイルの読み取りが試みられ、srcref レコードの元の行番号（つまり、要素 1 と 3）が使用される。  エラーが発生した場合 (ファイルが存在しない場合など)、代わりに<srcref: "file" chars 1:1 to 2:10>のようなテキストが返され、最初と最後の文字の行:列の範囲が示されます。  srcrefオブジェクトのリストは、"srcref "属性として式に添付することができます。  (srcrefオブジェクトのリストは、式と同じ長さでなければなりません。) デフォルトでは、式は、関連するsrcrefを使用してprint.defaultによって印刷されます。  代わりにデパースされたコードを表示するには、引数useSource = FALSEを指定してprintを呼び出します。  srcref オブジェクトが useSource = FALSE で出力された場合、<srcref: ...>レコードが出力されます。
stdin()、stdout()、stderr() は、それぞれコンソールの入力、出力、エラーに対応する標準接続です（ファイルストリームとは限りません）。  stdout()およびstderr()接続は、シンクによって再指示することができる（状況によっては、stdout()からの出力を分割することもできる：ヘルプ・ページを参照）。nullfile()は、ヌル・デバイスのファイル名（Unixでは"/dev/null"、Windowsでは "nul:"）を返す。showConnectionsは、情報のマトリックスを返す。  接続オブジェクトが失われたり忘れられたりした場合、getConnectionはテーブルから行番号を取り、その接続の接続オブジェクトを返す。  closeAllConnectionsは、すべてのユーザー接続をクローズ（および破棄）し、そうすることですべてのシンク・ディバージョンを復元します。isattyは、接続がクラス "terminal "接続の1つであり、それが明らかにターミナルに接続されている場合はtrueを返し、そうでない場合はfalseを返します。  GUIコンソールを含む組み込みアプリケーションでは、これは信頼できないかもしれない。
NA
これらの関数は、applyにFUN = meanまたはFUN = sumを適切なマージン付きで使用するのと同等ですが、より高速です。  これらの関数は高速化のために書かれているため、NaNとNAの微妙な点がぼやけています。  もしna.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、これはプラットフォームに依存するかもしれない。欠損値の省略は列または行単位で行われるので、列の平均は同じ行の集合に及ばないかもしれないし、その逆かもしれないことに注意。  完全な行または列のみを使用するには、まずna.omitまたはcomplete.cases（xの転置の場合あり）でそれらを選択します。名前に最初のドットが付いたバージョン（.colSums()など）は、プログラミングで使用するための「素の」バージョンです：これらは数値（のような）行列にのみ適用され、結果に名前を付けません。
オブジェクトに dimnamest がある場合、最初のコンポーネントは行名として使用され、2番目のコンポーネント（もしあれば）は列名として使用されます。  do.NULLがFALSEの場合、nodimnamesが存在するか、dimnamesの対応する成分がNULLであれば、単純な数値の前に接頭辞を付加した文字ベクトル（長さNROW(x)またはNCOL(x)）が返されます。配列/行列の置換メソッドは、value の vector と factor の値を文字に強制しますが、foras.character のメソッドはディスパッチしません。データフレームの場合、rownames の value は、重複せず欠落していない名前の文字ベクトルであるべきであり（これは強制されます）、colnames の value は、（できれば）一意な構文的に有効な名前の文字ベクトルであるべきです。  どちらの場合も、valueはas.characterに強制され、colnamesを設定すると行名がcharacterに変換されます。
オブジェクトがdimnamestを持つ場合、第1成分が行名として使用され、第2成分（もしあれば）が列名として使用されます。  do.NULLがFALSEの場合、nodimnamesが存在するか、dimnamesの対応する成分がNULLであれば、単純な数値の前に接頭辞を付加した文字ベクトル（長さNROW(x)またはNCOL(x)）が返されます。配列/行列の置換メソッドは、value の vector と factor の値を文字に強制しますが、foras.character のメソッドはディスパッチしません。データフレームの場合、rownames の value は、重複せず欠落していない名前の文字ベクトルであるべきであり（これは強制されます）、colnames の value は、（できれば）一意な構文的に有効な名前の文字ベクトルであるべきです。  どちらの場合も、valueはas.characterによって強制され、colnamesを設定すると行名がcharacterに変換されます。
これらの関数は、applyにFUN=meanまたはFUN=sumを適切なマージン付きで使用するのと同じであるが、より高速である。  これらの関数は高速化のために書かれているため、NaNとNAの微妙な違いがぼやけてしまっている。  もしna.rm = FALSEで、NaNかNAのどちらかが合計に現れると、結果はNaNかNAのどちらかになるが、これはプラットフォームに依存するかもしれない。欠損値の省略は列または行単位で行われるので、列の平均は同じ行の集合にならないかもしれないし、その逆もあり得ることに注意。  完全な行または列のみを使用するには、まずna.omitまたはcomplete.cases（xの転置の場合あり）でそれらを選択します。名前に最初のドットが付いたバージョン（.colSums()など）は、プログラミングで使用するための「基本的な」バージョンです：これらは数値（のような）行列にのみ適用され、結果に名前を付けません。
これらの引数は、標準的なRのコマンドライン処理が行われる前に取り込まれます。  つまり、これらは変更されていない値である。  これは、特にRの--argscommand-lineフラグで有用である。
NA
NA
複素数ベクトルはcomplexで作成できる。  ベクトルは、その長さ、実部と虚部、またはモジュラスと引数を与えて指定することができる。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、つまり実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られず、実数部または虚数部がNaNの複素数が得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義されており、solve, eigen, svdも同様である。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか一方または両方がNaN(NAを含む。NA_complex_と上記を参照)またはプラスマイナス無限大になる。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供する。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現される。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最近確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによって不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みを有効にしている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートで不足したパッケージをインストールする）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すべきではありません。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  .signalSimpleWarning、.handleSimpleError、および.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、これらのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。libraryがpackageまたはhelp引数なしで呼び出された場合、lib.locで指定されたライブラリ内の利用可能なすべてのパッケージをリストし、対応する情報をクラス "libraryIQR "のオブジェクトに返します。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locのデフォルト値(NULL)とともに使用すると、ライブラリよりも先に付属パッケージが検索されます。
NA
複素数ベクトルはcomplexで作成できます。  ベクトルは、長さ、実部と虚部、またはモジュラスと引数を与えて指定することができます。  (長さだけを指定すると、複素数のゼロのベクトルが生成されます。)as.complexは、引数が複素数型であることを強制しようとします: as.vectorのように、名前を含む属性を取り除きます。  Rバージョン3.2.xまでは、NAとNaNのすべての形式は複素数NA、つまり実部と虚部の両方がNAであるNA_complex_constantに強制されていました。R 3.3.0以降、通常、部分がNAのオブジェクトだけが複素数NAに強制されますが、NaNの部分を持つ他のオブジェクトは強制されません。  その結果、NaN（ただしNAは含まない）のみが関係する複素数演算では、通常、複素数NAは得られませんが、実数部または虚数部がNaNの複素数は得られます。is.complexとis.numericが両方ともTRUEになることはないことに注意してください。関数Re、Im、Mod、Arg、Conjは、複素数値に対して実数部、虚数部、モジュラス、引数、複素共役を返すという通常の解釈を持っています。  モジュラスと引数は極座標とも呼ばれる。  実数のxとyでz = x + i yとすると、r = Mod(z) = √(x^2 + y^2)、φ = Arg(z)で、x = r*cos(φ)、y = r*sin(φ)となる。  算術演算子(算術を参照)+, -, *, /, ^に加えて、初等三角関数、対数関数、指数関数、平方根関数、双曲線関数が複素数値に対して実装されています。行列乗算(%*%, crossprod, tcrossprod)も複素行列(matrix)に対して定義され、solve, eigen, svdも定義されている。内部的には、複素数は倍精度数値のペアとして格納され、そのどちらか、または両方がNaN(NAを含む。 NA_complex_と上記を参照)、またはプラスマイナス無限大になる。
NA
2つの引数のアークタンジェント atan2(y, x)は、x軸と原点から(x, y)へのベクトルとの間の角度を返す。 すなわち、正の引数の場合、atan2(y, x) == atan(y/x)となる、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
ブランチカットは逆三角関数asinらと一致しており、AbramowitzとStegunの図4.7、86ページで定義されているものと一致しています。   カットの実際の振る舞いは、端点を反時計回りに回ってくる連続性を要求するC99標準に従っている。
2つの引数atan2(y, x)のアークタンジェントは、x軸と原点から(x, y)へのベクトルとの間の角度を返します。つまり、正の引数の場合、atan2(y, x) == atan(y/x)です、cospi(x)、sinpi(x)、tanpi(x)は、2分の1の倍数であるx値に対して正確です。atan2以外は、内部ジェネリック・プリミティブ関数です。メソッドは、個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。  (cospi,sinpi,tanpiはC11拡張の一部であり、macOSやSolarisなどで提供されています: まだ利用可能でない場合、cosなどの呼び出しが使用されます。）
NA
ほとんどのプラットフォームでは、Rが初期化されたときにCのスタック情報が記録され、スタック・チェックに使用される。  この情報が利用できない場合、サイズはNAとして返され、スタックチェックは実行されない。スタックのベースアドレスに関する情報は、Windows、Linux（glibcを使用）、macOS、FreeBSDでは正確であると考えられるが、他のプラットフォームではヒューリスティックが使用される。  これは若干不正確な可能性があるため、現在の使用量はマイナスと推定される可能性がある。  (このヒューリスティックは、スタックベース情報が正確でないと思われるプラットフォーム上のRの組み込み使用では使用されません。)'評価深度'は、現在評価中のネストされたR式の数です: これは、options("expressions")によって制御される制限があります。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これらはジェネリック関数です：メソッドはそれらに対して個別に、またはMathグループジェネリックを介して定義することができます。
これは、curl -I -Lまたはcurl -Iが報告する内容を報告します。  ftp:// URLの場合、'ヘッダー'はデータ転送前のクライアントとサーバー間の会話の記録である。500行のヘッダーのみが報告される。20回のリダイレクトの制限があるので、これで十分であろう（20回でも問題があることを示している）。引数のtimeoutが正の整数に設定されていない場合、デフォルトで60秒に設定されているgetOption("timeout")を使用する。  HTTP[S]サーバーは、ヘッダーを読む要求を拒否することが許されており、拒否するサーバーもある。  通常、ブラウザでURLを見れば、何が問題なのかがわかる（マシン固有の問題である可能性もある）。
breaksが1つの数値として指定された場合、データの範囲は同じ長さのbreakに分割され、極端な値がbreakの区間内に収まるように、外側の限界は範囲の0.1%だけ遠ざけられる。  (xが定数ベクトルの場合、等しい長さの区間が作成され、そのうちの1つは単一の値を含みます。)labelsパラメータが指定されている場合、その値は因子レベルの名前に使用されます。  この場合、dig.lab は、数値 b1、b2、...の書式設定に使用されるべき最小の桁数を示します。端点のペアを区別するために必要な場合は、より大きな値（最大 12）が使用されます。  デフォルトのメソッドは、区切りの数値ベクトルをソートしますが、他のメソッドはソートする必要はなく、ラベルはソート後の区間に対応します。R 3.2.0以降では、labels = NULLでラベルが作成されると、getOption("OutDec")が参照されます。
rightのデフォルトはdefaultメソッドと異なることに注意。  breaks="quarter "を使用すると、3暦月の区間が作成され、区間は（min(x)に基づいて）1月1日、4月1日、7月1日、10月1日のいずれかに開始される。
breaksが1つの数値として指定された場合、データの範囲は等しい長さのbreakの部分に分割され、極端な値が両方ともbreakの区間内に収まることを保証するために、外側の限界は範囲の0.1%だけ遠ざけられます。  (xが定数ベクトルの場合、等しい長さの区間が作成され、そのうちの1つは単一の値を含みます。)labelsパラメータが指定されている場合、その値が因子レベルの名前に使用されます。  この場合、dig.lab は、数値 b1、b2、...の書式設定に使用されるべき最小の桁数を示します。端点のペアを区別するために必要な場合は、より大きな値（最大 12）が使用されます。  デフォルトのメソッドは、区切りの数値ベクトルをソートしますが、他のメソッドはソートする必要はなく、ラベルはソート後の区間に対応します。R 3.2.0以降では、labels = NULLでラベルが作成されると、getOption("OutDec")が参照されます。
rightのデフォルトはdefaultメソッドと異なることに注意。  breaks = "quarter "を使用すると、3暦月の区間が作成され、区間は（min(x)に基づいて）1月1日、4月1日、7月1日、10月1日のいずれかに開始する。
NA
データフレームは、"data.frame "クラスで指定された、同じ行数で同じ行名を持つ変数のリストである。  列名は空であってはならず、空の名前を使おうとするとサポートされない結果になります。  列名の重複は許されますが、そのようなデータフレームを生成するにはdata.frametでcheck.names = FALSEを使用する必要があります。  例えば、matrix-likesubsettingでは、結果の列名は一意でなければなりません。data.frameは、as.data.frame(optional = TRUE)を呼び出すことで、各引数をデータフレームに変換します。  これは一般的な関数であるため、引数の振る舞いをそのクラスに応じて変更するメソッドを書くことができる：data.frameに渡された文字変数は、Iで保護されているか、引数のstringsAsFactorsがfalseでない限り、因子列に変換されます。  data.frameにリストやデータフレーム、行列が渡された場合、各成分や列が別々の引数として渡されたのと同じになります（Iで保護されたフォーマット行列を除く）。data.frameに渡されるオブジェクトは同じ行数を持つべきですが、アトミックベクトル（is.vectorを参照）、因子、Iで保護された文字ベクトルは、必要であれば（リスト引数の要素としても）整数回リサイクルされます。data.frameの呼び出しで行名が与えられなかった場合、行名は適切な名前を持つ最初の構成要素、例えば名前付きベクトルや行名を持つ行列、データフレームから取得されます(その構成要素がその後にリサイクルされた場合、行名は警告と共に破棄されます)。  row.namesがNULLで与えられた場合、または適切なコンポーネントが見つからなかった場合、行名は1から始まる整数のシーケンスとなります（このような行名はas.matrixによって保存されず、'自動'であるとみなされます）。I.default.stringsAsFactors は、getOption("stringsAsFactors") を受け取り、その結果が TRUE または FALSE であることを保証する（あるいは、値が NULL でない場合はエラーをスローする）ユーティリティです。  この関数は現在非推奨であり、将来は使用できなくなります。
論理列と因子列は整数に変換されます。  文字列はまず因数に変換され、次に整数に変換されます。(is.numericに従って)数値でないその他の列は、as.numericまたはS4オブジェクトの場合はas(, "numeric")によって変換されます。  変換後）すべての列が整数の場合、結果は整数行列となり、そうでない場合は数値（double）行列となります。
NA
デバッグ用のフラグが付けられた関数に入ると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  デバッグプロンプトでは、コマンドまたはR式を入力することができ、その後に改行が続きます。  別の関数の内部で定義されている関数をデバッグするには、その定義の最後までシングルステップで進み、その関数の名前に対してdebugを呼び出します。デバッグの使用は永続的で、デバッグがオフにされない限り、デバッガはすべての呼び出しで入力されます（関数が削除され、置き換えられた場合、デバッグ状態は保存されないことに注意してください）。明示的なシグネチャでS4メソッドをデバッグするには、シグネチャを使用します。シグネチャを指定すると、デバッグ対象のメソッドを示す。この場合のデバッグは、デバッグ・ビットではなくトレース・マシンを使用するため、若干異なる実装になっていることに注意してください。そのため、テキストと条件を非NULLシグネチャと組み合わせて指定することはできません。isdebuggedは、a)シグネチャがNULLでクロージャfunがデバッグされた場合、またはb)シグネチャがNULLでなく、funがS4ジェネリックで、そのシグネチャのfunのメソッドがデバッグされた場合にTRUEを返します。関数がデバッグ用に入力されたとき、デパースされた呼び出しに対して出力される行数は、options(deparse.max.lines)を設定することで制限することができます。バイトコンパイルされた関数でデバッグが有効になっている場合、デバッグが無効になるまで、関数の解釈バージョンが使用されます。
デバッグ用のフラグが付けられた関数が入力されると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  デバッグ・プロンプトでは、コマンドまたはR式を入力することができ、その後に改行が続きます。  別の関数の内部で定義されている関数をデバッグするには、その定義の最後までシングルステップで進み、その関数の名前に対してdebugをコールします。デバッグの使用は永続的で、デバッグがオフにされない限り、デバッガはすべての呼び出しで入力されます（関数が削除され、置き換えられた場合、デバッグ状態は保存されないことに注意してください）。明示的なシグネチャでS4メソッドをデバッグするには、シグネチャを使用します。シグネチャを指定すると、デバッグ対象のメソッドを示す。この場合のデバッグは、デバッグ・ビットではなくトレース・マシンを使用するため、若干異なる実装になっていることに注意してください。そのため、テキストと条件を非NULLシグネチャと組み合わせて指定することはできません。isdebuggedは、a)シグネチャがNULLでクロージャfunがデバッグされた場合、またはb)シグネチャがNULLでなく、funがS4ジェネリックで、そのシグネチャのfunのメソッドがデバッグされた場合にTRUEを返します。関数がデバッグ用に入力されたとき、デパースされた呼び出しに対して出力される行数は、options(deparse.max.lines)を設定することで制限することができます。バイトコンパイルされた関数でデバッグが有効になっている場合、デバッグが無効になるまで、関数の解釈バージョンが使用されます。
デバッグ用のフラグが付けられた関数が入力されると、通常の実行は中断され、関数本体が1ステートメントずつ実行されます。  デバッグ・プロンプトでは、コマンドまたはR式を入力することができ、その後に改行が続きます。  別の関数の内部で定義されている関数をデバッグするには、その定義の最後までシングルステップで進み、その関数の名前に対してdebugを呼び出します。デバッグの使用は永続的で、デバッグがオフにされない限り、デバッガはすべての呼び出しで入力されます（関数が削除され、置き換えられた場合、デバッグ状態は保存されないことに注意してください）。明示的なシグネチャでS4メソッドをデバッグするには、シグネチャを使用します。シグネチャを指定すると、デバッグ対象のメソッドを示す。この場合のデバッグは、デバッグ・ビットではなくトレース・マシンを使用するため、若干異なる実装になっていることに注意してください。そのため、テキストと条件を非NULLシグネチャと組み合わせて指定することはできません。isdebuggedは、a)シグネチャがNULLでクロージャfunがデバッグされた場合、またはb)シグネチャがNULLでなく、funがS4ジェネリックで、そのシグネチャのfunのメソッドがデバッグされた場合にTRUEを返します。バイトコンパイルされた関数のデバッグが有効になっている場合、デバッグが無効になるまで、その関数の解釈されたバージョンが使用されます。
データ・フレームは、同じ行数の変数からなるリストで、"data.frame "というクラスが与えられます。  列名は空であってはならず、空の名前を使おうとするとサポートされない結果になります。  列名の重複は許されますが、そのようなデータフレームを生成するにはdata.frametでcheck.names = FALSEを使用する必要があります。  例えば、matrix-likesubsettingでは、結果の列名は一意でなければなりません。data.frameは、as.data.frame(optional = TRUE)を呼び出すことで、各引数をデータフレームに変換します。  これは一般的な関数であるため、引数の振る舞いをそのクラスに応じて変更するメソッドを書くことができる：data.frameに渡された文字変数は、Iで保護されているか、引数のstringsAsFactorsがfalseでない限り、因子列に変換されます。  data.frameにリストやデータフレーム、行列が渡された場合、各成分や列が別々の引数として渡されたのと同じになります（Iで保護されたフォーマット行列を除く）。data.frameに渡されるオブジェクトは同じ行数を持つべきですが、アトミックベクトル（is.vectorを参照）、因子、Iで保護された文字ベクトルは、必要であれば（リスト引数の要素としても）整数回リサイクルされます。data.frameの呼び出しで行名が与えられなかった場合、行名は適切な名前を持つ最初の構成要素、例えば名前付きベクトルや行名を持つ行列、データフレームから取得されます(その構成要素がその後にリサイクルされた場合、行名は警告と共に破棄されます)。  row.namesがNULLで与えられた場合、または適切なコンポーネントが見つからなかった場合、行名は1から始まる整数のシーケンスとなります（このような行名はas.matrixによって保存されず、'自動'であるとみなされます）。I.default.stringsAsFactors は、getOption("stringsAsFactors") を受け取り、その結果が TRUE または FALSE であることを保証する（あるいは、値が NULL でない場合はエラーをスローする）ユーティリティです。  この関数は現在非推奨であり、今後使用できなくなります。
eval.envもassign.envもデフォルトは現在アクティブな環境です。delayedAssignによってプロミスに代入された式は、最終的に「強制」されるまで評価されません。  これは変数が最初にアクセスされたときに起こります。最終的にプロミスが強制されると、eval.envで指定された環境（その間に内容が変更されている可能性があります）で評価されます。  その後、値は固定され、式は再び評価されることはありません。
これらの関数は、評価されない式（ここで'式'は、expressionで使用されるmodeとtypeof "expression "のベクトルという厳密な概念よりも広い意味でとらえられる）を文字列（parseの逆の一種）に変換します。典型的な使用法は、データセットやプロットの情報ラベルを作成することです。  この例では、この機能の簡単な使い方を示している。  この例では、関数deparseとsubstituteを使用して、関数myplotの実際の引数の文字列バージョンであるプロットのラベルを作成している。  control=c("all", "hexDigits")を使用することは、deparse()をparse()の逆とすることに最も近い（しかし、"digits17 "を含む "all "が良くないという例はまだ見たことがない）。  コントロールに "digits17 "または "hexDigits "が含まれていない限り（あるいは "all "または "exact "にこれらのいずれかが含まれていない限り）、数値ベクトルおよび複素数ベクトルは有効数字15桁で変換される。deparse1()は、R 4.0.0で追加された簡単なユーティリティで、deparse1(substitute(.))と同様に、名前作成でよく使われる文字列の結果(長さ1の文字ベクトル)を保証します。
これらの関数は、評価されない式（ここで'expression'は、expressionで使用されるmodeとtypeof "expression "のベクトルの厳密な概念よりも広い意味でとらえられる）を文字列に変換する（parseの逆の一種）。  この例では、この機能の簡単な使い方を示している。  この例では、関数deparseとsubstituteを使用して、関数myplotの実際の引数の文字列バージョンであるプロットのラベルを作成している。  control=c("all", "hexDigits")を使用することは、deparse()をparse()の逆とすることに最も近い(しかし、"digits17 "を含む "all "が良くないという例をまだ見たことがない)。  コントロールに "digits17 "または "hexDigits "が含まれていない限り（あるいは "all "または "exact "にこれらのいずれかが含まれていない限り）、数値ベクトルおよび複素数ベクトルは有効数字15桁で変換される。deparse1()は、R 4.0.0で追加された簡単なユーティリティで、deparse1(substitute(.))のように、名前作成でよく使われる文字列の結果(長さ1の文字ベクトル)を保証します。
行列式関数はLU分解を使用し、det関数は単に行列式を呼び出すためのラッパーです。
また、package:toolsのような検索リスト上の項目の引用符なしまたは引用符付きの名前でも使用できます。パッケージに名前空間がある場合、デタッチしてもデフォルトでは名前空間はアンロードされず（unload = TRUEでもアンロードされないことがあります）、デタッチしても一般に動的にロードされたコンパイル済みコード（DLL）はアンロードされません。  さらに、名前空間から登録されたS3メソッドは削除されません。S3メソッドは登録時にそのソースにタグ付けされないため、一般的に、与えられたパッケージに関連付けられたメソッドの登録を安全に解除することはできません。名前空間がロードされたパッケージでライブラリを使用すると、すでにロードされた名前空間のエクスポートがアタッチされます。  そのため、パッケージをデタッチして再アタッチしても、パッケージの一部またはすべてのコンポーネントがリフレッシュされない可能性があり、お勧めできません。パッケージを完全にデタッチする最も確実な方法は、Rを再起動することです。
行列式関数はLU分解を使用し、det関数は単に行列式を呼び出すためのラッパーです。
行列式関数はLU分解を使用し、det関数は単にdeterminant関数を呼び出すためのラッパーです。
dputはファイルを開き、オブジェクトxをそのファイルに格納する。  オブジェクト名は（dumpとは異なり）書き込まれません。xが関数の場合、関連する環境は取り除かれます。したがって、スコープ情報が失われる可能性があります。  デフォルトの制御では、dput()は読みやすい方法でデパースを試みますが、複雑なオブジェクトや特殊なオブジェクト（seedump）では、オリジナルと同じものとして解析される可能性は高くありません。  dputは、ファイルに書き込まれた文字数が予想より少なかった場合に警告を出します。これは、ファイルシステムが一杯になっているか、壊れている可能性があります。内部表現をデパースするのではなく、保存されたソースを表示するには、controlに "useSource "を含めます。  Rは現在、関数定義に対してのみソースを保存する。  ソースの表示を気にしない場合（例えばデータ・オブジェクトの場合）、sourceを呼び出すときにoptions(keep.source = FALSE)を設定する。
x がスカラ（長さ 1 のベクトル）で唯一の引数である場合、スカラで指定されたサイズの正方恒等行列を返します。 x が「数値」（複素数、数値、整数、論理、または raw）ベクトルであり、長さが少なくとも 2 であるか、さらに引数があります。  これは、指定された対角エントリとゼロの対角外エントリを持つ行列を返す。
x がスカラ（長さ1のベクトル）で唯一の引数である場合、スカラで指定されたサイズの正方恒等行列を返します。 x が「数値」（複素数、数値、整数、論理、またはraw）ベクトルであり、長さが少なくとも2であるか、さらに引数がある場合。  この関数は、指定された対角エントリとゼロの対角外エントリを持つ行列を返す。
diffは、デフォルトのメソッドとクラス "ts"、"POSIXt"、"Date "に対するものを持つ汎用関数です。
diffはデフォルトのメソッドを持つ汎用関数であり、クラス "ts"、"POSIXt"、"Date".NAのものは伝播する。
diffはデフォルトのメソッドとクラス "ts"、"POSIXt"、"Date".NAのプロパゲートを持つ汎用関数です。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  units="auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる最大の単位（"weeks "を除く）が選択されます。difftimeをunits="auto "で呼び出すと、このクラスのオブジェクトが得られます。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
diffは、デフォルト・メソッドとクラス "ts"、"POSIXt"、"Date "用のものを持つ汎用関数です。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  units="auto "の場合、適切な単位セットが選択され、すべての絶対値の差が1より大きくなる最大の単位（"weeks "を除く）が選択されます。difftimeをunits="auto "で呼び出すと、このクラスのオブジェクトが得られます。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定しなければならず、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lgamma関数、digamma関数、trigamma関数は、内部ジェネリックプリミティブ関数です：メソッドは、個別に定義することも、Mathグループジェネリックを介して定義することもできます。
dimにはdata.frames用のメソッドがあり、xとxのrow.names属性の長さ（それぞれ行数と列数）を返します。
関数dimとdim<-は内部のgenericprimitive関数です。dimはdata.frames用のメソッドを持っており、xとxのrow.names属性の長さを（それぞれ行と列の数として）返します。
dimとdim<-は内部のgenericprimitive関数です。dimはdata.frames用のメソッドを持っており、xとxのrow.names属性の長さを（それぞれ行と列の数として）返します。
dimnames関数とdimnames<-関数は汎用的な関数で、配列（特に行列）に対して、オブジェクトのdimnames属性（属性参照）を取得または設定します。  配列/行列の置換メソッドは、vectorとfactorelementsの値をcharacterに強制しますが、as.characterのメソッドはディスパッチしません。  長さ0の要素はNULLに、長さ0のリストはNULLに強制されます。  valueが次元数より短いリストの場合は、必要な長さまでNULLで拡張されます。  データ・フレームの dimnames は、row.names と name です。  provideDimnames(x)は、"missing "の場合にdimnamesを提供し、その結果が各成分のcharacterdimnamesを持つようにします。  デフォルトでuniqueがtrueの場合、make.unique(*, sep=sep)によって各コンポーネント内で一意になります。
関数 dimnames と dimnames<- は汎用的なもので、配列の場合（特に行列の場合）、オブジェクトの dimnames 属性（属性を参照）を取得または設定します。  配列/行列の置換メソッドは、vectorとfactorelementsの値をcharacterに強制しますが、as.characterのメソッドはディスパッチしません。  長さ0の要素はNULLに、長さ0のリストはNULLに強制されます。  valueが次元数より短いリストの場合は、必要な長さまでNULLで拡張されます。  データ・フレームの dimnames は、row.names と name です。  provideDimnames(x)は、"missing "の場合にdimnamesを提供し、その結果が各成分のcharacterdimnamesを持つようにします。  デフォルトでuniqueがtrueの場合、make.unique(*, sep=sep)によって各コンポーネント内で一意になります。
関数 dimnames と dimnames<- は汎用的なもので、配列の場合（特に行列の場合）、オブジェクトの dimnames 属性（属性を参照）を取得または設定します。  配列/行列の置換メソッドは、vectorとfactorelementsの値をcharacterに強制しますが、as.characterのメソッドはディスパッチしません。  長さ0の要素はNULLに、長さ0のリストはNULLに強制されます。  valueが次元数より短いリストの場合は、必要な長さまでNULLで拡張されます。  データ・フレームの dimnames は、row.names と name です。  provideDimnames(x)は、"missing "の場合にdimnamesを提供し、その結果が各成分のcharacterdimnamesを持つようにします。  デフォルトでuniqueがtrueの場合、make.unique(*, sep=sep)によって各コンポーネント内で一意になります。
関数 dimnames と dimnames<- は汎用的なもので、配列の場合（特に行列の場合）、オブジェクトの dimnames 属性（属性を参照）を取得または設定します。  配列/行列の置換メソッドは、vectorとfactorelementsの値をcharacterに強制しますが、as.characterのメソッドはディスパッチしません。  長さ0の要素はNULLに、長さ0のリストはNULLに強制されます。  valueが次元数より短いリストの場合、必要な長さまでNULLで拡張されます。  データ・フレームの dimnames は、row.names と name です。  provideDimnames(x)は、"missing "の場合にdimnamesを提供し、その結果が各成分のcharacterdimnamesを持つようにします。  デフォルトでuniqueがtrueの場合、make.unique(*, sep=sep)によって各コンポーネント内で一意になります。
NA
dir.existsは、パスが（file.existsと同じ意味で）存在し、ディレクトリであることをチェックします。dir.createは、recursive = TRUEでない限り、パスの最後の要素を作成します。  モードは、システム関数mkdirと同じように、umaskの設定によって変更される。  どのようなモードが設定できるかはOS依存であり、3桁以上のオクタルディジットが使用されると仮定するのは危険である。  Windowsの特異性のひとつに、ディレクトリの作成が成功したと報告しても、別の名前のディレクトリが作成されることがある（例：dir.create("G.S.")は'"G.S"'を作成する）。  これは文書化されており、正確な状況は不明である（Windowsのバージョンに依存するかもしれない）。  Sys.chmodは、1つまたは複数のファイルのパーミッションを設定する。システムによってはサポートされていない場合がある（警告が出る場合）。モードがどのように解釈されるかについては、dir.createのコメントを参照のこと。  シンボリックリンクでモードを変更することは（必要でも）ないでしょう。詳細については、システムコールのchmodに関するOSのドキュメント、例えばman 2 chmodを参照してください（この名前のコマンドラインユーティリティのものではありません）。  シンボリックリンクのパーミッションを変更するか、ターゲットを変更するかはOSに依存します（ターゲットを変更する方が一般的ですが、POSIXはシンボリックリンクのモードをサポートしていません）：Sys.umaskはumaskを設定し、以前の値を返す。特殊なケースとして、mode = NAは現在の値を返すだけである。  詳細については、システムコールumaskに関するOSのドキュメント、例えばman 2 umaskを参照のこと。モードがどのように扱われるかは、Unix系であってもファイルシステムによって異なる（ただし、それらのドキュメントはPOSIXファイルシステムを想定して書かれていることが多い）。  そのため、例えばFAT/FAT32やネットワークマウントされたファイルシステムを使用している場合は、ドキュメントを慎重に扱ってください。マークされたエンコーディングのファイルパスがどのように解釈されるかは、ファイルを参照してください。  
dir.existsは、（file.existsと同じ意味で）パスが存在し、ディレクトリであることをチェックします。dir.createは、recursive = TRUEでない限り、パスの最後の要素を作成します。  モードは、システム関数mkdirと同じように、umaskの設定によって変更される。  どのようなモードが設定できるかはOS依存であり、3桁以上のオクタルディジットが使用されると仮定するのは危険である。  Windowsの特異性のひとつに、ディレクトリの作成が成功したと報告しても、別の名前のディレクトリが作成されることがある（例：dir.create("G.S.")は'"G.S"'を作成する）。  これは文書化されており、正確な状況は不明である（Windowsのバージョンに依存するかもしれない）。  Sys.chmodは、1つまたは複数のファイルのパーミッションを設定する。システムによってはサポートされていない場合がある（警告が出る場合）。モードがどのように解釈されるかについては、dir.createのコメントを参照のこと。  シンボリックリンクでモードを変更することは（必要でも）ないでしょう。詳細については、システムコールのchmodに関するOSのドキュメント、例えばman 2 chmodを参照してください（この名前のコマンドラインユーティリティのものではありません）。  シンボリックリンクのパーミッションを変更するか、ターゲットを変更するかはOSに依存します（ターゲットを変更する方が一般的ですが、POSIXはシンボリックリンクのモードをサポートしていません）：Sys.umaskはumaskを設定し、以前の値を返す。特殊なケースとして、mode = NAは現在の値を返すだけである。  詳細については、システムコールumaskに関するOSのドキュメント、例えばman 2 umaskを参照のこと。モードがどのように扱われるかは、Unix系であってもファイルシステムによって異なる（ただし、それらのドキュメントはPOSIXファイルシステムを想定して書かれていることが多い）。  そのため、例えばFAT/FAT32やネットワークマウントされたファイルシステムを使用している場合は、ドキュメントを慎重に扱ってください。マークされたエンコーディングのファイルパスがどのように解釈されるかは、ファイルを参照してください。  
Windows 以外では、パスのチルダ展開が行われる。パスを分解する前に、末尾のパス区切り文字が削除され、dirname については、末尾のファイル区切り文字が結果から削除される。
quoteがFALSE（デフォルト）の場合、引数は（envirではなく呼び出し側の環境で）評価される。  もしquoteがTRUEであれば、各引数は引用符で囲まれ(quoteを参照)、引数評価の効果として引用符が取り除かれます。  正確なセマンティクスは現在未定義であり、変更される可能性があります。
NA
doubleは、指定された長さの倍精度ベクトルを作成します。  これはnumeric.as.doubleと同じ汎用関数です。  as.numericと同じです。  is.doubleはdouble型のテストです。Rには単精度データ型がありません。  すべての実数は倍精度形式で格納されます。  関数as.singleとsingleはas.doubleとdoubleと同じですが、Cと.Fortranインターフェースで使用される属性Csingleを設定します。
dputはファイルを開き、オブジェクトxをそのファイルに格納します。  オブジェクト名は書き込まれません（dumpとは異なります）。xが関数の場合、関連する環境は取り除かれます。したがって、スコープ情報が失われる可能性があります。  デフォルトの制御では、dput()は読みやすい方法でデパースを試みますが、複雑なオブジェクトや特殊なオブジェクト（seedump）では、オリジナルと同じものとして解析される可能性は高くありません。  dputは、ファイルに書き込まれた文字数が予想より少なかった場合に警告を出します。これは、ファイルシステムが一杯になっているか、壊れている可能性があります。内部表現をデパースするのではなく、保存されたソースを表示するには、controlに "useSource "を含めます。  Rは現在、関数定義に対してのみソースを保存する。  ソースの表示を気にしない場合（例えばデータ・オブジェクトの場合）は、sourceを呼び出す際にoptions(keep.source = FALSE)を指定してください。
この関数の目的は、R の出力（警告やエラー・メッセージなど）で使用するテキストを引用するための簡単なマークアップ手段を提供することです。適切な引用符の選択は、ロケールと使用可能な文字セットの両方に依存します。  古いUnix/X11フォントでは、グレイブ・アクセント（ASCIIコード0x60）とアポストロフィ（0x27）が、マッチする開閉単一引用符としても使用できるように表示されます。  最近のフォントやUnix以外のシステムでは、これらの文字はもはや一致するグリフを生成しません。  Unicodeは左右のシングルクォーテーション・マーク・キャラクタ（U+2018とU+2019）を提供しています。Unicodeのマークアップが利用可能であると仮定できない場合、アポストロフィを非方向シングルクォーテーション・マークとして使用するのが良い方法と思われます。同様に、Unicodeには左右のダブルクォーテーション・マーク文字(U+201CとU+201D)があります。ASCIIのタイプライターの特性しか利用できない場合は、ASCIIのクォーテーション・マーク(0x22)を左右両方のダブルクォーテーション・マークとして使用する必要があります。  TeXはグレイヴとアポストロフィを方向シングルクォーテーションに使用し、ダブルグレイヴとダブルアポストロフィを方向ダブルクォーテーションに使用します。どのレンダリングが使用されるかはqに依存し、デフォルトではuseFancyQuotesのオプション設定に依存します。  これがFALSEの場合、無指向性のASCII引用符スタイルが使用されます。  UTF-8 "に設定すると、UTF-8マークアップが使用されます（現在のロケールが何であれ）。TeX "に設定すると、TeXスタイルのマークアップが使われます。  最後に、これを長さ 4 の文字ベクトルに設定すると、最初の 2 つのエントリが開始と終了のシングルクォートに、後の 2 つのエントリが開始と終了のダブルクォートに使用されます: これは、ギルメットの使用など、英語以外のクォート規則を実装するために使用できます。
NA
factor "クラスのメソッドは、現在のところfactor(x, exclude=exclude)と同等です。  データ・フレーム・メソッドでは、すべての因子列に対して exclude を "グローバルに "指定することはほとんどありません。
クラス "factor "のメソッドは、現在のところfactor(x, exclude=exclude)と等価です。  データ・フレーム・メソッドでは、すべての因子列に対して exclude を "グローバルに "指定することはほとんどありません。
クラス "factor "のメソッドは、現在のところfactor(x, exclude=exclude)と等価です。  データ・フレーム・メソッドでは、すべての factor 列に対して exclude を "グローバルに "指定することはほとんどありません。
指定されたオブジェクトの一部が（スコープ内に）存在しない場合、警告を伴ってそれらは除外されます。  sourceingは、ダンプされたオブジェクトの同一コピーを生成しない場合があります。  ダンプ・ファイルは別のR（またはおそらくS）セッションにソースすることができますが、関数saveおよびsaveRDSはRデータの転送に使用するように設計されており、dumpが扱わないRオブジェクトでも動作します。  再現性を最大にするために、econtrol = c("all", "hexNumeric")を使用します。オブジェクトをより読みやすく表現するには、econtrol = NULLを使用します。  これは属性をスキップし、ソースが同じコピーを生成する可能性を低くするような他の簡略化を行います。  詳細については、「deparse」を参照してください。保存されたソースを表示するのではなく、関数の内部表現をdeparseするには、control = c("keepInteger", "warnIncomplete", "keepNA")を使用します。  プロミスは通常、レイジー・ロードの結果（デフォルトのevaluate = TRUEが不可欠な場合）、およびdelayedAssignの使用後（evaluate = FALSEが意図されている場合）にしかユーザは遭遇しないでしょう。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに等価なメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに等価なメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに等価なメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに同等のメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠損値（"NA"）は、NaNとは異なる数値や複素数のものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。詳細は、同じ概念を使用するmatch（およびunique）を参照してください。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax が小さすぎる場合、エラーが発生する可能性があります: nmax = 1 は黙って無視されます。長いベクトルはデフォルトのメソッドであるduplicatedでサポートされていますが、 nmax が指定された場合にのみ使用可能です。
これらは、ベクトル（リストを含む）、データフレーム、配列（行列を含む）用のメソッドを持つ汎用関数です。デフォルトのメソッド、およびduplicatedとanyDuplicatedに等価なメソッド定義がある場合、anyDuplicated(x, ...)はany(duplicated(x, ...))の "一般化された "ショートカットで、重複する最初のエントリx[i]があればそのインデックスiを返し、なければ0を返します。  duplicated(x, fromLast = TRUE)は、rev(duplicated(rev(x)))と等価ですが、rev(duplicated(rev(x)))よりも高速です。配列メソッドは、MARGINで指定された部分配列の各要素について、残りの次元が以前の（または fromLast = TRUE の場合は後の）要素と同じかどうかを計算します（行の長さ順）。  MARGIN=0は、xと同じ次元属性の配列を返すことに注意してください。欠落値（"NA"）は、NaNとは異なる数値や複雑なものと等しいとみなされます。文字列は、"共通のエンコーディング "で比較されます。これは、かなり小さな値の集合に対して使用することを意図しており、非常に大きな集合に対しては効率的ではありません。因数、論理、生のベクトルを除いて、デフォルトのnmax = NAは、nmax = length(x)と等価です。  サイズ8*nmaxバイトのハッシュ・テーブルが割り当てられるので、nmaxを適切に設定することで、大量のメモリを節約することができます。  因子の場合、nmaxは自動的に length(x)とレベル数に1を足した値（NAの場合）のうち小さい方に設定される。  nmax があまりに小さく設定されるとエラーになる可能性があります: nmax = 1 は黙って無視されます。長いベクトルは、デフォルトの重複法でサポートされていますが、 nmax が指定された場合にのみ使用可能です。
数値バージョンは1つ以上の非負整数からなるシーケンスで、通常は(パッケージの'DESCRIPTION'ファイルなどでは)シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷を可能にする表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
日付/時刻には2つの基本クラスがあります。  クラス "POSIXct "は、(UTCタイムゾーンにおける)1970年初頭からの(符号付き)秒数を数値ベクトルで表します。  クラス "POSIXlt "は、0-61:秒0-59:分0-23:時1-31:月0-11:年始以降の月1900年以降の年0-6:曜日（日曜日から始まる）0-365:年（うるう年のみ365）夏時間フラグ。  有効ならプラス、無効ならゼロ、不明ならマイナス。(オプション。) その時点で有効なタイムゾーンの略称：未知の場合は""（ただしUTCの場合は""を使うこともある）。（オプション）GMTからのオフセット（秒）。  (オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。(オプション) GMTからのオフセット(秒): 正の値は子午線の東を意味する。しかし、必ずしも設定されているわけではない)。  多くのメソッド(length(x)、print()、strを含む)は "POSIXct "のように抽象的な日付時刻ベクトルに適用されるため、内部リスト構造は多少隠されていることに注意。  R 3.5.0以降では、2つのインデックスを持つ[ インデックス付け]によって、単一のコンポーネントを抽出したり置き換えたりすることができます(例を参照)。  これらのクラスは、POSIX/C99の'calendartime'(time_tデータ型)と'local time'(またはbroken-down time、 struct tmデータ型)に対応しており、その名前も継承している。  POSIXlt "の構成要素は、secとzoneを除いて整数ベクトルである。"POSIXct "の方がデータフレームに含めるのに便利であり、"POSIXlt "の方が人間が読める形に近い。  POSIXlt "の構成要素wdayとydayは情報用であり、暦時間への変換には使用されない。しかし、isdstは夏時間終了時の時間を区別するために必要である。  それ以外の時間帯では、isdstは最初の6つの値から推測することができるが、設定が正しくない場合の動作はプラットフォームに依存する。論理比較といくつかの算術演算は、両方のクラスで利用可能である。  日付-時刻オブジェクトから秒数を加算または減算することはできるが、2つの日付-時刻オブジェクトを加算することはできない。  POSIXlt "オブジェクトには "tzone "という属性があることが多い。"tzone "は長さ3の文字ベクトルで、タイムゾーン名（TZ環境変数または "POSIXlt "オブジェクトを生成する関数の引数tzから得られる。  POSIXct "オブジェクトはまた、"tzone "という属性を持つことがあり、これは長さ1の文字ベクトルである。  空でない値が設定された場合、そのオブジェクトがどのように "POSIXlt "クラスに変換され、特にどのように印刷されるかが決定される。  残念ながら、この変換はタイムゾーンとうるう秒の操作によって複雑になります（このバージョンのRのデータによると、27日はこれまで86401秒の長さで、最後は2017-01-01（実際はその直前）です：余分な秒の時間はオブジェクト.leap.secondsにあります）。  この詳細は、可能な限りOSのサービスに委ねられている。  稀にうるう秒を使用するシステムもあったようだが、現在知られているすべてのプラットフォームはうるう秒を無視している（POSIXで要求されている）。  POSIXlt "オブジェクトでcを使用すると、それらは現在のタイムゾーンに変換され、"POSIXct "オブジェクトでは、それらがすべて同じタイムゾーンでマークされていない限り、すべての "tzone "属性は削除されます。  まず、うるう秒は無視され、"2005-12-31 23:59:60 "のような実時間は（おそらく）次の秒として扱われる。  しかし、これらはRによって生成されることはなく、入力として発生する可能性は低い。  第2に、いくつかのOSでは、POSIX/C99標準の "1969-12-31 23:59:59 UTC "に問題があり、これは暦時間では-1であり、これらのOSではこの値はエラーコードとしても使用される。  したがって、as.POSIXct("1969-12-31 23:59:59", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")はNAを与えるかもしれず、したがってas.POSIXct("1969-12-31 23:59:59", tz = "UTC")は "1969-12-31 23:59:00 "を与える。  printメソッドはoptions("max.print")を尊重する。
last.warningオブジェクトが存在し、warnings()が使用される状況については、options("warn")の説明を参照のこと。  last.warning "の長さは、options("nwarnings")(警告が生成される時点)で最大となり、デフォルトでは50であることに注意。  例えば、options(warn)が変更された場合や、致命的なエラーが発生した場合などである。
dyn.loadがロードするオブジェクトは、macOSを除くすべてのプラットフォームで「dynamicallyloadable libraries」（「DLL」と略される）と呼ばれる。  Unix系では「dynamicallyhared objects」（略称「DSO」）、または「shared objects」とも呼ばれる。  (POSIX標準では'実行可能オブジェクトファイル'を使用していますが、他の誰も使用していません。)適切なDLLを作成しインストールする方法については、'参照'および'R拡張の作成'および'Rのインストールと管理'マニュアルを参照してください。  これらの引数は、ユーザーが個々のライブラリのロード・プロセスをより詳細に制御できるようにするために用意されています。  一般的には、デフォルト値が適切であり、正当な理由があり、その意味を理解している場合にのみオーバーライドする必要があります。ローカル引数では、アタッチされるDLL内のシンボルを他のDLLから見えるようにするかどうかを制御できます。  シンボルを独自の名前空間に保持することは良い習慣ですが、関連する「章」をまたいでシンボルを共有する機能は、多くの場合に有用です。  さらに、プラットフォームやオペレーティング・システムのバージョンによっては、すべてのシンボルを正常に解決するために、シンボルをグローバルにロードしなければならないライブラリもあります。now引数をFALSEとして遅延ロードを使用すると、副作用が発生する可能性があるので注意が必要です。  シンボルが見つからないルーチンが呼び出された場合、プロセスは即座に終了する。  ライブラリ開発者がTRUEを指定して呼び出すと、すべてのシンボルが実際に解決されていることが確認され、一般ユーザーがFALSEを指定して呼び出すと、見つからないシンボルは無視され、使用可能なシンボルが呼び出されるようになる。  グローバル・テーブルに追加されたシンボルは、アプリケーションの他のすべての要素で使用できるため、2つの異なるDLL間で共有することができる。  これは微妙なバグの原因になる。  サポートされていないオプションが使われたときに警告メッセージが出るようにすることもできる。  これは、options関数でverboseまたはwarnオプションのいずれかをゼロ以外に設定することで可能です。これらの追加引数については、http://www.stat.ucdavis.edu/~duncan/R/dynload/に短い説明とサンプルコードがあります。
dyn.loadがロードするオブジェクトは、macOSを除くすべてのプラットフォームで「dynamicallyloadable libraries」（「DLL」と略される）と呼ばれる。  Unix系では「dynamicallyhared objects」（略称「DSO」）、または「shared objects」とも呼ばれる。  (POSIX標準では'実行可能オブジェクトファイル'を使用していますが、他の誰も使用していません。)適切なDLLを作成しインストールする方法については、'参照'および'R拡張の作成'および'Rのインストールと管理'マニュアルを参照してください。  これらの引数は、ユーザーが個々のライブラリのロード・プロセスをより詳細に制御できるようにするために用意されています。  一般的には、デフォルト値が適切であり、正当な理由があり、その意味を理解している場合にのみオーバーライドする必要があります。ローカル引数では、アタッチされるDLL内のシンボルを他のDLLから見えるようにするかどうかを制御できます。  シンボルを独自の名前空間に保持することは良い習慣ですが、関連する「章」をまたいでシンボルを共有する機能は、多くの場合に有用です。  さらに、プラットフォームやオペレーティング・システムのバージョンによっては、すべてのシンボルを正常に解決するために、シンボルをグローバルにロードしなければならないライブラリもあります。now 引数を FALSE として遅延ロードを使用すると、副作用が発生する可能性があるので注意が必要です。  シンボルが見つからないルーチンが呼び出された場合、プロセスは即座に終了する。  ライブラリ開発者がTRUEを指定して呼び出すと、すべてのシンボルが実際に解決されていることが確認され、一般ユーザーがFALSEを指定して呼び出すと、見つからないシンボルは無視され、使用可能なシンボルが呼び出されるようになる。  グローバル・テーブルに追加されたシンボルは、アプリケーションの他のすべての要素で使用できるため、2つの異なるDLL間で共有することができる。  これは微妙なバグの原因になる。  サポートされていないオプションが使われたときに警告メッセージが出るようにすることもできる。  これは、options関数でverboseまたはwarnオプションのいずれかをゼロ以外に設定することで行える。これらの追加引数については、http://www.stat.ucdavis.edu/~duncan/R/dynload/に短い説明とサンプルコードがある。
pos引数は、オブジェクトを検索する環境を、正の整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frametを使用することを含む）として、いくつかの方法で指定することができます。  デフォルトの-1は、toget呼び出しの現在の環境を示す。envir引数は、環境を指定する別の方法です。これらの関数は、指定された環境において、それぞれの名前xに値が束縛されているかどうかを調べます。  inheritsがTRUEであり、指定された環境内でxに値が見つからない場合、xという名前に出会うまでその環境を囲むフレームが検索されます。  modeが指定された場合、その型のオブジェクトのみが探索されます。ここでのmodeは、typeofとmodeの意味が混在しています：「mgetの場合、modeとifnotfoundの値は、xと同じ長さか、長さ1でなければならない。  引数ifnotfoundは、要求された項目が見つからなかった場合に使用する値か、項目が見つからなかった場合に呼び出される引数1つの関数を含むリストでなければならない。  dynGet()はやや実験的なもので、他の関数の内部で使用されます。この関数は呼び出し側、つまり関数のsys.frame()内でオブジェクトを探します。  注意して使用してください。
NA
対称行列が指定されていない場合、 isSymmetric(x)は、その行列が対称であるかどうかを、もっともらしい数値誤差の範囲で判定します。  行列の固有ベクトルを計算するのは、大きな行列では時間がかかる部分です。行列の固有分解を計算するのは、現実世界のコンピュータでは誤差が生じます。  あなたが望むことができるのは、適切に近い毒素の問題に対する解である。  したがって、実数の非対称なxが実数の固有値を繰り返す代数的な解を持つとしても、計算された解は複素共役な固有値の組を持つ類似の行列である可能性がある。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しにローカルな変数のフレームであり、その囲みは関数が定義された環境である（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピーのセマンティクスがあるため、注意が必要です。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言することができる。  この宣言はエンコーディングによって読み取ることができ、エンコーディングは "latin1"、"UTF-8"、"bytes"、または "unknown "という値の文字ベクトルを返します。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。enc2nativeとenc2utf8は、マークされたエンコーディングを考慮して、文字ベクトルの要素をそれぞれネイティブエンコーディングまたはUTF-8に変換します。  文字列が宣言されたエンコードを取得する方法は、明示的に設定する以外にもあります （そして、これらはRの進化に伴って変化してきました）。  Parserは "su "または "u "エスケープを含む文字列をマークする。  intToUtf8は出力を "UTF-8 "と宣言し、出力テキスト接続(seeTextConnection)は適切なロケールで実行されている場合にマークされます。  ほとんどの文字操作関数は、対応する入力でエンコーディングが宣言されていれば、出力文字列のエンコーディングを設定します。  これには、chartr、strsplit(useBytes = FALSE)、tolower、toupper、assub(useBytes = FALSE)、gsub(useBytes = FALSE)が含まれます。  substrはエンコーディングを保持し、chartr、 tolower、toupperはUnicodeワイド文字を持つシステムでUTF-8エンコーディングを保持します。  pasteとsprintfは、対応する入力のいずれかがバイトとしてマークされていれば、バイトとしてマークされた要素を返し、それ以外の入力のいずれかがUTF-8としてマークされていれば、UTF-8としてマークされた要素を返します。match、pmatch、charmatch、duplicated、uniqueはすべて、要素のいずれかがUTF-8としてマークされていれば、UTF-8でマッチする。一部のOS（特にWindows）では、ISO 8859-1文字セットで未定義の（または制御文字に使用される）文字位置が使用されるため、「Latin-1」ロケールの意味については曖昧な部分がある。  このような文字がどのように解釈されるかはシステムに依存しますが、R 3.5.0からは、UTF-8などに変換する際に、可能であればWindowsのコードページ1252（Microsoftは「WindowsLatin 1 (ANSI)」と呼んでいます）に従って解釈されます。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言することができる。  これらの宣言はエンコーディングによって読み込まれ、"latin1"、"UTF-8"、"bytes"、または "unknown "という値の文字ベクトルを返します。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。  文字列が宣言されたエンコードを取得する方法は、明示的に設定する以外にもあります （そして、これらはRの進化に伴って変化してきました）。  Parserは "su "または "u "エスケープを含む文字列をマークする。  intToUtf8は出力を "UTF-8 "と宣言し、出力テキスト接続(seeTextConnection)は適切なロケールで実行されている場合にマークされます。  ほとんどの文字操作関数は、対応する入力でエンコーディングが宣言されていれば、出力文字列のエンコーディングを設定します。  これには、chartr、strsplit(useBytes = FALSE)、tolower、toupper、assub(useBytes = FALSE)、gsub(useBytes = FALSE)が含まれます。  substrはエンコーディングを保持し、chartr、 tolower、toupperはUnicodeワイド文字を持つシステムでUTF-8エンコーディングを保持します。  pasteとsprintfは、対応する入力のいずれかがバイトとしてマークされていれば、バイトとしてマークされた要素を返し、それ以外の入力のいずれかがUTF-8としてマークされていれば、UTF-8としてマークされた要素を返します。match、pmatch、charmatch、duplicated、uniqueはすべて、要素のいずれかがUTF-8としてマークされていれば、UTF-8でマッチする。一部のOS（特にWindows）では、ISO 8859-1文字セットで未定義の（または制御文字に使用される）文字位置が使用されるため、「Latin-1」ロケールの意味については曖昧な部分がある。  このような文字がどのように解釈されるかはシステムに依存しますが、R 3.5.0からは、UTF-8などに変換する際に、可能であればWindowsのコードページ1252（Microsoftは「WindowsLatin 1 (ANSI)」と呼んでいます）に従って解釈されます。
これは、バックスラッシュや、制御文字( \a(ベル), ˶ b(バックスペース), ˶ f(フォームフィード), ˶ n(ラインフィード), ˶ r(キャリッジリターン), ˶ t(タブ), ˶ v(バーティカルタブ)をエスケープし、8進数表記(˶ xyz with leading zeroes)で印刷されます。どの文字が印字不可能文字になるかは、現在のロケールに依存する。Windowsの印字可能文字の報告 は信頼性に欠けるため、シングルバイトロケールでは、その他の制御文字はすべて印字不可能文字とみなされ、 コード32～255の文字はすべて印字可能文字とみなされる。マルチバイトロケールでの印字不可能文字の扱いにつ いては、print.defaultを参照のこと。  quoteがシングルクォートまたはダブルクォートの場合、同じタイプの埋め込みクォートはエスケープされます。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言することができる。  これらの宣言はエンコーディングによって読み取ることができ、エンコーディングは "latin1"、"UTF-8"、"bytes"、"unknown "のいずれかの値の文字ベクトルを返す。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。  文字列が宣言されたエンコードを取得する方法は、明示的に設定する以外にもあります （そして、これらはRの進化に伴って変化してきました）。  Parserは "su "または "u "エスケープを含む文字列をマークする。  intToUtf8は出力を "UTF-8 "と宣言し、出力テキスト接続(seeTextConnection)は適切なロケールで実行されている場合にマークされます。  ほとんどの文字操作関数は、対応する入力でエンコーディングが宣言されていれば、出力文字列のエンコーディングを設定します。  これには、chartr、strsplit(useBytes = FALSE)、tolower、toupper、assub(useBytes = FALSE)、gsub(useBytes = FALSE)が含まれます。  substrはエンコーディングを保持し、chartr、 tolower、toupperはUnicodeワイド文字を持つシステムでUTF-8エンコーディングを保持します。  pasteとsprintfは、対応する入力のいずれかがバイトとしてマークされていれば、バイトとしてマークされた要素を返し、それ以外の入力のいずれかがUTF-8としてマークされていれば、UTF-8としてマークされた要素を返します。match、pmatch、charmatch、duplicated、uniqueはすべて、要素のいずれかがUTF-8としてマークされていれば、UTF-8でマッチする。一部のOS（特にWindows）では、ISO 8859-1文字セットで未定義の（または制御文字に使用される）文字位置が使用されるため、「Latin-1」ロケールの意味については曖昧な部分がある。  このような文字がどのように解釈されるかはシステムに依存しますが、R 3.5.0からは、UTF-8などに変換する際に、可能であればWindowsのコードページ1252（Microsoftは「WindowsLatin 1 (ANSI)」と呼んでいます）に従って解釈されます。
Rの文字列は、"latin1"、"UTF-8"、または "bytes "でエンコードされると宣言することができる。  これらの宣言はエンコーディングによって読み込むことができ、エンコーディングは "latin1"、"UTF-8"、"bytes"、"unknown "のいずれかの値の文字ベクトルを返します。  ASCII文字列は、宣言されたエンコーディングでマークされることはない。  bytes "としてマークされた文字列は、バイトとして操作されるべきASCII文字列であり、文字エンコーディングに変換されることはありません（したがって、テキストファイルへの書き込みは、writeLines(useBytes = TRUE)によってのみサポートされます）。enc2nativeとenc2utf8は、マークされたエンコーディングを考慮して、文字ベクトルの要素をそれぞれネイティブエンコーディングまたはUTF-8に変換します。  文字列が宣言されたエンコードを取得する方法は、明示的に設定する以外にもあります （そして、これらはRの進化に伴って変化してきました）。  Parserは "su "または "u "エスケープを含む文字列をマークする。  intToUtf8は出力を "UTF-8 "と宣言し、出力テキスト接続(seeTextConnection)は適切なロケールで実行されている場合にマークされます。  ほとんどの文字操作関数は、対応する入力でエンコーディングが宣言されていれば、出力文字列のエンコーディングを設定します。  これには、chartr、strsplit(useBytes = FALSE)、tolower、toupper、assub(useBytes = FALSE)、gsub(useBytes = FALSE)が含まれます。  substrはエンコーディングを保持し、chartr、 tolower、toupperはUnicodeワイド文字を持つシステムでUTF-8エンコーディングを保持します。  pasteとsprintfは、対応する入力のいずれかがバイトとしてマークされていれば、バイトとしてマークされた要素を返し、それ以外の入力のいずれかがUTF-8としてマークされていれば、UTF-8としてマークされた要素を返します。match、pmatch、charmatch、duplicated、uniqueはすべて、要素のいずれかがUTF-8としてマークされていれば、UTF-8でマッチする。一部のOS（特にWindows）では、ISO 8859-1文字セットで未定義の（または制御文字に使用される）文字位置が使用されるため、「Latin-1」ロケールの意味については曖昧な部分がある。  このような文字がどのように解釈されるかはシステムに依存しますが、R 3.5.0からは、UTF-8などに変換する際に、可能であればWindowsのコードページ1252(Microsoftは'WindowsLatin 1 (ANSI)'と呼んでいます)に従って解釈されます。
このコードには、接頭辞または接尾辞の長さが 1 である最も一般的な使用法に対して最適化された分岐があり、UTF-8 または 8 バイトのロケールで ASCII 文字列に変換する場合にさらに最適化されます。
以下のmyplotの例では、この機能の簡単な使い方を示しています。deparse関数とsubstitute関数を使用して、myplot関数の実際の引数の文字列バージョンであるプロットのラベルを作成しています：envのバインドシンボルでなければ、変更される。  もしそれがpromiseオブジェクト、つまり関数の正式な引数であるか、delayedAssign()を使って明示的に作成されたものであれば、promiseの式スロットがシンボルを置き換えます。  ただし、envがGlobalEnvの場合はシンボルは変更されません。quoteとsubstitutionはどちらも引数を評価しない「特別な」プリミティブ関数です。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には変わったコピー・セマンティクスがあるため、注意が必要です。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードによる仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピー・セマンティクスがあるため、注意が必要です。
環境は、フレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードの仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピー・セマンティクスがあるため、注意が必要です。
環境をロックすると、その環境からの変数バインディングの追加や削除ができなくなります。  バインディングがロックされていない限り、変数の値を変更することは可能です。  lockBindingは、指定された環境内の個々のバインディングをロックします。  ロックされたバインディングの値は変更できません。  ロックされたバインディングは、その環境がロックされていない限り、環境から削除することができます。makeActiveBindingは環境envにfunをインストールし、symの値を取得する場合は引数なしでfunを呼び出し、symに代入する場合は引数付きでfunを呼び出します。  これにより、R変数にリンクされたC変数やデータベースにリンクされた変数のようなものを実装することができ、setRefClassを実装するために使用されます。  現在のところ、アクティブなバインディングはパッケージのインストール時に保存されませんが、.onLoadで作成することができます。
環境はフレーム、または名前付きオブジェクトのコレクションと、それを囲む環境へのポインタから構成されます。  最も一般的な例は、関数呼び出しのローカル変数のフレームで、その囲みは関数が定義された環境です（その後変更されない限り）。  後者（parent.frameが返す）は関数の呼び出し元の環境を指します。  getやexistsがデフォルトのinherits = TRUEで環境を検索する場合、フレーム内の変数を探し、次にそれを囲むフレームを探し、といった具合です。  これはglobalenv()によってもアクセスできる。  BaseNamespaceEnv オブジェクトは、ベース・パッケージのネームスペース環境です。  どの環境からでもparent.envを繰り返し呼び出すことで見つかるエンクロージャの連鎖をたどっていくと、最終的には何も割り当てられていない空の環境emptyenv()に到達する。置換関数parent.env<-は、内部Cコードの仮定を破るような方法で環境を破壊的に変更するために使用される可能性があり、非常に危険である。  environmentの置換形であるis.environment、baseenv、emptyenv、globalenvは原始的な関数です。base環境、global環境、empty環境などのシステム環境には、パッケージ環境、名前空間環境、attach()によって生成される環境と同様に名前があります。  その他の環境は、"name "属性を与えることで名前を付けることができますが、環境には通常とは異なるコピーのセマンティクスがあるため、注意が必要です。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出されるハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  これらの関数は、クリーンアップ・ハンドラが割り込まれないようにするために使用できます。.signalSimpleWarning、.handleSimpleError、および.tryResumeInterruptは内部的に使用されるため、直接呼び出すべきではありません。
envirが指定されていない場合、デフォルトはparent.frame()(evalが呼び出された環境)です。評価されるオブジェクトには、orexpressionまたはname(現在のスコープでnameが検索され、そのバインディングが評価される場合)、promise、またはvector、function、environment(変更されずに返される)などの基本的な型を呼び出すことができます。evalq形式はeval(quote(expr), ...)と等価です。evalは最初の引数を現在のスコープで評価してから評価器に渡します。evalqはこれを回避します。eval.parent(expr, n)はval(expr, parent.frame(n))の省略形です。envirがリスト（データフレームなど）またはペアリストの場合、一時的な環境にコピーされ（囲み付き）、一時的な環境が評価に使用されます。  envirがNULLの場合、空リストとして解釈され、envirに値が見つからず、ルックアップは直接enclosに行きます。  evalqと同等であるが、デフォルトの引数は空の環境を新たに生成する。  これは、無名再帰関数を作成したり、環境内で定義された変数は外部からは見えないので、一種の限定名前空間機能として便利です。
envirが指定されていない場合、デフォルトはparent.frame()(evalが呼び出された環境)です。評価されるオブジェクトには、call orexpression型やname型(現在のスコープでnameが検索され、そのバインディングが評価される場合)、promise型、またはvector、function、environment(変更されずに返される)などの基本的な型があります。evalq形式はeval(quote(expr), ...)と等価です。evalは最初の引数を現在のスコープで評価してから評価器に渡します。evalqはこれを回避します。eval.parent(expr, n)はval(expr, parent.frame(n))の省略形です。envirがリスト（データフレームなど）またはペアリストの場合、一時的な環境にコピーされ（囲み付き）、一時的な環境が評価に使用されます。  envirがNULLの場合、空リストとして解釈され、envirに値が見つからず、ルックアップは直接enclosに行きます。  evalqと同等であるが、デフォルトの引数は空の環境を新たに生成する。  これは、無名再帰関数を作成したり、環境内で定義された変数は外部からは見えないので、一種の限定名前空間機能として便利です。
envirが指定されていない場合、デフォルトはparent.frame()(evalが呼び出された環境)です。評価されるオブジェクトには、call orexpression型やname型(現在のスコープでnameが検索され、そのバインディングが評価される場合)、promise型、またはvector、function、environment(変更されずに返される)などの基本的な型があります。evalq形式はeval(quote(expr), ...)と等価です。evalは最初の引数を現在のスコープで評価してから評価器に渡します。evalqはこれを回避します。eval.parent(expr, n)はval(expr, parent.frame(n))の省略形です。envirがリスト（データフレームなど）またはペアリストの場合、一時的な環境にコピーされ（囲み付き）、一時的な環境が評価に使用されます。  envirがNULLの場合、空リストとして解釈され、envirに値が見つからず、ルックアップは直接enclosに行きます。  evalqと同等であるが、デフォルトの引数は空の環境を新たに生成する。  これは、無名再帰関数を作成したり、環境内で定義された変数は外部からは見えないので、一種の限定名前空間機能として便利です。
where引数は、オブジェクトを検索する環境を、整数（検索リスト内の位置）、検索リスト内の要素の文字列名、または環境（現在アクティブな関数呼び出しにアクセスするためにsys.frameを使用することを含む）として指定することができます。  envir引数は環境を指定する別の方法ですが、主に互換性のために存在します。この関数は、名前xが指定された環境でそれにバインドされた値を持っているかどうかを調べます。  inheritsがTRUEで、指定された環境でxに値が見つからない場合、xという名前に出会うまで、環境の閉じたフレームが検索されます。  modeが指定された場合、その型のオブジェクトのみが探索されます。modeは "numeric "コレクションと "function "コレクション(modeを参照)のいずれかを指定することができます。  (これは、コレクションのメンバが指定されている場合でも同様で、例えば mode = "special" は、あらゆるタイプの関数を求めることになります)。
log10とlog2は便宜的なラッパーに過ぎないが、OSでサポートされている場合、基数10と基数2のlogは（logで計算してもラッパーで計算しても）より効率的かつ正確に計算される。logbは、Sとの互換性のためにlogのラッパーです。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされます。
NA
log10 と log2 は便利なラッパーに過ぎませんが、OS でサポートされている場合、基数 10 と基数 2 の log は（log で計算してもラッパーで計算しても）より効率的かつ正確に計算されます。logbは、Sとの互換性のためにlogのラッパーです。（S3またはS4）メソッドがlogに設定されている場合、それらはディスパッチされます。
ここでの「式」は、口語的な意味、つまり数学的な式の意味で使われているのではありません。  expression "モードのオブジェクトはリストであるため、[, [[ や $ で置き換えることができます。  expressionとis.expressionはプリミティブ関数です。expressionは「特殊」で、引数を評価しません。
これらは外部ライブラリであることが多いが、インストール時にRにコンパイルされていることもある。動的リンクの場合は、このセッションでリンクされたライブラリのバージョンであり、静的リンクの場合は、コンパイルされたライブラリである。
TRUEとFALSEはR言語の論理定数を表す予約語であり、TとFは初期値がこれらに設定されるグローバル変数である。  TRUEは1Lに、FALSEは0Lに、NAはNA_integer_にマッピングされる。
順序付き因子は因子とクラスが異なるだけですが、メソッドとモデル適合関数はこの2つのクラスを全く異なるものとして扱います。ベクトルのエンコーディングは次のように行われます。  まず、exclude の値がすべて levels から取り除かれます。x[i]がlevels[j]と等しい場合、結果のi番目の要素はjになります。  通常、結果の属性として使用される'levels'は、exclude内のものを削除した後の縮小されたレベルセットですが、これはラベルを指定することで変更できます。  factor(x,exclude=NULL)がNAなしの因子に適用された場合、未使用のレベルがない限り、操作は行われない。  excludeが使用されると、Rバージョン3.4.0以降、存在しない文字レベルを除外することは何も除外しないことと同じになり、excludeが文字ベクトルである場合、それがxのレベルに適用される。  数値xの場合、exclude = NULLを設定すると、NAが外部レベル(<NA>と表示される) になります。デフォルトでは、これは最後のレベルです。NAがレベルである場合、(欠落しているレベルのコードではなく)欠落しているコードを設定する方法は、代入の左側にis.naを使用することです(is.na(f)[i] <- TRUEのように; is.naの内部でのインデックス付けは機能しません)、is.factorはジェネリックです。オブジェクトの特定のクラスを扱うメソッドを書くことができます。0であるため、cを使用して（並べ替え可能な）因子を他のオブジェクトと結合する場合、すべてのオブジェクトが（並べ替え可能な）因子であれば、結果は、レベルが要素のレベル集合に出現する順序で、要素のレベル集合の和を持つ因子になります（これは、すべての要素が同じレベル集合を持つ場合、それが結果のレベル集合であることを意味します）。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lγ関数、digamma関数、trigamma関数は内部ジェネリック・プリミティブ関数です：メソッドは個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。
最初の11個の関数は接続を作成します。  デフォルトでは、接続はオープンされません（socketConnectionまたはsocketAcceptで作成されたソケット接続とserverSocketで作成されたサーバーソケットコネクションを除く）。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファを即座にフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
mode値は排他的か、以下の値のいずれかを指定することができるestest for existence.test for execute permission.test for write permission.test for read permission.パーミッションは、(実効IDではなく)実際のユーザーIDとグループIDに対して計算される。  マルチタスク・システムでは、file.access()を呼び出してからファイルを開こうとするまでの間に、ファイルのアクセシビリティが変更される可能性があります。
これらの関数はすべて、パス名を展開します。path.expand.file.createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされます。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（たとえば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなっています。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkでは、to引数で既存のディレクトリを1つ指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATまたはSMBでマウントされたファイルシステムで何が起こるかは、OS固有です。)マークされたエンコーディング(エンコーディングを参照)を持つファイル引数は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換されます(そのため、UTF-8としてマークすることは、適切なファイルシステム上でネイティブエンコーディングでないファイルパスにアクセスするために使用することができます)。
NA
これらの関数はすべて、パス名を展開します: path.expand.file.createを参照してください。createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされます。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（たとえば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなっています。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkでは、to引数で既存のディレクトリを1つ指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATやSMBでマウントされたファイルシステムで何が起こるかは、OS固有のものです。)マークされたエンコーディングを持つファイル引数(エンコーディングを参照)は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換されます(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングでないファイルパスにアクセスするために使用することができます)。
これらの関数はすべて、パス名を展開します: path.expand.file.createを参照してください。createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされる。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（たとえば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなっています。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkの場合、引数toは既存の1つのディレクトリを指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATやSMBでマウントされたファイルシステムで何が起こるかは、OS固有のものです。)マークされたエンコーディングを持つファイル引数(エンコーディングを参照)は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換されます(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングでないファイルパスにアクセスするために使用することができます)。
これらの関数はすべて、パス名を展開します: path.expand.file.createを参照してください。createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされる。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（例えば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなります。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkの場合、引数toは既存の1つのディレクトリを指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATやSMBでマウントされたファイルシステムで何が起こるかは、OS固有のものです。)マークされたエンコーディングを持つファイル引数(エンコーディングを参照してください。)は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換されます(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングではないファイルパスにアクセスするために使用することができます)。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  ファイルの「モード」はPOSIXの規則に従い、3桁の8進数でファイルの所有者、所有者のグループ、および誰でものパーミッションをそれぞれ表す。  ほとんどのシステムでは、シンボリックリンクに従うので、リンク先のファイルではなく、リンク先のファイルについての情報が与えられる。
これらの関数はすべて、パス名を展開します: path.expand.file.createを参照してください。createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされる。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（たとえば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなっています。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkの場合、引数toは既存の1つのディレクトリを指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATやSMBでマウントされたファイルシステムで何が起こるかは、OS固有のものです。)マークされたエンコーディングを持つファイル引数(エンコーディングを参照してください。)は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換されます(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングではないファイルパスにアクセスするために使用することができます)。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  ファイルの「モード」はPOSIXの規則に従い、3桁の8進数でファイルの所有者、所有者のグループ、および誰でものパーミッションをそれぞれ表す。  ほとんどのシステムではシンボリックリンクに従うので、リンクの情報よりもリンク先のファイルに関する情報が与えられる。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバックスラッシュやスラッシュを含んではならない)。  ファイルの「モード」はPOSIXの慣例に従い、ファイルの所有者、所有者のグループ、および誰でものパーミッションをそれぞれ要約した3桁の8進数を与える。  ほとんどのシステムではシンボリックリンクが使用されるため、リンク先のファイルではなく、リンク先のファイルに関する情報が提供される。
この関数はR自体で広く使用されているため、実装は高速（貼り付けよりも高速）になるように設計されています。PATHやR_LIBSのような環境パスに対しても、fsep = .Platform$path.sep.末尾のパスセパレータは、Windowsのファイルパスでは'/'と'd:/'以外では無効なので（一部の関数やユーティリティでは受け付けられますが）、末尾の/や♪は削除されます。
これらの関数はすべてパス名を展開します。path.expand.file.createを参照してください。指定された名前のファイルがすでに存在しなければ作成し、存在すれば切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされる。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（例えば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなります。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkでは、to引数で既存のディレクトリを1つ指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATやSMBでマウントされたファイルシステムで何が起こるかは、OS固有のものです。)マークされたエンコーディングを持つファイル引数(エンコーディングを参照してください。)は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換されます(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングではないファイルパスにアクセスするために使用することができます)。
これらの関数はすべて、パス名を展開します: path.expand.file.createを参照してください。createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされる。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（例えば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなります。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkでは、to引数で既存のディレクトリを1つ指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンのシンボリックリンクに関連する概念があります。  FATまたはSMBでマウントされたファイルシステムで何が起こるかは、OS固有である。)マークされたエンコーディング(エンコーディングを参照)を持つファイル引数は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換される(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングでないファイルパスにアクセスするために使用することができる)。
基本的なUnixバージョンは、ファイルを（ヘッダを使用して）一時ファイルに連結し、pager引数で選択されたページャーに表示します。pager引数は、ファイル集合に対して実行するシステムコマンド（フルパスまたはPATHで見つかったコマンド）を指定する文字ベクトルです。  工場出荷時」のデフォルトは「R_HOME/bin/pager」で、これは環境変数PAGERで指定されたコマンドラインを実行するシェルスクリプトである。  Unix-alikemoreでは、ページャーが空の場合に使用される。ほとんどのGUIシステムでは、ファイルごとに独立したページャー・ウィンドウを使用し、Rが実行され続けている間、ユーザーはそれを表示したままにする。  このようなページャの選択は、特別なページャ名（Windowsの "internal "や "console "など）を使用して、低レベルのコードにインターセプトさせるか、あるいは、pagerをRfunctionにして、ile.showの最初の4つの引数に対応する引数（files、header、title、delete.file）を指定して呼び出すことで、GUIとのインタフェースを行うことができる。  特に、Windowsで外部ページャーを使っても、外部アプリケーションがいつファイルの処理を終了したかを知る方法がないため、削除できません。
何を「ファイル」とするかはOSに依存するが、ディレクトリも含まれる。  (ただし、Windowsでは、ディレクトリ名にバッ クスラッシュやスラッシュを含めてはならない)。  ファイルの「モード」はPOSIXの慣例に従っており、ファイルの所有者、所有者のグループ、およびすべての人のパーミッションをそれぞれ要約した3桁の8進数を与える。  ほとんどのシステムでは、シンボリックリンクに従うので、リンク先のファイルではなく、リンク先のファイルについての情報が与えられる。
これらの関数はすべて、パス名を展開します。path.expand.file.createは、指定された名前のファイルがすでに存在しない場合は作成し、存在する場合は切り捨てます。  ファイルは、'umask'設定（関連する場合）で許可された最大の読み取り/書き込みパーミッションで作成されます。  デフォルトでは、操作に失敗した場合、（理由とともに）警告が出されます。file.existsは、引数で指定されたファイルが存在するかどうかを示す論理ベクトルを返します。  (ここで'存在する'とは、システムのstat呼び出しの意味である。ファイルが存在すると報告されるのは、statが必要とするパーミッションを持っている場合だけである。）  何をもって「ファイル」とするかはシステムに依存するが、ディレクトリを含むべきである(ただし、Windowsでは、ディレクトリ名に末尾のバックスラッシュまたはスラッシュを含んではならない)。  最後に、Rオブジェクトの存在をチェックする異なる関数existsに注意すること。file.removeは、引数で指定されたファイルを削除しようとする。  Windowsでは、'file'は通常のファイルを意味し、空のディレクトリを意味しない。file.renameはファイル名の変更を試みる（fromとtoは同じ長さでなければならない）。  ファイルのパーミッションが許す限り、これは既存のtoの要素を上書きする。  これは、OSの対応するシステムコール（Unix系ではman 2 renameのようなもの）の制限を受けます：特に'file'の解釈において：ほとんどのプラットフォームは、あるファイルシステムから別のファイルシステムへファイル名を変更しません。  注意: これは、パッケージのインストール中に、一時ディレクトリからユーザーのファイルスペースへのファイル名の変更に失敗することが多いことを意味します。  (Windowsでは、file.renameはファイル名を変更できるが、ボリュームをまたいでディレクトリを変更することはできない。) ディレクトリの名前を変更できるプラットフォームでは、通常、fromとtoのどちらか一方または両方がディレクトリでなければならず、toが存在する場合は空のディレクトリでなければならない。  file.copyは、file.appendと同じように動作するが、引数を自然な順序でコピーする。  既存のコピー先ファイルへのコピーは、overwrite = TRUEでない限りスキップされます。  引数toは、1つの既存のディレクトリを指定できます。  copy.mode=TRUEの場合、ファイルの読み取り/書き込み/実行パーミッションは、'umask'によって制限され、可能な限りコピーされる。  (Windowsでは、これはファイルにのみ適用される。) ACLのような他のセキュリティ属性はコピーされない。  POSIXファイルシステムでは、シンボリックリンクのターゲットはリンクそのものではなくコピーされ、ハードリンクは別々にコピーされる。  copy.date=TRUEを使用すると、タイムスタンプが正確にコピーされる場合とされない場合があります（たとえば、秒の端数が省略される場合があります）が、R 3.4.0以降では、コピーされる可能性が高くなります。file.symlinkとfile.linkは、それらをサポートしているファイルシステムでシンボリックリンクとハードリンクを作成します。  file.symlinkでは、to引数で既存のディレクトリを1つ指定できます。  (UnixとmacOSのネイティブ・ファイルシステムは両方をサポートしています。  Windowsでは、NTFSファイルシステム上のファイルへのハードリンクと、最近のバージョンでのシンボリックリンクに関連する概念があります。  FATまたはSMBマウントされたファイルシステムで何が起こるかは、OS固有である。)マークされたエンコーディングを持つファイル引数(エンコーディングを参照)は、Unicodeファイル操作が使用されるWindowsを除いて、可能であればネイティブエンコーディングに変換される(そのため、UTF-8としてのマークは、適切なファイルシステム上でネイティブエンコーディングでないファイルパスにアクセスするために使用することができる)。
initが与えられると、Reduceは論理的にそれをxの開始点（左から右に進む場合）または終了点にそれぞれ追加する。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  現在の実装は、安定性とスケーラビリティを確保するために非再帰的である。  duceはfold（Haskellなど）やaccumulate（C++標準テンプレート・ライブラリなど）としても知られている。  Filterは単項述語関数fをxの要素に適用し、必要であれば論理に強制し、これが真を返すxの部分集合を返します。  可能性のあるNA値は、現在のところ常に偽とみなされることに注意してください。  FindとPositionはそれぞれCommon Lispのfind-ifとposition-ifに倣ったものです。  述語関数がtrueを与える要素がある場合、rightがfalse（デフォルト）かtrueかによって、そのような要素の最初か最後、またはその位置がそれぞれ返されます。  そのような要素がない場合は、nomatchで指定された値が返されます。  Mapはmapplyの単純なラッパーであり、結果を単純化するようなことはしていません。  NegateはCommon Lispの補語に相当する。  述語）関数fが与えられると、fが返す関数の論理否定を返す関数を作成する。
もしinitが与えられると、Reduceは論理的にそれをxの先頭（左から右に進む場合）または末尾にそれぞれ追加します。この拡張される可能性のあるベクトルvがn > 1の要素を持つ場合、Reduceはfをvの要素に左から右、または右から左にそれぞれ連続して適用します。  すなわち、leftreduceはl_1 = f(v_1, v_2)、l_2 = f(l_1, v_3)などを計算する、を計算し、l_{n-1} = f(l_{n-2}, v_n)を返し、右リデュースはr_{n-1} = f(v_{n-1}, v_n)、r_{n-2} = f(v_{n-2}, r_{n-1})を計算し、r_1 = f(v_1, r_2)を返す。  (例えば、vがこの数列(2, 3, 4)でfが除算の場合、左と右はそれぞれ、(2 / 3) / 4 = 1/6 と 2 / (3 / 4) = 8/3を与える。)vに要素が1つしかない場合はこれが返され、要素がない場合はNULLが返される。  現在の実装は、安定性とスケーラビリティを確保するために非再帰的である。  duceはfold（Haskellなど）やaccumulate（C++標準テンプレート・ライブラリなど）としても知られている。  Filterは単項述語関数fをxの要素に適用し、必要であれば論理に強制し、これが真を返すxの部分集合を返します。  可能性のあるNA値は、現在のところ常に偽とみなされることに注意してください。  FindとPositionはそれぞれCommon Lispのfind-ifとposition-ifに倣ったものです。  述語関数がtrueを与える要素がある場合、rightがfalse（デフォルト）かtrueかによって、そのような要素の最初か最後、またはその位置がそれぞれ返されます。  そのような要素がない場合は、nomatchで指定された値が返されます。  Mapはmapplyの単純なラッパーであり、結果を単純化するようなことはしていません。  NegateはCommon Lispの補語に相当する。  (述語)関数fが与えられると、fが返す関数の論理否定を返す関数を作成します。
find.packageは、与えられたパッケージが見つかる場所へのパスを返します。  lib.locがNULLの場合、ライブラリの前にロードされた名前空間が検索されます。  パッケージが複数回見つかった場合は、最初にマッチしたものが使用されます。  quiet = TRUEでない限り、名前付きパッケージが見つからなかった場合は警告が、見つからなかった場合はエラーが表示されます。  verbose = TRUE の場合、複数回見つかったパッケージについての警告が表示されます。  find.packageは通常、パッケージが使用可能かどうかを調べるための正しいツールではありません。  path.packageは、指定されたパッケージがロードされたパス、または指定されたパッケージがない場合は、現在アタッチされているすべてのパッケージを返します。コンディション・オブジェクトは、フィールドpackageとlib.loc.を含んでいます。  
関数 findInterval は、あるベクトル x の別のベクトル vec におけるインデックスを求めます。  これは些細なことであり、apply( outer(x, vec, ">="), 1, sum)と等価であるが、実のところ、内部アルゴリズムでは、ren <- length(x) (and N <- length(vec))の場合、O(n * log(N))の複雑さを保証する区間探索を使用する。  これは経験分布関数と同じ計算であり，実際に findInterval(t, sort(X)) は n * Fn(t; X[1],...) と同じである．ここでFnはX[1],...,X[n]の経験分布関数である。rightmost.closed = TRUEの場合，x[j] = vec[N]( = max(vec))の結果は，最後の区間における他のすべての値と同様にN - 1となる．(反)対称性の理由から、これは "ミラーされた "データを使用することと等価である。
関数.subsetと.subset2は、メソッドのディスパッチが行われないことを除けば、本質的に[[ 演算子と等価です。  これは、デフォルト・メソッドをオブジェクトに適用する際に、高価なクラス解除を避けるためです。  これらは通常、エンドユーザーから呼び出されることはありません。  getRequiredPackages2は、Dependsフィールドで言及されたすべてのパッケージをアタッチします。  .getRequiredPackagesは、'DESCRIPTION'ファイルを使用した.getRequiredPackages2のラッパーです。.isMethodsDispatchOn()関数は、S4メソッドのディスパッチが(通常はパッケージメソッドをロードすることによって)評価側でオンになっている場合にTRUEを返します。  sys.save.imageはq()とそのGUIアナログから呼び出されるシステム関数です。sys.load.imageはスタートアップ・コードから呼び出されます。これらの関数は直接呼び出されるべきではなく、変更される可能性があります。  .set_row_names(n)は、attr(<a data frame>, "row.names")に代入される、長さnの自動的な行名を生成します。  .row_names_infoは、データフレームの行名の内部形式に関する情報を与えます。どのような情報かについては、引数の型を参照してください。.GenericArgsEnvと.ArgsEnvは、プリミティブがクロージャであった場合の引数リストを持つクロージャを含む環境です。  内部S3ジェネリックである全てのプリミティブは.GenericArgsEnvの対応するメンバーを持っており、残りの非言語要素プリミティブは.ArgsEnvに対応しています。  詳細は'R Internals'マニュアルを参照してください。  これらはargsとprint.defaultとQC関数codocとcheckS3methodsで使用されます。.findPackageEnvはunserializeコードで呼び出され、可能であれば保存された環境を設定します。.TAOCP1997initは "Knuth-TAOCP "RNGの初期化コードです。.gtと.gtnはrankとisからのコールバックです。.primTraceと.primUntraceは、それぞれtraceとuntraceの基礎となるプリミティブ関数です。.Date、.POSIXct、.POSIXlt、.difftimeは、クラスジェネレーターです。.cache_classは、S3メソッドディスパッチで使用するために、S4クラスの継承をキャッシュします。  .popathは起動時に生成される変数で、使用中の翻訳パッケージがどこにあるかを記録します。.detachは、他のRパッケージで使用するためのdetachの「ベアボーン」バージョンです。.maskedMsgは、警告メッセージを生成するために、attach()とlibrary()の両方から呼び出されるユーティリティです。.C_および.F_で始まるオブジェクトは、登録されたCおよびFortranエントリ・ポイントへの参照です。Windowsのみ:.fixupGFortranStdoutおよび.fixupGFortranStderrは、systemおよびsystem2経由で外部コードを実行する際に、gfortranの標準出力および標準エラー・ユニットを有効にするヘルパー関数です。デフォルトでは、これらのユニットは、RGui内部で実行されているとき、Windowsプロファイルによって無効になっています。
コンディション・システムは、エラーや警告を含む異常なコンディションを通知し、処理するためのメカニズムを提供します。コンディションは、メッセージやコンディションが発生した呼び出しなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。  コンディションは、メッセージやコンディションが発生したコールなど、発生したコンディションに関する情報を含むオブジェクトとして表現されます。現在のところ、コンディションはS3スタイルのオブジェクトですが、これはいずれ変更される可能性があります。  simpleErrorクラスはstopとすべての内部エラーシグナルで使用されるクラスです。  同様に、simpleWarningはwarningで使用され、simpleMessageはmessageで使用されます。  同じ名前のコンストラクタは、条件を記述する文字列を引数として取り、オプションで呼び出します。  関数conditionMessageとconditionCallは、条件のメッセージとコールを返す汎用関数である。関数errorConditionは、...引数として指定された追加フィールドを持つ特定のクラスのエラー条件を構築するために使用することができる。  tryCatch関数は、...引数で指定されたハンドラが使用可能なコンテキストで式引数を評価します。  つまり、現在のtryCatch呼び出しに提供されたハンドラは、finally式が評価されるときにはアクティブではありません。tryCatchの...引数に提供されたハンドラは、exprの評価期間中確立されます。exprの評価中に条件が通知されなかった場合、tryCatchは式の値を返します。exprの評価中に条件が通知された場合、確立されたハンドラは、最も新しく確立されたものから順に、条件のクラスに一致するものがないかチェックされます。  ハンドラが見つかった場合、そのハンドラを確立したtryCatch呼び出しに制御が移され、見つかったハンドラとそれより新しいハンドラはすべて確立解除され、ハンドラは条件を引数として呼び出され、ハンドラが返した結果はtryCatch呼び出しの値として返されます。  コンディションがシグナルされ、該当するハンドラが呼び出しハンドラである場合、そのハンドラはコンディションがシグナルされたコンテキスト内でsignalConditionによって呼び出されるが、利用可能なハンドラはハンドラスタック内で呼び出されたハンドラの下に制限される。  最後のハンドラが試行されると、signalConditionはNULLを返します。globalCallingHandlersは、グローバルにハンドラを呼び出します。これらのハンドラは、withCallingHandlersで動的に登録された他のハンドラが呼び出された後、最後の手段としてのみ呼び出されます。同じハンドラを複数回登録すると、そのハンドラはスタックの一番上に移動し、最初に呼び出されるようになります。グローバル・ハンドラは、汎用ロガー（例えば、グローバル・ワークスペースの最後のエラー・オブジェクトを保存する）や、一般的なリカバリ戦略（例えば、try_loadNamespaceリスタートによる不足パッケージのインストール）を定義するのに適した場所です。すべてのグローバルハンドラの登録を解除するには、'NULL'を1つ渡します。削除されたハンドラのリストは不可視で返される。最後に、引数なしでglobalCallingHandlersを呼び出すと、現在確立されているハンドラのリストが目に見える形で返されます。ユーザー割り込みは、デフォルトの割り込みアクションを実行する前に、クラス条件から直接継承したクラス割り込みの条件をシグナルします。  リスタートは回復プロトコルを確立するために使用されます。  findRestartとcomputeRestartsは、利用可能なリスタートを検索します。findRestartは、指定された名前の最近確立されたリスタートを返します。  invokeRestartは、指定されたリスタートが確立されたポイントに制御を移し、invokeRestartの追加引数として与えられた引数（もしあれば）を使ってリスタートのハンドラを呼び出します。  invokeRestartのrestart引数には文字列を指定することができます。tryInvokeRestartはinvokeRestartの亜種で、findRestartでリスタートが見つからなかった場合に無言で返されます。与えられたクラスの条件が任意のプロトコル（エラー、警告など）で通知される可能性があるため、外部コンテキストから通知される条件を処理する場合は、この寛容なバリアントを使用することをお勧めします。例えば、"muffleWarning "リスタートの呼び出しはオプションであるべきです。なぜなら、警告はユーザによって、またはstopプロトコルやメッセージプロトコルで別のパッケージから通知されたかもしれないからです。withRestarts用の新しいリスタートは、いくつかの方法で指定することができる。最も簡単なのは、name = function形式で、関数はリスタートが呼び出されたときに呼び出すハンドラである。  この場合、ハンドラは引数を無視し、NULLを返します。  この場合、ハンドラはその引数を無視し、NULLを返します。リスタート指定の最も柔軟な形式は、ハンドラ、説明、テストを含むいくつかのフィールドを含むことができるリストです。  testフィールドには、リスタートが条件に適用される場合はTRUEを、適用されない場合はFALSEを返す、1つの引数aconditionを持つ関数を含める必要があります。  これはリスタート・ハンドラに渡す引数のリストを返す引数なしの関数でなければなりません。  このリストは、必要であれば、ユーザーとの対話によって得ることができる。  invokeRestartInteractively関数はこの関数を呼び出し、リスタートを呼び出す際に使用する引数を取得します。  デフォルトの対話型メソッドは、ハンドラ関数の初期引数の値をユーザに問い合わせます。  allowInterrupts を使用すると、割り込みが有効になっている間に部分式を評価できます。  signalSimpleWarning、.handleSimpleError、.tryResumeInterrupt は内部的に使用されるため、直接呼び出すことはできません。
5を四捨五入する場合、IEC 60559標準（'IEEE 754'も参照）が使用され、「偶数桁に行く」ことが期待されていることに注意してください。  ただし、これはOSのサービスや表示誤差に依存する（例えば0.15は正確に表現されていないため、丸めルールは表現された数字に適用され、印刷された数字には適用されないため、round(0.15, 1)は0.1にも0.2にもなりうる）。例えば、 round(x, digits = -2) は、最も近い100に丸められます。signifの場合、digitsの認識値は1...22であり、欠落していない値は、その範囲の最も近い整数に丸められます。  複素数は、指定された桁数を保持するように、成分の大きいほうに丸められます。  これらはすべてプリミティブ関数です。
最初の11個の関数はコネクションを作成します。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ使用可能であり（そのOSのWinINet機能を使用）、メソッド "libcurl"（その名前のライブラリを使用:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma(https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の単一ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
最初の11の関数はコネクションを作成する。  デフォルトでは、コネクションはオープンされないが（socketConnectionまたはsocketAcceptで作成されたソケットコネクション、およびserverSocketで作成されたサーバーソケットコネクションを除く）、引数openに空でない値を設定することでオープンされる。  プロセスのCレベルの'標準入力'を参照するには、"stdin "を使用する（Rのコンソールや組み込みバージョンでは何も接続する必要はなく、WindowsのRGuiにもない）。  微妙に異なるRレベルのstdinの概念についてはstdin()も参照のこと。nullデバイスのファイル名を取得するプラットフォームに依存しない方法については、nullfile()を参照のこと。urlの記述は、スキーム（http://、https://、ftp://、file://など）を含む完全なURLである。  メソッド "internal "は、コネクションが導入されたときから利用可能です。  メソッド "wininet "は、Windowsでのみ利用可能であり（そのOSのWinINet機能を使用する）、メソッド "libcurl"（その名前のライブラリを使用する:https://curl.se/libcurl/）は、Unix-alikeでは必要ですが、Windowsではオプションです。  メソッド "default "は、file:// URLにメソッド "internal "を使用し、ftp:// および ftps:// URLに "libcurl"(利用可能な場合)を使用します。  Unix-alikeでは、http:// とhttps:// URLに "libcurl "を使用します。Windowsでは、http://and https:// URLに "wininet "を使用します（"libcurl "が利用できない場合は、ftp://）。  どのメソッドがどのスキームをサポートするかは、Rversionによって異なります。現在、"internal "は、file://、http:// (非推奨)、ftp:// (非推奨)をサポートしています。"wininet "は、file://、http://,https://、ftp:// (非推奨)をサポートしています。  プロキシを指定することもできる: download.file を参照。gzfile の場合は、gzip で圧縮されたファイルへのパスが記述される: 非圧縮ファイルや bzip2、xz、lzma で圧縮されたファイルを読み込むために開くこともできる。bzfile の場合は、bzip2 で圧縮されたファイルへのパスが記述される.xzfile の場合は、xz で圧縮されたファイルへのパスが記述される (https://en.wikipedia.org/wiki/Xz)または(読み込み専用)lzma (https://en.wikipedia.org/wiki/LZMA)によって圧縮されたファイルへのパスである。unzは、zipファイル内の(単一の)ファイルのみをバイナリモードで読み込む。  これは、Windowsの場合、環境変数COMSPECで指定されたシェルで実行されます。  (fifo接続のサポートはオプションですが、ほとんどのUnixプラットフォームとWindowsで利用可能です。)fileとgzfileは、それぞれテキスト入力(ファイル、http://、https:// URLから)とバイナリ入力に汎用的に使用できることを意図しています。open、close、seekは汎用関数です。以下は、接続に関連するメソッドに適用されます。  一般的に、コネクションを使用する関数は、コネクションがオープンされていない場合はオープンしますが、その後再びクローズするので、コネクションをオープンしたままにするには、明示的にオープンを呼び出します。  コネクションを参照するRオブジェクトがなくなると、（警告とともに）自動的にこの処理が行われます。最大128個のコネクションを一度に割り当てることができます（開いている必要はありません）。  このうち3つはあらかじめ割り当てられている（seestdout）。   flushは、write/append用にオープンされている接続の出力ストリームをフラッシュします（実装されている場合、現在のところファイルおよびクリップボード接続ではstdoutとstderr）。ファイルまたは（ほとんどのプラットフォームで）fifo接続の記述が""の場合、ファイル/fifoは直ちにオープンされ（open = "w+b "が指定されていない限り "w+"モード）、ファイルシステムからリンク解除されます。  socketConnection(server=TRUE)は、指定されたポートに新しい一時的なサーバーソケットを作成する。  serverSocketは、socketAcceptによって複数のソケット接続を受け付けることができる待ち受けサーバーソケットを作成する。  socketConnectionとsocketAcceptは、ソケット固有のオプションを設定できる。現在実装されているのは "no-delay "のみで、TCP_NODELAYソケットオプションを有効にすると、ソケットは送信バッファをすぐにフラッシュする（送信前にすべての出力を収集するのを待つのではなく）。socketTimeout はソケット接続のタイムアウトを設定する。  負のタイムアウトを指定すると、古い値を問い合わせることができる。
breakはforループ、whileループ、repeatループから抜け出し、制御は最内周の外側にある最初のステートメントに移る。  breakもnextも、入れ子になったループの一番内側だけに適用される。よくある間違いだが、ステートメントを中括弧（{ .. }）で囲むのを忘れることがある、特に、キーボードやソースからif...else構文を入力する際の構文エラーを避けるために、}とelseの間に改行を入れるべきではありません。そのため、防御的プログラミングの（やや極端な）姿勢の1つとして、if句などには常に中括弧を使用することが挙げられます。  seqの長さがゼロの場合、ループ本体はスキップされる。そうでなければ、変数varにseqの各要素の値が順番に代入される。ループ本体内でvarに代入することもできるが、次の繰り返しには影響しない。  ループが終了しても、varは最新の値を含む変数として残ります。
force は、正式な引数の評価を強制します。  これは、その引数がレキシカル・スコープ・ルールによってクロージャに取り込まれ、後で明示的な代入やループ内の暗黙的な代入、あるいはapply関数によって変更される場合に便利です。
forceAndCallは、...で指定された引数で関数FUNを呼び出します。  FUNの値がクロージャの場合、関数本体を実行する前に、関数の最初のn個の引数が評価されます（つまり、遅延評価の約束が強制されます）。  forceAndCallは、applyのような高次関数を定義する際に、適用された関数が返す結果が引数をキャプチャしたクロージャであった場合に、より合理的な振る舞いができるようにすることを目的としています。
最初の形式では、funには操作する関数の名前を文字列で指定することもでき、デフォルトでは親フレームからenvirで検索されます。  指定されない場合、formalsを呼び出す関数が使用されます。formalsを持つのはクロージャのみで、プリミティブ関数は持ちません。
最初の形式では、funには操作する関数を指定する文字列を指定することもでき、デフォルトでは親フレームからenvirで検索されます。  指定されない場合、formalsを呼び出す関数が使用されます。formalsを持つのはクロージャのみで、プリミティブ関数は持ちません。
formalsは汎用関数です。  format.data.frameはデータフレームを列ごとにフォーマットし、各列に適切なフォーマット方法を適用します。  行列とデータフレームの列は結果の中で分離された列に変換され、文字列（通常はすべて）はクラス "AsIs "が与えられます。format.factorは因子を文字ベクトルに変換し、デフォルトのメソッドを呼び出します（そのため、正当性が適用されます）。  文字オブジェクトと(アトミック)行列はデフォルトのメソッドに渡されます(したがって、幅は適用されません)。それ以外の場合は、toStringを呼び出してオブジェクトを文字に変換し(ベクトルまたはリストであれば、要素ごとに)、その結果を右寄せにします。文字ベクトル(およびそれらのメソッドによって文字ベクトルに変換されたオブジェクト)の幅寄せは、表示幅(seechar)で行われ、全角文字と特殊文字のレンダリング(バックスラッシュのエスケープを含むがダブルクォートは含まないエスケープシーケンスとして:print.defaultを参照)が考慮されます。  したがって、幅はprint(quote = FALSE)で表示される幅であり、catで表示される幅ではない。  (na.encode=FALSEの場合、文字列の欠落は幅の計算に含まれず、エンコードされません。)数値ベクトルは、すべての要素を少なくとも有効桁数まで表示するのに必要な最小の小数点以下の桁数でエンコードされます。  ただし、すべての要素に末尾にゼロがある場合は、nsmallに達するか、少なくとも1つの要素の末尾の桁がゼロでなくなるまで、小数点以下の桁数が減らされます; 上記のbig.*、small.*などの引数の説明も参照してください。  生ベクトルは、as.character.format.default(x)によって2桁の16進数表現に変換されます。内部コードは、'10進マーク'のoptiongetOption("OutDec")を尊重するので、これが". "以外に設定されている場合は、引数のdecimal.markよりも優先されます。
formatは汎用関数です。  format.data.frameはデータフレームを列ごとにフォーマットし、各列に適切なフォーマット方法を適用します。  行列とデータフレームの列は結果の中で分離された列に変換され、文字列（通常はすべて）はクラス "AsIs "が与えられます。format.factorは因子を文字ベクトルに変換し、デフォルトのメソッドを呼び出します（そのため、正当性が適用されます）。  文字オブジェクトと(アトミック)行列はデフォルトのメソッドに渡されます(したがって、幅は適用されません).そうでなければ、toStringを呼び出してオブジェクトを文字に変換し(ベクトルまたはリストであれば、要素ごとに)、結果を右寄せにします.文字ベクトル(およびそれらのメソッドによって文字ベクトルに変換されたオブジェクト)の幅揃えは、表示幅(seechar)で行われ、2倍幅の文字と特殊文字のレンダリング(エスケープバックラッシュを含むが、ダブルクォートを含まないエスケープシーケンスとして:print.defaultを参照)が考慮されます。  したがって、幅はprint(quote = FALSE)で表示される幅であり、catで表示される幅ではない。  (na.encode=FALSEの場合、文字列の欠落は幅の計算に含まれず、エンコードされません。)数値ベクトルは、すべての要素を少なくとも有効桁数まで表示するのに必要な最小の小数点以下の桁数でエンコードされます。  ただし、すべての要素に末尾にゼロがある場合は、nsmallに達するか、少なくとも1つの要素の末尾の桁がゼロでなくなるまで、小数点以下の桁数が減らされます; 上記のbig.*、small.*などの引数の説明も参照してください。  生ベクトルは、as.character.format.default(x)によって2桁の16進数表現に変換されます。内部コードは、'10進マーク'のoptiongetOption("OutDec")を尊重するので、これが". "以外に設定されている場合は、引数のdecimal.markよりも優先されます。
formatは汎用関数です。  format.data.frameはデータフレームを列ごとにフォーマットし、各列に対して適切なフォーマット方法を適用します。  行列とデータフレームの列は結果の中で分離された列に変換され、文字列（通常はすべて）はクラス "AsIs "が与えられます。format.factorは因子を文字ベクトルに変換し、デフォルトのメソッドを呼び出します（そのため、正当性が適用されます）。  文字オブジェクトと(アトミック)行列はデフォルトのメソッドに渡されます(したがって、幅は適用されません).そうでなければ、toStringを呼び出してオブジェクトを文字に変換し(ベクトルまたはリストであれば、要素ごとに)、結果を右寄せにします.文字ベクトル(およびそれらのメソッドによって文字ベクトルに変換されたオブジェクト)の幅揃えは、表示幅(seechar)で行われ、2倍幅の文字と特殊文字のレンダリング(エスケープバックラッシュを含むが、ダブルクォートを含まないエスケープシーケンスとして:print.defaultを参照)が考慮されます。  したがって、幅はprint(quote = FALSE)で表示される幅であり、catで表示される幅ではない。  (na.encode=FALSEの場合、文字列の欠落は幅の計算に含まれず、エンコードされません。)数値ベクトルは、すべての要素を少なくとも有効桁数まで表示するのに必要な最小の小数点以下の桁数でエンコードされます。  ただし、すべての要素に末尾にゼロがある場合は、nsmallに達するか、少なくとも1つの要素の末尾の桁がゼロでなくなるまで、小数点以下の桁数が減らされます; 上記のbig.*、small.*などの引数の説明も参照してください。  生ベクトルは、as.character.format.default(x)によって、2桁の16進数表現に変換されます。内部コードは、'10進数マーク'のオプションgetOption("OutDec")を尊重するので、これが". "以外に設定されている場合は、引数decimal.markよりも優先されます。
通常のベクトルの再循環ルールがxとformatに適用されるので、答えはベクトルの長い方の長さになります。文字列への変換や文字列からの変換は、適切で利用可能な場合、ロケール固有の変換が使用されます。  as.Dateメソッドは、文字列、係数、論理NA、および "POSIXlt "クラスと "POSIXct "クラスのオブジェクトを受け付ける。  (最後のオブジェクトは、指定されたタイムゾーン(デフォルトはUTC)での時刻の表現において、午前0時以降の時刻を無視して日数に変換されます)。  また、"date"(frompackage date)と "dates"(frompackage chron)というクラスのオブジェクトもあります。  as.Dateは数値データ(ある時点からの日数)を受け付けますが、これはoriginが指定されている場合に限ります。formatメソッドとas.characterメソッドは、日付の端数を無視します。
formatは汎用関数です。  format.data.frameはデータフレームを列ごとにフォーマットし、各列に適切なフォーマット方法を適用します。  行列とデータフレームの列は結果の中で分離された列に変換され、文字列（通常はすべて）はクラス "AsIs "が与えられます。format.factorは因子を文字ベクトルに変換し、デフォルトのメソッドを呼び出します（そのため、正当性が適用されます）。  文字オブジェクトと(アトミック)行列はデフォルトのメソッドに渡されます(したがって、幅は適用されません)。それ以外の場合は、toStringを呼び出してオブジェクトを文字に変換し(ベクトルまたはリストであれば、要素ごとに)、結果を右寄せにします。文字ベクトル(およびそれらのメソッドによって文字ベクトルに変換されたオブジェクト)の幅寄せは、表示幅(seechar)で行われ、全角文字と特殊文字のレンダリング(バックスラッシュのエスケープを含むがダブルクォートは含まないエスケープシーケンスとして:print.defaultを参照)が考慮されます。  したがって、幅はprint(quote = FALSE)で表示される幅であり、catで表示される幅ではない。  (na.encode=FALSEの場合、文字列の欠落は幅の計算に含まれず、エンコードされません。)数値ベクトルは、すべての要素を少なくとも有効桁数まで表示するのに必要な最小の小数点以下の桁数でエンコードされます。  ただし、すべての要素に末尾にゼロがある場合は、nsmallに達するか、少なくとも1つの要素の末尾の桁がゼロでなくなるまで、小数点以下の桁数が減らされます; 上記のbig.*、small.*などの引数の説明も参照してください。  生ベクトルは、as.character.format.default(x)によって2桁の16進数表現に変換されます。内部コードは、'10進マーク'のoptiongetOption("OutDec")を尊重するので、これが". "以外に設定されている場合は、引数decimal.markよりも優先されます。
関数difftimeは、2つの日付/時刻オブジェクトの差を計算し、単位を示す属性を持つクラス "difftime "のオブジェクトを返します。  Mathグループ・メソッドは、このクラスのオブジェクトに対してround、signif、floor、ceiling、trunc、abs、signメソッドを提供し、グループ・ジェネリック（Opsを参照）の論理演算と算術演算のためのメソッドもあります。  また、as.difftime()は、文字コードまたは数値の時間間隔で動作します。後者の場合、単位を指定する必要があり、フォーマットは影響しません。  difftime "オブジェクトの単位はunits関数で抽出することができます。  単位が変更された場合、数値はそれに応じてスケーリングされます。  units="days "は24時間の期間を意味し、夏時間は考慮されないことに注意。  as.double メソッドは、指定された単位で表された数値を返します。  formatメソッドは、単に数値をフォーマットし、単位をテキスト文字列として追加します。
formatは汎用関数です。  format.data.frameはデータ・フレームを列ごとにフォーマットし、各列に適切なフォーマット方法を適用します。  行列とデータフレームの列は結果の中で分離された列に変換され、文字列（通常はすべて）はクラス "AsIs "が与えられます。format.factorは因子を文字ベクトルに変換し、デフォルトのメソッドを呼び出します（そのため、正当性が適用されます）。  文字オブジェクトと(アトミック)行列はデフォルトのメソッドに渡されます(したがって、幅は適用されません)。それ以外の場合は、toStringを呼び出してオブジェクトを文字に変換し(ベクトルまたはリストであれば、要素ごとに)、結果を右寄せにします。文字ベクトル(およびそれらのメソッドによって文字ベクトルに変換されたオブジェクト)の幅寄せは、表示幅(seechar)で行われ、全角文字と特殊文字のレンダリング(バックスラッシュのエスケープを含むがダブルクォートは含まないエスケープシーケンスとして:print.defaultを参照)が考慮されます。  したがって、幅はprint(quote = FALSE)で表示される幅であり、catで表示される幅ではない。  (na.encode=FALSEの場合、文字列の欠落は幅の計算に含まれず、エンコードされません。)数値ベクトルは、すべての要素を少なくとも有効桁数まで表示するのに必要な最小の小数点以下の桁数でエンコードされます。  ただし、すべての要素に末尾にゼロがある場合は、nsmallに達するか、少なくとも1つの要素の末尾の桁がゼロでなくなるまで、小数点以下の桁数が減らされます; 上記のbig.*、small.*などの引数の説明も参照してください。  生ベクトルは、as.character.format.default(x)によって、2桁の16進数表現に変換されます。内部コードは、'10進数マーク'のオプションgetOption("OutDec")を尊重するので、これが". "以外に設定されている場合は、引数decimal.markよりも優先されます。
クラス "hexmode "は、単に16進数で出力されることを保証するために使用される、そのクラス属性を持つ整数ベクトルから構成されます。width = NULL（デフォルト）の場合、出力は、ミスしないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。hexmodeは、（"integer "または "double "型の）整数と、0-9、a-f、A-F（またはNA）だけを要素に含む文字ベクトルを "hexmode "クラスに変換することができる。
NA
library(package)とrequire(package)は、どちらもpackageという名前のパッケージの名前空間をロードし、そのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locにデフォルト値(NULL)を指定すると、ライブラリより先に付属パッケージが検索されます。
数値バージョンは1つ以上の非負整数からなるシーケンスで、通常は（パッケージの'DESCRIPTION'ファイルなどでは）シーケンスの要素を連結し、.または-文字で区切った文字列として表現されます。  関数 numeric_version、package_version、R_system_version は、(適切であれば)このような文字列から、強制やテスト、組み合わせ、比較、要約(min/max)、データフレームへの組み込み、添え字、印刷が可能な表現を作成します。  getRversion は、実行中の R のバージョンを Rsystem version オブジェクトとして返します。  バージョンの整数にアクセスするには、2つのインデックスを使用します。
クラス "octmode "は、そのクラス属性を持つ整数ベクトルから構成され、特に755のようなUnixライクなファイルパーミッションのために、8進数で表示されることを保証するためだけに使用されます。  width=NULL(デフォルト)の場合、出力は、欠落していないすべての要素に必要な最小の幅まで、先頭のゼロでパディングされます。as.octmodeは、整数(integer型またはdouble型)や、要素が0〜7桁のみを含む(またはNAの)文字ベクトルをクラス "octmode "に変換することができます。
library(package)とrequire(package)はどちらも、packageという名前のパッケージの名前空間をロードし、そのarchリストにアタッチします。requireは他の関数の内部で使用するように設計されており、パッケージが存在しない場合はFALSEを返し、（デフォルトのlibrary()のようにエラーではなく）警告を出します。  どちらの関数も、現在アタッチされているパッケージのリストをチェックして更新し、すでにロードされている名前空間を再ロードすることはありません。  (そのようなパッケージを再ロードしたい場合は、まず detach(unload = TRUE) または unloadNamespace を呼び出します)。  パッケージのロード中に表示されるメッセージを抑制するには、suppressPackageStartupMessagesを使用します。これは、R自身からのすべてのメッセージを抑制しますが、パッケージ作成者からのすべてのメッセージを抑制するとは限りません。  (このクラスの構造は、将来のバージョンで変更される可能性があります。) .packages(all = TRUE)を使用して、利用可能なすべてのパッケージの名前だけを取得し、installed.packages()を使用して、さらに多くの情報を取得します。library(help = somename)は、somenameというパッケージに関する基本的な情報を計算し、これを "packageInfo "クラスのオブジェクトに返します(このクラスの構造は、将来のバージョンで変更される可能性があります。)。  (lib.locにデフォルト値(NULL)を指定すると、ライブラリより先に付属パッケージが検索されます。
formatメソッドとas.characterメソッドとstrftimecは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換します。strptimeは文字ベクトルを "POSIXlt "クラスに変換します。strftimeはformat.POSIXltのラッパーであり、format.POSIXctはまずas.POSIXltを呼び出してクラス "POSIXlt "に変換します（したがって、これらはクラス "Date "でも動作します）。  xとformatには、通常のベクトルの再循環規則が適用されるため、答えはこれらのベクトルのうち長い方の長さになる。  これは、LC_TIMEロケールカテゴリの設定によって、日や月の名前、AM/PMインジケータ（使用されている場合）、%xや%Xなどの出力書式のセパレータに影響します。  説明の'currentlocale'は、Rセッションの開始時またはこれらの関数が最初に使用された時に使用されているロケールを意味する。  (入力の場合、ロケール固有の変換は、LC_TIME (またはLC_ALL)カテゴリでSys.setlocaleを呼び出すことで変更できる。  変換指定は%で導入され、通常はその後に1文字、またはOかE、そして1文字が続く。  変換指定の一部でない書式文字列の文字は、文字通りに解釈されます（そして、%%は%%を与えます）。  広く実装されている変換指定には、このプラットフォームの現在のロケールでの曜日名の省略形があります。  (入力時のフルネームにもマッチする。ロケールによっては、名前の省略形がないものもある。)現在のロケールでの完全な曜日名。  (入力時の省略形名とも一致します。)このプラットフォーム上の現在のロケールにおける月名の省略形。  (入力時のフルネームとも一致する。ロケールによっては省略形のない名前もある。)現在のロケールにおける完全な月名。  (入力時には省略形にもマッチする。)日付と時刻。   センチュリー（00-99）：西暦を100で割った整数部分。10進数としての月日（01-31）。%m/%d/%yのような日付書式：C99標準では、この書式に忠実であるべきとされている（ただし、すべてのOSが準拠しているわけではない）。Y-%m-%d（ISO8601の日付書式）に相当する。  (入力時は無視される。)10進数としての週ベースの年(%Vを参照)。  (入力時に無視されますが、受け付けられます。)%b.Hours as decimal number (00-23)に相当します。  特別な例外として、ISO 8601では24:00:00のような文字列が許可されているため、入力として受け入れられる：  出力時には改行、入力時には任意の空白文字。  Iとは併用され、%Hとは併用されない。  一部のロケールでは空文字列となる（例えば、一部のOS、ロシアを含む非英語欧州ロケール）。このようなロケールで入力に使われた場合の動作は未定義である。いくつかのプラットフォームでは、小文字変換を使う%Pを出力に受け付ける（%pも小文字を使うことがある）。秒を整数 (00-61) で表し、うるう秒を2つまで許容する (ただし、POSIX準拠の実装ではうるう秒は無視される)。出力時にはタブ、入力時には任意の空白。  1月1日を含む週（月曜始まり）が新年に4日以上ある場合、その週は第1週とみなされる。  そうでない場合は前年の最終週となり、次の週が第1週となる。  (曜日は10進数（0～6、日曜日は0）、週は10進数（00～53）で、月曜日を週の初日とする（通常、その年の最初の月曜日を第1週の第1日目とする）。  英国の慣習。  出力時はロケール固有、入力時は"%y/%m/%d"。  出力時はロケール固有、入力時は"%H:%M:%S"。  入力では、00から68の値の先頭に20が、69から99の値の先頭に19が付きます。これは2018年のPOSIX標準によって指定された動作ですが、「将来のバージョンでは、2桁の年から推測されるデフォルトの世紀が変更されることが予想される」とも書かれています。  元のグレゴリオ暦にはゼロがなかったが、ISO 8601:2004ではゼロが有効であると定義されていることに注意すること（1BCと解釈される）：https://en.wikipedia.org/wiki/0_(year)を参照のこと。  入力については、年0:9999のみが受け入れられる。符号のオフセットはUTCから時分単位で、-0800はUTCから8時間遅れとなる。最大値は+1400。  (標準は出力のみ。  (出力のみ。) タイムゾーンの略称を1文字文字列で指定(利用できない場合は空)。  先頭のゼロが表示されている場合、出力時には使用されるが、入力時にはオプションである。  名前は、入力時には大文字小文字を区別せずにマッチングされる。出力時に大文字になるかどうかは、プラットフォームとロケールに依存する。  略称はプラットフォーム固有であることに注意してください（標準では、Cロケールでは大文字で表記された英語名の最初の3文字でなければならないと規定されていますが：この規約は英語のロケールでは広く使われていますが、例えばフランス語の月の略称はLinux、macOS、Solaris、Windowsのどれでも同じではありません）。入力フォーマットの一部として%a、%b、%hを使いたい場合は、省略形が何であるかを知っておくことが重要です。タイムゾーンが割り当てられているオブジェクトの出力に%zまたは%Zが使われると、そのタイムゾーンの値を使おうと試みますが、必ず成功するとは限りません。標準にはなく、あまり広く実装されていないのは、24時間時計の時刻で、1桁の前に空白が入ります。ロケールに依存する可能性がある。出力には、ロケールに依存する別の書式（ローマ数字など）で数字を出力する%O[dHImMUVwWy]や、別の「時代」（別の宗教暦など）を使うことができる%E[cCyYxX]もある。  どれがサポートされるかはOSに依存する。  Rに特有なのは%OSnで、これは出力時に小数点以下0 <= n <= 6桁に切り詰めた秒を与える（また、%OSの後に数字が続かない場合は、getOption("digits.secs")の設定を使うか、それが未設定の場合はn = 0となる）。  さらに、strptimeの場合、%OSは端数秒を含む秒を入力する。  Sは、出力で端数部分を読まないことに注意してください。他の変換指定の動作は（また、%で始まる他の文字シーケンスが変換指定であっても）システム固有である。  システムによっては、フォーマットでのマルチバイト文字の使用がサポートされていないことを文書化しているものもあります：UTF-8ローカライズが問題になる可能性は低い。
formatメソッドとas.characterメソッド、そしてstrftimメソッドは、"POSIXlt "クラスと "POSIXct "クラスのオブジェクトを文字ベクトルに変換する。strftimeはformat.POSIXltのラッパーであり、format.POSIXctはまずas.POSIXltを呼び出してクラス "POSIXlt "に変換します（したがって、これらはクラス "Date "でも動作します）。  xとformatには、通常のベクトルの再循環規則が適用されるため、答えはこれらのベクトルのうち長い方の長さになる。  これは、LC_TIMEロケールカテゴリの設定によって、日や月の名前、AM/PMインジケータ（使用されている場合）、%xや%Xなどの出力書式のセパレータに影響します。  説明の'currentlocale'は、Rセッションの開始時またはこれらの関数が最初に使用された時に使用されているロケールを意味する。  (入力の場合、ロケール固有の変換は、LC_TIME (またはLC_ALL)カテゴリでSys.setlocaleを呼び出すことで変更できる。  変換指定は%で導入され、通常はその後に1文字、またはOかE、そして1文字が続く。  変換指定の一部でない書式文字列の文字は、文字通りに解釈されます（そして、%%は%%を与えます）。  広く実装されている変換指定には、このプラットフォームの現在のロケールでの曜日名の省略形があります。  (入力時のフルネームにもマッチする。ロケールによっては、名前の省略形がないものもある。)現在のロケールでの完全な曜日名。  (入力時の省略形名とも一致します。)このプラットフォーム上の現在のロケールにおける月名の省略形。  (入力時のフルネームとも一致する。ロケールによっては省略形がないものもある。)現在のロケールにおける完全な月名。  (入力時には省略形にもマッチする。)日付と時刻。   センチュリー（00-99）：西暦を100で割った整数部分。10進数としての月日（01-31）。%m/%d/%yのような日付書式：C99標準では、この書式に忠実であるべきとされている（ただし、すべてのOSが準拠しているわけではない）。Y-%m-%d（ISO8601の日付書式）に相当する。  (入力時は無視される。)10進数としての週ベースの年(%Vを参照)。  (入力時に無視されますが受け入れられます。)%b.Hours as decimal number (00-23)に相当します。  特別な例外として、ISO 8601では24:00:00のような文字列が許可されているため、入力として受け入れられる：  出力時には改行、入力時には任意の空白文字。  Iとは併用され、%Hとは併用されない。  一部のロケールでは空文字列となる（例えば、一部のOS、ロシアを含む非英語欧州ロケール）。このようなロケールで入力に使用された場合の動作は未定義である。プラットフォームによっては、小文字変換を使用する出力に%Pを受け付けるものもある（%pも小文字を使用することがある）。秒を整数 (00-61) で表し、うるう秒を2つまで許容する (ただし、POSIX準拠の実装ではうるう秒は無視される)。出力時にはタブ、入力時には任意の空白。  1月1日を含む週（月曜始まり）が新年に4日以上ある場合、その週は第1週とみなされる。  そうでない場合は前年の最終週となり、次の週が第1週となる。  (曜日は10進数（0～6、日曜日は0）、週は10進数（00～53）で、月曜日を週の初日とする（通常、その年の最初の月曜日を第1週の第1日目とする）。  英国の慣習。  出力時はロケール固有、入力時は"%y/%m/%d"。  出力時はロケール固有、入力時は"%H:%M:%S"。  入力では、00から68の値の先頭に20が、69から99の値の先頭に19が付きます。これは2018年のPOSIX標準によって指定された動作ですが、「将来のバージョンでは、2桁の年から推測されるデフォルトの世紀が変更されることが予想される」とも書かれています。  元のグレゴリオ暦にはゼロがなかったが、ISO 8601:2004ではゼロが有効であると定義されていることに注意すること（1BCと解釈される）：https://en.wikipedia.org/wiki/0_(year)を参照のこと。  入力については、年0:9999のみが受け入れられる。符号のオフセットはUTCから時分単位で、-0800はUTCから8時間遅れとなる。最大値は+1400。  (標準は出力のみ。  (出力のみ。) タイムゾーンの略称を1文字文字列で指定(利用できない場合は空)。  先頭のゼロが表示されている場合、出力時には使用されるが、入力時にはオプションである。  名前は、入力時には大文字小文字を区別せずにマッチングされる。出力時に大文字になるかどうかは、プラットフォームとロケールに依存する。  略称はプラットフォーム固有であることに注意してください（標準では、Cロケールでは大文字で表記された英語名の最初の3文字でなければならないと規定されていますが：この規約は英語のロケールでは広く使われていますが、例えばフランス語の月の略称はLinux、macOS、Solaris、Windowsのどれでも同じではありません）。入力フォーマットの一部として%a、%b、%hを使いたい場合は、省略形が何であるかを知っておくことが重要です。タイムゾーンが割り当てられているオブジェクトの出力に%zまたは%Zが使われた場合、そのタイムゾーンの値を使おうと試みますが、必ず成功するとは限りません。標準にはなく、あまり広く実装されていないのは、24時間時計の時刻で、1桁の前に空白が入ります。ロケールに依存する可能性がある。出力には、ロケールに依存した別の書式（ローマ数字など）で数字を出力する%O[dHImMUVwWy]や、別の「時代」（別の宗教暦など）を使うことができる%E[cCyYxX]もある。  どれがサポートされるかはOSに依存する。  Rに特有なのは%OSnで、これは出力時に小数点以下0 <= n <= 6桁に切り詰めた秒を与える（そして、%OSの後に桁が続かない場合は、getOption("digits.secs")の設定を使うか、それが未設定の場合はn = 0となる）。  さらに、strptimeの場合、%OSは端数秒を含む秒を入力する。  Sは、出力で端数部分を読まないことに注意してください。他の変換指定の動作は（また、%で始まる他の文字シーケンスが変換指定であっても）システム固有である。  システムによっては、フォーマットでのマルチバイト文字の使用がサポートされていないことを文書化しているものもあります：UTF-8のローカライズが問題になる可能性は低い。
format.pvalは、主にprint.summary.lmなどの補助関数であり、固定値、浮動小数点数、非常に小さな値に対して別々の書式設定を行う。eps未満の値は、"< [eps]"（ここで、'[eps]'はformat(eps, digits)を表す）として書式設定される。
因子の場合、最初の最大和-1番目に頻度の高いレベルの頻度が表示され、頻度の低いレベルは"(その他) "で要約されます（最大和の頻度になります）。
数値の場合、formatC()は必要に応じてprettyNum()を呼び出し、それ自体が.format.zeros(*, replace=replace.zero)を呼び出します("必要な場合": zero.printがNULLでない場合、drop0trailingがtrueの場合、big.mark、small.mark、decimal.markのいずれかがデフォルトでない場合)。formatを設定すると、modeの設定が上書きされます。formatC(c(6.11,13.1), digits = 2, format = "fg") はc("6.1", " 13")を与える。formatC(c(6.11, 13.1), digits = 2, format = "fg") はc("6.1", " 13")を与える。  複数の数字に共通の書式が必要な場合は、format.prettyNumを使用します。prettyNumは、xをきれいにするためのユーティリティ関数です。  xが文字でない場合、format(x[i], ...)が各要素に適用され、他のすべての引数がデフォルトの場合、変更されません。  gsubはbig.markとsmall.markを挿入するために使用されるので、特殊文字はエスケープする必要があります。  
表形式では、インデント-3文字以上の項目はそれ自身の行に表示されます。
x <- backsolve (R, b) は R x = b を、x <- forwardsolve(L, b) は L x = b をそれぞれ解きます。r/l は少なくとも k 行と列を持たなければならず、x は少なくとも k 行を持たなければなりません。
引数リストの名前はバッククォートされた非標準名（'backquote'を参照）であることができる。  単一の式の場合、評価された式の値が返されます(式は、return が呼び出されるとすぐに、関数の評価枠内 で、on.exit 式が評価される前に評価されます)。return を呼び出さずに関数の終わりに達した場合、最後に評価された式の値が返されます。これは、単純な関数式を含むコードを読みやすくするのに役立ちます。
正式な定義はintegral_0^1 t^(a-1) (1-t)^(b-1) dt(Abramowitz and Stegun section 6.2.1, page 258)です。  関数 gamma と lgamma はガンマ関数Γ(x)とガンマ関数の絶対値の自然対数を返します。  ガンマ関数は(Abramowitz and Stegun セクション 6.1.1、255 ページ)Γ(x) = integral_0^Inf t^(x-1) exp(-t) dt で定義されます。  factorial(x) (x! for non-negative integer x)はgamma(x+1)と定義され、 lfactorialはbelgamma(x+1)と定義されます。psigamma(x,div)(div≧0)は、ψ(x)の4階微分を計算します。digamma(x) = ψ(x) = d/dx{ln Γ(x)} = Γ'(x) / Γ(x)ψ とその導関数である psigamma() 関数はしばしば 'polygamma' 関数と呼ばれます。関数 choose と lchoose は、二項係数とその絶対値の対数を返す。  choose(n,k)はすべての実数nと整数kに対して定義されることに注意。  非整数のkの値は警告付きで整数に丸められます。choose(*, k)は、速度と精度の理由から、小さなkに対しては[l]ガンマ 呼び出しの代わりに直接算術を使用します。  gamma関数、lgamma関数、digamma関数、trigamma関数は内部ジェネリック・プリミティブ関数です：メソッドは個別に定義することも、Mathグループ・ジェネリックを介して定義することもできます。
gcを呼び出すとガベージ・コレクションが実行されます。これはユーザが操作しなくても自動的に実行され、gcを呼び出す主な目的はメモリ使用量のレポートです。  正確なレポートを得るには、full = TRUEを使用する必要がある。大きなオブジェクトが削除された後にgcを呼び出すと便利なことがある。gcinfo(TRUE)が有効な場合、ガベージコレクションのたびにメッセージがメッセー ジコネクションに送信される。最後の2行は、現在のメモリ使用量を0.1Mb単位で切り上げ、現在のトリガー値に対するパーセンテージで表示している。
これはプリミティブである。
gcを呼び出すと、ガベージ・コレクションが行われる。これは、ユーザーの介入なしに自動的に行われ、gcを呼び出す主な目的は、メモリ使用量のレポートである。  正確なレポートを得るには、full = TRUEを使用する必要がある。大きなオブジェクトが削除された後にgcを呼び出すと便利なことがある。gcinfo(TRUE)が有効な場合、ガベージ・コレクションのたびにメッセージがメッセー ジ接続に送られる。最後の2行は、現在のメモリ使用量を0.1Mb単位で切り上げ、現在のトリガー値に対するパーセンテージで示す。
